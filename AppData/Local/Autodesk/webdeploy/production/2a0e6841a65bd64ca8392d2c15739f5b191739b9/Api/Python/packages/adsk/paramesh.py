# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _paramesh
else:
    import _paramesh

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _paramesh.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _paramesh.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _paramesh.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _paramesh.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _paramesh.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _paramesh.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _paramesh.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _paramesh.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _paramesh.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _paramesh.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _paramesh.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _paramesh.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _paramesh.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _paramesh.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _paramesh.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _paramesh.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _paramesh.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _paramesh:
_paramesh.SwigPyIterator_swigregister(SwigPyIterator)

class Base(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Base *":
        return _paramesh.Base___deref__(self)

    def __eq__(self, rhs: "Application") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _paramesh.Base___eq__(self, rhs)


    def __ne__(self, rhs: "Base") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _paramesh.Base___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _paramesh.Base_classType()
    __swig_destroy__ = _paramesh.delete_Base

    def _get_objectType(self) -> "char const *":
        return _paramesh.Base__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _paramesh.Base__get_isValid(self)

# Register Base in _paramesh:
_paramesh.Base_swigregister(Base)

def Base_classType() -> "char const *":
    return _paramesh.Base_classType()


Base.objectType = property(Base._get_objectType, doc="Returns a string indicating the type of the object.")
Base.isValid = property(Base._get_isValid, doc="Indicates if this object is still valid, i.e. hasn't been deleted or some other action done to invalidate the reference.")

import adsk.core
class ParaMeshRemeshTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    RemeshAdaptive = _paramesh.ParaMeshRemeshTypes_RemeshAdaptive
    RemeshUniform = _paramesh.ParaMeshRemeshTypes_RemeshUniform

    def __init__(self):
        _paramesh.ParaMeshRemeshTypes_swiginit(self, _paramesh.new_ParaMeshRemeshTypes())
    __swig_destroy__ = _paramesh.delete_ParaMeshRemeshTypes

# Register ParaMeshRemeshTypes in _paramesh:
_paramesh.ParaMeshRemeshTypes_swigregister(ParaMeshRemeshTypes)

class ParaMeshReduceTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    MaxDeviation = _paramesh.ParaMeshReduceTypes_MaxDeviation
    Proportion = _paramesh.ParaMeshReduceTypes_Proportion
    TriangleBudget = _paramesh.ParaMeshReduceTypes_TriangleBudget

    def __init__(self):
        _paramesh.ParaMeshReduceTypes_swiginit(self, _paramesh.new_ParaMeshReduceTypes())
    __swig_destroy__ = _paramesh.delete_ParaMeshReduceTypes

# Register ParaMeshReduceTypes in _paramesh:
_paramesh.ParaMeshReduceTypes_swigregister(ParaMeshReduceTypes)

class ParaMeshUnits(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    CentimeterMeshUnit = _paramesh.ParaMeshUnits_CentimeterMeshUnit
    MillimeterMeshUnit = _paramesh.ParaMeshUnits_MillimeterMeshUnit
    MeterMeshUnit = _paramesh.ParaMeshUnits_MeterMeshUnit
    InchMeshUnit = _paramesh.ParaMeshUnits_InchMeshUnit
    FootMeshUnit = _paramesh.ParaMeshUnits_FootMeshUnit

    def __init__(self):
        _paramesh.ParaMeshUnits_swiginit(self, _paramesh.new_ParaMeshUnits())
    __swig_destroy__ = _paramesh.delete_ParaMeshUnits

# Register ParaMeshUnits in _paramesh:
_paramesh.ParaMeshUnits_swigregister(ParaMeshUnits)

class ParaMeshBodies(Base):
    r"""
    Provides access to the ParaMeshBodies in the parent Component and
    supports the creation of new mesh bodies.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::paramesh::ParaMeshBodies *":
        return _paramesh.ParaMeshBodies___deref__(self)

    def __eq__(self, rhs: "ParaMeshBodies") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _paramesh.ParaMeshBodies___eq__(self, rhs)


    def __ne__(self, rhs: "ParaMeshBodies") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _paramesh.ParaMeshBodies___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _paramesh.ParaMeshBodies___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::paramesh::ParaMeshBody >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _paramesh.ParaMeshBodies___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _paramesh.ParaMeshBodies_classType()

    @staticmethod
    def getFromComponent(component: "adsk::core::Ptr< adsk::fusion::Component > const &") -> "adsk::core::Ptr< adsk::paramesh::ParaMeshBodies >":
        return _paramesh.ParaMeshBodies_getFromComponent(component)
    __swig_destroy__ = _paramesh.delete_ParaMeshBodies

    def add(self, *args) -> "adsk::core::Ptr< adsk::paramesh::ParaMeshBodyList >":
        r"""
        Creates a new mesh body by importing an .stl or .obj file.
        Because of a current limitation, if you want to create a mesh body in a parametric model, 
        you must first call the edit method of the base or form feature, use this method to create 
        the mesh body, and then call the finishEdit method of the base or form feature. The base 
        or form feature must be in an 'edit' state to be able to add any additional items to it. 
        fullFilename : The full filename (path and file) of a .stl or .obj file. 
        units : The units to use when importing the file. 
        baseOrFormFeature : The BaseFeature or FormFeature object that this mesh body will be associated with. This is an optional
        requirement and is required when the model design history is being captured (paremetric model) but is
        ignored otherwise (direct edit model). 
        Returns a list of the newly created mesh bodies or null if the creation failed. Multiple
        bodies can be created in the case where a .obj file that contains multiple bodies was imported.
        stl files always contain a single body.
        """
        return _paramesh.ParaMeshBodies_add(self, *args)

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::paramesh::ParaMeshBody >":
        r"""
        Provides access to a mesh body within the collection. 
        index : The index of the mesh body to return, where an index of 0 is the first mesh body in the collection. 
        Returns the specified mesh body or null in the case of a invalid index.
        """
        return _paramesh.ParaMeshBodies_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of mesh bodies in the collection."""
        return _paramesh.ParaMeshBodies__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _paramesh.ParaMeshBodies__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _paramesh.ParaMeshBodies__get_isValid(self)

# Register ParaMeshBodies in _paramesh:
_paramesh.ParaMeshBodies_swigregister(ParaMeshBodies)

def ParaMeshBodies_classType() -> "char const *":
    return _paramesh.ParaMeshBodies_classType()

def ParaMeshBodies_getFromComponent(component: "adsk::core::Ptr< adsk::fusion::Component > const &") -> "adsk::core::Ptr< adsk::paramesh::ParaMeshBodies >":
    return _paramesh.ParaMeshBodies_getFromComponent(component)


ParaMeshBodies.count = property(ParaMeshBodies._get_count, doc="Returns the number of mesh bodies in the collection.")


ParaMeshBodies.cast = lambda arg: arg if isinstance(arg, ParaMeshBodies) else None

class ParaMeshBody(Base):
    r"""An empty API definition for testing."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::paramesh::ParaMeshBody *":
        return _paramesh.ParaMeshBody___deref__(self)

    def __eq__(self, rhs: "ParaMeshBody") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _paramesh.ParaMeshBody___eq__(self, rhs)


    def __ne__(self, rhs: "ParaMeshBody") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _paramesh.ParaMeshBody___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _paramesh.ParaMeshBody_classType()
    __swig_destroy__ = _paramesh.delete_ParaMeshBody

    def _get_name(self) -> "std::string":
        r"""Gets and sets the name of the mesh body as displayed in the browser."""
        return _paramesh.ParaMeshBody__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the name of the mesh body as displayed in the browser."""
        return _paramesh.ParaMeshBody__set_name(self, value)

    def reduce(self, inputProportions: "double", maxDeviation: "double", triangleBudget: "int", remeshType: "ParaMeshRemeshTypes", reduceType: "ParaMeshReduceTypes") -> "bool":
        r"""Reduces the number of triangles on a mesh."""
        return _paramesh.ParaMeshBody_reduce(self, inputProportions, maxDeviation, triangleBudget, remeshType, reduceType)

    def _get_mesh(self) -> "adsk::core::Ptr< adsk::fusion::PolygonMesh >":
        return _paramesh.ParaMeshBody__get_mesh(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent Component."""
        return _paramesh.ParaMeshBody__get_parentComponent(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _paramesh.ParaMeshBody__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::paramesh::ParaMeshBody >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _paramesh.ParaMeshBody__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "adsk::core::Ptr< adsk::fusion::Occurrence > const &") -> "adsk::core::Ptr< adsk::paramesh::ParaMeshBody >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence.
        Fails if this object is not the NativeObject. 
        occurrence : The occurrence that represents the context you want to create this proxy in. 
        Returns the proxy for the occurrence in the context of the specified occurrence. Returns null if it failed.
        """
        return _paramesh.ParaMeshBody_createForAssemblyContext(self, occurrence)

    def _get_objectType(self) -> "char const *":
        return _paramesh.ParaMeshBody__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _paramesh.ParaMeshBody__get_isValid(self)

# Register ParaMeshBody in _paramesh:
_paramesh.ParaMeshBody_swigregister(ParaMeshBody)

def ParaMeshBody_classType() -> "char const *":
    return _paramesh.ParaMeshBody_classType()


ParaMeshBody.name = property(ParaMeshBody._get_name, ParaMeshBody._set_name, doc="Gets and sets the name of the mesh body as displayed in the browser.")


ParaMeshBody.mesh = property(ParaMeshBody._get_mesh)


ParaMeshBody.parentComponent = property(ParaMeshBody._get_parentComponent, doc="Returns the parent Component.")


ParaMeshBody.assemblyContext = property(ParaMeshBody._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")


ParaMeshBody.nativeObject = property(ParaMeshBody._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


ParaMeshBody.cast = lambda arg: arg if isinstance(arg, ParaMeshBody) else None

class ParaMeshBodyList(Base):
    r"""Provides access to a list of ParaMeshBody objects."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::paramesh::ParaMeshBodyList *":
        return _paramesh.ParaMeshBodyList___deref__(self)

    def __eq__(self, rhs: "ParaMeshBodyList") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _paramesh.ParaMeshBodyList___eq__(self, rhs)


    def __ne__(self, rhs: "ParaMeshBodyList") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _paramesh.ParaMeshBodyList___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _paramesh.ParaMeshBodyList___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::paramesh::ParaMeshBody >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _paramesh.ParaMeshBodyList___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _paramesh.ParaMeshBodyList_classType()
    __swig_destroy__ = _paramesh.delete_ParaMeshBodyList

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::paramesh::ParaMeshBody >":
        r"""
        Provides access to a mesh body within the collection. 
        index : The index of the mesh body to return, where an index of 0 is the first mesh body in the collection. 
        Returns the specified mesh body or null in the case of a invalid index.
        """
        return _paramesh.ParaMeshBodyList_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of mesh bodies in the collection."""
        return _paramesh.ParaMeshBodyList__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _paramesh.ParaMeshBodyList__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _paramesh.ParaMeshBodyList__get_isValid(self)

# Register ParaMeshBodyList in _paramesh:
_paramesh.ParaMeshBodyList_swigregister(ParaMeshBodyList)

def ParaMeshBodyList_classType() -> "char const *":
    return _paramesh.ParaMeshBodyList_classType()


ParaMeshBodyList.count = property(ParaMeshBodyList._get_count, doc="Returns the number of mesh bodies in the collection.")


ParaMeshBodyList.cast = lambda arg: arg if isinstance(arg, ParaMeshBodyList) else None



