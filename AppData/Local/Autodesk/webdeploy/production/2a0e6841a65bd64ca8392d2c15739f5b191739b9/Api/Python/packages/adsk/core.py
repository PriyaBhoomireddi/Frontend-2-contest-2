# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _core
else:
    import _core

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _core.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _core.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _core.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _core.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _core.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _core.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _core.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _core.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _core.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _core.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _core.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _core.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _core.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _core.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _core.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _core.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _core.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _core:
_core.SwigPyIterator_swigregister(SwigPyIterator)

class StringVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.StringVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.StringVector___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _core.StringVector___len__(self)

    def __getslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "std::vector< std::string,std::allocator< std::string > > *":
        return _core.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.StringVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "void":
        return _core.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.StringVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _core.StringVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.StringVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _core.StringVector_pop(self)

    def append(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _core.StringVector_append(self, x)

    def empty(self) -> "bool":
        return _core.StringVector_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _core.StringVector_size(self)

    def swap(self, v: "StringVector") -> "void":
        return _core.StringVector_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _core.StringVector_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _core.StringVector_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _core.StringVector_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _core.StringVector_rend(self)

    def clear(self) -> "void":
        return _core.StringVector_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _core.StringVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.StringVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _core.StringVector_erase(self, *args)

    def __init__(self, *args):
        _core.StringVector_swiginit(self, _core.new_StringVector(*args))

    def push_back(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _core.StringVector_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _core.StringVector_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _core.StringVector_back(self)

    def assign(self, n: "std::vector< std::string >::size_type", x: "std::vector< std::string >::value_type const &") -> "void":
        return _core.StringVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.StringVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.StringVector_insert(self, *args)

    def reserve(self, n: "std::vector< std::string >::size_type") -> "void":
        return _core.StringVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _core.StringVector_capacity(self)
    __swig_destroy__ = _core.delete_StringVector

# Register StringVector in _core:
_core.StringVector_swigregister(StringVector)

class DoubleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.DoubleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.DoubleVector___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _core.DoubleVector___len__(self)

    def __getslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "std::vector< double,std::allocator< double > > *":
        return _core.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "void":
        return _core.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _core.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.DoubleVector___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _core.DoubleVector_pop(self)

    def append(self, x: "std::vector< double >::value_type const &") -> "void":
        return _core.DoubleVector_append(self, x)

    def empty(self) -> "bool":
        return _core.DoubleVector_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _core.DoubleVector_size(self)

    def swap(self, v: "DoubleVector") -> "void":
        return _core.DoubleVector_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _core.DoubleVector_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _core.DoubleVector_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _core.DoubleVector_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _core.DoubleVector_rend(self)

    def clear(self) -> "void":
        return _core.DoubleVector_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _core.DoubleVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.DoubleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _core.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        _core.DoubleVector_swiginit(self, _core.new_DoubleVector(*args))

    def push_back(self, x: "std::vector< double >::value_type const &") -> "void":
        return _core.DoubleVector_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _core.DoubleVector_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _core.DoubleVector_back(self)

    def assign(self, n: "std::vector< double >::size_type", x: "std::vector< double >::value_type const &") -> "void":
        return _core.DoubleVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.DoubleVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.DoubleVector_insert(self, *args)

    def reserve(self, n: "std::vector< double >::size_type") -> "void":
        return _core.DoubleVector_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _core.DoubleVector_capacity(self)
    __swig_destroy__ = _core.delete_DoubleVector

# Register DoubleVector in _core:
_core.DoubleVector_swigregister(DoubleVector)

class BoolVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.BoolVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.BoolVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.BoolVector___bool__(self)

    def __len__(self) -> "std::vector< bool >::size_type":
        return _core.BoolVector___len__(self)

    def __getslice__(self, i: "std::vector< bool >::difference_type", j: "std::vector< bool >::difference_type") -> "std::vector< bool,std::allocator< bool > > *":
        return _core.BoolVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.BoolVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< bool >::difference_type", j: "std::vector< bool >::difference_type") -> "void":
        return _core.BoolVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.BoolVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< bool >::value_type":
        return _core.BoolVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.BoolVector___setitem__(self, *args)

    def pop(self) -> "std::vector< bool >::value_type":
        return _core.BoolVector_pop(self)

    def append(self, x: "std::vector< bool >::value_type") -> "void":
        return _core.BoolVector_append(self, x)

    def empty(self) -> "bool":
        return _core.BoolVector_empty(self)

    def size(self) -> "std::vector< bool >::size_type":
        return _core.BoolVector_size(self)

    def swap(self, v: "BoolVector") -> "void":
        return _core.BoolVector_swap(self, v)

    def begin(self) -> "std::vector< bool >::iterator":
        return _core.BoolVector_begin(self)

    def end(self) -> "std::vector< bool >::iterator":
        return _core.BoolVector_end(self)

    def rbegin(self) -> "std::vector< bool >::reverse_iterator":
        return _core.BoolVector_rbegin(self)

    def rend(self) -> "std::vector< bool >::reverse_iterator":
        return _core.BoolVector_rend(self)

    def clear(self) -> "void":
        return _core.BoolVector_clear(self)

    def get_allocator(self) -> "std::vector< bool >::allocator_type":
        return _core.BoolVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.BoolVector_pop_back(self)

    def erase(self, *args) -> "std::vector< bool >::iterator":
        return _core.BoolVector_erase(self, *args)

    def __init__(self, *args):
        _core.BoolVector_swiginit(self, _core.new_BoolVector(*args))

    def push_back(self, x: "std::vector< bool >::value_type") -> "void":
        return _core.BoolVector_push_back(self, x)

    def front(self) -> "std::vector< bool >::value_type":
        return _core.BoolVector_front(self)

    def back(self) -> "std::vector< bool >::value_type":
        return _core.BoolVector_back(self)

    def assign(self, n: "std::vector< bool >::size_type", x: "std::vector< bool >::value_type") -> "void":
        return _core.BoolVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.BoolVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.BoolVector_insert(self, *args)

    def reserve(self, n: "std::vector< bool >::size_type") -> "void":
        return _core.BoolVector_reserve(self, n)

    def capacity(self) -> "std::vector< bool >::size_type":
        return _core.BoolVector_capacity(self)
    __swig_destroy__ = _core.delete_BoolVector

# Register BoolVector in _core:
_core.BoolVector_swigregister(BoolVector)

class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.IntVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.IntVector___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _core.IntVector___len__(self)

    def __getslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "std::vector< int,std::allocator< int > > *":
        return _core.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.IntVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "void":
        return _core.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.IntVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _core.IntVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.IntVector___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _core.IntVector_pop(self)

    def append(self, x: "std::vector< int >::value_type const &") -> "void":
        return _core.IntVector_append(self, x)

    def empty(self) -> "bool":
        return _core.IntVector_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _core.IntVector_size(self)

    def swap(self, v: "IntVector") -> "void":
        return _core.IntVector_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _core.IntVector_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _core.IntVector_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _core.IntVector_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _core.IntVector_rend(self)

    def clear(self) -> "void":
        return _core.IntVector_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _core.IntVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.IntVector_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _core.IntVector_erase(self, *args)

    def __init__(self, *args):
        _core.IntVector_swiginit(self, _core.new_IntVector(*args))

    def push_back(self, x: "std::vector< int >::value_type const &") -> "void":
        return _core.IntVector_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _core.IntVector_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _core.IntVector_back(self)

    def assign(self, n: "std::vector< int >::size_type", x: "std::vector< int >::value_type const &") -> "void":
        return _core.IntVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.IntVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.IntVector_insert(self, *args)

    def reserve(self, n: "std::vector< int >::size_type") -> "void":
        return _core.IntVector_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _core.IntVector_capacity(self)
    __swig_destroy__ = _core.delete_IntVector

# Register IntVector in _core:
_core.IntVector_swigregister(IntVector)

class Base(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Base *":
        return _core.Base___deref__(self)

    def __eq__(self, rhs: "Application") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Base___eq__(self, rhs)


    def __ne__(self, rhs: "Base") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Base___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Base_classType()
    __swig_destroy__ = _core.delete_Base

    def _get_objectType(self) -> "char const *":
        return _core.Base__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Base__get_isValid(self)

# Register Base in _core:
_core.Base_swigregister(Base)

def Base_classType() -> "char const *":
    return _core.Base_classType()


Base.objectType = property(Base._get_objectType, doc="Returns a string indicating the type of the object.")
Base.isValid = property(Base._get_isValid, doc="Indicates if this object is still valid, i.e. hasn't been deleted or some other action done to invalidate the reference.")

class EnsureGILState(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _core.EnsureGILState_swiginit(self, _core.new_EnsureGILState())
    __swig_destroy__ = _core.delete_EnsureGILState

# Register EnsureGILState in _core:
_core.EnsureGILState_swigregister(EnsureGILState)


def eventDirectorCallNotify(_self: "PyObject *", eventargs: "PyObject *") -> "PyObject *":
    return _core.eventDirectorCallNotify(_self, eventargs)

def adsk_terminate() -> "void":
    return _core.adsk_terminate()

def get_adsk_autoTerminate() -> "bool":
    return _core.get_adsk_autoTerminate()

def set_adsk_autoTerminate(value: "bool") -> "void":
    return _core.set_adsk_autoTerminate(value)

def adsk_doEvents() -> "void":
    return _core.adsk_doEvents()

import sys
if 'adsk' in sys.modules:
    sys.modules['adsk'].terminate = adsk_terminate
    sys.modules['adsk'].autoTerminate = lambda value = None: get_adsk_autoTerminate() if value == None else set_adsk_autoTerminate(value)
    sys.modules['adsk'].doEvents = adsk_doEvents

class GenericErrors(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Ok = _core.GenericErrors_Ok
    UnexpectedError = _core.GenericErrors_UnexpectedError
    InternalValidationError = _core.GenericErrors_InternalValidationError
    BadApiCallError = _core.GenericErrors_BadApiCallError
    UnderlyingObjectDeletedError = _core.GenericErrors_UnderlyingObjectDeletedError
    OperationFailed = _core.GenericErrors_OperationFailed
    ExpressionError = _core.GenericErrors_ExpressionError
    InvalidGeometryError = _core.GenericErrors_InvalidGeometryError
    ClassSpecificError = _core.GenericErrors_ClassSpecificError
    FunctionSpecificError = _core.GenericErrors_FunctionSpecificError

    def __init__(self):
        _core.GenericErrors_swiginit(self, _core.new_GenericErrors())
    __swig_destroy__ = _core.delete_GenericErrors

# Register GenericErrors in _core:
_core.GenericErrors_swigregister(GenericErrors)

class DocumentTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    FusionDesignDocumentType = _core.DocumentTypes_FusionDesignDocumentType

    def __init__(self):
        _core.DocumentTypes_swiginit(self, _core.new_DocumentTypes())
    __swig_destroy__ = _core.delete_DocumentTypes

# Register DocumentTypes in _core:
_core.DocumentTypes_swigregister(DocumentTypes)

class OpenDocumentError(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DocumentNotFoundError = _core.OpenDocumentError_DocumentNotFoundError

    def __init__(self):
        _core.OpenDocumentError_swiginit(self, _core.new_OpenDocumentError())
    __swig_destroy__ = _core.delete_OpenDocumentError

# Register OpenDocumentError in _core:
_core.OpenDocumentError_swigregister(OpenDocumentError)

class CloseError(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    CloseCancelledError = _core.CloseError_CloseCancelledError

    def __init__(self):
        _core.CloseError_swiginit(self, _core.new_CloseError())
    __swig_destroy__ = _core.delete_CloseError

# Register CloseError in _core:
_core.CloseError_swigregister(CloseError)

class SaveLocalErrors(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    SaveCancelledSaveLocalError = _core.SaveLocalErrors_SaveCancelledSaveLocalError
    DiskFullSaveLocalError = _core.SaveLocalErrors_DiskFullSaveLocalError
    FileReadOnlySaveLocalError = _core.SaveLocalErrors_FileReadOnlySaveLocalError

    def __init__(self):
        _core.SaveLocalErrors_swiginit(self, _core.new_SaveLocalErrors())
    __swig_destroy__ = _core.delete_SaveLocalErrors

# Register SaveLocalErrors in _core:
_core.SaveLocalErrors_swigregister(SaveLocalErrors)

class UserLanguages(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ChinesePRCLanguage = _core.UserLanguages_ChinesePRCLanguage
    ChineseTaiwanLanguage = _core.UserLanguages_ChineseTaiwanLanguage
    CzechLanguage = _core.UserLanguages_CzechLanguage
    EnglishLanguage = _core.UserLanguages_EnglishLanguage
    FrenchLanguage = _core.UserLanguages_FrenchLanguage
    GermanLanguage = _core.UserLanguages_GermanLanguage
    HungarianLanguage = _core.UserLanguages_HungarianLanguage
    ItalianLanguage = _core.UserLanguages_ItalianLanguage
    JapaneseLanguage = _core.UserLanguages_JapaneseLanguage
    KoreanLanguage = _core.UserLanguages_KoreanLanguage
    PolishLanguage = _core.UserLanguages_PolishLanguage
    PortugueseBrazilianLanguage = _core.UserLanguages_PortugueseBrazilianLanguage
    RussianLanguage = _core.UserLanguages_RussianLanguage
    SpanishLanguage = _core.UserLanguages_SpanishLanguage

    def __init__(self):
        _core.UserLanguages_swiginit(self, _core.new_UserLanguages())
    __swig_destroy__ = _core.delete_UserLanguages

# Register UserLanguages in _core:
_core.UserLanguages_swigregister(UserLanguages)

class GraphicsDrivers(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DirectX9GraphicsDriver = _core.GraphicsDrivers_DirectX9GraphicsDriver
    DirectX11GraphicsDriver = _core.GraphicsDrivers_DirectX11GraphicsDriver
    AutoSelectGraphicsDriver = _core.GraphicsDrivers_AutoSelectGraphicsDriver
    OpenGLCoreProfileGraphicsDriver = _core.GraphicsDrivers_OpenGLCoreProfileGraphicsDriver
    OpenGLGraphicsDriver = _core.GraphicsDrivers_OpenGLGraphicsDriver

    def __init__(self):
        _core.GraphicsDrivers_swiginit(self, _core.new_GraphicsDrivers())
    __swig_destroy__ = _core.delete_GraphicsDrivers

# Register GraphicsDrivers in _core:
_core.GraphicsDrivers_swigregister(GraphicsDrivers)

class DefaultModelingOrientations(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    YUpModelingOrientation = _core.DefaultModelingOrientations_YUpModelingOrientation
    ZUpModelingOrientation = _core.DefaultModelingOrientations_ZUpModelingOrientation

    def __init__(self):
        _core.DefaultModelingOrientations_swiginit(self, _core.new_DefaultModelingOrientations())
    __swig_destroy__ = _core.delete_DefaultModelingOrientations

# Register DefaultModelingOrientations in _core:
_core.DefaultModelingOrientations_swigregister(DefaultModelingOrientations)

class DefaultOrbits(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ConstrainedOrbit = _core.DefaultOrbits_ConstrainedOrbit
    FreeOrbit = _core.DefaultOrbits_FreeOrbit

    def __init__(self):
        _core.DefaultOrbits_swiginit(self, _core.new_DefaultOrbits())
    __swig_destroy__ = _core.delete_DefaultOrbits

# Register DefaultOrbits in _core:
_core.DefaultOrbits_swigregister(DefaultOrbits)

class SelectionDisplayStyles(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    NormalDisplayStyle = _core.SelectionDisplayStyles_NormalDisplayStyle
    SimpleDisplayStyle = _core.SelectionDisplayStyles_SimpleDisplayStyle

    def __init__(self):
        _core.SelectionDisplayStyles_swiginit(self, _core.new_SelectionDisplayStyles())
    __swig_destroy__ = _core.delete_SelectionDisplayStyles

# Register SelectionDisplayStyles in _core:
_core.SelectionDisplayStyles_swigregister(SelectionDisplayStyles)

class DegradedSelectionDisplayStyles(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    NormalWithGlowDegradedSelectionStyle = _core.DegradedSelectionDisplayStyles_NormalWithGlowDegradedSelectionStyle
    SimpleWithoutGlowDegradedSelectionStyle = _core.DegradedSelectionDisplayStyles_SimpleWithoutGlowDegradedSelectionStyle

    def __init__(self):
        _core.DegradedSelectionDisplayStyles_swiginit(self, _core.new_DegradedSelectionDisplayStyles())
    __swig_destroy__ = _core.delete_DegradedSelectionDisplayStyles

# Register DegradedSelectionDisplayStyles in _core:
_core.DegradedSelectionDisplayStyles_swigregister(DegradedSelectionDisplayStyles)

class TransparencyDisplayEffects(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BetterPerformanceTransparencyEffect = _core.TransparencyDisplayEffects_BetterPerformanceTransparencyEffect
    BetterDisplayTransparencyEffect = _core.TransparencyDisplayEffects_BetterDisplayTransparencyEffect

    def __init__(self):
        _core.TransparencyDisplayEffects_swiginit(self, _core.new_TransparencyDisplayEffects())
    __swig_destroy__ = _core.delete_TransparencyDisplayEffects

# Register TransparencyDisplayEffects in _core:
_core.TransparencyDisplayEffects_swigregister(TransparencyDisplayEffects)

class NetworkProxySettings(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    AutomaticProxySettings = _core.NetworkProxySettings_AutomaticProxySettings
    NoProxyProxySettings = _core.NetworkProxySettings_NoProxyProxySettings
    WindowsDefaultProxySettings = _core.NetworkProxySettings_WindowsDefaultProxySettings
    OverrideProxySettings = _core.NetworkProxySettings_OverrideProxySettings

    def __init__(self):
        _core.NetworkProxySettings_swiginit(self, _core.new_NetworkProxySettings())
    __swig_destroy__ = _core.delete_NetworkProxySettings

# Register NetworkProxySettings in _core:
_core.NetworkProxySettings_swigregister(NetworkProxySettings)

class FootAndInchDisplayFormats(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DecimalFootAndInchDisplay = _core.FootAndInchDisplayFormats_DecimalFootAndInchDisplay
    FractionalFootAndInchDisplay = _core.FootAndInchDisplayFormats_FractionalFootAndInchDisplay
    ArchitecturalFootAndInchDisplay = _core.FootAndInchDisplayFormats_ArchitecturalFootAndInchDisplay

    def __init__(self):
        _core.FootAndInchDisplayFormats_swiginit(self, _core.new_FootAndInchDisplayFormats())
    __swig_destroy__ = _core.delete_FootAndInchDisplayFormats

# Register FootAndInchDisplayFormats in _core:
_core.FootAndInchDisplayFormats_swigregister(FootAndInchDisplayFormats)

class DegreeDisplayFormats(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DecimalDegreeDisplay = _core.DegreeDisplayFormats_DecimalDegreeDisplay
    MinutesAndSecondsDegreeDisplay = _core.DegreeDisplayFormats_MinutesAndSecondsDegreeDisplay

    def __init__(self):
        _core.DegreeDisplayFormats_swiginit(self, _core.new_DegreeDisplayFormats())
    __swig_destroy__ = _core.delete_DegreeDisplayFormats

# Register DegreeDisplayFormats in _core:
_core.DegreeDisplayFormats_swigregister(DegreeDisplayFormats)

class MaterialDisplayUnits(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    MetricStandardDisplayUnits = _core.MaterialDisplayUnits_MetricStandardDisplayUnits
    MetricMKSDisplayUnits = _core.MaterialDisplayUnits_MetricMKSDisplayUnits
    MetricMMNSDisplayUnits = _core.MaterialDisplayUnits_MetricMMNSDisplayUnits
    MetricCGSDisplayUnits = _core.MaterialDisplayUnits_MetricCGSDisplayUnits
    MetricUMNSDisplayUnits = _core.MaterialDisplayUnits_MetricUMNSDisplayUnits
    EnglishStandardDisplayUnits = _core.MaterialDisplayUnits_EnglishStandardDisplayUnits
    EnglishInchDisplayUnits = _core.MaterialDisplayUnits_EnglishInchDisplayUnits
    EnglishFootDisplayUnits = _core.MaterialDisplayUnits_EnglishFootDisplayUnits

    def __init__(self):
        _core.MaterialDisplayUnits_swiginit(self, _core.new_MaterialDisplayUnits())
    __swig_destroy__ = _core.delete_MaterialDisplayUnits

# Register MaterialDisplayUnits in _core:
_core.MaterialDisplayUnits_swigregister(MaterialDisplayUnits)

class HorizontalAlignments(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    LeftHorizontalAlignment = _core.HorizontalAlignments_LeftHorizontalAlignment
    CenterHorizontalAlignment = _core.HorizontalAlignments_CenterHorizontalAlignment
    RightHorizontalAlignment = _core.HorizontalAlignments_RightHorizontalAlignment

    def __init__(self):
        _core.HorizontalAlignments_swiginit(self, _core.new_HorizontalAlignments())
    __swig_destroy__ = _core.delete_HorizontalAlignments

# Register HorizontalAlignments in _core:
_core.HorizontalAlignments_swigregister(HorizontalAlignments)

class VerticalAlignments(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    TopVerticalAlignment = _core.VerticalAlignments_TopVerticalAlignment
    MiddleVerticalAlignment = _core.VerticalAlignments_MiddleVerticalAlignment
    BottomVerticalAlignment = _core.VerticalAlignments_BottomVerticalAlignment

    def __init__(self):
        _core.VerticalAlignments_swiginit(self, _core.new_VerticalAlignments())
    __swig_destroy__ = _core.delete_VerticalAlignments

# Register VerticalAlignments in _core:
_core.VerticalAlignments_swigregister(VerticalAlignments)

class ValueTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    StringValueType = _core.ValueTypes_StringValueType
    RealValueType = _core.ValueTypes_RealValueType
    ObjectValueType = _core.ValueTypes_ObjectValueType
    BooleanValueType = _core.ValueTypes_BooleanValueType

    def __init__(self):
        _core.ValueTypes_swiginit(self, _core.new_ValueTypes())
    __swig_destroy__ = _core.delete_ValueTypes

# Register ValueTypes in _core:
_core.ValueTypes_swigregister(ValueTypes)

class ValueInputError(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ValueNotOfTypeError = _core.ValueInputError_ValueNotOfTypeError

    def __init__(self):
        _core.ValueInputError_swiginit(self, _core.new_ValueInputError())
    __swig_destroy__ = _core.delete_ValueInputError

# Register ValueInputError in _core:
_core.ValueInputError_swigregister(ValueInputError)

class VisualStyles(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ShadedVisualStyle = _core.VisualStyles_ShadedVisualStyle
    ShadedWithHiddenEdgesVisualStyle = _core.VisualStyles_ShadedWithHiddenEdgesVisualStyle
    ShadedWithVisibleEdgesOnlyVisualStyle = _core.VisualStyles_ShadedWithVisibleEdgesOnlyVisualStyle
    WireframeVisualStyle = _core.VisualStyles_WireframeVisualStyle
    WireframeWithHiddenEdgesVisualStyle = _core.VisualStyles_WireframeWithHiddenEdgesVisualStyle
    WireframeWithVisibleEdgesOnlyVisualStyle = _core.VisualStyles_WireframeWithVisibleEdgesOnlyVisualStyle

    def __init__(self):
        _core.VisualStyles_swiginit(self, _core.new_VisualStyles())
    __swig_destroy__ = _core.delete_VisualStyles

# Register VisualStyles in _core:
_core.VisualStyles_swigregister(VisualStyles)

class CameraTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    OrthographicCameraType = _core.CameraTypes_OrthographicCameraType
    PerspectiveCameraType = _core.CameraTypes_PerspectiveCameraType
    PerspectiveWithOrthoFacesCameraType = _core.CameraTypes_PerspectiveWithOrthoFacesCameraType

    def __init__(self):
        _core.CameraTypes_swiginit(self, _core.new_CameraTypes())
    __swig_destroy__ = _core.delete_CameraTypes

# Register CameraTypes in _core:
_core.CameraTypes_swigregister(CameraTypes)

class ViewOrientations(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ArbitraryViewOrientation = _core.ViewOrientations_ArbitraryViewOrientation
    BackViewOrientation = _core.ViewOrientations_BackViewOrientation
    BottomViewOrientation = _core.ViewOrientations_BottomViewOrientation
    FrontViewOrientation = _core.ViewOrientations_FrontViewOrientation
    IsoBottomLeftViewOrientation = _core.ViewOrientations_IsoBottomLeftViewOrientation
    IsoBottomRightViewOrientation = _core.ViewOrientations_IsoBottomRightViewOrientation
    IsoTopLeftViewOrientation = _core.ViewOrientations_IsoTopLeftViewOrientation
    IsoTopRightViewOrientation = _core.ViewOrientations_IsoTopRightViewOrientation
    LeftViewOrientation = _core.ViewOrientations_LeftViewOrientation
    RightViewOrientation = _core.ViewOrientations_RightViewOrientation
    TopViewOrientation = _core.ViewOrientations_TopViewOrientation

    def __init__(self):
        _core.ViewOrientations_swiginit(self, _core.new_ViewOrientations())
    __swig_destroy__ = _core.delete_ViewOrientations

# Register ViewOrientations in _core:
_core.ViewOrientations_swigregister(ViewOrientations)

class HubTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    PersonalHubType = _core.HubTypes_PersonalHubType
    TeamHubType = _core.HubTypes_TeamHubType

    def __init__(self):
        _core.HubTypes_swiginit(self, _core.new_HubTypes())
    __swig_destroy__ = _core.delete_HubTypes

# Register HubTypes in _core:
_core.HubTypes_swigregister(HubTypes)

class UploadStates(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    UploadProcessing = _core.UploadStates_UploadProcessing
    UploadFinished = _core.UploadStates_UploadFinished
    UploadFailed = _core.UploadStates_UploadFailed

    def __init__(self):
        _core.UploadStates_swiginit(self, _core.new_UploadStates())
    __swig_destroy__ = _core.delete_UploadStates

# Register UploadStates in _core:
_core.UploadStates_swigregister(UploadStates)

class Curve2DTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Line2DCurveType = _core.Curve2DTypes_Line2DCurveType
    Arc2DCurveType = _core.Curve2DTypes_Arc2DCurveType
    Circle2DCurveType = _core.Curve2DTypes_Circle2DCurveType
    Ellipse2DCurveType = _core.Curve2DTypes_Ellipse2DCurveType
    EllipticalArc2DCurveType = _core.Curve2DTypes_EllipticalArc2DCurveType
    InfiniteLine2DCurveType = _core.Curve2DTypes_InfiniteLine2DCurveType
    NurbsCurve2DCurveType = _core.Curve2DTypes_NurbsCurve2DCurveType

    def __init__(self):
        _core.Curve2DTypes_swiginit(self, _core.new_Curve2DTypes())
    __swig_destroy__ = _core.delete_Curve2DTypes

# Register Curve2DTypes in _core:
_core.Curve2DTypes_swigregister(Curve2DTypes)

class Curve3DTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Line3DCurveType = _core.Curve3DTypes_Line3DCurveType
    Arc3DCurveType = _core.Curve3DTypes_Arc3DCurveType
    Circle3DCurveType = _core.Curve3DTypes_Circle3DCurveType
    Ellipse3DCurveType = _core.Curve3DTypes_Ellipse3DCurveType
    EllipticalArc3DCurveType = _core.Curve3DTypes_EllipticalArc3DCurveType
    InfiniteLine3DCurveType = _core.Curve3DTypes_InfiniteLine3DCurveType
    NurbsCurve3DCurveType = _core.Curve3DTypes_NurbsCurve3DCurveType

    def __init__(self):
        _core.Curve3DTypes_swiginit(self, _core.new_Curve3DTypes())
    __swig_destroy__ = _core.delete_Curve3DTypes

# Register Curve3DTypes in _core:
_core.Curve3DTypes_swigregister(Curve3DTypes)

class SurfaceTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    PlaneSurfaceType = _core.SurfaceTypes_PlaneSurfaceType
    CylinderSurfaceType = _core.SurfaceTypes_CylinderSurfaceType
    ConeSurfaceType = _core.SurfaceTypes_ConeSurfaceType
    SphereSurfaceType = _core.SurfaceTypes_SphereSurfaceType
    TorusSurfaceType = _core.SurfaceTypes_TorusSurfaceType
    EllipticalCylinderSurfaceType = _core.SurfaceTypes_EllipticalCylinderSurfaceType
    EllipticalConeSurfaceType = _core.SurfaceTypes_EllipticalConeSurfaceType
    NurbsSurfaceType = _core.SurfaceTypes_NurbsSurfaceType

    def __init__(self):
        _core.SurfaceTypes_swiginit(self, _core.new_SurfaceTypes())
    __swig_destroy__ = _core.delete_SurfaceTypes

# Register SurfaceTypes in _core:
_core.SurfaceTypes_swigregister(SurfaceTypes)

class NurbsSurfaceProperties(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    OpenNurbsSurface = _core.NurbsSurfaceProperties_OpenNurbsSurface
    ClosedNurbsSurface = _core.NurbsSurfaceProperties_ClosedNurbsSurface
    PeriodicNurbsSurface = _core.NurbsSurfaceProperties_PeriodicNurbsSurface
    RationalNurbsSurface = _core.NurbsSurfaceProperties_RationalNurbsSurface

    def __init__(self):
        _core.NurbsSurfaceProperties_swiginit(self, _core.new_NurbsSurfaceProperties())
    __swig_destroy__ = _core.delete_NurbsSurfaceProperties

# Register NurbsSurfaceProperties in _core:
_core.NurbsSurfaceProperties_swigregister(NurbsSurfaceProperties)

class VectorError(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ZeroLengthVectorError = _core.VectorError_ZeroLengthVectorError

    def __init__(self):
        _core.VectorError_swiginit(self, _core.new_VectorError())
    __swig_destroy__ = _core.delete_VectorError

# Register VectorError in _core:
_core.VectorError_swigregister(VectorError)

class TextureTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    UnknownTexture = _core.TextureTypes_UnknownTexture
    ImageTexture = _core.TextureTypes_ImageTexture
    CheckerTexture = _core.TextureTypes_CheckerTexture
    GradientTexture = _core.TextureTypes_GradientTexture
    MarbleTexture = _core.TextureTypes_MarbleTexture
    NoiseTexture = _core.TextureTypes_NoiseTexture
    SpeckleTexture = _core.TextureTypes_SpeckleTexture
    TileTexture = _core.TextureTypes_TileTexture
    WaveTexture = _core.TextureTypes_WaveTexture
    WoodTexture = _core.TextureTypes_WoodTexture

    def __init__(self):
        _core.TextureTypes_swiginit(self, _core.new_TextureTypes())
    __swig_destroy__ = _core.delete_TextureTypes

# Register TextureTypes in _core:
_core.TextureTypes_swigregister(TextureTypes)

class AppearanceSourceTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    MaterialAppearanceSource = _core.AppearanceSourceTypes_MaterialAppearanceSource
    BodyAppearanceSource = _core.AppearanceSourceTypes_BodyAppearanceSource
    OccurrenceAppearanceSource = _core.AppearanceSourceTypes_OccurrenceAppearanceSource
    FaceAppearanceSource = _core.AppearanceSourceTypes_FaceAppearanceSource
    OverrideAppearanceSource = _core.AppearanceSourceTypes_OverrideAppearanceSource

    def __init__(self):
        _core.AppearanceSourceTypes_swiginit(self, _core.new_AppearanceSourceTypes())
    __swig_destroy__ = _core.delete_AppearanceSourceTypes

# Register AppearanceSourceTypes in _core:
_core.AppearanceSourceTypes_swigregister(AppearanceSourceTypes)

class DialogResults(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DialogError = _core.DialogResults_DialogError
    DialogOK = _core.DialogResults_DialogOK
    DialogCancel = _core.DialogResults_DialogCancel
    DialogYes = _core.DialogResults_DialogYes
    DialogNo = _core.DialogResults_DialogNo

    def __init__(self):
        _core.DialogResults_swiginit(self, _core.new_DialogResults())
    __swig_destroy__ = _core.delete_DialogResults

# Register DialogResults in _core:
_core.DialogResults_swigregister(DialogResults)

class MessageBoxButtonTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    OKButtonType = _core.MessageBoxButtonTypes_OKButtonType
    OKCancelButtonType = _core.MessageBoxButtonTypes_OKCancelButtonType
    RetryCancelButtonType = _core.MessageBoxButtonTypes_RetryCancelButtonType
    YesNoButtonType = _core.MessageBoxButtonTypes_YesNoButtonType
    YesNoCancelButtonType = _core.MessageBoxButtonTypes_YesNoCancelButtonType

    def __init__(self):
        _core.MessageBoxButtonTypes_swiginit(self, _core.new_MessageBoxButtonTypes())
    __swig_destroy__ = _core.delete_MessageBoxButtonTypes

# Register MessageBoxButtonTypes in _core:
_core.MessageBoxButtonTypes_swigregister(MessageBoxButtonTypes)

class MessageBoxIconTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    NoIconIconType = _core.MessageBoxIconTypes_NoIconIconType
    QuestionIconType = _core.MessageBoxIconTypes_QuestionIconType
    InformationIconType = _core.MessageBoxIconTypes_InformationIconType
    WarningIconType = _core.MessageBoxIconTypes_WarningIconType
    CriticalIconType = _core.MessageBoxIconTypes_CriticalIconType

    def __init__(self):
        _core.MessageBoxIconTypes_swiginit(self, _core.new_MessageBoxIconTypes())
    __swig_destroy__ = _core.delete_MessageBoxIconTypes

# Register MessageBoxIconTypes in _core:
_core.MessageBoxIconTypes_swigregister(MessageBoxIconTypes)

class PaletteDockingOptions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    PaletteDockOptionsNone = _core.PaletteDockingOptions_PaletteDockOptionsNone
    PaletteDockOptionsToVerticalOnly = _core.PaletteDockingOptions_PaletteDockOptionsToVerticalOnly
    PaletteDockOptionsToHorizontalOnly = _core.PaletteDockingOptions_PaletteDockOptionsToHorizontalOnly
    PaletteDockOptionsToVerticalAndHorizontal = _core.PaletteDockingOptions_PaletteDockOptionsToVerticalAndHorizontal

    def __init__(self):
        _core.PaletteDockingOptions_swiginit(self, _core.new_PaletteDockingOptions())
    __swig_destroy__ = _core.delete_PaletteDockingOptions

# Register PaletteDockingOptions in _core:
_core.PaletteDockingOptions_swigregister(PaletteDockingOptions)

class PaletteDockingStates(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    PaletteDockStateFloating = _core.PaletteDockingStates_PaletteDockStateFloating
    PaletteDockStateTop = _core.PaletteDockingStates_PaletteDockStateTop
    PaletteDockStateBottom = _core.PaletteDockingStates_PaletteDockStateBottom
    PaletteDockStateLeft = _core.PaletteDockingStates_PaletteDockStateLeft
    PaletteDockStateRight = _core.PaletteDockingStates_PaletteDockStateRight

    def __init__(self):
        _core.PaletteDockingStates_swiginit(self, _core.new_PaletteDockingStates())
    __swig_destroy__ = _core.delete_PaletteDockingStates

# Register PaletteDockingStates in _core:
_core.PaletteDockingStates_swigregister(PaletteDockingStates)

class PaletteSnapOptions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    PaletteSnapOptionsTop = _core.PaletteSnapOptions_PaletteSnapOptionsTop
    PaletteSnapOptionsLeft = _core.PaletteSnapOptions_PaletteSnapOptionsLeft
    PaletteSnapOptionsRight = _core.PaletteSnapOptions_PaletteSnapOptionsRight
    PaletteSnapOptionsBottom = _core.PaletteSnapOptions_PaletteSnapOptionsBottom

    def __init__(self):
        _core.PaletteSnapOptions_swiginit(self, _core.new_PaletteSnapOptions())
    __swig_destroy__ = _core.delete_PaletteSnapOptions

# Register PaletteSnapOptions in _core:
_core.PaletteSnapOptions_swigregister(PaletteSnapOptions)

class ListControlDisplayTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    CheckBoxListType = _core.ListControlDisplayTypes_CheckBoxListType
    RadioButtonlistType = _core.ListControlDisplayTypes_RadioButtonlistType
    StandardListType = _core.ListControlDisplayTypes_StandardListType

    def __init__(self):
        _core.ListControlDisplayTypes_swiginit(self, _core.new_ListControlDisplayTypes())
    __swig_destroy__ = _core.delete_ListControlDisplayTypes

# Register ListControlDisplayTypes in _core:
_core.ListControlDisplayTypes_swigregister(ListControlDisplayTypes)

class CommandTerminationReason(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    UnknownTerminationReason = _core.CommandTerminationReason_UnknownTerminationReason
    CompletedTerminationReason = _core.CommandTerminationReason_CompletedTerminationReason
    CancelledTerminationReason = _core.CommandTerminationReason_CancelledTerminationReason
    AbortedTerminationReason = _core.CommandTerminationReason_AbortedTerminationReason
    PreEmptedTerminationReason = _core.CommandTerminationReason_PreEmptedTerminationReason
    SessionEndingTerminationReason = _core.CommandTerminationReason_SessionEndingTerminationReason

    def __init__(self):
        _core.CommandTerminationReason_swiginit(self, _core.new_CommandTerminationReason())
    __swig_destroy__ = _core.delete_CommandTerminationReason

# Register CommandTerminationReason in _core:
_core.CommandTerminationReason_swigregister(CommandTerminationReason)

class KeyCodes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    NoKeyCode = _core.KeyCodes_NoKeyCode
    SpaceKeyCode = _core.KeyCodes_SpaceKeyCode
    AsteriskKeyCode = _core.KeyCodes_AsteriskKeyCode
    PlusKeyCode = _core.KeyCodes_PlusKeyCode
    CommaKeyCode = _core.KeyCodes_CommaKeyCode
    MinusKeyCode = _core.KeyCodes_MinusKeyCode
    PeriodKeyCode = _core.KeyCodes_PeriodKeyCode
    SlashKeyCode = _core.KeyCodes_SlashKeyCode
    D0KeyCode = _core.KeyCodes_D0KeyCode
    D1KeyCode = _core.KeyCodes_D1KeyCode
    D2KeyCode = _core.KeyCodes_D2KeyCode
    D3KeyCode = _core.KeyCodes_D3KeyCode
    D4KeyCode = _core.KeyCodes_D4KeyCode
    D5KeyCode = _core.KeyCodes_D5KeyCode
    D6KeyCode = _core.KeyCodes_D6KeyCode
    D7KeyCode = _core.KeyCodes_D7KeyCode
    D8KeyCode = _core.KeyCodes_D8KeyCode
    D9KeyCode = _core.KeyCodes_D9KeyCode
    ColonKeyCode = _core.KeyCodes_ColonKeyCode
    SemicolonKeyCode = _core.KeyCodes_SemicolonKeyCode
    LessKeyCode = _core.KeyCodes_LessKeyCode
    EqualKeyCode = _core.KeyCodes_EqualKeyCode
    GreaterKeyCode = _core.KeyCodes_GreaterKeyCode
    QuestionKeyCode = _core.KeyCodes_QuestionKeyCode
    AKeyCode = _core.KeyCodes_AKeyCode
    BKeyCode = _core.KeyCodes_BKeyCode
    CKeyCode = _core.KeyCodes_CKeyCode
    DKeyCode = _core.KeyCodes_DKeyCode
    EKeyCode = _core.KeyCodes_EKeyCode
    FKeyCode = _core.KeyCodes_FKeyCode
    GKeyCode = _core.KeyCodes_GKeyCode
    HKeyCode = _core.KeyCodes_HKeyCode
    IKeyCode = _core.KeyCodes_IKeyCode
    JKeyCode = _core.KeyCodes_JKeyCode
    KKeyCode = _core.KeyCodes_KKeyCode
    LKeyCode = _core.KeyCodes_LKeyCode
    MKeyCode = _core.KeyCodes_MKeyCode
    NKeyCode = _core.KeyCodes_NKeyCode
    OKeyCode = _core.KeyCodes_OKeyCode
    PKeyCode = _core.KeyCodes_PKeyCode
    QKeyCode = _core.KeyCodes_QKeyCode
    RKeyCode = _core.KeyCodes_RKeyCode
    SKeyCode = _core.KeyCodes_SKeyCode
    TKeyCode = _core.KeyCodes_TKeyCode
    UKeyCode = _core.KeyCodes_UKeyCode
    VKeyCode = _core.KeyCodes_VKeyCode
    WKeyCode = _core.KeyCodes_WKeyCode
    XKeyCode = _core.KeyCodes_XKeyCode
    YKeyCode = _core.KeyCodes_YKeyCode
    ZKeyCode = _core.KeyCodes_ZKeyCode
    BracketLeftKeyCode = _core.KeyCodes_BracketLeftKeyCode
    BackslashKeyCode = _core.KeyCodes_BackslashKeyCode
    BracketRightKeyCode = _core.KeyCodes_BracketRightKeyCode
    AsciiCircumKeyCode = _core.KeyCodes_AsciiCircumKeyCode
    UnderscoreKeyCode = _core.KeyCodes_UnderscoreKeyCode
    QuoteLeftKeyCode = _core.KeyCodes_QuoteLeftKeyCode
    BraceLeftKeyCode = _core.KeyCodes_BraceLeftKeyCode
    BarKeyCode = _core.KeyCodes_BarKeyCode
    BraceRightKeyCode = _core.KeyCodes_BraceRightKeyCode
    AsciiTildeKeyCode = _core.KeyCodes_AsciiTildeKeyCode
    GraveAccentKeyCode = _core.KeyCodes_GraveAccentKeyCode
    EscapeKeyCode = _core.KeyCodes_EscapeKeyCode
    TabKeyCode = _core.KeyCodes_TabKeyCode
    BacktabKeyCode = _core.KeyCodes_BacktabKeyCode
    BackspaceKeyCode = _core.KeyCodes_BackspaceKeyCode
    ReturnKeyCode = _core.KeyCodes_ReturnKeyCode
    EnterKeyCode = _core.KeyCodes_EnterKeyCode
    InsertKeyCode = _core.KeyCodes_InsertKeyCode
    DeleteKeyCode = _core.KeyCodes_DeleteKeyCode
    PauseKeyCode = _core.KeyCodes_PauseKeyCode
    PrintKeyCode = _core.KeyCodes_PrintKeyCode
    SysReqKeyCode = _core.KeyCodes_SysReqKeyCode
    ClearKeyCode = _core.KeyCodes_ClearKeyCode
    HomeKeyCode = _core.KeyCodes_HomeKeyCode
    EndKeyCode = _core.KeyCodes_EndKeyCode
    LeftKeyCode = _core.KeyCodes_LeftKeyCode
    UpKeyCode = _core.KeyCodes_UpKeyCode
    RightKeyCode = _core.KeyCodes_RightKeyCode
    DownKeyCode = _core.KeyCodes_DownKeyCode
    PageUpKeyCode = _core.KeyCodes_PageUpKeyCode
    PageDownKeyCode = _core.KeyCodes_PageDownKeyCode
    ShiftKeyCode = _core.KeyCodes_ShiftKeyCode
    ControlKeyCode = _core.KeyCodes_ControlKeyCode
    MetaKeyCode = _core.KeyCodes_MetaKeyCode
    AltKeyCode = _core.KeyCodes_AltKeyCode
    F1KeyCode = _core.KeyCodes_F1KeyCode
    F2KeyCode = _core.KeyCodes_F2KeyCode
    F3KeyCode = _core.KeyCodes_F3KeyCode
    F4KeyCode = _core.KeyCodes_F4KeyCode
    F5KeyCode = _core.KeyCodes_F5KeyCode
    F6KeyCode = _core.KeyCodes_F6KeyCode
    F7KeyCode = _core.KeyCodes_F7KeyCode
    F8KeyCode = _core.KeyCodes_F8KeyCode
    F9KeyCode = _core.KeyCodes_F9KeyCode
    F10KeyCode = _core.KeyCodes_F10KeyCode
    F11KeyCode = _core.KeyCodes_F11KeyCode
    F12KeyCode = _core.KeyCodes_F12KeyCode
    MenuKeyCode = _core.KeyCodes_MenuKeyCode

    def __init__(self):
        _core.KeyCodes_swiginit(self, _core.new_KeyCodes())
    __swig_destroy__ = _core.delete_KeyCodes

# Register KeyCodes in _core:
_core.KeyCodes_swigregister(KeyCodes)

class KeyboardModifiers(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    NoKeyboardModifier = _core.KeyboardModifiers_NoKeyboardModifier
    ShiftKeyboardModifier = _core.KeyboardModifiers_ShiftKeyboardModifier
    CtrlKeyboardModifier = _core.KeyboardModifiers_CtrlKeyboardModifier
    AltKeyboardModifier = _core.KeyboardModifiers_AltKeyboardModifier
    MetaKeyboardModifier = _core.KeyboardModifiers_MetaKeyboardModifier

    def __init__(self):
        _core.KeyboardModifiers_swiginit(self, _core.new_KeyboardModifiers())
    __swig_destroy__ = _core.delete_KeyboardModifiers

# Register KeyboardModifiers in _core:
_core.KeyboardModifiers_swigregister(KeyboardModifiers)

class MouseButtons(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    NoMouseButton = _core.MouseButtons_NoMouseButton
    LeftMouseButton = _core.MouseButtons_LeftMouseButton
    RightMouseButton = _core.MouseButtons_RightMouseButton
    MiddleMouseButton = _core.MouseButtons_MiddleMouseButton

    def __init__(self):
        _core.MouseButtons_swiginit(self, _core.new_MouseButtons())
    __swig_destroy__ = _core.delete_MouseButtons

# Register MouseButtons in _core:
_core.MouseButtons_swigregister(MouseButtons)

class DropDownStyles(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    LabeledIconDropDownStyle = _core.DropDownStyles_LabeledIconDropDownStyle
    TextListDropDownStyle = _core.DropDownStyles_TextListDropDownStyle
    CheckBoxDropDownStyle = _core.DropDownStyles_CheckBoxDropDownStyle

    def __init__(self):
        _core.DropDownStyles_swiginit(self, _core.new_DropDownStyles())
    __swig_destroy__ = _core.delete_DropDownStyles

# Register DropDownStyles in _core:
_core.DropDownStyles_swigregister(DropDownStyles)

class TablePresentationStyles(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nameValueTablePresentationStyle = _core.TablePresentationStyles_nameValueTablePresentationStyle
    itemBorderTablePresentationStyle = _core.TablePresentationStyles_itemBorderTablePresentationStyle
    transparentBackgroundTablePresentationStyle = _core.TablePresentationStyles_transparentBackgroundTablePresentationStyle

    def __init__(self):
        _core.TablePresentationStyles_swiginit(self, _core.new_TablePresentationStyles())
    __swig_destroy__ = _core.delete_TablePresentationStyles

# Register TablePresentationStyles in _core:
_core.TablePresentationStyles_swigregister(TablePresentationStyles)

class AttributeVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.AttributeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.AttributeVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.AttributeVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::size_type":
        return _core.AttributeVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::core::Attribute >,std::allocator< adsk::core::Ptr< adsk::core::Attribute > > > *":
        return _core.AttributeVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.AttributeVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::difference_type") -> "void":
        return _core.AttributeVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.AttributeVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::value_type const &":
        return _core.AttributeVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.AttributeVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::value_type":
        return _core.AttributeVector_pop(self)

    def append(self, x: "Attribute") -> "void":
        return _core.AttributeVector_append(self, x)

    def empty(self) -> "bool":
        return _core.AttributeVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::size_type":
        return _core.AttributeVector_size(self)

    def swap(self, v: "AttributeVector") -> "void":
        return _core.AttributeVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::iterator":
        return _core.AttributeVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::iterator":
        return _core.AttributeVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::reverse_iterator":
        return _core.AttributeVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::reverse_iterator":
        return _core.AttributeVector_rend(self)

    def clear(self) -> "void":
        return _core.AttributeVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::allocator_type":
        return _core.AttributeVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.AttributeVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::iterator":
        return _core.AttributeVector_erase(self, *args)

    def __init__(self, *args):
        _core.AttributeVector_swiginit(self, _core.new_AttributeVector(*args))

    def push_back(self, x: "Attribute") -> "void":
        return _core.AttributeVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::value_type const &":
        return _core.AttributeVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::value_type const &":
        return _core.AttributeVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::size_type", x: "Attribute") -> "void":
        return _core.AttributeVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.AttributeVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.AttributeVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::size_type") -> "void":
        return _core.AttributeVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::size_type":
        return _core.AttributeVector_capacity(self)
    __swig_destroy__ = _core.delete_AttributeVector

# Register AttributeVector in _core:
_core.AttributeVector_swigregister(AttributeVector)

class ColorVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.ColorVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.ColorVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.ColorVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::size_type":
        return _core.ColorVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::Color > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::Color > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::core::Color >,std::allocator< adsk::core::Ptr< adsk::core::Color > > > *":
        return _core.ColorVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.ColorVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::Color > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::Color > >::difference_type") -> "void":
        return _core.ColorVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.ColorVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::value_type const &":
        return _core.ColorVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.ColorVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::value_type":
        return _core.ColorVector_pop(self)

    def append(self, x: "Color") -> "void":
        return _core.ColorVector_append(self, x)

    def empty(self) -> "bool":
        return _core.ColorVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::size_type":
        return _core.ColorVector_size(self)

    def swap(self, v: "ColorVector") -> "void":
        return _core.ColorVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::iterator":
        return _core.ColorVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::iterator":
        return _core.ColorVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::reverse_iterator":
        return _core.ColorVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::reverse_iterator":
        return _core.ColorVector_rend(self)

    def clear(self) -> "void":
        return _core.ColorVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::allocator_type":
        return _core.ColorVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.ColorVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::iterator":
        return _core.ColorVector_erase(self, *args)

    def __init__(self, *args):
        _core.ColorVector_swiginit(self, _core.new_ColorVector(*args))

    def push_back(self, x: "Color") -> "void":
        return _core.ColorVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::value_type const &":
        return _core.ColorVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::value_type const &":
        return _core.ColorVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::core::Color > >::size_type", x: "Color") -> "void":
        return _core.ColorVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.ColorVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.ColorVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::core::Color > >::size_type") -> "void":
        return _core.ColorVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::size_type":
        return _core.ColorVector_capacity(self)
    __swig_destroy__ = _core.delete_ColorVector

# Register ColorVector in _core:
_core.ColorVector_swigregister(ColorVector)

class CommandDefinitionVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.CommandDefinitionVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.CommandDefinitionVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.CommandDefinitionVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::size_type":
        return _core.CommandDefinitionVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition >,std::allocator< adsk::core::Ptr< adsk::core::CommandDefinition > > > *":
        return _core.CommandDefinitionVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.CommandDefinitionVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::difference_type") -> "void":
        return _core.CommandDefinitionVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.CommandDefinitionVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::value_type const &":
        return _core.CommandDefinitionVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.CommandDefinitionVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::value_type":
        return _core.CommandDefinitionVector_pop(self)

    def append(self, x: "CommandDefinition") -> "void":
        return _core.CommandDefinitionVector_append(self, x)

    def empty(self) -> "bool":
        return _core.CommandDefinitionVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::size_type":
        return _core.CommandDefinitionVector_size(self)

    def swap(self, v: "CommandDefinitionVector") -> "void":
        return _core.CommandDefinitionVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::iterator":
        return _core.CommandDefinitionVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::iterator":
        return _core.CommandDefinitionVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::reverse_iterator":
        return _core.CommandDefinitionVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::reverse_iterator":
        return _core.CommandDefinitionVector_rend(self)

    def clear(self) -> "void":
        return _core.CommandDefinitionVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::allocator_type":
        return _core.CommandDefinitionVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.CommandDefinitionVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::iterator":
        return _core.CommandDefinitionVector_erase(self, *args)

    def __init__(self, *args):
        _core.CommandDefinitionVector_swiginit(self, _core.new_CommandDefinitionVector(*args))

    def push_back(self, x: "CommandDefinition") -> "void":
        return _core.CommandDefinitionVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::value_type const &":
        return _core.CommandDefinitionVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::value_type const &":
        return _core.CommandDefinitionVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::size_type", x: "CommandDefinition") -> "void":
        return _core.CommandDefinitionVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.CommandDefinitionVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.CommandDefinitionVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::size_type") -> "void":
        return _core.CommandDefinitionVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::size_type":
        return _core.CommandDefinitionVector_capacity(self)
    __swig_destroy__ = _core.delete_CommandDefinitionVector

# Register CommandDefinitionVector in _core:
_core.CommandDefinitionVector_swigregister(CommandDefinitionVector)

class DataFileVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.DataFileVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.DataFileVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.DataFileVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFile > >::size_type":
        return _core.DataFileVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::DataFile > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::DataFile > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::core::DataFile >,std::allocator< adsk::core::Ptr< adsk::core::DataFile > > > *":
        return _core.DataFileVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.DataFileVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::DataFile > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::DataFile > >::difference_type") -> "void":
        return _core.DataFileVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.DataFileVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::DataFile > >::value_type const &":
        return _core.DataFileVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.DataFileVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFile > >::value_type":
        return _core.DataFileVector_pop(self)

    def append(self, x: "DataFile") -> "void":
        return _core.DataFileVector_append(self, x)

    def empty(self) -> "bool":
        return _core.DataFileVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFile > >::size_type":
        return _core.DataFileVector_size(self)

    def swap(self, v: "DataFileVector") -> "void":
        return _core.DataFileVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFile > >::iterator":
        return _core.DataFileVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFile > >::iterator":
        return _core.DataFileVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFile > >::reverse_iterator":
        return _core.DataFileVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFile > >::reverse_iterator":
        return _core.DataFileVector_rend(self)

    def clear(self) -> "void":
        return _core.DataFileVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFile > >::allocator_type":
        return _core.DataFileVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.DataFileVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::DataFile > >::iterator":
        return _core.DataFileVector_erase(self, *args)

    def __init__(self, *args):
        _core.DataFileVector_swiginit(self, _core.new_DataFileVector(*args))

    def push_back(self, x: "DataFile") -> "void":
        return _core.DataFileVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFile > >::value_type const &":
        return _core.DataFileVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFile > >::value_type const &":
        return _core.DataFileVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::core::DataFile > >::size_type", x: "DataFile") -> "void":
        return _core.DataFileVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.DataFileVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.DataFileVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::core::DataFile > >::size_type") -> "void":
        return _core.DataFileVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFile > >::size_type":
        return _core.DataFileVector_capacity(self)
    __swig_destroy__ = _core.delete_DataFileVector

# Register DataFileVector in _core:
_core.DataFileVector_swigregister(DataFileVector)

class DataFolderVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.DataFolderVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.DataFolderVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.DataFolderVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFolder > >::size_type":
        return _core.DataFolderVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::DataFolder > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::DataFolder > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::core::DataFolder >,std::allocator< adsk::core::Ptr< adsk::core::DataFolder > > > *":
        return _core.DataFolderVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.DataFolderVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::DataFolder > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::DataFolder > >::difference_type") -> "void":
        return _core.DataFolderVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.DataFolderVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::DataFolder > >::value_type const &":
        return _core.DataFolderVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.DataFolderVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFolder > >::value_type":
        return _core.DataFolderVector_pop(self)

    def append(self, x: "DataFolder") -> "void":
        return _core.DataFolderVector_append(self, x)

    def empty(self) -> "bool":
        return _core.DataFolderVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFolder > >::size_type":
        return _core.DataFolderVector_size(self)

    def swap(self, v: "DataFolderVector") -> "void":
        return _core.DataFolderVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFolder > >::iterator":
        return _core.DataFolderVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFolder > >::iterator":
        return _core.DataFolderVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFolder > >::reverse_iterator":
        return _core.DataFolderVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFolder > >::reverse_iterator":
        return _core.DataFolderVector_rend(self)

    def clear(self) -> "void":
        return _core.DataFolderVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFolder > >::allocator_type":
        return _core.DataFolderVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.DataFolderVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::DataFolder > >::iterator":
        return _core.DataFolderVector_erase(self, *args)

    def __init__(self, *args):
        _core.DataFolderVector_swiginit(self, _core.new_DataFolderVector(*args))

    def push_back(self, x: "DataFolder") -> "void":
        return _core.DataFolderVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFolder > >::value_type const &":
        return _core.DataFolderVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFolder > >::value_type const &":
        return _core.DataFolderVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::core::DataFolder > >::size_type", x: "DataFolder") -> "void":
        return _core.DataFolderVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.DataFolderVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.DataFolderVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::core::DataFolder > >::size_type") -> "void":
        return _core.DataFolderVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFolder > >::size_type":
        return _core.DataFolderVector_capacity(self)
    __swig_destroy__ = _core.delete_DataFolderVector

# Register DataFolderVector in _core:
_core.DataFolderVector_swigregister(DataFolderVector)

class DataHubVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.DataHubVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.DataHubVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.DataHubVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataHub > >::size_type":
        return _core.DataHubVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::DataHub > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::DataHub > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::core::DataHub >,std::allocator< adsk::core::Ptr< adsk::core::DataHub > > > *":
        return _core.DataHubVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.DataHubVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::DataHub > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::DataHub > >::difference_type") -> "void":
        return _core.DataHubVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.DataHubVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::DataHub > >::value_type const &":
        return _core.DataHubVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.DataHubVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataHub > >::value_type":
        return _core.DataHubVector_pop(self)

    def append(self, x: "DataHub") -> "void":
        return _core.DataHubVector_append(self, x)

    def empty(self) -> "bool":
        return _core.DataHubVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataHub > >::size_type":
        return _core.DataHubVector_size(self)

    def swap(self, v: "DataHubVector") -> "void":
        return _core.DataHubVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataHub > >::iterator":
        return _core.DataHubVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataHub > >::iterator":
        return _core.DataHubVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataHub > >::reverse_iterator":
        return _core.DataHubVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataHub > >::reverse_iterator":
        return _core.DataHubVector_rend(self)

    def clear(self) -> "void":
        return _core.DataHubVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataHub > >::allocator_type":
        return _core.DataHubVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.DataHubVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::DataHub > >::iterator":
        return _core.DataHubVector_erase(self, *args)

    def __init__(self, *args):
        _core.DataHubVector_swiginit(self, _core.new_DataHubVector(*args))

    def push_back(self, x: "DataHub") -> "void":
        return _core.DataHubVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataHub > >::value_type const &":
        return _core.DataHubVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataHub > >::value_type const &":
        return _core.DataHubVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::core::DataHub > >::size_type", x: "DataHub") -> "void":
        return _core.DataHubVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.DataHubVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.DataHubVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::core::DataHub > >::size_type") -> "void":
        return _core.DataHubVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataHub > >::size_type":
        return _core.DataHubVector_capacity(self)
    __swig_destroy__ = _core.delete_DataHubVector

# Register DataHubVector in _core:
_core.DataHubVector_swigregister(DataHubVector)

class DataProjectVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.DataProjectVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.DataProjectVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.DataProjectVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataProject > >::size_type":
        return _core.DataProjectVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::DataProject > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::DataProject > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::core::DataProject >,std::allocator< adsk::core::Ptr< adsk::core::DataProject > > > *":
        return _core.DataProjectVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.DataProjectVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::DataProject > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::DataProject > >::difference_type") -> "void":
        return _core.DataProjectVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.DataProjectVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::DataProject > >::value_type const &":
        return _core.DataProjectVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.DataProjectVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataProject > >::value_type":
        return _core.DataProjectVector_pop(self)

    def append(self, x: "DataProject") -> "void":
        return _core.DataProjectVector_append(self, x)

    def empty(self) -> "bool":
        return _core.DataProjectVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataProject > >::size_type":
        return _core.DataProjectVector_size(self)

    def swap(self, v: "DataProjectVector") -> "void":
        return _core.DataProjectVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataProject > >::iterator":
        return _core.DataProjectVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataProject > >::iterator":
        return _core.DataProjectVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataProject > >::reverse_iterator":
        return _core.DataProjectVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataProject > >::reverse_iterator":
        return _core.DataProjectVector_rend(self)

    def clear(self) -> "void":
        return _core.DataProjectVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataProject > >::allocator_type":
        return _core.DataProjectVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.DataProjectVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::DataProject > >::iterator":
        return _core.DataProjectVector_erase(self, *args)

    def __init__(self, *args):
        _core.DataProjectVector_swiginit(self, _core.new_DataProjectVector(*args))

    def push_back(self, x: "DataProject") -> "void":
        return _core.DataProjectVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataProject > >::value_type const &":
        return _core.DataProjectVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataProject > >::value_type const &":
        return _core.DataProjectVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::core::DataProject > >::size_type", x: "DataProject") -> "void":
        return _core.DataProjectVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.DataProjectVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.DataProjectVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::core::DataProject > >::size_type") -> "void":
        return _core.DataProjectVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataProject > >::size_type":
        return _core.DataProjectVector_capacity(self)
    __swig_destroy__ = _core.delete_DataProjectVector

# Register DataProjectVector in _core:
_core.DataProjectVector_swigregister(DataProjectVector)

class Point2DVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.Point2DVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.Point2DVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.Point2DVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::size_type":
        return _core.Point2DVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::core::Point2D >,std::allocator< adsk::core::Ptr< adsk::core::Point2D > > > *":
        return _core.Point2DVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.Point2DVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::difference_type") -> "void":
        return _core.Point2DVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.Point2DVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::value_type const &":
        return _core.Point2DVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.Point2DVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::value_type":
        return _core.Point2DVector_pop(self)

    def append(self, x: "Point2D") -> "void":
        return _core.Point2DVector_append(self, x)

    def empty(self) -> "bool":
        return _core.Point2DVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::size_type":
        return _core.Point2DVector_size(self)

    def swap(self, v: "Point2DVector") -> "void":
        return _core.Point2DVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::iterator":
        return _core.Point2DVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::iterator":
        return _core.Point2DVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::reverse_iterator":
        return _core.Point2DVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::reverse_iterator":
        return _core.Point2DVector_rend(self)

    def clear(self) -> "void":
        return _core.Point2DVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::allocator_type":
        return _core.Point2DVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.Point2DVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::iterator":
        return _core.Point2DVector_erase(self, *args)

    def __init__(self, *args):
        _core.Point2DVector_swiginit(self, _core.new_Point2DVector(*args))

    def push_back(self, x: "Point2D") -> "void":
        return _core.Point2DVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::value_type const &":
        return _core.Point2DVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::value_type const &":
        return _core.Point2DVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::size_type", x: "Point2D") -> "void":
        return _core.Point2DVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.Point2DVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.Point2DVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::size_type") -> "void":
        return _core.Point2DVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::size_type":
        return _core.Point2DVector_capacity(self)
    __swig_destroy__ = _core.delete_Point2DVector

# Register Point2DVector in _core:
_core.Point2DVector_swigregister(Point2DVector)

class Point3DVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.Point3DVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.Point3DVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.Point3DVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::size_type":
        return _core.Point3DVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::core::Point3D >,std::allocator< adsk::core::Ptr< adsk::core::Point3D > > > *":
        return _core.Point3DVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.Point3DVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::difference_type") -> "void":
        return _core.Point3DVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.Point3DVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::value_type const &":
        return _core.Point3DVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.Point3DVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::value_type":
        return _core.Point3DVector_pop(self)

    def append(self, x: "Point3D") -> "void":
        return _core.Point3DVector_append(self, x)

    def empty(self) -> "bool":
        return _core.Point3DVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::size_type":
        return _core.Point3DVector_size(self)

    def swap(self, v: "Point3DVector") -> "void":
        return _core.Point3DVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::iterator":
        return _core.Point3DVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::iterator":
        return _core.Point3DVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::reverse_iterator":
        return _core.Point3DVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::reverse_iterator":
        return _core.Point3DVector_rend(self)

    def clear(self) -> "void":
        return _core.Point3DVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::allocator_type":
        return _core.Point3DVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.Point3DVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::iterator":
        return _core.Point3DVector_erase(self, *args)

    def __init__(self, *args):
        _core.Point3DVector_swiginit(self, _core.new_Point3DVector(*args))

    def push_back(self, x: "Point3D") -> "void":
        return _core.Point3DVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::value_type const &":
        return _core.Point3DVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::value_type const &":
        return _core.Point3DVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::size_type", x: "Point3D") -> "void":
        return _core.Point3DVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.Point3DVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.Point3DVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::size_type") -> "void":
        return _core.Point3DVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::size_type":
        return _core.Point3DVector_capacity(self)
    __swig_destroy__ = _core.delete_Point3DVector

# Register Point3DVector in _core:
_core.Point3DVector_swigregister(Point3DVector)

class SelectionVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.SelectionVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.SelectionVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.SelectionVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::size_type":
        return _core.SelectionVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::Selection > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::Selection > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::core::Selection >,std::allocator< adsk::core::Ptr< adsk::core::Selection > > > *":
        return _core.SelectionVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.SelectionVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::Selection > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::Selection > >::difference_type") -> "void":
        return _core.SelectionVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.SelectionVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::value_type const &":
        return _core.SelectionVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.SelectionVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::value_type":
        return _core.SelectionVector_pop(self)

    def append(self, x: "Selection") -> "void":
        return _core.SelectionVector_append(self, x)

    def empty(self) -> "bool":
        return _core.SelectionVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::size_type":
        return _core.SelectionVector_size(self)

    def swap(self, v: "SelectionVector") -> "void":
        return _core.SelectionVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::iterator":
        return _core.SelectionVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::iterator":
        return _core.SelectionVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::reverse_iterator":
        return _core.SelectionVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::reverse_iterator":
        return _core.SelectionVector_rend(self)

    def clear(self) -> "void":
        return _core.SelectionVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::allocator_type":
        return _core.SelectionVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.SelectionVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::iterator":
        return _core.SelectionVector_erase(self, *args)

    def __init__(self, *args):
        _core.SelectionVector_swiginit(self, _core.new_SelectionVector(*args))

    def push_back(self, x: "Selection") -> "void":
        return _core.SelectionVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::value_type const &":
        return _core.SelectionVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::value_type const &":
        return _core.SelectionVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::core::Selection > >::size_type", x: "Selection") -> "void":
        return _core.SelectionVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.SelectionVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.SelectionVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::core::Selection > >::size_type") -> "void":
        return _core.SelectionVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::size_type":
        return _core.SelectionVector_capacity(self)
    __swig_destroy__ = _core.delete_SelectionVector

# Register SelectionVector in _core:
_core.SelectionVector_swigregister(SelectionVector)

class UserVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.UserVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.UserVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.UserVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::size_type":
        return _core.UserVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::User > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::User > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::core::User >,std::allocator< adsk::core::Ptr< adsk::core::User > > > *":
        return _core.UserVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.UserVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::User > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::User > >::difference_type") -> "void":
        return _core.UserVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.UserVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::value_type const &":
        return _core.UserVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.UserVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::value_type":
        return _core.UserVector_pop(self)

    def append(self, x: "User") -> "void":
        return _core.UserVector_append(self, x)

    def empty(self) -> "bool":
        return _core.UserVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::size_type":
        return _core.UserVector_size(self)

    def swap(self, v: "UserVector") -> "void":
        return _core.UserVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::iterator":
        return _core.UserVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::iterator":
        return _core.UserVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::reverse_iterator":
        return _core.UserVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::reverse_iterator":
        return _core.UserVector_rend(self)

    def clear(self) -> "void":
        return _core.UserVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::allocator_type":
        return _core.UserVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.UserVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::iterator":
        return _core.UserVector_erase(self, *args)

    def __init__(self, *args):
        _core.UserVector_swiginit(self, _core.new_UserVector(*args))

    def push_back(self, x: "User") -> "void":
        return _core.UserVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::value_type const &":
        return _core.UserVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::value_type const &":
        return _core.UserVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::core::User > >::size_type", x: "User") -> "void":
        return _core.UserVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.UserVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.UserVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::core::User > >::size_type") -> "void":
        return _core.UserVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::size_type":
        return _core.UserVector_capacity(self)
    __swig_destroy__ = _core.delete_UserVector

# Register UserVector in _core:
_core.UserVector_swigregister(UserVector)

class Vector2DVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.Vector2DVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.Vector2DVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.Vector2DVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::size_type":
        return _core.Vector2DVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D >,std::allocator< adsk::core::Ptr< adsk::core::Vector2D > > > *":
        return _core.Vector2DVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.Vector2DVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::difference_type") -> "void":
        return _core.Vector2DVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.Vector2DVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::value_type const &":
        return _core.Vector2DVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.Vector2DVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::value_type":
        return _core.Vector2DVector_pop(self)

    def append(self, x: "Vector2D") -> "void":
        return _core.Vector2DVector_append(self, x)

    def empty(self) -> "bool":
        return _core.Vector2DVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::size_type":
        return _core.Vector2DVector_size(self)

    def swap(self, v: "Vector2DVector") -> "void":
        return _core.Vector2DVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::iterator":
        return _core.Vector2DVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::iterator":
        return _core.Vector2DVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::reverse_iterator":
        return _core.Vector2DVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::reverse_iterator":
        return _core.Vector2DVector_rend(self)

    def clear(self) -> "void":
        return _core.Vector2DVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::allocator_type":
        return _core.Vector2DVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.Vector2DVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::iterator":
        return _core.Vector2DVector_erase(self, *args)

    def __init__(self, *args):
        _core.Vector2DVector_swiginit(self, _core.new_Vector2DVector(*args))

    def push_back(self, x: "Vector2D") -> "void":
        return _core.Vector2DVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::value_type const &":
        return _core.Vector2DVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::value_type const &":
        return _core.Vector2DVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::size_type", x: "Vector2D") -> "void":
        return _core.Vector2DVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.Vector2DVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.Vector2DVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::size_type") -> "void":
        return _core.Vector2DVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::size_type":
        return _core.Vector2DVector_capacity(self)
    __swig_destroy__ = _core.delete_Vector2DVector

# Register Vector2DVector in _core:
_core.Vector2DVector_swigregister(Vector2DVector)

class Vector3DVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.Vector3DVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.Vector3DVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.Vector3DVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::size_type":
        return _core.Vector3DVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D >,std::allocator< adsk::core::Ptr< adsk::core::Vector3D > > > *":
        return _core.Vector3DVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.Vector3DVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::difference_type") -> "void":
        return _core.Vector3DVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.Vector3DVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::value_type const &":
        return _core.Vector3DVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.Vector3DVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::value_type":
        return _core.Vector3DVector_pop(self)

    def append(self, x: "Vector3D") -> "void":
        return _core.Vector3DVector_append(self, x)

    def empty(self) -> "bool":
        return _core.Vector3DVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::size_type":
        return _core.Vector3DVector_size(self)

    def swap(self, v: "Vector3DVector") -> "void":
        return _core.Vector3DVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::iterator":
        return _core.Vector3DVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::iterator":
        return _core.Vector3DVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::reverse_iterator":
        return _core.Vector3DVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::reverse_iterator":
        return _core.Vector3DVector_rend(self)

    def clear(self) -> "void":
        return _core.Vector3DVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::allocator_type":
        return _core.Vector3DVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.Vector3DVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::iterator":
        return _core.Vector3DVector_erase(self, *args)

    def __init__(self, *args):
        _core.Vector3DVector_swiginit(self, _core.new_Vector3DVector(*args))

    def push_back(self, x: "Vector3D") -> "void":
        return _core.Vector3DVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::value_type const &":
        return _core.Vector3DVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::value_type const &":
        return _core.Vector3DVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::size_type", x: "Vector3D") -> "void":
        return _core.Vector3DVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.Vector3DVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.Vector3DVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::size_type") -> "void":
        return _core.Vector3DVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::size_type":
        return _core.Vector3DVector_capacity(self)
    __swig_destroy__ = _core.delete_Vector3DVector

# Register Vector3DVector in _core:
_core.Vector3DVector_swigregister(Vector3DVector)

class BaseVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.BaseVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.BaseVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.BaseVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::size_type":
        return _core.BaseVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::Base > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::Base > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::core::Base >,std::allocator< adsk::core::Ptr< adsk::core::Base > > > *":
        return _core.BaseVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.BaseVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::Base > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::Base > >::difference_type") -> "void":
        return _core.BaseVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.BaseVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::value_type const &":
        return _core.BaseVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.BaseVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::value_type":
        return _core.BaseVector_pop(self)

    def append(self, x: "Base") -> "void":
        return _core.BaseVector_append(self, x)

    def empty(self) -> "bool":
        return _core.BaseVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::size_type":
        return _core.BaseVector_size(self)

    def swap(self, v: "BaseVector") -> "void":
        return _core.BaseVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::iterator":
        return _core.BaseVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::iterator":
        return _core.BaseVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::reverse_iterator":
        return _core.BaseVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::reverse_iterator":
        return _core.BaseVector_rend(self)

    def clear(self) -> "void":
        return _core.BaseVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::allocator_type":
        return _core.BaseVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.BaseVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::iterator":
        return _core.BaseVector_erase(self, *args)

    def __init__(self, *args):
        _core.BaseVector_swiginit(self, _core.new_BaseVector(*args))

    def push_back(self, x: "Base") -> "void":
        return _core.BaseVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::value_type const &":
        return _core.BaseVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::value_type const &":
        return _core.BaseVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::core::Base > >::size_type", x: "Base") -> "void":
        return _core.BaseVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.BaseVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.BaseVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::core::Base > >::size_type") -> "void":
        return _core.BaseVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::size_type":
        return _core.BaseVector_capacity(self)
    __swig_destroy__ = _core.delete_BaseVector

# Register BaseVector in _core:
_core.BaseVector_swigregister(BaseVector)

class ActiveSelectionEventHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notify(self, eventArgs: "ActiveSelectionEventArgs") -> "void":
        return _core.ActiveSelectionEventHandler_notify(self, eventArgs)

    def __init__(self):
        if self.__class__ == ActiveSelectionEventHandler:
            _self = None
        else:
            _self = self
        _core.ActiveSelectionEventHandler_swiginit(self, _core.new_ActiveSelectionEventHandler(_self, ))
    __swig_destroy__ = _core.delete_ActiveSelectionEventHandler
    def __disown__(self):
        self.this.disown()
        _core.disown_ActiveSelectionEventHandler(self)
        return weakref.proxy(self)

# Register ActiveSelectionEventHandler in _core:
_core.ActiveSelectionEventHandler_swigregister(ActiveSelectionEventHandler)


ActiveSelectionEventHandler.cast = lambda arg: arg if isinstance(arg, ActiveSelectionEventHandler) else None

class Appearance(Base):
    r"""An appearance."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Appearance *":
        return _core.Appearance___deref__(self)

    def __eq__(self, rhs: "Appearance") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Appearance___eq__(self, rhs)


    def __ne__(self, rhs: "Appearance") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Appearance___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Appearance_classType()
    __swig_destroy__ = _core.delete_Appearance

    def _get_id(self) -> "std::string":
        r"""The unique internal ID of this Appearance."""
        return _core.Appearance__get_id(self)

    def _get_isUsed(self) -> "bool":
        r"""Returns true if this Appearance is used in the Design."""
        return _core.Appearance__get_isUsed(self)

    def _get_usedBy(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Returns a collection of the entities currently using this appearance. This 
        property is only valid for an appearance in a Design and where the IsUsed
        property returns true. The collection returned can contain
        """
        return _core.Appearance__get_usedBy(self)

    def _get_name(self) -> "std::string":
        r"""
        Returns the name of this Appearance. This is the localized name
        shown in the UI.
        """
        return _core.Appearance__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""
        Returns the name of this Appearance. This is the localized name
        shown in the UI.
        """
        return _core.Appearance__set_name(self, value)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Property that returns the Parent object of this Appearance (a MaterialLibrary, Design, or AppearanceFavorites collection)."""
        return _core.Appearance__get_parent(self)

    def _get_hasTexture(self) -> "bool":
        r"""Property that indicates if this appearance has a texture associated with it."""
        return _core.Appearance__get_hasTexture(self)

    def _get_appearanceProperties(self) -> "adsk::core::Ptr< adsk::core::Properties >":
        r"""returns the collection of Properties that define this appearance"""
        return _core.Appearance__get_appearanceProperties(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the Appearance from the Design. This method is only valid for appearances
        that are in a Design and are unused. 
        Returns true if the delete was successful.
        """
        return _core.Appearance_deleteMe(self)

    def copyTo(self, target: "Base") -> "bool":
        r"""
        Copies this appearance to the specified target.
        ***Depricated Method: Use the addByCopyMethod on the Appearances object instead, where you can rename the copied Appearance
        and the return type is Appearance rather than bool.*** 
        target : The target can be a Design or MaterialFavorites object. 
        Returns true if the copy was successful.
        """
        return _core.Appearance_copyTo(self, target)

    def _get_objectType(self) -> "char const *":
        return _core.Appearance__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Appearance__get_isValid(self)

# Register Appearance in _core:
_core.Appearance_swigregister(Appearance)

def Appearance_classType() -> "char const *":
    return _core.Appearance_classType()


Appearance.id = property(Appearance._get_id, doc="The unique internal ID of this Appearance.")


Appearance.isUsed = property(Appearance._get_isUsed, doc="Returns true if this Appearance is used in the Design.")


Appearance.usedBy = property(Appearance._get_usedBy, doc="Returns a collection of the entities currently using this appearance. This\nproperty is only valid for an appearance in a Design and where the IsUsed\nproperty returns true. The collection returned can contain")


Appearance.name = property(Appearance._get_name, Appearance._set_name, doc="Returns the name of this Appearance. This is the localized name\nshown in the UI.")


Appearance.parent = property(Appearance._get_parent, doc="Property that returns the Parent object of this Appearance (a MaterialLibrary, Design, or AppearanceFavorites collection).")


Appearance.hasTexture = property(Appearance._get_hasTexture, doc="Property that indicates if this appearance has a texture associated with it.")


Appearance.appearanceProperties = property(Appearance._get_appearanceProperties, doc="returns the collection of Properties that define this appearance")


Appearance.cast = lambda arg: arg if isinstance(arg, Appearance) else None

class Appearances(Base):
    r"""A collection of appearances."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Appearances *":
        return _core.Appearances___deref__(self)

    def __eq__(self, rhs: "Appearances") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Appearances___eq__(self, rhs)


    def __ne__(self, rhs: "Appearances") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Appearances___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.Appearances___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::Appearance >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.Appearances___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.Appearances_classType()
    __swig_destroy__ = _core.delete_Appearances

    def item(self, index: "int") -> "adsk::core::Ptr< adsk::core::Appearance >":
        r"""
        Returns the specified Appearance using an index into the collection. 
        index : The index of the appearance to return where the first item in the collection is 0. 
        Returns the specified appearance or null if an invalid index is specified.
        """
        return _core.Appearances_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of Materials in the collection."""
        return _core.Appearances__get_count(self)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::core::Appearance >":
        r"""
        Returns the specified Appearance using the name as seen in the user interface. This often isn't
        a reliable way of accessing a specific appearance because appearances are not required to be unique. 
        name : The name of the appearance to return,. 
        Returns the specified appearance or null if there isn't a matching name.
        """
        return _core.Appearances_itemByName(self, name)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::Appearance >":
        r"""
        Returns the Appearance by it's internal unique ID. 
        id : The ID of the appearance to return. 
        Returns the specified appearance or null if there isn't a matching ID.
        """
        return _core.Appearances_itemById(self, id)

    def addByCopy(self, appearanceToCopy: "Appearance", name: "std::string const &") -> "adsk::core::Ptr< adsk::core::Appearance >":
        r"""
        Add an Appearance to a Design by copying an existing Appearance from Favorites, a Library or from the 
        appearances stored in the Design. This method currently only applies to the Appearances collection from a Design and 
        cannot be used to copy an Appearance to a library. 
        appearanceToCopy : The Appearance you want to copy. The Appearance to copy can be from Favorites, a Library or from the 
        appearances stored in the Design. 
        name : The Appearnce name to apply to the copy. 
        Returns the newly created Appearance or null if the copy operation failed.
        """
        return _core.Appearances_addByCopy(self, appearanceToCopy, name)

    def _get_objectType(self) -> "char const *":
        return _core.Appearances__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Appearances__get_isValid(self)

# Register Appearances in _core:
_core.Appearances_swigregister(Appearances)

def Appearances_classType() -> "char const *":
    return _core.Appearances_classType()


Appearances.count = property(Appearances._get_count, doc="The number of Materials in the collection.")


Appearances.cast = lambda arg: arg if isinstance(arg, Appearances) else None

class AppearanceTexture(Base):
    r"""Provides access to a list of properties that define a texture."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::AppearanceTexture *":
        return _core.AppearanceTexture___deref__(self)

    def __eq__(self, rhs: "AppearanceTexture") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.AppearanceTexture___eq__(self, rhs)


    def __ne__(self, rhs: "AppearanceTexture") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.AppearanceTexture___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.AppearanceTexture_classType()
    __swig_destroy__ = _core.delete_AppearanceTexture

    def changeTextureImage(self, imageFilename: "std::string const &") -> "bool":
        r"""
        Changes the image of this texture. 
        imageFilename : Input String specifying the full filename of the texture file to use. 
        Returns true if the change was successful.
        """
        return _core.AppearanceTexture_changeTextureImage(self, imageFilename)

    def _get_properties(self) -> "adsk::core::Ptr< adsk::core::Properties >":
        r"""Returns a collection of the properties associated with this texture."""
        return _core.AppearanceTexture__get_properties(self)

    def _get_textureType(self) -> "adsk::core::TextureTypes":
        r"""Gets the type of texture this appearance currently is."""
        return _core.AppearanceTexture__get_textureType(self)

    def _get_objectType(self) -> "char const *":
        return _core.AppearanceTexture__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.AppearanceTexture__get_isValid(self)

# Register AppearanceTexture in _core:
_core.AppearanceTexture_swigregister(AppearanceTexture)

def AppearanceTexture_classType() -> "char const *":
    return _core.AppearanceTexture_classType()


AppearanceTexture.properties = property(AppearanceTexture._get_properties, doc="Returns a collection of the properties associated with this texture.")


AppearanceTexture.textureType = property(AppearanceTexture._get_textureType, doc="Gets the type of texture this appearance currently is.")


AppearanceTexture.cast = lambda arg: arg if isinstance(arg, AppearanceTexture) else None

class Application(Base):
    r"""
    The top-level object that represents the Fusion 360 application (all of Fusion 360). 
    This provides access to the modeler and files.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Application *":
        return _core.Application___deref__(self)

    def __eq__(self, rhs: "Application") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Application___eq__(self, rhs)


    def __ne__(self, rhs: "Application") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Application___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Application_classType()

    @staticmethod
    def get() -> "adsk::core::Ptr< adsk::core::Application >":
        return _core.Application_get()
    __swig_destroy__ = _core.delete_Application

    def _get_documents(self) -> "adsk::core::Ptr< adsk::core::Documents >":
        r"""
        Returns the Documents collection object which supports accessing
        opened documents, opening existing documents, and creating new documents.
        """
        return _core.Application__get_documents(self)

    def _get_activeDocument(self) -> "adsk::core::Ptr< adsk::core::Document >":
        r"""Returns the current active document."""
        return _core.Application__get_activeDocument(self)

    def _get_activeProduct(self) -> "adsk::core::Ptr< adsk::core::Product >":
        r"""Returns the current active product."""
        return _core.Application__get_activeProduct(self)

    def _get_activeViewport(self) -> "adsk::core::Ptr< adsk::core::Viewport >":
        r"""Returns the currently active graphics view."""
        return _core.Application__get_activeViewport(self)

    def _get_activeEditObject(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the current edit target as seen in the user interface. This edit target
        is defined as the container object that will be added to if something is created.
        For example, a component can be an edit target so that when new bodies are created they
        are added to that component. A sketch can also be an edit target.
        """
        return _core.Application__get_activeEditObject(self)

    def _get_data(self) -> "adsk::core::Ptr< adsk::core::Data >":
        r"""Returns the Data object which provides access the files."""
        return _core.Application__get_data(self)

    def _get_pointTolerance(self) -> "double":
        r"""The modeling tolerance used internally when comparing two points. The value is in centimeters."""
        return _core.Application__get_pointTolerance(self)

    def _get_vectorAngleTolerance(self) -> "double":
        r"""The modeling tolerance used when comparing vector angles. The value is in radians."""
        return _core.Application__get_vectorAngleTolerance(self)

    def _get_preferences(self) -> "adsk::core::Ptr< adsk::core::Preferences >":
        r"""Provides access to all of the application preferences."""
        return _core.Application__get_preferences(self)

    def _get_documentOpening(self) -> "adsk::core::Ptr< adsk::core::DocumentEvent >":
        r"""
        The DocumentOpening event fires at the VERY start of a document being opened.
        There is no promise that the document will be opened, hence
        a documentOpened event may not follow.
        When a document is being opened that references other documents, only the 
        top-level document will cause a documentOpening event to be fired.
        """
        return _core.Application__get_documentOpening(self)

    def _get_documentOpened(self) -> "adsk::core::Ptr< adsk::core::DocumentEvent >":
        r"""
        The DocumentOpened event fires at the VERY end of a document being opened so the
        Document object is avialable to be used.
        When a document is opened that references other documents, only the top-level
        document will cause the documentOpened event to be fired. You can access the
        referenced documents by using the documentReferences property of the Document object.
        """
        return _core.Application__get_documentOpened(self)

    def getLastError(self) -> "int":
        r"""
        Returns information about the last error that occurred. 
        description : A description of the last error in English. 
        Returns the number of the specific error.
        """
        return _core.Application_getLastError(self)

    def _get_userInterface(self) -> "adsk::core::Ptr< adsk::core::UserInterface >":
        r"""Provides access to functionality specific to the user interface."""
        return _core.Application__get_userInterface(self)

    def _get_materialLibraries(self) -> "adsk::core::Ptr< adsk::core::MaterialLibraries >":
        r"""Returns the collection of material libraries currently available."""
        return _core.Application__get_materialLibraries(self)

    def _get_favoriteMaterials(self) -> "adsk::core::Ptr< adsk::core::FavoriteMaterials >":
        r"""Returns the set of favorite materials."""
        return _core.Application__get_favoriteMaterials(self)

    def _get_favoriteAppearances(self) -> "adsk::core::Ptr< adsk::core::FavoriteAppearances >":
        r"""Returns the set of favorite appearances."""
        return _core.Application__get_favoriteAppearances(self)

    def _get_supportedProductTypes(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Returns an array containing the names of the products types currently
        supported by Fusion 360. For example, the name returned for Fusion 360 is
        'DesignProductType'. These product type names are used to identify
        specific products in some other API functions such as the productType
        property on the Workspace and ToolbarPanel objects.
        """
        return _core.Application__get_supportedProductTypes(self)

    def _get_importManager(self) -> "adsk::core::Ptr< adsk::core::ImportManager >":
        r"""
        Returns the ImportManager. You use the ImportManager
        to import files (of various neutral formats.) into existing components or new document.
        """
        return _core.Application__get_importManager(self)

    def _get_userName(self) -> "std::string":
        r"""Returns the user name of the Autodesk account currently logged in."""
        return _core.Application__get_userName(self)

    def _get_userId(self) -> "std::string":
        r"""
        Returns the internal name of the Autodesk account currently logged in.
        This can be used by applications sold through the Autodesk Exchange Store
        to verify that the user has in fact purchased the product.
        """
        return _core.Application__get_userId(self)

    def _get_isOffLine(self) -> "bool":
        r"""Gets and sets if Fusion 360 is offline or not."""
        return _core.Application__get_isOffLine(self)

    def _set_isOffLine(self, value: "bool") -> "bool":
        r"""Gets and sets if Fusion 360 is offline or not."""
        return _core.Application__set_isOffLine(self, value)

    def _get_isStartupComplete(self) -> "bool":
        r"""
        Boolean property indicating whether Fusion 360 has completed its initialization. 
        This includes initialization of all the Add-ins loaded at startup.
        """
        return _core.Application__get_isStartupComplete(self)

    def _get_onlineStatusChanged(self) -> "adsk::core::Ptr< adsk::core::ApplicationEvent >":
        r"""
        The onlineStatusChanged event fires immediately after Fusion 360 goes online or offline. 
        This event fires whether or not the online status was changed deliberately by the user by using the Fusion 360 
        'Work Offline' command or because of inadvertent network/Internet connectivity issues. 
        You can get the isOffline property of ApplicationEventArgs to determine whether Fusion 360 has gone Offline or 
        has come back Online.
        The client can add or remove ApplicationEventHandlers from the ApplicationEvent.
        """
        return _core.Application__get_onlineStatusChanged(self)

    def _get_startupCompleted(self) -> "adsk::core::Ptr< adsk::core::ApplicationEvent >":
        r"""
        The startupCompleted event fires after Fusion 360 has completed its initialization. 
        This includes initialization of all the Add-ins loaded at startup.
        The client can add or remove ApplicationEventHandlers from the ApplicationEvent.
        """
        return _core.Application__get_startupCompleted(self)

    def _get_currentUser(self) -> "adsk::core::Ptr< adsk::core::User >":
        r"""Returns the User that is currently logged in."""
        return _core.Application__get_currentUser(self)

    def _get_insertingFromURL(self) -> "adsk::core::Ptr< adsk::core::WebRequestEvent >":
        r"""
        The insertingFromURL event fires when the user has clicked a link in a web
        page that uses the Fusion 360 protocol handler to insert a file as new component.
        This event is fired at the beginning of the request but before Fusion 360 has
        take any action so that it's still possible to cancel the operation.
        """
        return _core.Application__get_insertingFromURL(self)

    def _get_insertedFromURL(self) -> "adsk::core::Ptr< adsk::core::WebRequestEvent >":
        r"""
        The insertedFromURL event fires after the user has clicked a link in a web
        page that uses the Fusion 360 protocol handler to insert a file as new component
        and that operation has completed.
        """
        return _core.Application__get_insertedFromURL(self)

    def _get_openingFromURL(self) -> "adsk::core::Ptr< adsk::core::WebRequestEvent >":
        r"""
        The openingFromURL event fires when the user has clicked a link in a web
        page that uses the Fusion 360 protocol handler to create a new file using an
        existing file as the initial contents. This event is fired at the beginning 
        of the request but before Fusion 360 has take any action so that it's still 
        possible to cancel the operation.
        """
        return _core.Application__get_openingFromURL(self)

    def _get_openedFromURL(self) -> "adsk::core::Ptr< adsk::core::WebRequestEvent >":
        r"""
        The openedFromURL event fires after the user has clicked a link in a web
        page that uses the Fusion 360 protocol handler to create a new using an existing
        file as the initial contents and that operation has completed.
        """
        return _core.Application__get_openedFromURL(self)

    def _get_version(self) -> "std::string":
        r"""Returns the current version of the Fusion 360 application."""
        return _core.Application__get_version(self)

    def registerCustomEvent(self, eventId: "std::string const &") -> "adsk::core::Ptr< adsk::core::CustomEvent >":
        r"""
        This registers a new CustomEvent which is intended to be primarily used 
        used to send an event from a worker thread you've created back to your
        add-in running in the primary thread. It's also possible that two add-ins
        could be cooperating and another add-in can fire the event to your add-in. 
        eventId : This serves as the unique ID for this event and is used by the worker thread or other
        add-in to identify which custom event to fire using the fireCustomEvent method. 
        Returns the registered CustomEvent or null in the case of failure, which would typically
        be because the provided eventId is not unique.
        """
        return _core.Application_registerCustomEvent(self, eventId)

    def fireCustomEvent(self, *args) -> "bool":
        r"""
        Fires a previously registered custom event. This method is used by a worker thread or another
        add-in to fire an event to the add-in that registered the event and is running in the primary thread.
        Firing a custom event does not immediately result in the event handler being called. When a custom
        event is fired the event is put on the queue and will be handled in the main thread when Fusion 360 is idle. 
        eventId : The ID of the custom event you want to fire. 
        additionalInfo : Any additional information you want to pass through the event to the add-in in the primary thread. 
        Returns true if the event was successfully added to the event queue. A value of true does not indicate
        that the event was fired and handled but only that it's been put on the primary thread's event queue to
        be fired when application is idle.
        """
        return _core.Application_fireCustomEvent(self, *args)

    def unregisterCustomEvent(self, eventId: "std::string const &") -> "bool":
        r"""
        Unregisters an existing CustomEvent. 
        eventId : Th unique ID of the custom event you want to unregister. 
        Returns True if the unregister succeeded.
        """
        return _core.Application_unregisterCustomEvent(self, eventId)

    def _get_documentCreated(self) -> "adsk::core::Ptr< adsk::core::DocumentEvent >":
        r"""The DocumentCreated event fires when a new document is created."""
        return _core.Application__get_documentCreated(self)

    def _get_documentClosing(self) -> "adsk::core::Ptr< adsk::core::DocumentEvent >":
        r"""
        The DocumentClosing event fires at the VERY start of a document being closed.
        User can set the isSaveCanceled property of DocumentEventArgs to true to cancel the document close.
        """
        return _core.Application__get_documentClosing(self)

    def _get_documentClosed(self) -> "adsk::core::Ptr< adsk::core::DocumentEvent >":
        r"""
        The DocumentClosed event fires at the VERY end of a document being closed. The 
        Document object is not longer available because it has been closed.
        """
        return _core.Application__get_documentClosed(self)

    def _get_documentSaving(self) -> "adsk::core::Ptr< adsk::core::DocumentEvent >":
        r"""
        The DocumentSaving event fires at the VERY start of a document being saved.
        You can set the isSaveCanceled property of DocumentEventArgs to true to cancel the document save.
        """
        return _core.Application__get_documentSaving(self)

    def _get_documentSaved(self) -> "adsk::core::Ptr< adsk::core::DocumentEvent >":
        r"""The DocumentSaved event fires after the save operation has been completed."""
        return _core.Application__get_documentSaved(self)

    def _get_documentActivating(self) -> "adsk::core::Ptr< adsk::core::DocumentEvent >":
        r"""The DocumentActivating event fires at the VERY start of a document being activated."""
        return _core.Application__get_documentActivating(self)

    def _get_documentActivated(self) -> "adsk::core::Ptr< adsk::core::DocumentEvent >":
        r"""The DocumentActivated event fires at the VERY end of a document being activated."""
        return _core.Application__get_documentActivated(self)

    def _get_documentDeactivating(self) -> "adsk::core::Ptr< adsk::core::DocumentEvent >":
        r"""The DocumentDeactivating event fires at the VERY start of a document being deactivated."""
        return _core.Application__get_documentDeactivating(self)

    def _get_documentDeactivated(self) -> "adsk::core::Ptr< adsk::core::DocumentEvent >":
        r"""The DocumentDeactivated event fires at the VERY end of a document being deactivated."""
        return _core.Application__get_documentDeactivated(self)

    def _get_cameraChanged(self) -> "adsk::core::Ptr< adsk::core::CameraEvent >":
        r"""
        The cameraChanged event fires immediately after a change in the camera has been made.
        Camera changes happen when user changes the view by rotating, zooming in or out, panning, 
        changing from parallel to perspective, or when the extents of the viewport changes.
        You can add or remove event handlers from the CameraEvent.
        """
        return _core.Application__get_cameraChanged(self)

    def _get_measureManager(self) -> "adsk::core::Ptr< adsk::core::MeasureManager >":
        r"""Get the MeasureManager object which can be used to perform measurements of geometry."""
        return _core.Application__get_measureManager(self)

    def executeTextCommand(self, command: "std::string const &") -> "std::string":
        r"""
        Executes the input text command. 
        command : The text command to execute. 
        Returns the result of the input text command.
        """
        return _core.Application_executeTextCommand(self, command)

    def _get_objectType(self) -> "char const *":
        return _core.Application__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Application__get_isValid(self)

# Register Application in _core:
_core.Application_swigregister(Application)

def Application_classType() -> "char const *":
    return _core.Application_classType()

def Application_get() -> "adsk::core::Ptr< adsk::core::Application >":
    return _core.Application_get()


Application.documents = property(Application._get_documents, doc="Returns the Documents collection object which supports accessing\nopened documents, opening existing documents, and creating new documents.")


Application.activeDocument = property(Application._get_activeDocument, doc="Returns the current active document.")


Application.activeProduct = property(Application._get_activeProduct, doc="Returns the current active product.")


Application.activeViewport = property(Application._get_activeViewport, doc="Returns the currently active graphics view.")


Application.activeEditObject = property(Application._get_activeEditObject, doc="Returns the current edit target as seen in the user interface. This edit target\nis defined as the container object that will be added to if something is created.\nFor example, a component can be an edit target so that when new bodies are created they\nare added to that component. A sketch can also be an edit target.")


Application.data = property(Application._get_data, doc="Returns the Data object which provides access the files.")


Application.pointTolerance = property(Application._get_pointTolerance, doc="The modeling tolerance used internally when comparing two points. The value is in centimeters.")


Application.vectorAngleTolerance = property(Application._get_vectorAngleTolerance, doc="The modeling tolerance used when comparing vector angles. The value is in radians.")


Application.preferences = property(Application._get_preferences, doc="Provides access to all of the application preferences.")


Application.documentOpening = property(Application._get_documentOpening, doc="The DocumentOpening event fires at the VERY start of a document being opened.\nThere is no promise that the document will be opened, hence\na documentOpened event may not follow.\nWhen a document is being opened that references other documents, only the\ntop-level document will cause a documentOpening event to be fired.")


Application.documentOpened = property(Application._get_documentOpened, doc="The DocumentOpened event fires at the VERY end of a document being opened so the\nDocument object is avialable to be used.\nWhen a document is opened that references other documents, only the top-level\ndocument will cause the documentOpened event to be fired. You can access the\nreferenced documents by using the documentReferences property of the Document object.")


Application.userInterface = property(Application._get_userInterface, doc="Provides access to functionality specific to the user interface.")


Application.materialLibraries = property(Application._get_materialLibraries, doc="Returns the collection of material libraries currently available.")


Application.favoriteMaterials = property(Application._get_favoriteMaterials, doc="Returns the set of favorite materials.")


Application.favoriteAppearances = property(Application._get_favoriteAppearances, doc="Returns the set of favorite appearances.")


Application.supportedProductTypes = property(Application._get_supportedProductTypes, doc="Returns an array containing the names of the products types currently\nsupported by Fusion 360. For example, the name returned for Fusion 360 is\n'DesignProductType'. These product type names are used to identify\nspecific products in some other API functions such as the productType\nproperty on the Workspace and ToolbarPanel objects.")


Application.importManager = property(Application._get_importManager, doc="Returns the ImportManager. You use the ImportManager\nto import files (of various neutral formats.) into existing components or new document.")


Application.userName = property(Application._get_userName, doc="Returns the user name of the Autodesk account currently logged in.")


Application.userId = property(Application._get_userId, doc="Returns the internal name of the Autodesk account currently logged in.\nThis can be used by applications sold through the Autodesk Exchange Store\nto verify that the user has in fact purchased the product.")


Application.isOffLine = property(Application._get_isOffLine, Application._set_isOffLine, doc="Gets and sets if Fusion 360 is offline or not.")


Application.isStartupComplete = property(Application._get_isStartupComplete, doc="Boolean property indicating whether Fusion 360 has completed its initialization.\nThis includes initialization of all the Add-ins loaded at startup.")


Application.onlineStatusChanged = property(Application._get_onlineStatusChanged, doc="The onlineStatusChanged event fires immediately after Fusion 360 goes online or offline.\nThis event fires whether or not the online status was changed deliberately by the user by using the Fusion 360\n'Work Offline' command or because of inadvertent network/Internet connectivity issues.\nYou can get the isOffline property of ApplicationEventArgs to determine whether Fusion 360 has gone Offline or\nhas come back Online.\nThe client can add or remove ApplicationEventHandlers from the ApplicationEvent.")


Application.startupCompleted = property(Application._get_startupCompleted, doc="The startupCompleted event fires after Fusion 360 has completed its initialization.\nThis includes initialization of all the Add-ins loaded at startup.\nThe client can add or remove ApplicationEventHandlers from the ApplicationEvent.")


Application.currentUser = property(Application._get_currentUser, doc="Returns the User that is currently logged in.")


Application.insertingFromURL = property(Application._get_insertingFromURL, doc="The insertingFromURL event fires when the user has clicked a link in a web\npage that uses the Fusion 360 protocol handler to insert a file as new component.\nThis event is fired at the beginning of the request but before Fusion 360 has\ntake any action so that it's still possible to cancel the operation.")


Application.insertedFromURL = property(Application._get_insertedFromURL, doc="The insertedFromURL event fires after the user has clicked a link in a web\npage that uses the Fusion 360 protocol handler to insert a file as new component\nand that operation has completed.")


Application.openingFromURL = property(Application._get_openingFromURL, doc="The openingFromURL event fires when the user has clicked a link in a web\npage that uses the Fusion 360 protocol handler to create a new file using an\nexisting file as the initial contents. This event is fired at the beginning\nof the request but before Fusion 360 has take any action so that it's still\npossible to cancel the operation.")


Application.openedFromURL = property(Application._get_openedFromURL, doc="The openedFromURL event fires after the user has clicked a link in a web\npage that uses the Fusion 360 protocol handler to create a new using an existing\nfile as the initial contents and that operation has completed.")


Application.version = property(Application._get_version, doc="Returns the current version of the Fusion 360 application.")


Application.documentCreated = property(Application._get_documentCreated, doc="The DocumentCreated event fires when a new document is created.")


Application.documentClosing = property(Application._get_documentClosing, doc="The DocumentClosing event fires at the VERY start of a document being closed.\nUser can set the isSaveCanceled property of DocumentEventArgs to true to cancel the document close.")


Application.documentClosed = property(Application._get_documentClosed, doc="The DocumentClosed event fires at the VERY end of a document being closed. The\nDocument object is not longer available because it has been closed.")


Application.documentSaving = property(Application._get_documentSaving, doc="The DocumentSaving event fires at the VERY start of a document being saved.\nYou can set the isSaveCanceled property of DocumentEventArgs to true to cancel the document save.")


Application.documentSaved = property(Application._get_documentSaved, doc="The DocumentSaved event fires after the save operation has been completed.")


Application.documentActivating = property(Application._get_documentActivating, doc="The DocumentActivating event fires at the VERY start of a document being activated.")


Application.documentActivated = property(Application._get_documentActivated, doc="The DocumentActivated event fires at the VERY end of a document being activated.")


Application.documentDeactivating = property(Application._get_documentDeactivating, doc="The DocumentDeactivating event fires at the VERY start of a document being deactivated.")


Application.documentDeactivated = property(Application._get_documentDeactivated, doc="The DocumentDeactivated event fires at the VERY end of a document being deactivated.")


Application.cameraChanged = property(Application._get_cameraChanged, doc="The cameraChanged event fires immediately after a change in the camera has been made.\nCamera changes happen when user changes the view by rotating, zooming in or out, panning,\nchanging from parallel to perspective, or when the extents of the viewport changes.\nYou can add or remove event handlers from the CameraEvent.")


Application.measureManager = property(Application._get_measureManager, doc="Get the MeasureManager object which can be used to perform measurements of geometry.")


Application.cast = lambda arg: arg if isinstance(arg, Application) else None

class ApplicationCommandEventHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notify(self, eventArgs: "ApplicationCommandEventArgs") -> "void":
        return _core.ApplicationCommandEventHandler_notify(self, eventArgs)

    def __init__(self):
        if self.__class__ == ApplicationCommandEventHandler:
            _self = None
        else:
            _self = self
        _core.ApplicationCommandEventHandler_swiginit(self, _core.new_ApplicationCommandEventHandler(_self, ))
    __swig_destroy__ = _core.delete_ApplicationCommandEventHandler
    def __disown__(self):
        self.this.disown()
        _core.disown_ApplicationCommandEventHandler(self)
        return weakref.proxy(self)

# Register ApplicationCommandEventHandler in _core:
_core.ApplicationCommandEventHandler_swigregister(ApplicationCommandEventHandler)


ApplicationCommandEventHandler.cast = lambda arg: arg if isinstance(arg, ApplicationCommandEventHandler) else None

class ApplicationEventHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notify(self, eventArgs: "ApplicationEventArgs") -> "void":
        return _core.ApplicationEventHandler_notify(self, eventArgs)

    def __init__(self):
        if self.__class__ == ApplicationEventHandler:
            _self = None
        else:
            _self = self
        _core.ApplicationEventHandler_swiginit(self, _core.new_ApplicationEventHandler(_self, ))
    __swig_destroy__ = _core.delete_ApplicationEventHandler
    def __disown__(self):
        self.this.disown()
        _core.disown_ApplicationEventHandler(self)
        return weakref.proxy(self)

# Register ApplicationEventHandler in _core:
_core.ApplicationEventHandler_swigregister(ApplicationEventHandler)


ApplicationEventHandler.cast = lambda arg: arg if isinstance(arg, ApplicationEventHandler) else None

class Attribute(Base):
    r"""
    Represents an attribute associated with a specific entity, Product, or Document.
    An attribute is a named value.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Attribute *":
        return _core.Attribute___deref__(self)

    def __eq__(self, rhs: "Attribute") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Attribute___eq__(self, rhs)


    def __ne__(self, rhs: "Attribute") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Attribute___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Attribute_classType()
    __swig_destroy__ = _core.delete_Attribute

    def _get_groupName(self) -> "std::string":
        r"""Gets the name of the group this attribute is a part of."""
        return _core.Attribute__get_groupName(self)

    def _get_name(self) -> "std::string":
        r"""Gets the name of the attribute."""
        return _core.Attribute__get_name(self)

    def _get_value(self) -> "std::string":
        r"""
        Gets and sets the value of this attribute.
        The size of an attribute value is limited to 2MB (2097152 bytes). If you need to
        save data that is larger than 2MB you'll need to break the data into pieces and 
        save it in multiple attributes.
        """
        return _core.Attribute__get_value(self)

    def _set_value(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the value of this attribute.
        The size of an attribute value is limited to 2MB (2097152 bytes). If you need to
        save data that is larger than 2MB you'll need to break the data into pieces and 
        save it in multiple attributes.
        """
        return _core.Attribute__set_value(self, value)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the parent entity this attribute is associated with. This can return null 
        in some cases. For example a BRepEdge might have been consumed by a fillet
        feature but can come back if the model is rolled back or the fillet is deleted.
        It's possible that the original parent that an attribute was placed on has been
        split. For example, if an attribute is placed on a face and then a slot is created
        that cuts the face into two pieces and the attribute is available from each face. 
        In this case the parent property will return the 'primary' face, which in most cases 
        is somewhat arbitrary. You can get the other entities the attribute is associated 
        with by using the otherParents property.
        """
        return _core.Attribute__get_parent(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this attribute. 
        Returns true if the delete was successful.
        """
        return _core.Attribute_deleteMe(self)

    def _get_otherParents(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        In the case where the entity the attribute was originally placed on has been split,
        this property will return the other entities the attribute is associated with. 
        For example, if an attribute is placed on a face and then a slot is created
        that cuts the face into two pieces and the attribute is available from both faces. 
        The parent property returns the 'primary' entity and this property returns any other 
        entities, if any. If there aren't any other associated entities the ObjectCollection 
        returned will be empty.
        """
        return _core.Attribute__get_otherParents(self)

    def _get_objectType(self) -> "char const *":
        return _core.Attribute__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Attribute__get_isValid(self)

# Register Attribute in _core:
_core.Attribute_swigregister(Attribute)

def Attribute_classType() -> "char const *":
    return _core.Attribute_classType()


Attribute.groupName = property(Attribute._get_groupName, doc="Gets the name of the group this attribute is a part of.")


Attribute.name = property(Attribute._get_name, doc="Gets the name of the attribute.")


Attribute.value = property(Attribute._get_value, Attribute._set_value, doc="Gets and sets the value of this attribute.\nThe size of an attribute value is limited to 2MB (2097152 bytes). If you need to\nsave data that is larger than 2MB you'll need to break the data into pieces and\nsave it in multiple attributes.")


Attribute.parent = property(Attribute._get_parent, doc="Returns the parent entity this attribute is associated with. This can return null\nin some cases. For example a BRepEdge might have been consumed by a fillet\nfeature but can come back if the model is rolled back or the fillet is deleted.\nIt's possible that the original parent that an attribute was placed on has been\nsplit. For example, if an attribute is placed on a face and then a slot is created\nthat cuts the face into two pieces and the attribute is available from each face.\nIn this case the parent property will return the 'primary' face, which in most cases\nis somewhat arbitrary. You can get the other entities the attribute is associated\nwith by using the otherParents property.")


Attribute.otherParents = property(Attribute._get_otherParents, doc="In the case where the entity the attribute was originally placed on has been split,\nthis property will return the other entities the attribute is associated with.\nFor example, if an attribute is placed on a face and then a slot is created\nthat cuts the face into two pieces and the attribute is available from both faces.\nThe parent property returns the 'primary' entity and this property returns any other\nentities, if any. If there aren't any other associated entities the ObjectCollection\nreturned will be empty.")


Attribute.cast = lambda arg: arg if isinstance(arg, Attribute) else None

class Attributes(Base):
    r"""
    Provides access to attributes associated with a specific entity,
    Product, or Document. Also supports the creation of new attributes.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Attributes *":
        return _core.Attributes___deref__(self)

    def __eq__(self, rhs: "Attributes") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Attributes___eq__(self, rhs)


    def __ne__(self, rhs: "Attributes") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Attributes___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.Attributes___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::Attribute >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.Attributes___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.Attributes_classType()
    __swig_destroy__ = _core.delete_Attributes

    def _get_count(self) -> "size_t":
        r"""Returns the number of attributes in the collection."""
        return _core.Attributes__get_count(self)

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::Attribute >":
        r"""
        Returns the specified attribute using an index into the collection. 
        index : The index of the attribute within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified attribute or null if an invalid index was specified.
        """
        return _core.Attributes_item(self, index)

    def itemByName(self, groupName: "std::string const &", name: "std::string const &") -> "adsk::core::Ptr< adsk::core::Attribute >":
        r"""
        Returns the specified attribute using the name of the attribute. 
        groupName : The name of the attribute group this attribute will belong to. 
        name : The name of the attribute. 
        Returns the specified attribute or null if no attribute exists with the specified name.
        """
        return _core.Attributes_itemByName(self, groupName, name)

    def add(self, groupName: "std::string const &", name: "std::string const &", value: "std::string const &") -> "adsk::core::Ptr< adsk::core::Attribute >":
        r"""
        Adds a new attribute to the parent entity. If an attribute already exists on the entity with the
        same groupName and name already exists, this will update the existing attribute with the new value. 
        groupName : The name of the attribute group to create this attribute within. 
        name : The name of the attribute. This must be unique with respect to other attributes in the group. 
        value : The value of the attribute. The size of an attribute value is limited to 2MB (2097152 bytes). If
        you need to save data that is larger than 2MB you'll need to break it into pieces and save it in
        multiple attributes. 
        Returns the newly created attribute or null if the creation failed. If an attribute with the 
        same groupName and name already exists, it will return the existing attribute.
        """
        return _core.Attributes_add(self, groupName, name, value)

    def itemsByGroup(self, groupName: "std::string const &") -> "std::vector< adsk::core::Ptr< adsk::core::Attribute >,std::allocator< adsk::core::Ptr< adsk::core::Attribute > > >":
        r"""
        Returns an array of all of the attributes that belong to the specified group. 
        groupName : The name of the group. 
        Returns an array of attributes or will fail in the case where an invalid group name is specified.
        """
        return _core.Attributes_itemsByGroup(self, groupName)

    def _get_groupNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Returns an array of strings that are all of the name of attribute groups that exist on this entity.
        An empty array can be returns if there are no attributes on the entity.
        """
        return _core.Attributes__get_groupNames(self)

    def _get_objectType(self) -> "char const *":
        return _core.Attributes__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Attributes__get_isValid(self)

# Register Attributes in _core:
_core.Attributes_swigregister(Attributes)

def Attributes_classType() -> "char const *":
    return _core.Attributes_classType()


Attributes.count = property(Attributes._get_count, doc="Returns the number of attributes in the collection.")


Attributes.groupNames = property(Attributes._get_groupNames, doc="Returns an array of strings that are all of the name of attribute groups that exist on this entity.\nAn empty array can be returns if there are no attributes on the entity.")


Attributes.cast = lambda arg: arg if isinstance(arg, Attributes) else None

class BoundingBox2D(Base):
    r"""
    Transient object that represents a 2D bounding box. A 2D bounding box is a rectangle box that is parallel
    to the x and y axes. The box is defined by a minimum point (smallest x-y values) and maximum point (largest x-y values). 
    This object is a wrapper for these points and serves as a way to pass bounding box information
    in and out of functions. It also provides some convenience function when working with the bounding box data.
    They are created statically using the create method of the BoundingBox2D class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::BoundingBox2D *":
        return _core.BoundingBox2D___deref__(self)

    def __eq__(self, rhs: "BoundingBox2D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.BoundingBox2D___eq__(self, rhs)


    def __ne__(self, rhs: "BoundingBox2D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.BoundingBox2D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.BoundingBox2D_classType()

    @staticmethod
    def create(minPoint: "Point2D", maxPoint: "Point2D") -> "adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Point2D > const &":
        return _core.BoundingBox2D_create(minPoint, maxPoint)
    __swig_destroy__ = _core.delete_BoundingBox2D

    def _get_minPoint(self) -> "adsk::core::Ptr< adsk::core::Point2D >":
        r"""Gets and sets the minimum point of the box."""
        return _core.BoundingBox2D__get_minPoint(self)

    def _set_minPoint(self, value: "Point2D") -> "bool":
        r"""Gets and sets the minimum point of the box."""
        return _core.BoundingBox2D__set_minPoint(self, value)

    def _get_maxPoint(self) -> "adsk::core::Ptr< adsk::core::Point2D >":
        r"""Gets and sets the maximum point of the box."""
        return _core.BoundingBox2D__get_maxPoint(self)

    def _set_maxPoint(self, value: "Point2D") -> "bool":
        r"""Gets and sets the maximum point of the box."""
        return _core.BoundingBox2D__set_maxPoint(self, value)

    def contains(self, point: "Point2D") -> "bool":
        r"""
        Determines if the specified point lies within the bounding box. 
        point : The point to test containment with. 
        Returns true if the point lies within the bounding box.
        """
        return _core.BoundingBox2D_contains(self, point)

    def expand(self, point: "Point2D") -> "bool":
        r"""
        Expand this bounding box to contain the specified point. 
        point : The point to expand the box to. 
        Returns true if successful.
        """
        return _core.BoundingBox2D_expand(self, point)

    def intersects(self, boundingBox: "BoundingBox2D") -> "bool":
        r"""
        Test if this bounding box intersects with the specified bounding box. 
        boundingBox : The bounding box to test intersection with. 
        Returns true if the bounding boxes intersect.
        """
        return _core.BoundingBox2D_intersects(self, boundingBox)

    def copy(self) -> "adsk::core::Ptr< adsk::core::BoundingBox2D >":
        r"""
        Create a copy of this bounding box. 
        Returns the new bounding box copy.
        """
        return _core.BoundingBox2D_copy(self)

    def combine(self, boundingBox: "BoundingBox2D") -> "bool":
        r"""
        Combines this bounding box with the input bounding box. If the input
        bounding box extends outside this bounding box then this bounding box will
        be extended to encompass both of the original bounding boxes. 
        boundingBox : The other bounding box. It is not edited but is used to extend the boundaries
        of the bounding box the method is being called on. 
        Returns true if the combine was successful.
        """
        return _core.BoundingBox2D_combine(self, boundingBox)

    def _get_objectType(self) -> "char const *":
        return _core.BoundingBox2D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.BoundingBox2D__get_isValid(self)

# Register BoundingBox2D in _core:
_core.BoundingBox2D_swigregister(BoundingBox2D)

def BoundingBox2D_classType() -> "char const *":
    return _core.BoundingBox2D_classType()

def BoundingBox2D_create(minPoint: "Point2D", maxPoint: "Point2D") -> "adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Point2D > const &":
    return _core.BoundingBox2D_create(minPoint, maxPoint)


BoundingBox2D.minPoint = property(BoundingBox2D._get_minPoint, BoundingBox2D._set_minPoint, doc="Gets and sets the minimum point of the box.")


BoundingBox2D.maxPoint = property(BoundingBox2D._get_maxPoint, BoundingBox2D._set_maxPoint, doc="Gets and sets the maximum point of the box.")


BoundingBox2D.cast = lambda arg: arg if isinstance(arg, BoundingBox2D) else None

class BoundingBox3D(Base):
    r"""
    Transient object that represents a 3D bounding box. 
    It defines a rectangular box whose sides are parallel to the model space x, y, and z
    planes. Because of the fixed orientation of the box it can be fully defined
    by two points at opposing corners; the min and max points. This object is usually
    used to provide a rough approximation of the volume in space that an entity occupies.
    It also provides some convenience function when working with the bounding box data.
    They are created statically using the create method of the BoundingBox3D class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::BoundingBox3D *":
        return _core.BoundingBox3D___deref__(self)

    def __eq__(self, rhs: "BoundingBox3D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.BoundingBox3D___eq__(self, rhs)


    def __ne__(self, rhs: "BoundingBox3D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.BoundingBox3D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.BoundingBox3D_classType()

    @staticmethod
    def create(minPoint: "Point3D", maxPoint: "Point3D") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Point3D > const &":
        return _core.BoundingBox3D_create(minPoint, maxPoint)
    __swig_destroy__ = _core.delete_BoundingBox3D

    def _get_minPoint(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets the minimum point corner of the box."""
        return _core.BoundingBox3D__get_minPoint(self)

    def _set_minPoint(self, value: "Point3D") -> "bool":
        r"""Gets and sets the minimum point corner of the box."""
        return _core.BoundingBox3D__set_minPoint(self, value)

    def _get_maxPoint(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets the maximum point corner of the box."""
        return _core.BoundingBox3D__get_maxPoint(self)

    def _set_maxPoint(self, value: "Point3D") -> "bool":
        r"""Gets and sets the maximum point corner of the box."""
        return _core.BoundingBox3D__set_maxPoint(self, value)

    def contains(self, point: "Point3D") -> "bool":
        r"""
        Determines if the specified point is within the bound box. 
        point : The point you want to check to see if it's in the bounding box. 
        Returns true if the point is within the bounding box.
        """
        return _core.BoundingBox3D_contains(self, point)

    def expand(self, point: "Point3D") -> "bool":
        r"""
        Expands the size of bounding box to include the specified point. 
        point : The point to include within the bounding box. 
        Returns true if the expansion was successful.
        """
        return _core.BoundingBox3D_expand(self, point)

    def intersects(self, boundingBox: "BoundingBox3D") -> "bool":
        r"""
        Determines if the two bounding boxes intersect. 
        boundingBox : The other bounding box to check for intersection with. 
        Returns true if the two boxes intersect.
        """
        return _core.BoundingBox3D_intersects(self, boundingBox)

    def copy(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""
        Creates an independent copy of this bounding box. 
        Returns the new bounding box or null if the copy failed.
        """
        return _core.BoundingBox3D_copy(self)

    def combine(self, boundingBox: "BoundingBox3D") -> "bool":
        r"""
        Combines this bounding box with the input bounding box. If the input
        bounding box extends outside this bounding box then this bounding box will
        be extended to encompass both of the original bounding boxes. 
        boundingBox : The other bounding box. It is not edited but is used to extend the boundaries
        of the bounding box the method is being called on. 
        Returns true if the combine was successful.
        """
        return _core.BoundingBox3D_combine(self, boundingBox)

    def _get_objectType(self) -> "char const *":
        return _core.BoundingBox3D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.BoundingBox3D__get_isValid(self)

# Register BoundingBox3D in _core:
_core.BoundingBox3D_swigregister(BoundingBox3D)

def BoundingBox3D_classType() -> "char const *":
    return _core.BoundingBox3D_classType()

def BoundingBox3D_create(minPoint: "Point3D", maxPoint: "Point3D") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Point3D > const &":
    return _core.BoundingBox3D_create(minPoint, maxPoint)


BoundingBox3D.minPoint = property(BoundingBox3D._get_minPoint, BoundingBox3D._set_minPoint, doc="Gets and sets the minimum point corner of the box.")


BoundingBox3D.maxPoint = property(BoundingBox3D._get_maxPoint, BoundingBox3D._set_maxPoint, doc="Gets and sets the maximum point corner of the box.")


BoundingBox3D.cast = lambda arg: arg if isinstance(arg, BoundingBox3D) else None

class Camera(Base):
    r"""
    The Camera class represents the information that specifies how a model
    is viewed and displayed. It's analogous to a real camera where it has
    a position in space, is pointed towards a specific point and is oriented
    in a particular way.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Camera *":
        return _core.Camera___deref__(self)

    def __eq__(self, rhs: "Camera") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Camera___eq__(self, rhs)


    def __ne__(self, rhs: "Camera") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Camera___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Camera_classType()
    __swig_destroy__ = _core.delete_Camera

    def _get_eye(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets the position of the eye in world space."""
        return _core.Camera__get_eye(self)

    def _set_eye(self, value: "Point3D") -> "bool":
        r"""Gets and sets the position of the eye in world space."""
        return _core.Camera__set_eye(self, value)

    def _get_target(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets the camera target point in world space."""
        return _core.Camera__get_target(self)

    def _set_target(self, value: "Point3D") -> "bool":
        r"""Gets and sets the camera target point in world space."""
        return _core.Camera__set_target(self, value)

    def _get_cameraType(self) -> "adsk::core::CameraTypes":
        r"""Gets and sets the current camera type."""
        return _core.Camera__get_cameraType(self)

    def _set_cameraType(self, value: "CameraTypes") -> "bool":
        r"""Gets and sets the current camera type."""
        return _core.Camera__set_cameraType(self, value)

    def _get_perspectiveAngle(self) -> "double":
        r"""
        Gets and sets the perspective angle of the camera. This
        property is only valid when the CameraType property is
        either Perspective or PerspectiveWithOrthoFaces.
        """
        return _core.Camera__get_perspectiveAngle(self)

    def _set_perspectiveAngle(self, value: "double") -> "bool":
        r"""
        Gets and sets the perspective angle of the camera. This
        property is only valid when the CameraType property is
        either Perspective or PerspectiveWithOrthoFaces.
        """
        return _core.Camera__set_perspectiveAngle(self, value)

    def _get_upVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Defines the 'up' direction for the camera which controls the orientation of the camera around the line
        defined between the eye and target points.
        """
        return _core.Camera__get_upVector(self)

    def _set_upVector(self, value: "Vector3D") -> "bool":
        r"""
        Defines the 'up' direction for the camera which controls the orientation of the camera around the line
        defined between the eye and target points.
        """
        return _core.Camera__set_upVector(self, value)

    def _get_viewExtents(self) -> "double":
        r"""
        Defines the area that's visible by the camera. This
        value is the radius of a sphere centered at the target point.
        The camera will display everything within that sphere and
        everything in front of and behind the sphere. Additional
        geometry outside of the sphere will also be visible depending
        on the shape of the window. Setting this
        value can cause the eye and/or perspective angle to be
        modified when the camera type is perspective.
        """
        return _core.Camera__get_viewExtents(self)

    def _set_viewExtents(self, value: "double") -> "bool":
        r"""
        Defines the area that's visible by the camera. This
        value is the radius of a sphere centered at the target point.
        The camera will display everything within that sphere and
        everything in front of and behind the sphere. Additional
        geometry outside of the sphere will also be visible depending
        on the shape of the window. Setting this
        value can cause the eye and/or perspective angle to be
        modified when the camera type is perspective.
        """
        return _core.Camera__set_viewExtents(self, value)

    def _get_isFitView(self) -> "bool":
        r"""
        If this property is true, when this camera is applied to a viewport it
        will modify the camera such that the entire model is displayed in the viewport. 
        When getting a camera from a viewport this property is always initialized to false.
        """
        return _core.Camera__get_isFitView(self)

    def _set_isFitView(self, value: "bool") -> "bool":
        r"""
        If this property is true, when this camera is applied to a viewport it
        will modify the camera such that the entire model is displayed in the viewport. 
        When getting a camera from a viewport this property is always initialized to false.
        """
        return _core.Camera__set_isFitView(self, value)

    def _get_isSmoothTransition(self) -> "bool":
        r"""
        Determines whether Fusion 360 does a smooth transition to this camera positoin when the
        camera is assigned to a ViewPort. If this is true it will do a smooth transition from
        the current camera position to the new camera position. If false, the view will jump
        to the position defined by the camera with no intermediate steps. This is useful if
        you're providing a series of cameras to control the camera animation.
        """
        return _core.Camera__get_isSmoothTransition(self)

    def _set_isSmoothTransition(self, value: "bool") -> "bool":
        r"""
        Determines whether Fusion 360 does a smooth transition to this camera positoin when the
        camera is assigned to a ViewPort. If this is true it will do a smooth transition from
        the current camera position to the new camera position. If false, the view will jump
        to the position defined by the camera with no intermediate steps. This is useful if
        you're providing a series of cameras to control the camera animation.
        """
        return _core.Camera__set_isSmoothTransition(self, value)

    def _get_viewOrientation(self) -> "adsk::core::ViewOrientations":
        r"""
        Sets the camera to a standard orientation. If this is set,
        it will result in resetting all of the camera values except
        the camera type.
        """
        return _core.Camera__get_viewOrientation(self)

    def _set_viewOrientation(self, value: "ViewOrientations") -> "bool":
        r"""
        Sets the camera to a standard orientation. If this is set,
        it will result in resetting all of the camera values except
        the camera type.
        """
        return _core.Camera__set_viewOrientation(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.Camera__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Camera__get_isValid(self)

# Register Camera in _core:
_core.Camera_swigregister(Camera)

def Camera_classType() -> "char const *":
    return _core.Camera_classType()


Camera.eye = property(Camera._get_eye, Camera._set_eye, doc="Gets and sets the position of the eye in world space.")


Camera.target = property(Camera._get_target, Camera._set_target, doc="Gets and sets the camera target point in world space.")


Camera.cameraType = property(Camera._get_cameraType, Camera._set_cameraType, doc="Gets and sets the current camera type.")


Camera.perspectiveAngle = property(Camera._get_perspectiveAngle, Camera._set_perspectiveAngle, doc="Gets and sets the perspective angle of the camera. This\nproperty is only valid when the CameraType property is\neither Perspective or PerspectiveWithOrthoFaces.")


Camera.upVector = property(Camera._get_upVector, Camera._set_upVector, doc="Defines the 'up' direction for the camera which controls the orientation of the camera around the line\ndefined between the eye and target points.")


Camera.viewExtents = property(Camera._get_viewExtents, Camera._set_viewExtents, doc="Defines the area that's visible by the camera. This\nvalue is the radius of a sphere centered at the target point.\nThe camera will display everything within that sphere and\neverything in front of and behind the sphere. Additional\ngeometry outside of the sphere will also be visible depending\non the shape of the window. Setting this\nvalue can cause the eye and/or perspective angle to be\nmodified when the camera type is perspective.")


Camera.isFitView = property(Camera._get_isFitView, Camera._set_isFitView, doc="If this property is true, when this camera is applied to a viewport it\nwill modify the camera such that the entire model is displayed in the viewport.\nWhen getting a camera from a viewport this property is always initialized to false.")


Camera.isSmoothTransition = property(Camera._get_isSmoothTransition, Camera._set_isSmoothTransition, doc="Determines whether Fusion 360 does a smooth transition to this camera positoin when the\ncamera is assigned to a ViewPort. If this is true it will do a smooth transition from\nthe current camera position to the new camera position. If false, the view will jump\nto the position defined by the camera with no intermediate steps. This is useful if\nyou're providing a series of cameras to control the camera animation.")


Camera.viewOrientation = property(Camera._get_viewOrientation, Camera._set_viewOrientation, doc="Sets the camera to a standard orientation. If this is set,\nit will result in resetting all of the camera values except\nthe camera type.")


Camera.cast = lambda arg: arg if isinstance(arg, Camera) else None

class CameraEventHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notify(self, eventArgs: "CameraEventArgs") -> "void":
        return _core.CameraEventHandler_notify(self, eventArgs)

    def __init__(self):
        if self.__class__ == CameraEventHandler:
            _self = None
        else:
            _self = self
        _core.CameraEventHandler_swiginit(self, _core.new_CameraEventHandler(_self, ))
    __swig_destroy__ = _core.delete_CameraEventHandler
    def __disown__(self):
        self.this.disown()
        _core.disown_CameraEventHandler(self)
        return weakref.proxy(self)

# Register CameraEventHandler in _core:
_core.CameraEventHandler_swigregister(CameraEventHandler)


CameraEventHandler.cast = lambda arg: arg if isinstance(arg, CameraEventHandler) else None

class Color(Base):
    r"""The Color class wraps all of the information that defines a simple color."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Color *":
        return _core.Color___deref__(self)

    def __eq__(self, rhs: "Color") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Color___eq__(self, rhs)


    def __ne__(self, rhs: "Color") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Color___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Color_classType()

    @staticmethod
    def create(red: "short", green: "short", blue: "short", opacity: "short") -> "adsk::core::Ptr< adsk::core::Color >":
        return _core.Color_create(red, green, blue, opacity)
    __swig_destroy__ = _core.delete_Color

    def _get_red(self) -> "short":
        r"""Gets and sets the red component of the color. The value can be 0 to 255."""
        return _core.Color__get_red(self)

    def _set_red(self, value: "short") -> "bool":
        r"""Gets and sets the red component of the color. The value can be 0 to 255."""
        return _core.Color__set_red(self, value)

    def _get_green(self) -> "short":
        r"""Gets and sets the green component of the color. The value can be 0 to 255."""
        return _core.Color__get_green(self)

    def _set_green(self, value: "short") -> "bool":
        r"""Gets and sets the green component of the color. The value can be 0 to 255."""
        return _core.Color__set_green(self, value)

    def _get_blue(self) -> "short":
        r"""Gets and sets the blue component of the color. The value can be 0 to 255."""
        return _core.Color__get_blue(self)

    def _set_blue(self, value: "short") -> "bool":
        r"""Gets and sets the blue component of the color. The value can be 0 to 255."""
        return _core.Color__set_blue(self, value)

    def _get_opacity(self) -> "short":
        r"""Gets and sets the opacity of the color. The value can be 0 to 255."""
        return _core.Color__get_opacity(self)

    def _set_opacity(self, value: "short") -> "bool":
        r"""Gets and sets the opacity of the color. The value can be 0 to 255."""
        return _core.Color__set_opacity(self, value)

    def getColor(self) -> "bool":
        r"""
        Gets all of the information defining this color. 
        red : The red component of the color. The value can be 0 to 255. 
        green : The green component of the color. The value can be 0 to 255. 
        blue : The blue component of the color. The value can be 0 to 255. 
        opacity : The opacity of the color. The value can be 0 to 255. A value of 255 indicates
        it is completely opaque. 
        Returns true if getting the color information was successful.
        """
        return _core.Color_getColor(self)

    def setColor(self, red: "short", green: "short", blue: "short", opacity: "short") -> "bool":
        r"""
        Sets all of the color information. 
        red : The red component of the color. The value can be 0 to 255. 
        green : The green component of the color. The value can be 0 to 255. 
        blue : The blue component of the color. The value can be 0 to 255. 
        opacity : The opacity of the color. The value can be 0 to 255. A value of 255 indicates
        it is completely opaque. Depending on where the color is used, the opacity
        value may be ignored. 
        Returns true if setting the color information was successful.
        """
        return _core.Color_setColor(self, red, green, blue, opacity)

    def _get_objectType(self) -> "char const *":
        return _core.Color__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Color__get_isValid(self)

# Register Color in _core:
_core.Color_swigregister(Color)

def Color_classType() -> "char const *":
    return _core.Color_classType()

def Color_create(red: "short", green: "short", blue: "short", opacity: "short") -> "adsk::core::Ptr< adsk::core::Color >":
    return _core.Color_create(red, green, blue, opacity)


Color.red = property(Color._get_red, Color._set_red, doc="Gets and sets the red component of the color. The value can be 0 to 255.")


Color.green = property(Color._get_green, Color._set_green, doc="Gets and sets the green component of the color. The value can be 0 to 255.")


Color.blue = property(Color._get_blue, Color._set_blue, doc="Gets and sets the blue component of the color. The value can be 0 to 255.")


Color.opacity = property(Color._get_opacity, Color._set_opacity, doc="Gets and sets the opacity of the color. The value can be 0 to 255.")


Color.cast = lambda arg: arg if isinstance(arg, Color) else None

class Command(Base):
    r"""
    The Command class contains all of the functionality needed by a command to gather
    various command input from a user, provide previews, and create the final result
    which is also encapsulated within a transaction so it can be undone.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Command *":
        return _core.Command___deref__(self)

    def __eq__(self, rhs: "Command") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Command___eq__(self, rhs)


    def __ne__(self, rhs: "Command") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Command___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Command_classType()
    __swig_destroy__ = _core.delete_Command

    def _get_parentCommandDefinition(self) -> "adsk::core::Ptr< adsk::core::CommandDefinition >":
        r"""Gets the parent CommandDefinition object."""
        return _core.Command__get_parentCommandDefinition(self)

    def _get_activate(self) -> "adsk::core::Ptr< adsk::core::CommandEvent >":
        r"""
        Gets an event that is fired when the command is first activated or re-activated after being suspended. 
        Returns a CommandEvent object that is used to connect and release from the event.
        """
        return _core.Command__get_activate(self)

    def _get_deactivate(self) -> "adsk::core::Ptr< adsk::core::CommandEvent >":
        r"""
        Gets an event that is fired when the command is deactivated. The command still exists and could still be activated again. 
        Returns a CommandEvent object that is used to connect and release from the event.
        """
        return _core.Command__get_deactivate(self)

    def _get_destroy(self) -> "adsk::core::Ptr< adsk::core::CommandEvent >":
        r"""
        Gets an event that is fired when the command is destroyed. The command is destroyed and can be cleaned up. 
        Returns a CommandEvent object that is used to connect and release from the event.
        """
        return _core.Command__get_destroy(self)

    def _get_execute(self) -> "adsk::core::Ptr< adsk::core::CommandEvent >":
        r"""
        Gets an event that is fired when the command has completed gathering the required input and now
        needs to perform whatever action the command does. 
        Returns a CommandEvent object that is used to connect and release from the event.
        """
        return _core.Command__get_execute(self)

    def _get_executePreview(self) -> "adsk::core::Ptr< adsk::core::CommandEvent >":
        r"""
        Gets an event that is fired when the command has completed gathering the required input and now
        needs to perform a preview. 
        Returns a CommandEvent object that is used to connect and release from the event.
        """
        return _core.Command__get_executePreview(self)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""
        Gets the associated CommandInputs object which provides the ability
        to create new command inputs and provides access to any existing inputs
        that have already been created for this command.
        """
        return _core.Command__get_commandInputs(self)

    def _get_inputChanged(self) -> "adsk::core::Ptr< adsk::core::InputChangedEvent >":
        r"""
        Gets an event that is fired whenever an input value is changed. 
        Returns an InputChangedEvent object that is used to connect and release from the event.
        """
        return _core.Command__get_inputChanged(self)

    def _get_validateInputs(self) -> "adsk::core::Ptr< adsk::core::ValidateInputsEvent >":
        r"""
        Gets an event that is fired to allow you to check if the current state of the inputs are valid for execution. 
        Returns a ValidateInputsEvent object that is used to connect and release from the event.
        """
        return _core.Command__get_validateInputs(self)

    def _get_keyDown(self) -> "adsk::core::Ptr< adsk::core::KeyboardEvent >":
        r"""Geta an event that is fired when a key on the keyboard is pressed down."""
        return _core.Command__get_keyDown(self)

    def _get_keyUp(self) -> "adsk::core::Ptr< adsk::core::KeyboardEvent >":
        r"""Gets an event that is fired when a key on the keyboard goes up."""
        return _core.Command__get_keyUp(self)

    def _get_mouseClick(self) -> "adsk::core::Ptr< adsk::core::MouseEvent >":
        r"""Gets an event that is fired when the mouse is clicked, (a button is pressed and released)."""
        return _core.Command__get_mouseClick(self)

    def _get_mouseDoubleClick(self) -> "adsk::core::Ptr< adsk::core::MouseEvent >":
        r"""Gets an event that is fired when the mouse is double-clicked, (clicked twice within the time specified by a system setting.)"""
        return _core.Command__get_mouseDoubleClick(self)

    def _get_mouseDown(self) -> "adsk::core::Ptr< adsk::core::MouseEvent >":
        r"""Gets an event that is fired when a mouse button is pressed."""
        return _core.Command__get_mouseDown(self)

    def _get_mouseMove(self) -> "adsk::core::Ptr< adsk::core::MouseEvent >":
        r"""Gets an event that is fired when the mouse is moved."""
        return _core.Command__get_mouseMove(self)

    def _get_mouseUp(self) -> "adsk::core::Ptr< adsk::core::MouseEvent >":
        r"""Gets an event that is fired when a mouse button is released."""
        return _core.Command__get_mouseUp(self)

    def _get_mouseWheel(self) -> "adsk::core::Ptr< adsk::core::MouseEvent >":
        r"""Gets an event that is fired when the mouse wheel is rotated."""
        return _core.Command__get_mouseWheel(self)

    def _get_mouseDragBegin(self) -> "adsk::core::Ptr< adsk::core::MouseEvent >":
        r"""
        Gets an event that is fired when a mouse drag starts, 
        (the mouse is pressed and moved).
        """
        return _core.Command__get_mouseDragBegin(self)

    def _get_mouseDrag(self) -> "adsk::core::Ptr< adsk::core::MouseEvent >":
        r"""
        Gets an event that is fired when the mouse is in drag mode, 
        (being moved while a button is pressed).
        """
        return _core.Command__get_mouseDrag(self)

    def _get_mouseDragEnd(self) -> "adsk::core::Ptr< adsk::core::MouseEvent >":
        r"""Gets an event that is fired when the mouse button is released after a drag."""
        return _core.Command__get_mouseDragEnd(self)

    def _get_isOKButtonVisible(self) -> "bool":
        r"""
        Specifies if the OK button is visible or not.
        If set to false then the OK button is removed and the
        'CANCEL' button text changes to 'CLOSE'. You can override
        the default button text using the cancelButtonText property.
        """
        return _core.Command__get_isOKButtonVisible(self)

    def _set_isOKButtonVisible(self, value: "bool") -> "bool":
        r"""
        Specifies if the OK button is visible or not.
        If set to false then the OK button is removed and the
        'CANCEL' button text changes to 'CLOSE'. You can override
        the default button text using the cancelButtonText property.
        """
        return _core.Command__set_isOKButtonVisible(self, value)

    def _get_okButtonText(self) -> "std::string":
        r"""
        Gets and sets the text displayed on the OK button. When the OK and Cancel
        buttons are displayed, this text defaults to 'OK'. If the Cancel button
        is not displayed the text defaults to 'CLOSE'.
        """
        return _core.Command__get_okButtonText(self)

    def _set_okButtonText(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the text displayed on the OK button. When the OK and Cancel
        buttons are displayed, this text defaults to 'OK'. If the Cancel button
        is not displayed the text defaults to 'CLOSE'.
        """
        return _core.Command__set_okButtonText(self, value)

    def _get_cancelButtonText(self) -> "std::string":
        r"""
        Gets and sets the text displayed on the Cancel button. The value of this
        property is ignored if the isCancelButtonVisible property is false.
        """
        return _core.Command__get_cancelButtonText(self)

    def _set_cancelButtonText(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the text displayed on the Cancel button. The value of this
        property is ignored if the isCancelButtonVisible property is false.
        """
        return _core.Command__set_cancelButtonText(self, value)

    def setDialogInitialSize(self, width: "int", height: "int") -> "bool":
        r"""
        Sets the initial size of the dialog when it is first displayed. If this is not
        set, Fusion 360 will use a default size for the dialog. 
        width : The width of the dialog in pixels. 
        height : The height of the dialog in pixels. 
        Returns true if the default size was successfully set.
        """
        return _core.Command_setDialogInitialSize(self, width, height)

    def setDialogMinimumSize(self, width: "int", height: "int") -> "bool":
        r"""
        Sets the minimum size for the dialog when resized to by the user. If this is not
        set, a default minimum size is used. 
        width : The minimum width of the dialog in pixels. 
        height : The minimum height of the dialog in pixels. 
        Returns true if the minimum size was successfully set.
        """
        return _core.Command_setDialogMinimumSize(self, width, height)

    def _get_isRepeatable(self) -> "bool":
        r"""Gets and Sets if this command is repeatable using the 'Repeat Last Command' option from the Fusion 360 marking menu."""
        return _core.Command__get_isRepeatable(self)

    def _set_isRepeatable(self, value: "bool") -> "bool":
        r"""Gets and Sets if this command is repeatable using the 'Repeat Last Command' option from the Fusion 360 marking menu."""
        return _core.Command__set_isRepeatable(self, value)

    def _get_selectionEvent(self) -> "adsk::core::Ptr< adsk::core::SelectionEvent >":
        r"""This event has been retired. Equivalent functionality is supported by the preSelect event."""
        return _core.Command__get_selectionEvent(self)

    def _get_isExecutedWhenPreEmpted(self) -> "bool":
        r"""
        Specifies what the behavior will be when a command is pre-empted by the user executing another
        command. If true (the default), and all of the current inputs are valid, the command will be 
        executed just the same as if the user clicked the OK button. If false, the command is terminated.
        """
        return _core.Command__get_isExecutedWhenPreEmpted(self)

    def _set_isExecutedWhenPreEmpted(self, value: "bool") -> "bool":
        r"""
        Specifies what the behavior will be when a command is pre-empted by the user executing another
        command. If true (the default), and all of the current inputs are valid, the command will be 
        executed just the same as if the user clicked the OK button. If false, the command is terminated.
        """
        return _core.Command__set_isExecutedWhenPreEmpted(self, value)

    def _get_helpFile(self) -> "std::string":
        r"""
        <p class='api'>Gets and sets the associated html help file for this command. If this is defined
        then the help button will be displayed in the lower-left corner of the command dialog
        and when clicked the help file will be displayed using the application defined by the
        operating system for that file type. For example if the helpfile references a .htm or .html
        file, the default browser will be invoked to display the file. If a .pdf file is used then
        whatever the default application is for viewing a pdf file will be invoked.</p>
        <p class='api'>The file referenced must be a local file and cannot be a url. However, you can use a local
        html file that redirects to a url.</p>
        <pre class='api-code'><html>
        &lt;head&gt;
        &lt;meta http-equiv='refresh' content='0; url=http://example.com/' /&gt;
        &lt;/head&gt;
        &lt;body&gt;&lt;/body&gt;
        &lt;/html&gt;
        </pre>
        <p class='api'>The filename can be either a full path or a relative path with respect to the script or add-in 
        .py, .js, .dll, or .dylib file. If this is an empty string, (which is the default), then the 
        help button will not be displayed.</p>
        """
        return _core.Command__get_helpFile(self)

    def _set_helpFile(self, value: "std::string const &") -> "bool":
        r"""
        <p class='api'>Gets and sets the associated html help file for this command. If this is defined
        then the help button will be displayed in the lower-left corner of the command dialog
        and when clicked the help file will be displayed using the application defined by the
        operating system for that file type. For example if the helpfile references a .htm or .html
        file, the default browser will be invoked to display the file. If a .pdf file is used then
        whatever the default application is for viewing a pdf file will be invoked.</p>
        <p class='api'>The file referenced must be a local file and cannot be a url. However, you can use a local
        html file that redirects to a url.</p>
        <pre class='api-code'><html>
        &lt;head&gt;
        &lt;meta http-equiv='refresh' content='0; url=http://example.com/' /&gt;
        &lt;/head&gt;
        &lt;body&gt;&lt;/body&gt;
        &lt;/html&gt;
        </pre>
        <p class='api'>The filename can be either a full path or a relative path with respect to the script or add-in 
        .py, .js, .dll, or .dylib file. If this is an empty string, (which is the default), then the 
        help button will not be displayed.</p>
        """
        return _core.Command__set_helpFile(self, value)

    def _get_isAutoExecute(self) -> "bool":
        r"""
        Gets and sets whether this command will automatically execute if no command inputs have been
        defined. If any command inputs have been created, the value of this property is ignored and
        the command dialog will be displayed and the command will execute when the user clicks 'OK'.
        if no command inputs have been defined and this is set to False, then the command will not
        execute but will remain running.
        The default value for this property is true so that the command will execute if no command inputs
        have been defined.
        """
        return _core.Command__get_isAutoExecute(self)

    def _set_isAutoExecute(self, value: "bool") -> "bool":
        r"""
        Gets and sets whether this command will automatically execute if no command inputs have been
        defined. If any command inputs have been created, the value of this property is ignored and
        the command dialog will be displayed and the command will execute when the user clicks 'OK'.
        if no command inputs have been defined and this is set to False, then the command will not
        execute but will remain running.
        The default value for this property is true so that the command will execute if no command inputs
        have been defined.
        """
        return _core.Command__set_isAutoExecute(self, value)

    def doExecute(self, terminate: "bool") -> "bool":
        r"""
        Causes the execution of this command which results in the execute event being fired. This is the
        same effect as the user clicking the 'OK' button in the command dialog and is most useful when there
        is no command dialog (no command inputs where created) and the isAutoExecute property has been set
        to False. This allows you to execute the command through code. 
        terminate : In the case where there isn't a command dialog you can also use the terminate argument to specify if 
        the command should terminate after execution or continue running. This is similar to the sketch line
        command where each line placement results in the creation of an undoable line but the command continues
        to run to allow additional lines to be placed. 
        Returns true if the execution of the command was successful.
        """
        return _core.Command_doExecute(self, terminate)

    def doExecutePreview(self) -> "bool":
        r"""
        Causes the executePreview event of this command to be fired. This is most useful when there
        is no command dialog (no command inputs where created) and the isAutoExecute property has been set
        to False. This allows you to force the preview to be generated instead of relying on changing
        command inputs. 
        Returns true if the execute Preview event was successfully fired..
        """
        return _core.Command_doExecutePreview(self)

    def _get_isPositionDependent(self) -> "bool":
        r"""
        When working in a parametric design in Fusion and you move any occurrences, those move operations are
        pending and aren't captured until you use the 'Capture Position' command from the POSITION panel or
        use the 'Revert' command from the same panel to move them all back to their original positions. If
        the design is in a pending situation and you run a command like 'Create Sketch', a dialog appears
        asking if you want to capture the current position or not before continuing. This is because
        the creation of a sketch can be dependent on the current positions of occurrences in the design. Other comamnds, like
        'Fillet', depend directly on model geometry and do not rely on occurrence positions so running the Fillet command
        does not display the dialog and does not affect the pending state of the occurrences.
        This property allows you to specify if your command is dependent on the current position of occurrences
        or not. One good way to know if your command is dependent or not is to run the commands in the UI that are 
        equivalent to the API functions you're using and see if the dialog that prompts to save or abort appears. 
        If it does, then you know your command is dependent on occurrence positions.
        If this property is true, then the dialog will appear if there are any pending moved occurrences.
        The user can choose whether to capture the current changes or abort them, and then your command will continue.
        If you set this property to false, (which is the default), then even if there are pending changes, the occurrences 
        are left in their current positions and your command will run.
        """
        return _core.Command__get_isPositionDependent(self)

    def _set_isPositionDependent(self, value: "bool") -> "bool":
        r"""
        When working in a parametric design in Fusion and you move any occurrences, those move operations are
        pending and aren't captured until you use the 'Capture Position' command from the POSITION panel or
        use the 'Revert' command from the same panel to move them all back to their original positions. If
        the design is in a pending situation and you run a command like 'Create Sketch', a dialog appears
        asking if you want to capture the current position or not before continuing. This is because
        the creation of a sketch can be dependent on the current positions of occurrences in the design. Other comamnds, like
        'Fillet', depend directly on model geometry and do not rely on occurrence positions so running the Fillet command
        does not display the dialog and does not affect the pending state of the occurrences.
        This property allows you to specify if your command is dependent on the current position of occurrences
        or not. One good way to know if your command is dependent or not is to run the commands in the UI that are 
        equivalent to the API functions you're using and see if the dialog that prompts to save or abort appears. 
        If it does, then you know your command is dependent on occurrence positions.
        If this property is true, then the dialog will appear if there are any pending moved occurrences.
        The user can choose whether to capture the current changes or abort them, and then your command will continue.
        If you set this property to false, (which is the default), then even if there are pending changes, the occurrences 
        are left in their current positions and your command will run.
        """
        return _core.Command__set_isPositionDependent(self, value)

    def setCursor(self, cursorImage: "std::string const &", xHotSpot: "int", yHotSpot: "int") -> "bool":
        r"""
        Specifies the cursor to display at the mouse. 
        cursorImage : The path to the png image to display as the cursor. This can either be a relative path from the py, dll, or dylib file
        of the full path. Specifying an empty string will set the cursor back to the default cursor. 
        xHotSpot : Specifies the position of the x pixel within the image that is the 'hot' spot or the point that is used as the mouse point. A value of
        zero indicates the far left of the image. If an empty string is used as the cursorImage, this value is ignored. 
        yHotSpot : Specifies the position of the y pixel within the image that is the 'hot' spot or the point that is used as the mouse point. A value of
        zero indicates the top of the image. If an empty string is used as the cursorImage, this value is ignored. 
        Returns true if setting the cursor was successful.
        """
        return _core.Command_setCursor(self, cursorImage, xHotSpot, yHotSpot)

    def getCursor(self) -> "bool":
        r"""
        Gets the custom cursor information currently being used. 
        cursorImage : The full path to the png image that is being displayed as the cursor. 
        xHotSpot : Gets the position of the x pixel within the image that is the 'hot' spot or the point that is used as the mouse point. A value of
        zero indicates the left of the image. 
        yHotSpot : Gets the position of the y pixel within the image that is the 'hot' spot or the point that is used as the mouse point. A value of
        zero indicates the top of the image. 
        Returns true if getting the cursor information was successful.
        """
        return _core.Command_getCursor(self)

    def _get_preSelect(self) -> "adsk::core::Ptr< adsk::core::SelectionEvent >":
        r"""
        This event is used to be able to particpate in the selection process in a dynamic way. 
        When a user is selecting geometry, they move the mouse over the model and if the 
        entity the mouse is currently over is valid for selection it will highlight indicating that 
        it can be selected. This process of determining what is available for selection and highlighting
        it is refered to as the 'pre-select' behavior. 
        You use functions on the SelectionCommandInput object to define what types of entities are
        selectable and in many cases this coarse level of specification is all that's needed, but in other
        cases you may need more control over the selection. For example, you might want to allow the user to
        selection construction planes and planar faces, which can easily be controlled by defining those as
        valid entities for selection in the SelectionCommandInput object. But if you only want to allow the
        user to select planes that are parallel then you need some dynamic control over the selection, which
        can be done using the preSelect event.
        In the example of selecting parallel planes, you would still set the valid selection types for the
        SelectionCommandInput to allow selection of construction planes and planar faces. This will limit
        the selection to only planes but any plane can still be selected. You'll also need to connect to the
        preSelect event for the command. As the user moves the mouse over any construction plane
        or planar face, the preSelect event will fire for the plane the mouse is current over. If no planes
        have yet been selected, then you allow allow the user to select this plane. If one or more planes have
        already selected, then in the preSelect event you'll check to see if the plane the mouse is over is 
        parallel to the first plane already selected. If it is then you allow it to be selected. If it isn't 
        parallel then you set the isSelectable property of the provided SelectEventArgs object to False so 
        that it won't pre-highlight and won't be selectable.
        The entity and mouse position on the entity can be obtained through the Selection object returned 
        through the selection property of the SelectionEventArgs object provided through the event.
        """
        return _core.Command__get_preSelect(self)

    def _get_preSelectMouseMove(self) -> "adsk::core::Ptr< adsk::core::SelectionEvent >":
        r"""
        This event fires continually while the mouse is moved over an entity that is valid for selected.
        The entity and mouse position on the entity can be obtained through the Selection object returned 
        through the selection property of the SelectionEventArgs object provided through the event.
        """
        return _core.Command__get_preSelectMouseMove(self)

    def _get_preSelectEnd(self) -> "adsk::core::Ptr< adsk::core::SelectionEvent >":
        r"""
        This event fires when the moused is moved away from an entity that was in a pre-select state. If
        your add-in has done something in reaction to the preSelect, like draw some custom graphics, this
        event provides the notification to clean up whatever you've done that's associated with the current
        pre-select.
        The entity and mouse position on the entity can be obtained through the Selection object returned 
        through the selection property of the SelectionEventArgs object provided through the event.
        """
        return _core.Command__get_preSelectEnd(self)

    def _get_select(self) -> "adsk::core::Ptr< adsk::core::SelectionEvent >":
        r"""
        This even fires when the user selects an entity. This is different from the pre-select where an
        entity is shown as being available for selection as the mouse passes over the entity. This is the actual
        selection where the user has clicked the mouse on the entity.
        The entity and mouse position on the entity can be obtained through the Selection object returned 
        through the selection property of the SelectionEventArgs object provided through the event.
        """
        return _core.Command__get_select(self)

    def _get_unselect(self) -> "adsk::core::Ptr< adsk::core::SelectionEvent >":
        r"""
        This even fires when the user unselects an entity by clicking the mouse again on selected entity
        or canceling previous selection.
        The entity and mouse position on the entity can be obtained through the Selection object returned 
        through the selection property of the SelectionEventArgs object provided through the event.
        """
        return _core.Command__get_unselect(self)

    def beginStep(self, makeExistingStepNonUndoable: "bool"=False) -> "bool":
        r"""
        Begin a transacted step within the command's transaction.
        If the all of the command inputs are valid, this will trigger the execute event for the current step. 
        makeExistingStepNonUndoable : If true the current step will not be undoable. 
        Returns true if beginning the step was successful.
        """
        return _core.Command_beginStep(self, makeExistingStepNonUndoable)

    def _get_editingFeature(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Sets the editing feature for this command. The timeline will be rolled to the editing feature
        on activate and will the current position will be restored on deactivate.
        """
        return _core.Command__get_editingFeature(self)

    def _set_editingFeature(self, value: "Base") -> "bool":
        r"""
        Sets the editing feature for this command. The timeline will be rolled to the editing feature
        on activate and will the current position will be restored on deactivate.
        """
        return _core.Command__set_editingFeature(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.Command__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Command__get_isValid(self)

# Register Command in _core:
_core.Command_swigregister(Command)

def Command_classType() -> "char const *":
    return _core.Command_classType()


Command.parentCommandDefinition = property(Command._get_parentCommandDefinition, doc="Gets the parent CommandDefinition object.")


Command.activate = property(Command._get_activate, doc="Gets an event that is fired when the command is first activated or re-activated after being suspended.\nReturns a CommandEvent object that is used to connect and release from the event.")


Command.deactivate = property(Command._get_deactivate, doc="Gets an event that is fired when the command is deactivated. The command still exists and could still be activated again.\nReturns a CommandEvent object that is used to connect and release from the event.")


Command.destroy = property(Command._get_destroy, doc="Gets an event that is fired when the command is destroyed. The command is destroyed and can be cleaned up.\nReturns a CommandEvent object that is used to connect and release from the event.")


Command.execute = property(Command._get_execute, doc="Gets an event that is fired when the command has completed gathering the required input and now\nneeds to perform whatever action the command does.\nReturns a CommandEvent object that is used to connect and release from the event.")


Command.executePreview = property(Command._get_executePreview, doc="Gets an event that is fired when the command has completed gathering the required input and now\nneeds to perform a preview.\nReturns a CommandEvent object that is used to connect and release from the event.")


Command.commandInputs = property(Command._get_commandInputs, doc="Gets the associated CommandInputs object which provides the ability\nto create new command inputs and provides access to any existing inputs\nthat have already been created for this command.")


Command.inputChanged = property(Command._get_inputChanged, doc="Gets an event that is fired whenever an input value is changed.\nReturns an InputChangedEvent object that is used to connect and release from the event.")


Command.validateInputs = property(Command._get_validateInputs, doc="Gets an event that is fired to allow you to check if the current state of the inputs are valid for execution.\nReturns a ValidateInputsEvent object that is used to connect and release from the event.")


Command.keyDown = property(Command._get_keyDown, doc="Geta an event that is fired when a key on the keyboard is pressed down.")


Command.keyUp = property(Command._get_keyUp, doc="Gets an event that is fired when a key on the keyboard goes up.")


Command.mouseClick = property(Command._get_mouseClick, doc="Gets an event that is fired when the mouse is clicked, (a button is pressed and released).")


Command.mouseDoubleClick = property(Command._get_mouseDoubleClick, doc="Gets an event that is fired when the mouse is double-clicked, (clicked twice within the time specified by a system setting.)")


Command.mouseDown = property(Command._get_mouseDown, doc="Gets an event that is fired when a mouse button is pressed.")


Command.mouseMove = property(Command._get_mouseMove, doc="Gets an event that is fired when the mouse is moved.")


Command.mouseUp = property(Command._get_mouseUp, doc="Gets an event that is fired when a mouse button is released.")


Command.mouseWheel = property(Command._get_mouseWheel, doc="Gets an event that is fired when the mouse wheel is rotated.")


Command.mouseDragBegin = property(Command._get_mouseDragBegin, doc="Gets an event that is fired when a mouse drag starts,\n(the mouse is pressed and moved).")


Command.mouseDrag = property(Command._get_mouseDrag, doc="Gets an event that is fired when the mouse is in drag mode,\n(being moved while a button is pressed).")


Command.mouseDragEnd = property(Command._get_mouseDragEnd, doc="Gets an event that is fired when the mouse button is released after a drag.")


Command.isOKButtonVisible = property(Command._get_isOKButtonVisible, Command._set_isOKButtonVisible, doc="Specifies if the OK button is visible or not.\nIf set to false then the OK button is removed and the\n'CANCEL' button text changes to 'CLOSE'. You can override\nthe default button text using the cancelButtonText property.")


Command.okButtonText = property(Command._get_okButtonText, Command._set_okButtonText, doc="Gets and sets the text displayed on the OK button. When the OK and Cancel\nbuttons are displayed, this text defaults to 'OK'. If the Cancel button\nis not displayed the text defaults to 'CLOSE'.")


Command.cancelButtonText = property(Command._get_cancelButtonText, Command._set_cancelButtonText, doc="Gets and sets the text displayed on the Cancel button. The value of this\nproperty is ignored if the isCancelButtonVisible property is false.")


Command.isRepeatable = property(Command._get_isRepeatable, Command._set_isRepeatable, doc="Gets and Sets if this command is repeatable using the 'Repeat Last Command' option from the Fusion 360 marking menu.")


Command.selectionEvent = property(Command._get_selectionEvent, doc="This event has been retired. Equivalent functionality is supported by the preSelect event.")


Command.isExecutedWhenPreEmpted = property(Command._get_isExecutedWhenPreEmpted, Command._set_isExecutedWhenPreEmpted, doc="Specifies what the behavior will be when a command is pre-empted by the user executing another\ncommand. If true (the default), and all of the current inputs are valid, the command will be\nexecuted just the same as if the user clicked the OK button. If false, the command is terminated.")


Command.helpFile = property(Command._get_helpFile, Command._set_helpFile, doc="<p class='api'>Gets and sets the associated html help file for this command. If this is defined\nthen the help button will be displayed in the lower-left corner of the command dialog\nand when clicked the help file will be displayed using the application defined by the\noperating system for that file type. For example if the helpfile references a .htm or .html\nfile, the default browser will be invoked to display the file. If a .pdf file is used then\nwhatever the default application is for viewing a pdf file will be invoked.</p>\n<p class='api'>The file referenced must be a local file and cannot be a url. However, you can use a local\nhtml file that redirects to a url.</p>\n<pre class='api-code'><html>\n&lt;head&gt;\n&lt;meta http-equiv='refresh' content='0; url=http://example.com/' /&gt;\n&lt;/head&gt;\n&lt;body&gt;&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n<p class='api'>The filename can be either a full path or a relative path with respect to the script or add-in\n.py, .js, .dll, or .dylib file. If this is an empty string, (which is the default), then the\nhelp button will not be displayed.</p>")


Command.isAutoExecute = property(Command._get_isAutoExecute, Command._set_isAutoExecute, doc="Gets and sets whether this command will automatically execute if no command inputs have been\ndefined. If any command inputs have been created, the value of this property is ignored and\nthe command dialog will be displayed and the command will execute when the user clicks 'OK'.\nif no command inputs have been defined and this is set to False, then the command will not\nexecute but will remain running.\nThe default value for this property is true so that the command will execute if no command inputs\nhave been defined.")


Command.isPositionDependent = property(Command._get_isPositionDependent, Command._set_isPositionDependent, doc="When working in a parametric design in Fusion and you move any occurrences, those move operations are\npending and aren't captured until you use the 'Capture Position' command from the POSITION panel or\nuse the 'Revert' command from the same panel to move them all back to their original positions. If\nthe design is in a pending situation and you run a command like 'Create Sketch', a dialog appears\nasking if you want to capture the current position or not before continuing. This is because\nthe creation of a sketch can be dependent on the current positions of occurrences in the design. Other comamnds, like\n'Fillet', depend directly on model geometry and do not rely on occurrence positions so running the Fillet command\ndoes not display the dialog and does not affect the pending state of the occurrences.\nThis property allows you to specify if your command is dependent on the current position of occurrences\nor not. One good way to know if your command is dependent or not is to run the commands in the UI that are\nequivalent to the API functions you're using and see if the dialog that prompts to save or abort appears.\nIf it does, then you know your command is dependent on occurrence positions.\nIf this property is true, then the dialog will appear if there are any pending moved occurrences.\nThe user can choose whether to capture the current changes or abort them, and then your command will continue.\nIf you set this property to false, (which is the default), then even if there are pending changes, the occurrences\nare left in their current positions and your command will run.")


Command.preSelect = property(Command._get_preSelect, doc="This event is used to be able to particpate in the selection process in a dynamic way.\nWhen a user is selecting geometry, they move the mouse over the model and if the\nentity the mouse is currently over is valid for selection it will highlight indicating that\nit can be selected. This process of determining what is available for selection and highlighting\nit is refered to as the 'pre-select' behavior.\nYou use functions on the SelectionCommandInput object to define what types of entities are\nselectable and in many cases this coarse level of specification is all that's needed, but in other\ncases you may need more control over the selection. For example, you might want to allow the user to\nselection construction planes and planar faces, which can easily be controlled by defining those as\nvalid entities for selection in the SelectionCommandInput object. But if you only want to allow the\nuser to select planes that are parallel then you need some dynamic control over the selection, which\ncan be done using the preSelect event.\nIn the example of selecting parallel planes, you would still set the valid selection types for the\nSelectionCommandInput to allow selection of construction planes and planar faces. This will limit\nthe selection to only planes but any plane can still be selected. You'll also need to connect to the\npreSelect event for the command. As the user moves the mouse over any construction plane\nor planar face, the preSelect event will fire for the plane the mouse is current over. If no planes\nhave yet been selected, then you allow allow the user to select this plane. If one or more planes have\nalready selected, then in the preSelect event you'll check to see if the plane the mouse is over is\nparallel to the first plane already selected. If it is then you allow it to be selected. If it isn't\nparallel then you set the isSelectable property of the provided SelectEventArgs object to False so\nthat it won't pre-highlight and won't be selectable.\nThe entity and mouse position on the entity can be obtained through the Selection object returned\nthrough the selection property of the SelectionEventArgs object provided through the event.")


Command.preSelectMouseMove = property(Command._get_preSelectMouseMove, doc="This event fires continually while the mouse is moved over an entity that is valid for selected.\nThe entity and mouse position on the entity can be obtained through the Selection object returned\nthrough the selection property of the SelectionEventArgs object provided through the event.")


Command.preSelectEnd = property(Command._get_preSelectEnd, doc="This event fires when the moused is moved away from an entity that was in a pre-select state. If\nyour add-in has done something in reaction to the preSelect, like draw some custom graphics, this\nevent provides the notification to clean up whatever you've done that's associated with the current\npre-select.\nThe entity and mouse position on the entity can be obtained through the Selection object returned\nthrough the selection property of the SelectionEventArgs object provided through the event.")


Command.select = property(Command._get_select, doc="This even fires when the user selects an entity. This is different from the pre-select where an\nentity is shown as being available for selection as the mouse passes over the entity. This is the actual\nselection where the user has clicked the mouse on the entity.\nThe entity and mouse position on the entity can be obtained through the Selection object returned\nthrough the selection property of the SelectionEventArgs object provided through the event.")


Command.unselect = property(Command._get_unselect, doc="This even fires when the user unselects an entity by clicking the mouse again on selected entity\nor canceling previous selection.\nThe entity and mouse position on the entity can be obtained through the Selection object returned\nthrough the selection property of the SelectionEventArgs object provided through the event.")


Command.editingFeature = property(Command._get_editingFeature, Command._set_editingFeature, doc="Sets the editing feature for this command. The timeline will be rolled to the editing feature\non activate and will the current position will be restored on deactivate.")


Command.cast = lambda arg: arg if isinstance(arg, Command) else None

class CommandCreatedEventHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notify(self, eventArgs: "CommandCreatedEventArgs") -> "void":
        return _core.CommandCreatedEventHandler_notify(self, eventArgs)

    def __init__(self):
        if self.__class__ == CommandCreatedEventHandler:
            _self = None
        else:
            _self = self
        _core.CommandCreatedEventHandler_swiginit(self, _core.new_CommandCreatedEventHandler(_self, ))
    __swig_destroy__ = _core.delete_CommandCreatedEventHandler
    def __disown__(self):
        self.this.disown()
        _core.disown_CommandCreatedEventHandler(self)
        return weakref.proxy(self)

# Register CommandCreatedEventHandler in _core:
_core.CommandCreatedEventHandler_swigregister(CommandCreatedEventHandler)


CommandCreatedEventHandler.cast = lambda arg: arg if isinstance(arg, CommandCreatedEventHandler) else None

class CommandDefinition(Base):
    r"""
    The CommandDefinition is the base class of the various types of commands. Command types are based
    on the type of control used to execute them in the user-interface. For example, most commands will
    use a ButtonDefinition since they're executed using a button in the user-interface. A command definition
    contains the information that defines the user-interface. For example, the name and icon. The command
    definition and also gets the notification when the user interacts with the associated control.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::CommandDefinition *":
        return _core.CommandDefinition___deref__(self)

    def __eq__(self, rhs: "CommandDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.CommandDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "CommandDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.CommandDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.CommandDefinition_classType()
    __swig_destroy__ = _core.delete_CommandDefinition

    def execute(self, *args) -> "bool":
        r"""
        Executes this command definition. This is the same as the user clicking
        a button that is associated with this command definition. 
        input : A list of named values that will provide input to the command. The values supported are unique for each command.
        and not all commands support input values. 
        Returns true or false indicating if the execution was successful.
        """
        return _core.CommandDefinition_execute(self, *args)

    def _get_commandCreated(self) -> "adsk::core::Ptr< adsk::core::CommandCreatedEvent >":
        r"""
        This event is fired when the associated control is manipulated by the user. A new Command object 
        is created and passed back through this event which you can then use to interact with the user
        to get any input the command requires.
        """
        return _core.CommandDefinition__get_commandCreated(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this command definition. This is only valid for API created command definitions
        and will fail if the isNative property is true. 
        Returns true or false indicating if the deletion was successful.
        """
        return _core.CommandDefinition_deleteMe(self)

    def _get_isNative(self) -> "bool":
        r"""
        Gets if this is a native command definition. If True then there
        are limitations to edits that can be done on the command definition.
        For example a native command definition cannot be deleted.
        """
        return _core.CommandDefinition__get_isNative(self)

    def _get_id(self) -> "std::string":
        r"""
        Gets the unique id for this command definition. This is guaranteed to be unique with
        respect to all other command definitions.
        """
        return _core.CommandDefinition__get_id(self)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip. 
        The tooltip is always shown but as the user hovers over the control it will progressively display the tool clip along with the tooltip text.
        """
        return _core.CommandDefinition__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip. 
        The tooltip is always shown but as the user hovers over the control it will progressively display the tool clip along with the tooltip text.
        """
        return _core.CommandDefinition__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description and/or tool clip are also specified then
        the tooltip will progressively display more information as the user hovers the mouse over the control.
        """
        return _core.CommandDefinition__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description and/or tool clip are also specified then
        the tooltip will progressively display more information as the user hovers the mouse over the control.
        """
        return _core.CommandDefinition__set_tooltip(self, value)

    def _get_resourceFolder(self) -> "std::string":
        r"""
        Gets or sets the directory that contains any additional files associated with this command.
        These are typically the image files that will be used for a button and the 
        html files for a tool clip or helps and tips.
        """
        return _core.CommandDefinition__get_resourceFolder(self)

    def _set_resourceFolder(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the directory that contains any additional files associated with this command.
        These are typically the image files that will be used for a button and the 
        html files for a tool clip or helps and tips.
        """
        return _core.CommandDefinition__set_resourceFolder(self, value)

    def _get_controlDefinition(self) -> "adsk::core::Ptr< adsk::core::ControlDefinition >":
        r"""
        Gets the ControlDefinition associated with this command. The control definition
        defines the type of control that can exist in the user interface to execute this command.
        You can use properties on the control definition to define the look and behavior of 
        the control.
        """
        return _core.CommandDefinition__get_controlDefinition(self)

    def _get_name(self) -> "std::string":
        r"""Gets or sets the visible name of the command when seen in the user interface."""
        return _core.CommandDefinition__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Gets or sets the visible name of the command when seen in the user interface."""
        return _core.CommandDefinition__set_name(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.CommandDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.CommandDefinition__get_isValid(self)

# Register CommandDefinition in _core:
_core.CommandDefinition_swigregister(CommandDefinition)

def CommandDefinition_classType() -> "char const *":
    return _core.CommandDefinition_classType()


CommandDefinition.commandCreated = property(CommandDefinition._get_commandCreated, doc="This event is fired when the associated control is manipulated by the user. A new Command object\nis created and passed back through this event which you can then use to interact with the user\nto get any input the command requires.")


CommandDefinition.isNative = property(CommandDefinition._get_isNative, doc="Gets if this is a native command definition. If True then there\nare limitations to edits that can be done on the command definition.\nFor example a native command definition cannot be deleted.")


CommandDefinition.id = property(CommandDefinition._get_id, doc="Gets the unique id for this command definition. This is guaranteed to be unique with\nrespect to all other command definitions.")


CommandDefinition.toolClipFilename = property(CommandDefinition._get_toolClipFilename, CommandDefinition._set_toolClipFilename, doc="Gets or sets the full filename of the image file (png) used for the tool clip.\nThe tooltip is always shown but as the user hovers over the control it will progressively display the tool clip along with the tooltip text.")


CommandDefinition.tooltip = property(CommandDefinition._get_tooltip, CommandDefinition._set_tooltip, doc="Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description and/or tool clip are also specified then\nthe tooltip will progressively display more information as the user hovers the mouse over the control.")


CommandDefinition.resourceFolder = property(CommandDefinition._get_resourceFolder, CommandDefinition._set_resourceFolder, doc="Gets or sets the directory that contains any additional files associated with this command.\nThese are typically the image files that will be used for a button and the\nhtml files for a tool clip or helps and tips.")


CommandDefinition.controlDefinition = property(CommandDefinition._get_controlDefinition, doc="Gets the ControlDefinition associated with this command. The control definition\ndefines the type of control that can exist in the user interface to execute this command.\nYou can use properties on the control definition to define the look and behavior of\nthe control.")


CommandDefinition.name = property(CommandDefinition._get_name, CommandDefinition._set_name, doc="Gets or sets the visible name of the command when seen in the user interface.")


CommandDefinition.cast = lambda arg: arg if isinstance(arg, CommandDefinition) else None

class CommandDefinitions(Base):
    r"""
    Provides access to all of the available command definitions. This is all those created via
    the API but also includes the command definitions defined by Fusion 360 for the native commands.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::CommandDefinitions *":
        return _core.CommandDefinitions___deref__(self)

    def __eq__(self, rhs: "CommandDefinitions") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.CommandDefinitions___eq__(self, rhs)


    def __ne__(self, rhs: "CommandDefinitions") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.CommandDefinitions___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.CommandDefinitions___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::CommandDefinition >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.CommandDefinitions___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.CommandDefinitions_classType()
    __swig_destroy__ = _core.delete_CommandDefinitions

    def addButtonDefinition(self, *args) -> "adsk::core::Ptr< adsk::core::CommandDefinition >":
        r"""
        Creates a new command definition that can be used to create a button control and handle the response when the button is clicked. 
        id : The unique identifier for this command definition. It must be unique with respect to all other command definitions and is
        limited to the following set of characters, [A-Z][a-z][0-9] and _. 
        name : The name displayed in the UI for the associated button control. 
        tooltip : The full description of the command as seen in the extended tooltip in the user interface.
        Using the returned CommandDefinition you can also optionally set the toolClipFilename property
        to show an image the extended tooltip. 
        resourceFolder : Specifies the folder where the resources for this command are located. These are various sizes and styles of png
        files that are used for the button image. To fully support all potential options you should create files with
        the following names and sizes: 16x16.png , 32x32.png, 32x32@2x.png (used for retina only), 16x16-dark.png, 32x32-dark.png, 32x32-dark@2x.png
        The dark images are used when the command is highlighted and can contain lighter lines to contrast better with the blue highlighting. If
        you don't provide dark images Fusion 360 will use the regular images when highlighting the button.
        This is an optional argument and if not provided a default icon will be used. 
        Returns the created CommandDefinition object or null if the creation failed.
        """
        return _core.CommandDefinitions_addButtonDefinition(self, *args)

    def addCheckBoxDefinition(self, id: "std::string const &", name: "std::string const &", tooltip: "std::string const &", isChecked: "bool") -> "adsk::core::Ptr< adsk::core::CommandDefinition >":
        r"""
        Creates a new command definition that can be used to create a single check box control and handle the response when the check box is clicked. 
        id : The unique identifier for this command definition. It must be unique with respect to all other command definitions and is
        limited to the following set of characters, [A-Z][a-z][0-9] and _. 
        name : The name displayed in the UI for the associated check box control. 
        tooltip : The full description of the command as seen in the extended tooltip in the user interface.
        Using the returned CommandDefinition you can also optionally set the toolClipFilename property
        to show an image in the extended tooltip. 
        isChecked : Indicates if the initial state of the check box. 
        Returns the created CommandDefinition object or null if the creation failed.
        """
        return _core.CommandDefinitions_addCheckBoxDefinition(self, id, name, tooltip, isChecked)

    def addListDefinition(self, *args) -> "adsk::core::Ptr< adsk::core::CommandDefinition >":
        r"""
        Creates a new command definition that can be used to create a list of check boxes, radio buttons, or text with an icon within a pop-up. 
        When the list is of check boxes any combinations of items in the list can be checked. The drop-down also remains displayed allowing the user to
        check and uncheck multiple items however a CommandCreated event is fired for every change.
        When the list is of radio buttons or a list of text items, only one item in the list can be selected at a time. 
        When an item is selected the drop-down is immediately dismissed.
        The items in the list and their initial state are defined using functionality on the associated ListControlDefinition, which is
        accessible through the returned CommandDefinition. 
        id : The unique identifier for this command definition. It must be unique with respect to all other command definitions and is
        limited to the following set of characters, [A-Z][a-z][0-9] and _. 
        name : The name displayed in the UI for the associated selected check box list control. 
        listControlDisplayType : Specifies the type of controls to be displayed within the list. 
        resourceFolder : The folder containing any resources used for items in this list. 
        Returns the created CommandDefinition object or null if the creation failed.
        """
        return _core.CommandDefinitions_addListDefinition(self, *args)

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::CommandDefinition >":
        r"""
        Returns the CommandDefinition at the specified index. 
        index : The index of the command definition within the collection to return. The first item in the
        collection has in index of 0. 
        Returns the CommandDefinition at the specified index or null if an invalid index is specified.
        """
        return _core.CommandDefinitions_item(self, index)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::CommandDefinition >":
        r"""
        Returns the CommandDefinition that has the specified ID. 
        id : The ID of the command definition to return. 
        Returns the CommandDefinition with the specified ID or null if there isn't a command definition with that ID.
        """
        return _core.CommandDefinitions_itemById(self, id)

    def _get_count(self) -> "size_t":
        r"""Gets the number of command definitions."""
        return _core.CommandDefinitions__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _core.CommandDefinitions__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.CommandDefinitions__get_isValid(self)

# Register CommandDefinitions in _core:
_core.CommandDefinitions_swigregister(CommandDefinitions)

def CommandDefinitions_classType() -> "char const *":
    return _core.CommandDefinitions_classType()


CommandDefinitions.count = property(CommandDefinitions._get_count, doc="Gets the number of command definitions.")


CommandDefinitions.cast = lambda arg: arg if isinstance(arg, CommandDefinitions) else None

class CommandEventHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notify(self, eventArgs: "CommandEventArgs") -> "void":
        return _core.CommandEventHandler_notify(self, eventArgs)

    def __init__(self):
        if self.__class__ == CommandEventHandler:
            _self = None
        else:
            _self = self
        _core.CommandEventHandler_swiginit(self, _core.new_CommandEventHandler(_self, ))
    __swig_destroy__ = _core.delete_CommandEventHandler
    def __disown__(self):
        self.this.disown()
        _core.disown_CommandEventHandler(self)
        return weakref.proxy(self)

# Register CommandEventHandler in _core:
_core.CommandEventHandler_swigregister(CommandEventHandler)


CommandEventHandler.cast = lambda arg: arg if isinstance(arg, CommandEventHandler) else None

class CommandInput(Base):
    r"""The base class for all command inputs. A CommandInput is used to gather an input value from the user when a command is executed."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::CommandInput *":
        return _core.CommandInput___deref__(self)

    def __eq__(self, rhs: "CommandInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.CommandInput___eq__(self, rhs)


    def __ne__(self, rhs: "CommandInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.CommandInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.CommandInput_classType()
    __swig_destroy__ = _core.delete_CommandInput

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.CommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string":
        r"""Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.CommandInput__get_id(self)

    def _get_name(self) -> "std::string":
        r"""Gets the user visible name of this input."""
        return _core.CommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.CommandInput__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.CommandInput__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.CommandInput__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.CommandInput__set_isVisible(self, value)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the parent Command."""
        return _core.CommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.CommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.CommandInput__set_isFullWidth(self, value)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.CommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.CommandInput__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.CommandInput__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.CommandInput__set_tooltip(self, value)

    def _get_tooltipDescription(self) -> "std::string":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.CommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.CommandInput__set_tooltipDescription(self, value)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.CommandInput__get_parentCommandInput(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this Command input. 
        Returns true if the delete was successful.
        """
        return _core.CommandInput_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.CommandInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.CommandInput__get_isValid(self)

# Register CommandInput in _core:
_core.CommandInput_swigregister(CommandInput)

def CommandInput_classType() -> "char const *":
    return _core.CommandInput_classType()


CommandInput.commandInputs = property(CommandInput._get_commandInputs, doc="Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput.")


CommandInput.id = property(CommandInput._get_id, doc="Gets the unique identifier for this input in the command's CommandInputs.")


CommandInput.name = property(CommandInput._get_name, doc="Gets the user visible name of this input.")


CommandInput.isEnabled = property(CommandInput._get_isEnabled, CommandInput._set_isEnabled, doc="Gets or sets if this input is currently enabled or disabled for user interaction.")


CommandInput.isVisible = property(CommandInput._get_isVisible, CommandInput._set_isVisible, doc="Gets or sets if this input will be visible to the user.")


CommandInput.parentCommand = property(CommandInput._get_parentCommand, doc="Gets the parent Command.")


CommandInput.isFullWidth = property(CommandInput._get_isFullWidth, CommandInput._set_isFullWidth, doc="Gets or sets if this input fills the entire width of the dialog. If\ntrue, the name is ignored and the input control will fill the entire width of the command dialog.\nThe default value for this property in a new command input if false, or not to fill the width.\nThis property does not apply to GroupCommandInputs or TabCommandInputs.")


CommandInput.toolClipFilename = property(CommandInput._get_toolClipFilename, CommandInput._set_toolClipFilename, doc="Gets or sets the full filename of the image file (png) used for the tool clip.\nThe tooltip is always shown but as the user hovers over the control it will progressively display\nthe tool clip and description text.")


CommandInput.tooltip = property(CommandInput._get_tooltip, CommandInput._set_tooltip, doc="Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description\nand/or tool clip are also specified then the tooltip will progressively display more information as the\nuser hovers the mouse over the control.")


CommandInput.tooltipDescription = property(CommandInput._get_tooltipDescription, CommandInput._set_tooltipDescription, doc="Gets or sets additional text to display progressively along with the tooltip. The text for the description\ncan contain some basic html formatting tags to format the tags. For example the br tag can be used to\ncreate multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will\nprogressively display the tool clip and description text.")


CommandInput.parentCommandInput = property(CommandInput._get_parentCommandInput, doc="Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput.\nReturns null if their is no parent.")


CommandInput.cast = lambda arg: arg if isinstance(arg, CommandInput) else None

class CommandInputs(Base):
    r"""
    Provides access to the set of inputs for a command. Command inputs are used to gather inputs from the user when a command is executed.
    The set of inputs used by a command are created and added to the command with the methods in this class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::CommandInputs *":
        return _core.CommandInputs___deref__(self)

    def __eq__(self, rhs: "CommandInputs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.CommandInputs___eq__(self, rhs)


    def __ne__(self, rhs: "CommandInputs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.CommandInputs___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.CommandInputs___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::CommandInput >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.CommandInputs___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.CommandInputs_classType()
    __swig_destroy__ = _core.delete_CommandInputs

    def _get_command(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the parent Command object."""
        return _core.CommandInputs__get_command(self)

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Returns the specified command input using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.CommandInputs_item(self, index)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Returns the command input that has the specified ID. 
        id : The unique ID of the command input you want to get. 
        Returns the specified command input or null if the input ID doesn't match an existing command input.
        """
        return _core.CommandInputs_itemById(self, id)

    def _get_count(self) -> "size_t":
        r"""Gets the number of inputs."""
        return _core.CommandInputs__get_count(self)

    def addValueInput(self, id: "std::string const &", name: "std::string const &", unitType: "std::string const &", initialValue: "ValueInput") -> "adsk::core::Ptr< adsk::core::ValueCommandInput >":
        r"""
        Adds a new value input to the command. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        unitType : The unit type of the value. This will be used to validate the input and the returned Value object
        will be of this type. 
        initialValue : The initial value of this input as shown in the dialog. This can be a string or a real. If it's a string
        it must be able to be evaluated using the specified unit type. If it's a real it is assumed to be in database
        units for the specified unit type and is displayed as a string 
        Returns the created ValueCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addValueInput(self, id, name, unitType, initialValue)

    def addBoolValueInput(self, *args) -> "adsk::core::Ptr< adsk::core::BoolValueCommandInput >":
        r"""
        Adds a new boolean input to the command. The input can be shown as a check box or a button. If it's a button
        you need to specify the resource folder to define the icon to use. Buttons don't have an up or down state but
        can just be clicked. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        isCheckBox : Specifies if this input should be displayed as a check box or a button. If true a check box is
        displayed, if false a button is displayed that can be clicked to toggle it's state. 
        resourceFolder : Specifies the folder that contains the image for the input.
        It's optional if isCheckBox is true. If it's set for check box, the check box will be present as a button and has an up or down state. 
        initialValue : Specifies the initial value of the check box or button where for a check box the value of True results
        in it being checked and for a button a value of true results in the button being pressed. 
        Returns the created BoolValueCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addBoolValueInput(self, *args)

    def addStringValueInput(self, *args) -> "adsk::core::Ptr< adsk::core::StringValueCommandInput >":
        r"""
        Adds a new string input to the command. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        initialValue : Specifies the initial value as shown in the dialog. 
        Returns the created StringValueCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addStringValueInput(self, *args)

    def addSelectionInput(self, id: "std::string const &", name: "std::string const &", commandPrompt: "std::string const &") -> "adsk::core::Ptr< adsk::core::SelectionCommandInput >":
        r"""
        Adds a new selection input to the command. This allows you to get entity selections from the user. The default
        behavior is that only one entity can be selected and it can be of any type. To change the selection behavior to
        select specific types and control the number of items selected use the methods and properties on the returned 
        SelectionCommandInput object. You can also use the selectionEvent event that's associated with the command 
        to have additional control over the selection process. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        commandPrompt : The text in the tooltip shown next to the cursor. 
        Returns the created SelectionCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addSelectionInput(self, id, name, commandPrompt)

    def addDropDownCommandInput(self, id: "std::string const &", name: "std::string const &", dropDownStyle: "DropDownStyles") -> "adsk::core::Ptr< adsk::core::DropDownCommandInput >":
        r"""
        Adds a new empty drop-down input to the command. drop-downs of various types are supported.
        To add items to the drop down use the returned DropDownCommandInput object. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed label of this command as seen in the dialog. 
        dropDownStyle : Specifies the style of the drop-down. 
        Returns the created DropDownCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addDropDownCommandInput(self, id, name, dropDownStyle)

    def addButtonRowCommandInput(self, id: "std::string const &", name: "std::string const &", isMultiSelectEnabled: "bool") -> "adsk::core::Ptr< adsk::core::ButtonRowCommandInput >":
        r"""
        Adds a new row of buttons as a command input. Depending on the isMultiSelectEnabled argument it can act like an option list 
        where only a single button on the row can be selected at a time or multiple buttons can be selected.
        The buttons are defined by using the returned ButtonRowCommandInput object. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed label of this command as seen in the dialog. 
        isMultiSelectEnabled : Sets if this button row can have multiple items selected at once or not.
        If True, multiple buttons can be selected at once. If False only one button
        can be selected and selecting another button unselects the one currently selected. 
        Returns the created ButtonRowCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addButtonRowCommandInput(self, id, name, isMultiSelectEnabled)

    def addFloatSliderCommandInput(self, id: "std::string const &", name: "std::string const &", unitType: "std::string const &", min: "double", max: "double", hasTwoSliders: "bool"=False) -> "adsk::core::Ptr< adsk::core::FloatSliderCommandInput >":
        r"""
        Adds a new slider input to the command. The value type is double. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        unitType : The unit type of the value. This will be used to validate the input and the returned value will be in the base units for this
        unit type. For example if you specify the unitType to be 'in' the returned value will be in centimeters because inches are
        a length unit and the base unit for length is centimeters. 
        min : Provides the minimum value in database units 
        max : Provides the maximum value in database units 
        hasTwoSliders : Optional input. Indicates if the slider input has two sliders. 
        Returns the created FloatSliderCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addFloatSliderCommandInput(self, id, name, unitType, min, max, hasTwoSliders)

    def addFloatSliderListCommandInput(self, id: "std::string const &", name: "std::string const &", unitType: "std::string const &", valueList: "DoubleVector", hasTwoSliders: "bool"=False) -> "adsk::core::Ptr< adsk::core::FloatSliderCommandInput >":
        r"""
        Adds a new slider input to the command. The value type is float. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        unitType : The unit type of the value. This will be used to validate the input and the returned Value object
        will be of this type. 
        valueList : Provides the value list (in database units) of the slider command input. This defines all of the values that the slider
        can return. As the user moves the slider it will jump between these values. The low and high values 
        of the list are used as the minimum and maximum values of the slider. 
        hasTwoSliders : Optional input. Indicates if the slider input has two sliders. 
        Returns the created FloatSliderCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addFloatSliderListCommandInput(self, id, name, unitType, valueList, hasTwoSliders)

    def addIntegerSliderCommandInput(self, id: "std::string const &", name: "std::string const &", min: "int", max: "int", hasTwoSliders: "bool"=False) -> "adsk::core::Ptr< adsk::core::IntegerSliderCommandInput >":
        r"""
        Adds a new slider input to the command. The value type is integer. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        min : Provides the minimum value. 
        max : Provides the maximum value. 
        hasTwoSliders : Optional input. Indicates if the slider input has two sliders. 
        Returns the created IntegerSliderCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addIntegerSliderCommandInput(self, id, name, min, max, hasTwoSliders)

    def addIntegerSliderListCommandInput(self, id: "std::string const &", name: "std::string const &", valueList: "IntVector", hasTwoSliders: "bool"=False) -> "adsk::core::Ptr< adsk::core::IntegerSliderCommandInput >":
        r"""
        Adds a new slider input to the command. The value type is integer. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        valueList : Provides the value list of the slider command input. This defines all of the values that the slider
        can return. As the user moves the slider it will jump between these values. The low and high values 
        of the list are used as the minimum and maximum values of the slider. 
        hasTwoSliders : Optional input. Indicates if the slider has two sliders. 
        Returns the created IntegerSliderCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addIntegerSliderListCommandInput(self, id, name, valueList, hasTwoSliders)

    def addTextBoxCommandInput(self, id: "std::string const &", name: "std::string const &", formattedText: "std::string const &", numRows: "int", isReadOnly: "bool") -> "adsk::core::Ptr< adsk::core::TextBoxCommandInput >":
        r"""
        Adds a text box input to the command. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. If an empty string is provided then
        no name will be displayed and the text box will span the width of the command dialog. 
        formattedText : Gets and sets the formatted text displayed in the dialog. Formatted text includes
        any basic html formatting that has been defined. For example, you can use basic html 
        formatting such as <code>&lt;b&gt;Bold&lt;/b&gt;</code>, <code>&lt;i&gt;Italic&lt;/i&gt;</code>, 
        and <code>&lt;br /&gt;</code> for a line break. It also supports hyperlinks, which when clicked 
        by the user, Fusion 360 will open the specified url in the default browser. Hyperlinks are defined 
        using the <code>&lt;a&gt;</code> tag such as 
        '<code>You are using Autodesk's &lt;a href='http://fusion360.autodesk.com'&gt;Fusion 360&lt;/a&gt;.</code>'. 
        numRows : Specifies the height of the text box as defined by the number of rows of text that can be displayed. 
        If the text is larger than will fit in the box a scroll bar will automatically be displayed. 
        isReadOnly : Specifies if the text box is read-only or not. 
        Returns the created TextBoxCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addTextBoxCommandInput(self, id, name, formattedText, numRows, isReadOnly)

    def addFloatSpinnerCommandInput(self, id: "std::string const &", name: "std::string const &", unitType: "std::string const &", min: "double", max: "double", spinStep: "double", initialValue: "double") -> "adsk::core::Ptr< adsk::core::FloatSpinnerCommandInput >":
        r"""
        Adds a new spinner input to the command. The value type is float. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        unitType : The unit type of the value. This will be used to validate the input and the returned Value object
        will be of this type. 
        min : Provides the minimum value in database units. 
        max : Provides the maximum value in database units. 
        spinStep : Sets the spin step value in the unit type set by the unitType argument. 
        The value should be more than zero. This is the amount the slider will advance
        when the user clicks the spin button beside the value. 
        initialValue : The initial value of this input as shown in the dialog. This value is assumed to be in database
        units for the specified unit type 
        Returns the created FloatSpinnerCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addFloatSpinnerCommandInput(self, id, name, unitType, min, max, spinStep, initialValue)

    def addIntegerSpinnerCommandInput(self, id: "std::string const &", name: "std::string const &", min: "int", max: "int", spinStep: "size_t", initialValue: "int") -> "adsk::core::Ptr< adsk::core::IntegerSpinnerCommandInput >":
        r"""
        Adds a new spinner input to the command. The value type is integer. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        min : Provides the minimum value. 
        max : Provides the maximum value. 
        spinStep : Provides the spin step. The value should be more than zero. This is the amount the slider will advance
        when the user clicks the spin button beside the value. 
        initialValue : The initial value of this input as shown in the dialog. 
        Returns the created IntegerSpinnerCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addIntegerSpinnerCommandInput(self, id, name, min, max, spinStep, initialValue)

    def addRadioButtonGroupCommandInput(self, *args) -> "adsk::core::Ptr< adsk::core::RadioButtonGroupCommandInput >":
        r"""
        Adds a new Radio Button Group input to the command. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed label of this radio button group as seen in the dialog. 
        Returns the created RadioButtonGroupCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addRadioButtonGroupCommandInput(self, *args)

    def addGroupCommandInput(self, id: "std::string const &", name: "std::string const &") -> "adsk::core::Ptr< adsk::core::GroupCommandInput >":
        r"""
        Adds a new Group input to the command. Group Command inputs organize a set of command inputs into a collapsible 
        list within a command dialog. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed label of this group as seen in the dialog. 
        Returns the created GroupCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addGroupCommandInput(self, id, name)

    def addTabCommandInput(self, *args) -> "adsk::core::Ptr< adsk::core::TabCommandInput >":
        r"""
        Adds a new Tab input to the command. Tab command inputs contain a set of command inputs and/or group command inputs 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed label of this tab as seen in the dialog. 
        resourceFolder : An optional parameter that specifies the folder that contains the image for the tab.
        If no name is specified (no text on tab), a resourceFolder containing the image to appear 
        on the tab needs to be provided. 
        Returns the created TabCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addTabCommandInput(self, *args)

    def addImageCommandInput(self, id: "std::string const &", name: "std::string const &", imageFile: "std::string const &") -> "adsk::core::Ptr< adsk::core::ImageCommandInput >":
        r"""
        Adds a new Image input to the command. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed label of this Image as seen in the dialog.
        If a name is not specified (an empty string), the image will be left justified within the dialog.
        If a name is specified it will appear as a left justified label aligned with the other command input labels, 
        and the left side of the image will be aligned with the other command input controls. 
        imageFile : The full path and file name of the image file.
        Supported image format is .png
        Images are displayed in the command dialog using their actual size. 
        Returns the created ImageCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addImageCommandInput(self, id, name, imageFile)

    def addDistanceValueCommandInput(self, id: "std::string const &", name: "std::string const &", initialValue: "ValueInput") -> "adsk::core::Ptr< adsk::core::DistanceValueCommandInput >":
        r"""
        Adds a new distance value input to the command. This displays a field in the command dialog where a
        distance value can be entered. It displays the distance in the dialog using current document default unit.
        There is also a graphical manipulator associated with the input.
        You use the setManipulator method of the returned DistanceValueCommandInput
        object to define the position and orientation of the manipulator. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed label of this input as seen in the dialog.
        If a name is not specified (an empty string), the input will be centered horizontally within it's row in the dialog.
        If a name is specified it will appear as a left justified label aligned with the other command input labels, 
        and the left side of the image will be aligned with the other command input controls. 
        initialValue : The initial value of the input. If the value input is a number then it is interpreted as centimeters. If it is 
        a string it uses the units specified in the string or if no units are specified it uses the active units of the design. 
        Returns the created DistanceValueCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addDistanceValueCommandInput(self, id, name, initialValue)

    def addDirectionCommandInput(self, *args) -> "adsk::core::Ptr< adsk::core::DirectionCommandInput >":
        r"""
        Adds a new direction command input to the command. The input can be shown as a check box or a button. If it's a button
        you need to specify the resource folder to define the icon to use for the Button. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        resourceFolder : Specifies the folder that contains the image for the input.
        This is an optional argument. The input is shown as a check box if the resource folder is not set. 
        Returns the created DirectionCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addDirectionCommandInput(self, *args)

    def addTableCommandInput(self, id: "std::string const &", name: "std::string const &", numberOfColumns: "int", columnRatio: "std::string const &") -> "adsk::core::Ptr< adsk::core::TableCommandInput >":
        r"""
        Adds a new table command input to the command. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        numberOfColumns : This argument is no longer used. The number of columns displayed is inferred by the
        number of columns that contain command inputs. As you add command inputs to the table
        the display of the table will adjust to show all of the columns that contain a command input. 
        columnRatio : Sets the width ratio of the columns. This is defined using a string
        such as '1:1:1' where this defines that the first three columns are all the same width.
        A value of '2:1' defines that the first column is twice the width of the second.
        If the table has more columns than are defined by this property, they will automatically
        default to a value of 1. If this property defines the width of more columns than are
        displayed, the extra definitions are ignored.
        You can also specify 0 as a column width and this will have the effect of hiding
        that column. Setting a column width to 0 does not delete the column or the command inputs
        but only hides them so they can be turned back on at a later time by resetting the
        column ratio. 
        Returns the created TableCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addTableCommandInput(self, id, name, numberOfColumns, columnRatio)

    def addAngleValueCommandInput(self, id: "std::string const &", name: "std::string const &", initialValue: "ValueInput") -> "adsk::core::Ptr< adsk::core::AngleValueCommandInput >":
        r"""
        Adds a new angle value input to the command. This displays a field in the command dialog where an
        angle value can be entered. It displays the angle in the dialog using degrees. There is also a graphical 
        manipulator associated with the input to allow the user to graphically set the value. You use the 
        setManipulator method of the returned AngleValueCommandInput object to define the position and 
        orientation of the manipulator. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed label of this input as seen in the dialog.
        If a name is not specified (an empty string), the input will be centered horizontally within it's row in the dialog.
        If a name is specified it will appear as a left justified label aligned with the other command input labels, 
        and the left side of the image will be aligned with the other command input controls. 
        initialValue : The initial value of the input. If the value input is a number then it is interpreted as radians. If it is 
        a string it uses the units specified in the string or if no units are specified it uses degrees. 
        Returns the created AngleValueCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addAngleValueCommandInput(self, id, name, initialValue)

    def _get_objectType(self) -> "char const *":
        return _core.CommandInputs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.CommandInputs__get_isValid(self)

# Register CommandInputs in _core:
_core.CommandInputs_swigregister(CommandInputs)

def CommandInputs_classType() -> "char const *":
    return _core.CommandInputs_classType()


CommandInputs.command = property(CommandInputs._get_command, doc="Gets the parent Command object.")


CommandInputs.count = property(CommandInputs._get_count, doc="Gets the number of inputs.")


CommandInputs.cast = lambda arg: arg if isinstance(arg, CommandInputs) else None

class ControlDefinition(Base):
    r"""
    The ControlDefinition is the base class for the various types of control definitions. 
    You can use properties on the control definition to define the look and behavior of 
    the control.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ControlDefinition *":
        return _core.ControlDefinition___deref__(self)

    def __eq__(self, rhs: "ControlDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ControlDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ControlDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ControlDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ControlDefinition_classType()
    __swig_destroy__ = _core.delete_ControlDefinition

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this definition is enabled or not. This has the effect of enabling and disabling any associated controls."""
        return _core.ControlDefinition__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this definition is enabled or not. This has the effect of enabling and disabling any associated controls."""
        return _core.ControlDefinition__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this definition is visible or not. This has the effect of making any associated controls visible or invisible in the user interface."""
        return _core.ControlDefinition__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this definition is visible or not. This has the effect of making any associated controls visible or invisible in the user interface."""
        return _core.ControlDefinition__set_isVisible(self, value)

    def _get_name(self) -> "std::string":
        r"""Gets or sets the name for this control. This is the visible name displayed in the user interface."""
        return _core.ControlDefinition__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Gets or sets the name for this control. This is the visible name displayed in the user interface."""
        return _core.ControlDefinition__set_name(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.ControlDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ControlDefinition__get_isValid(self)

# Register ControlDefinition in _core:
_core.ControlDefinition_swigregister(ControlDefinition)

def ControlDefinition_classType() -> "char const *":
    return _core.ControlDefinition_classType()


ControlDefinition.isEnabled = property(ControlDefinition._get_isEnabled, ControlDefinition._set_isEnabled, doc="Gets or sets if this definition is enabled or not. This has the effect of enabling and disabling any associated controls.")


ControlDefinition.isVisible = property(ControlDefinition._get_isVisible, ControlDefinition._set_isVisible, doc="Gets or sets if this definition is visible or not. This has the effect of making any associated controls visible or invisible in the user interface.")


ControlDefinition.name = property(ControlDefinition._get_name, ControlDefinition._set_name, doc="Gets or sets the name for this control. This is the visible name displayed in the user interface.")


ControlDefinition.cast = lambda arg: arg if isinstance(arg, ControlDefinition) else None

class Curve2D(Base):
    r"""The base class for all 2D transient geometry classes."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Curve2D *":
        return _core.Curve2D___deref__(self)

    def __eq__(self, rhs: "Curve2D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Curve2D___eq__(self, rhs)


    def __ne__(self, rhs: "Curve2D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Curve2D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Curve2D_classType()
    __swig_destroy__ = _core.delete_Curve2D

    def _get_curveType(self) -> "adsk::core::Curve2DTypes":
        r"""Returns the type of geometry this curve represents."""
        return _core.Curve2D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator2D >":
        r"""Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.Curve2D__get_evaluator(self)

    def transformBy(self, matrix: "Matrix2D") -> "bool":
        r"""
        Transforms this curve in 2D space. 
        matrix : A 2D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.Curve2D_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.Curve2D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Curve2D__get_isValid(self)

# Register Curve2D in _core:
_core.Curve2D_swigregister(Curve2D)

def Curve2D_classType() -> "char const *":
    return _core.Curve2D_classType()


Curve2D.curveType = property(Curve2D._get_curveType, doc="Returns the type of geometry this curve represents.")


Curve2D.evaluator = property(Curve2D._get_evaluator, doc="Returns an evaluator object that lets you perform additional evaluations on the curve.")


Curve2D.cast = lambda arg: arg if isinstance(arg, Curve2D) else None

class Curve3D(Base):
    r"""The base class for all 3D transient geometry classes."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Curve3D *":
        return _core.Curve3D___deref__(self)

    def __eq__(self, rhs: "Curve3D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Curve3D___eq__(self, rhs)


    def __ne__(self, rhs: "Curve3D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Curve3D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Curve3D_classType()
    __swig_destroy__ = _core.delete_Curve3D

    def _get_curveType(self) -> "adsk::core::Curve3DTypes":
        r"""Returns the type of geometry this curve represents."""
        return _core.Curve3D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator3D >":
        r"""Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.Curve3D__get_evaluator(self)

    def transformBy(self, matrix: "Matrix3D") -> "bool":
        r"""
        Transforms this curve in 3D space. 
        matrix : A 3D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.Curve3D_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.Curve3D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Curve3D__get_isValid(self)

# Register Curve3D in _core:
_core.Curve3D_swigregister(Curve3D)

def Curve3D_classType() -> "char const *":
    return _core.Curve3D_classType()


Curve3D.curveType = property(Curve3D._get_curveType, doc="Returns the type of geometry this curve represents.")


Curve3D.evaluator = property(Curve3D._get_evaluator, doc="Returns an evaluator object that lets you perform additional evaluations on the curve.")


Curve3D.cast = lambda arg: arg if isinstance(arg, Curve3D) else None

class CurveEvaluator2D(Base):
    r"""
    2D curve evaluator that is obtained from a transient curve and allows you to perform
    various evaluations on the curve.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::CurveEvaluator2D *":
        return _core.CurveEvaluator2D___deref__(self)

    def __eq__(self, rhs: "CurveEvaluator2D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.CurveEvaluator2D___eq__(self, rhs)


    def __ne__(self, rhs: "CurveEvaluator2D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.CurveEvaluator2D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.CurveEvaluator2D_classType()
    __swig_destroy__ = _core.delete_CurveEvaluator2D

    def getCurvatures(self, parameters: "DoubleVector") -> "bool":
        r"""
        Get the curvature values at a number of parameter positions on the curve. 
        parameters : The array of parameter positions to return curvature information at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        directions : The output array of the direction of the curvature at each position on the curve.
        The length of this array will be the same as the length of the parameters array provided. 
        curvatures : The output array of the magnitude of the curvature at the position on the curve.
        The length of this array will be the same as the length of the parameters array provided. 
        Returns true if the curvatures were successfully returned.
        """
        return _core.CurveEvaluator2D_getCurvatures(self, parameters)

    def getCurvature(self, parameter: "double") -> "bool":
        r"""
        Get the curvature value at a parameter position on the curve. 
        parameter : The parameter position to return the curvature information at.
        This value must be within the range of the parameter extents as provided by getParameterExtents. 
        direction : The output direction of the curvature at the position on the curve. 
        curvature : The output magnitude of the curvature at the position on the curve. 
        Returns true if the curvature was successfully returned.
        """
        return _core.CurveEvaluator2D_getCurvature(self, parameter)

    def getTangents(self, parameters: "DoubleVector") -> "bool":
        r"""
        Get the tangent to the curve at a number of parameter positions on the curve. 
        parameters : The array of parameter positions to return the tangent at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        tangents : The output array of tangent vectors for each position on the curve.
        The length of this array will be the same as the length of the parameters array provided. 
        Returns true if the tangents were successfully returned.
        """
        return _core.CurveEvaluator2D_getTangents(self, parameters)

    def getTangent(self, parameter: "double") -> "bool":
        r"""
        Get the tangent to the curve at a parameter position on the curve. 
        parameter : The parameter position to return the tangent at.
        This value must be within the range of the parameter extents as provided by getParameterExtents. 
        tangent : The output tangent vector at the curve position. 
        Returns true if the tangent was successfully returned.
        """
        return _core.CurveEvaluator2D_getTangent(self, parameter)

    def getEndPoints(self) -> "bool":
        r"""
        Get the end points of the curve. 
        startPoint : The output start point of the curve. If the curve is unbounded at the start, this value will be null. 
        endPoint : The output end point of the curve. If the curve is unbounded at the end, this value will be null. 
        Returns true if the end points were successfully returned.
        """
        return _core.CurveEvaluator2D_getEndPoints(self)

    def getLengthAtParameter(self, fromParameter: "double", toParameter: "double") -> "bool":
        r"""
        Get the length of the curve between two parameter positions on the curve. 
        fromParameter : The parameter position to measure the curve length from.
        This value must be within the range of the parameter extents as provided by getParameterExtents. 
        toParameter : The parameter position to measure the curve length to.
        This value must be within the range of the parameter extents as provided by getParameterExtents. 
        length : The output curve length between the from and to parameter positions on the curve. 
        Returns true if the length was successfully returned.
        """
        return _core.CurveEvaluator2D_getLengthAtParameter(self, fromParameter, toParameter)

    def getParameterAtLength(self, fromParameter: "double", length: "double") -> "bool":
        r"""
        Get the parameter position on the curve that is the specified curve length from the specified starting parameter position. 
        fromParameter : The parameter position to start measuring the curve length from.
        This value must be within the range of the parameter extents as provided by getParameterExtents. 
        length : The curve length to offset the from parameter by.
        A negative length value will offset in the negative parameter direction. 
        parameter : The output parameter value that is the specified curve length from the starting parameter position. 
        Returns true if the parameter was successfully returned.
        """
        return _core.CurveEvaluator2D_getParameterAtLength(self, fromParameter, length)

    def getParametersAtPoints(self, points: "Point2DVector") -> "bool":
        r"""
        Get the parameter positions that correspond to a set of points on the curve.
        For reliable results, the points should lie on the curve within model tolerance.
        If the points do not lie on the curve, the parameter of the nearest point on the curve will generally be returned. 
        points : An array of points to get the curve parameter values at. 
        parameters : The output array of parameter positions corresponding to the set of points.
        The length of this array will be equal to the length of the points array specified. 
        Returns true if the parameters were successfully returned.
        """
        return _core.CurveEvaluator2D_getParametersAtPoints(self, points)

    def getParameterAtPoint(self, point: "Point2D") -> "bool":
        r"""
        Get the parameter position that correspond to a point on the curve.
        For reliable results, the point should lie on the curve within model tolerance.
        If the point does not lie on the curve, the parameter of the nearest point on the curve will generally be returned. 
        point : The point to get the curve parameter value at. 
        parameter : The output parameter position corresponding to the point. 
        Returns true of the parameter was successfully returned.
        """
        return _core.CurveEvaluator2D_getParameterAtPoint(self, point)

    def getParameterExtents(self) -> "bool":
        r"""
        Get the parametric range of the curve. 
        startParameter : The output lower bound of the parameter range. 
        endParameter : The output upper bound of the parameter range. 
        Returns true if the curve is bounded and the parameter extents were successfully returned.
        """
        return _core.CurveEvaluator2D_getParameterExtents(self)

    def getPointsAtParameters(self, parameters: "DoubleVector") -> "bool":
        r"""
        Get the points on the curve that correspond to evaluating a set of parameter positions on the curve. 
        parameters : The array of parameter positions to evaluate the curve position at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        points : The output array of curve positions corresponding to evaluating the curve at that parameter position.
        The length of this array will be equal to the length of the parameters array specified. 
        Returns true if the points were successfully returned.
        """
        return _core.CurveEvaluator2D_getPointsAtParameters(self, parameters)

    def getPointAtParameter(self, parameter: "double") -> "bool":
        r"""
        Get the point on the curve that corresponds to evaluating a parameter position on the curve. 
        parameter : The parameter position to evaluate the curve position at.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        point : The output curve position corresponding to evaluating the curve at that parameter position. 
        Returns true if the point was successfully returned.
        """
        return _core.CurveEvaluator2D_getPointAtParameter(self, parameter)

    def getFirstDerivatives(self, parameters: "DoubleVector") -> "bool":
        r"""
        Get the first derivatives of the curve at the specified parameter positions. 
        parameters : The array of parameter positions to get the curve first derivative at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        firstDerivatives : The output array of first derivative vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        Returns true if the first derivatives were successfully returned.
        """
        return _core.CurveEvaluator2D_getFirstDerivatives(self, parameters)

    def getFirstDerivative(self, parameter: "double") -> "bool":
        r"""
        Get the first derivative of the curve at the specified parameter position. 
        parameter : The parameter position to get the curve first derivative at.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        firstDerivative : The output first derivative vector at the parameter position specified. 
        Returns true if the first derivative was successfully returned.
        """
        return _core.CurveEvaluator2D_getFirstDerivative(self, parameter)

    def getSecondDerivatives(self, parameters: "DoubleVector") -> "bool":
        r"""
        Get the second derivatives of the curve at the specified parameter positions. 
        parameters : The array of parameter positions to get the curve second derivative at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        secondDerivatives : The output array of second derivative vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        Returns true if the second derivatives were successfully returned.
        """
        return _core.CurveEvaluator2D_getSecondDerivatives(self, parameters)

    def getSecondDerivative(self, parameter: "double") -> "bool":
        r"""
        Get the second derivative of the curve at the specified parameter position. 
        parameter : The parameter position to get the curve second derivative at.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        secondDerivative : The output second derivative vector at the parameter position specified. 
        Returns true if the second derivative was successfully returned.
        """
        return _core.CurveEvaluator2D_getSecondDerivative(self, parameter)

    def getThirdDerivatives(self, parameters: "DoubleVector") -> "bool":
        r"""
        Get the third derivatives of the curve at the specified parameter positions. 
        parameters : The array of parameter positions to get the curve third derivative at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        thirdDerivatives : The output array of third derivative vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        Returns true if the third derivatives were successfully returned.
        """
        return _core.CurveEvaluator2D_getThirdDerivatives(self, parameters)

    def getThirdDerivative(self, parameter: "double") -> "bool":
        r"""
        Get the third derivative of the curve at the specified parameter position. 
        parameter : The parameter position to get the curve third derivative at.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        thirdDerivative : The output third derivative vector at the parameter position specified. 
        Returns true if the third derivative was successfully returned.
        """
        return _core.CurveEvaluator2D_getThirdDerivative(self, parameter)

    def getStrokes(self, fromParameter: "double", toParameter: "double", tolerance: "double") -> "bool":
        r"""
        Get a sequence of points between two curve parameter positions.
        The points will be a linear interpolation along the curve between these two
        parameter positions where the maximum deviation between the curve and each line
        segment will not exceed the specified tolerance value. 
        fromParameter : The starting parameter position to interpolate points from.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        toParameter : The ending parameter position to interpolate points to.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        tolerance : The maximum distance tolerance between the curve and the linear interpolation. 
        vertexCoordinates : The output array of linear interpolation points. 
        Returns true if the interpolation points were successfully returned.
        """
        return _core.CurveEvaluator2D_getStrokes(self, fromParameter, toParameter, tolerance)

    def _get_objectType(self) -> "char const *":
        return _core.CurveEvaluator2D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.CurveEvaluator2D__get_isValid(self)

# Register CurveEvaluator2D in _core:
_core.CurveEvaluator2D_swigregister(CurveEvaluator2D)

def CurveEvaluator2D_classType() -> "char const *":
    return _core.CurveEvaluator2D_classType()


CurveEvaluator2D.cast = lambda arg: arg if isinstance(arg, CurveEvaluator2D) else None

class CurveEvaluator3D(Base):
    r"""
    3D curve evaluator that is obtained from a transient curve and allows you to perform
    various evaluations on the curve.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::CurveEvaluator3D *":
        return _core.CurveEvaluator3D___deref__(self)

    def __eq__(self, rhs: "CurveEvaluator3D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.CurveEvaluator3D___eq__(self, rhs)


    def __ne__(self, rhs: "CurveEvaluator3D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.CurveEvaluator3D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.CurveEvaluator3D_classType()
    __swig_destroy__ = _core.delete_CurveEvaluator3D

    def getCurvatures(self, parameters: "DoubleVector") -> "bool":
        r"""
        Get the curvature values at a number of parameter positions on the curve. 
        parameters : The array of parameter positions to return curvature information at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        directions : The output array of the direction of the curvature at each position on the curve.
        The length of this array will be the same as the length of the parameters array provided. 
        curvatures : The output array of the magnitude of the curvature at the position on the curve.
        The length of this array will be the same as the length of the parameters array provided. 
        Returns true if the curvatures were successfully returned.
        """
        return _core.CurveEvaluator3D_getCurvatures(self, parameters)

    def getCurvature(self, parameter: "double") -> "bool":
        r"""
        Get the curvature value at a parameter position on the curve. 
        parameter : The parameter position to return the curvature information at.
        This value must be within the range of the parameter extents as provided by getParameterExtents. 
        direction : The output direction of the curvature at the position on the curve. 
        curvature : The output magnitude of the curvature at the position on the curve. 
        Returns true if the curvature was successfully returned.
        """
        return _core.CurveEvaluator3D_getCurvature(self, parameter)

    def getEndPoints(self) -> "bool":
        r"""
        Get the end points of the curve. 
        startPoint : The output start point of the curve. If the curve is unbounded at the start, this value will be null. 
        endPoint : The output end point of the curve. If the curve is unbounded at the end, this value will be null. 
        Returns true if the end points were successfully returned.
        """
        return _core.CurveEvaluator3D_getEndPoints(self)

    def getLengthAtParameter(self, fromParameter: "double", toParameter: "double") -> "bool":
        r"""
        Get the length of the curve between two parameter positions on the curve. 
        fromParameter : The parameter position to measure the curve length from.
        This value must be within the range of the parameter extents as provided by getParameterExtents. 
        toParameter : The parameter position to measure the curve length to.
        This value must be within the range of the parameter extents as provided by getParameterExtents. 
        length : The output curve length between the from and to parameter positions on the curve. 
        Returns true if the length was successfully returned.
        """
        return _core.CurveEvaluator3D_getLengthAtParameter(self, fromParameter, toParameter)

    def getParameterAtLength(self, fromParameter: "double", length: "double") -> "bool":
        r"""
        Get the parameter position on the curve that is the specified curve length from the specified starting parameter position. 
        fromParameter : The parameter position to start measuring the curve length from.
        This value must be within the range of the parameter extents as provided by getParameterExtents. 
        length : The curve length to offset the from parameter by.
        A negative length value will offset in the negative parameter direction. 
        parameter : The output parameter value that is the specified curve length from the starting parameter position. 
        Returns true if the parameter was successfully returned.
        """
        return _core.CurveEvaluator3D_getParameterAtLength(self, fromParameter, length)

    def getParametersAtPoints(self, points: "Point3DVector") -> "bool":
        r"""
        Get the parameter positions that correspond to a set of points on the curve.
        For reliable results, the points should lie on the curve within model tolerance.
        If the points do not lie on the curve, the parameter of the nearest point on the curve will generally be returned. 
        points : An array of points to get the curve parameter values at. 
        parameters : The output array of parameter positions corresponding to the set of points.
        The length of this array will be equal to the length of the points array specified. 
        Returns true if the parameters were successfully returned.
        """
        return _core.CurveEvaluator3D_getParametersAtPoints(self, points)

    def getParameterAtPoint(self, point: "Point3D") -> "bool":
        r"""
        Get the parameter position that correspond to a point on the curve.
        For reliable results, the point should lie on the curve within model tolerance.
        If the point does not lie on the curve, the parameter of the nearest point on the curve will generally be returned. 
        point : The point to get the curve parameter value at. 
        parameter : The output parameter position corresponding to the point. 
        Returns true of the parameter was successfully returned.
        """
        return _core.CurveEvaluator3D_getParameterAtPoint(self, point)

    def getParameterExtents(self) -> "bool":
        r"""
        Get the parametric range of the curve. 
        startParameter : The output lower bound of the parameter range. 
        endParameter : The output upper bound of the parameter range. 
        Returns true if the curve is bounded and the parameter extents were successfully returned.
        """
        return _core.CurveEvaluator3D_getParameterExtents(self)

    def getPointsAtParameters(self, parameters: "DoubleVector") -> "bool":
        r"""
        Get the points on the curve that correspond to evaluating a set of parameter positions on the curve. 
        parameters : The array of parameter positions to evaluate the curve position at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        points : The output array of curve positions corresponding to evaluating the curve at that parameter position.
        The length of this array will be equal to the length of the parameters array specified. 
        Returns true if the points were successfully returned.
        """
        return _core.CurveEvaluator3D_getPointsAtParameters(self, parameters)

    def getPointAtParameter(self, parameter: "double") -> "bool":
        r"""
        Get the point on the curve that corresponds to evaluating a parameter position on the curve. 
        parameter : The parameter position to evaluate the curve position at.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        point : The output curve position corresponding to evaluating the curve at that parameter position. 
        Returns true if the point was successfully returned.
        """
        return _core.CurveEvaluator3D_getPointAtParameter(self, parameter)

    def getFirstDerivatives(self, parameters: "DoubleVector") -> "bool":
        r"""
        Get the first derivatives of the curve at the specified parameter positions. 
        parameters : The array of parameter positions to get the curve first derivative at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        firstDerivatives : The output array of first derivative vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        Returns true if the first derivatives were successfully returned.
        """
        return _core.CurveEvaluator3D_getFirstDerivatives(self, parameters)

    def getFirstDerivative(self, parameter: "double") -> "bool":
        r"""
        Get the first derivative of the curve at the specified parameter position. 
        parameter : The parameter position to get the curve first derivative at.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        firstDerivative : The output first derivative vector at the parameter position specified. 
        Returns true if the first derivative was successfully returned.
        """
        return _core.CurveEvaluator3D_getFirstDerivative(self, parameter)

    def getSecondDerivatives(self, parameters: "DoubleVector") -> "bool":
        r"""
        Get the second derivatives of the curve at the specified parameter positions. 
        parameters : The array of parameter positions to get the curve second derivative at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        secondDerivatives : The output array of second derivative vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        Returns true if the second derivatives were successfully returned.
        """
        return _core.CurveEvaluator3D_getSecondDerivatives(self, parameters)

    def getSecondDerivative(self, parameter: "double") -> "bool":
        r"""
        Get the second derivative of the curve at the specified parameter position. 
        parameter : The parameter position to get the curve second derivative at.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        secondDerivative : The output second derivative vector at the parameter position specified. 
        Returns true if the second derivative was successfully returned.
        """
        return _core.CurveEvaluator3D_getSecondDerivative(self, parameter)

    def getThirdDerivatives(self, parameters: "DoubleVector") -> "bool":
        r"""
        Get the third derivatives of the curve at the specified parameter positions. 
        parameters : The array of parameter positions to get the curve third derivative at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        thirdDerivatives : The output array of third derivative vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        Returns true if the third derivatives were successfully returned.
        """
        return _core.CurveEvaluator3D_getThirdDerivatives(self, parameters)

    def getThirdDerivative(self, parameter: "double") -> "bool":
        r"""
        Get the third derivative of the curve at the specified parameter position. 
        parameter : The parameter position to get the curve third derivative at.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        thirdDerivative : The output third derivative vector at the parameter position specified. 
        Returns true if the third derivative was successfully returned.
        """
        return _core.CurveEvaluator3D_getThirdDerivative(self, parameter)

    def getStrokes(self, fromParameter: "double", toParameter: "double", tolerance: "double") -> "bool":
        r"""
        Get a sequence of points between two curve parameter positions.
        The points will be a linear interpolation along the curve between these two
        parameter positions where the maximum deviation between the curve and each line
        segment will not exceed the specified tolerance value. 
        fromParameter : The starting parameter position to interpolate points from.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        toParameter : The ending parameter position to interpolate points to.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        tolerance : The maximum distance tolerance between the curve and the linear interpolation. 
        vertexCoordinates : The output array of linear interpolation points. 
        Returns true if the interpolation points were successfully returned.
        """
        return _core.CurveEvaluator3D_getStrokes(self, fromParameter, toParameter, tolerance)

    def getTangents(self, parameters: "DoubleVector") -> "bool":
        r"""
        Get the tangent to the curve at a number of parameter positions on the curve. 
        parameters : The array of parameter positions to return the tangent at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        tangents : The output array of tangent vectors for each position on the curve.
        The length of this array will be the same as the length of the parameters array provided. 
        Returns true if the tangents were successfully returned.
        """
        return _core.CurveEvaluator3D_getTangents(self, parameters)

    def getTangent(self, parameter: "double") -> "bool":
        r"""
        Get the tangent to the curve at a parameter position on the curve. 
        parameter : The parameter position to return the tangent at.
        This value must be within the range of the parameter extents as provided by getParameterExtents. 
        tangent : The output tangent vector at the curve position. 
        Returns true if the tangent was successfully returned.
        """
        return _core.CurveEvaluator3D_getTangent(self, parameter)

    def _get_objectType(self) -> "char const *":
        return _core.CurveEvaluator3D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.CurveEvaluator3D__get_isValid(self)

# Register CurveEvaluator3D in _core:
_core.CurveEvaluator3D_swigregister(CurveEvaluator3D)

def CurveEvaluator3D_classType() -> "char const *":
    return _core.CurveEvaluator3D_classType()


CurveEvaluator3D.cast = lambda arg: arg if isinstance(arg, CurveEvaluator3D) else None

class CustomEventHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notify(self, eventArgs: "CustomEventArgs") -> "void":
        return _core.CustomEventHandler_notify(self, eventArgs)

    def __init__(self):
        if self.__class__ == CustomEventHandler:
            _self = None
        else:
            _self = self
        _core.CustomEventHandler_swiginit(self, _core.new_CustomEventHandler(_self, ))
    __swig_destroy__ = _core.delete_CustomEventHandler
    def __disown__(self):
        self.this.disown()
        _core.disown_CustomEventHandler(self)
        return weakref.proxy(self)

# Register CustomEventHandler in _core:
_core.CustomEventHandler_swigregister(CustomEventHandler)


CustomEventHandler.cast = lambda arg: arg if isinstance(arg, CustomEventHandler) else None

class Data(Base):
    r"""The Data class provides access to data files"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Data *":
        return _core.Data___deref__(self)

    def __eq__(self, rhs: "Data") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Data___eq__(self, rhs)


    def __ne__(self, rhs: "Data") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Data___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Data_classType()
    __swig_destroy__ = _core.delete_Data

    def _get_activeProject(self) -> "adsk::core::Ptr< adsk::core::DataProject >":
        r"""Gets and sets the active DataProject. This is the project currently displayed in the Fusion 360 Data Panel."""
        return _core.Data__get_activeProject(self)

    def _set_activeProject(self, value: "DataProject") -> "bool":
        r"""Gets and sets the active DataProject. This is the project currently displayed in the Fusion 360 Data Panel."""
        return _core.Data__set_activeProject(self, value)

    def _get_dataProjects(self) -> "adsk::core::Ptr< adsk::core::DataProjects >":
        r"""Gets the collection of DataProjects associated with the active Hub."""
        return _core.Data__get_dataProjects(self)

    def _get_dataHubs(self) -> "adsk::core::Ptr< adsk::core::DataHubs >":
        r"""Returns a collection of accessible hubs for the current user. A DataHub represents an A360 Team or Personal hub."""
        return _core.Data__get_dataHubs(self)

    def _get_activeHub(self) -> "adsk::core::Ptr< adsk::core::DataHub >":
        r"""Gets the active DataHub."""
        return _core.Data__get_activeHub(self)

    def _set_activeHub(self, value: "DataHub") -> "bool":
        r"""Gets the active DataHub."""
        return _core.Data__set_activeHub(self, value)

    def refreshDataPanel(self) -> "bool":
        r"""
        Refreshes the contents of the data panel to ensure what is displayed reflects the latest state. 
        Returns true if the refresh was successful.
        """
        return _core.Data_refreshDataPanel(self)

    def _get_isDataPanelVisible(self) -> "bool":
        r"""Gets and sets if the data panel is visible within Fusion 360."""
        return _core.Data__get_isDataPanelVisible(self)

    def _set_isDataPanelVisible(self, value: "bool") -> "bool":
        r"""Gets and sets if the data panel is visible within Fusion 360."""
        return _core.Data__set_isDataPanelVisible(self, value)

    def findFileById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::DataFile >":
        r"""
        Returns the DataFile identified by the input id. This can fail is there isn't a DataFile identified
        with the specified id or if the current user doesn't have privileges to access the file. 
        id : The full id of the file will be something similar to that shown below. The version argument can be 
        omitted which will result in getting the latest version.
        urn:adsk.wipprod:fs.file:vf.NazykCYLRWKZ5tpzJtEQ1A?version=3
        This is also the same id that you'll obtain if you use the Forge Data Management API. 
        Returns a DataFile if one was found matching the input id or null if one was not found or you don't
        have privileges to access it. You can use the Application.getLastError method to determine the reason
        for the failure.
        """
        return _core.Data_findFileById(self, id)

    def _get_objectType(self) -> "char const *":
        return _core.Data__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Data__get_isValid(self)

# Register Data in _core:
_core.Data_swigregister(Data)

def Data_classType() -> "char const *":
    return _core.Data_classType()


Data.activeProject = property(Data._get_activeProject, Data._set_activeProject, doc="Gets and sets the active DataProject. This is the project currently displayed in the Fusion 360 Data Panel.")


Data.dataProjects = property(Data._get_dataProjects, doc="Gets the collection of DataProjects associated with the active Hub.")


Data.dataHubs = property(Data._get_dataHubs, doc="Returns a collection of accessible hubs for the current user. A DataHub represents an A360 Team or Personal hub.")


Data.activeHub = property(Data._get_activeHub, Data._set_activeHub, doc="Gets the active DataHub.")


Data.isDataPanelVisible = property(Data._get_isDataPanelVisible, Data._set_isDataPanelVisible, doc="Gets and sets if the data panel is visible within Fusion 360.")


Data.cast = lambda arg: arg if isinstance(arg, Data) else None

class DataFile(Base):
    r"""A data file in a data folder."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::DataFile *":
        return _core.DataFile___deref__(self)

    def __eq__(self, rhs: "DataFile") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.DataFile___eq__(self, rhs)


    def __ne__(self, rhs: "DataFile") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.DataFile___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.DataFile_classType()
    __swig_destroy__ = _core.delete_DataFile

    def _get_name(self) -> "std::string":
        r"""Gets and sets the displayed name of this item."""
        return _core.DataFile__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the displayed name of this item."""
        return _core.DataFile__set_name(self, value)

    def _get_description(self) -> "std::string":
        r"""Gets and sets the description information associated with this item."""
        return _core.DataFile__get_description(self)

    def _get_parentFolder(self) -> "adsk::core::Ptr< adsk::core::DataFolder >":
        r"""Returns the parent folder this item is contained within."""
        return _core.DataFile__get_parentFolder(self)

    def _get_parentProject(self) -> "adsk::core::Ptr< adsk::core::DataProject >":
        r"""Returns the parent project that this item is in."""
        return _core.DataFile__get_parentProject(self)

    def _get_id(self) -> "std::string":
        r"""
        Returns the unique ID for this DataFile. This is the same id used in the
        Forge Data Management API for an Item and is in the unencoded form and will
        look similar to this: 'urn:adsk.wipprod:dm.lineage:hC6k4hndRWaeIVhIjvHu8w'
        """
        return _core.DataFile__get_id(self)

    def _get_versionNumber(self) -> "int":
        r"""Gets the version number of this DataFile."""
        return _core.DataFile__get_versionNumber(self)

    def _get_versions(self) -> "adsk::core::Ptr< adsk::core::DataFiles >":
        r"""Gets the other version of this item."""
        return _core.DataFile__get_versions(self)

    def _get_latestVersionNumber(self) -> "int":
        r"""Gets the latest version number for this DataFile."""
        return _core.DataFile__get_latestVersionNumber(self)

    def _get_latestVersion(self) -> "adsk::core::Ptr< adsk::core::DataFile >":
        r"""
        Returns the latest version of the DataFile. It can return a reference
        to the same DataFile is this DataFile is the latest version.
        """
        return _core.DataFile__get_latestVersion(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this DataFile. This can fail if this file is referenced by another file or is currently open. 
        Returns true if the deletion was successful.
        """
        return _core.DataFile_deleteMe(self)

    def move(self, targetFolder: "DataFolder") -> "bool":
        r"""
        Moves this DataFile to the specified folder. 
        targetFolder : The folder to move this DataFile to. 
        Returns true if the move was successful.
        """
        return _core.DataFile_move(self, targetFolder)

    def copy(self, targetFolder: "DataFolder") -> "adsk::core::Ptr< adsk::core::DataFile >":
        r"""
        Copies this DataFile to the specified folder. 
        targetFolder : The folder to copy this DataFile to. 
        Returns the copied DataFile if the copy was successful.
        """
        return _core.DataFile_copy(self, targetFolder)

    def promote(self) -> "bool":
        r"""
        Promotes this version to be the latest version. If this is the latest version, nothing happens. 
        Returns true if successful.
        """
        return _core.DataFile_promote(self)

    def _get_fileExtension(self) -> "std::string":
        r"""Gets the file extension for this data file. The file type can be inferred from this."""
        return _core.DataFile__get_fileExtension(self)

    def _get_isInUse(self) -> "bool":
        r"""Gets if this DataFile is currently in use (opened for edit) by any other user."""
        return _core.DataFile__get_isInUse(self)

    def _get_inUseBy(self) -> "std::vector< adsk::core::Ptr< adsk::core::User >,std::allocator< adsk::core::Ptr< adsk::core::User > > >":
        r"""Returns the array of users that are currently using (have open for edit) this data file."""
        return _core.DataFile__get_inUseBy(self)

    def _get_createdBy(self) -> "adsk::core::Ptr< adsk::core::User >":
        r"""Returns the User that created this data file."""
        return _core.DataFile__get_createdBy(self)

    def _get_lastUpdatedBy(self) -> "adsk::core::Ptr< adsk::core::User >":
        r"""Returns the User that last updated this data file"""
        return _core.DataFile__get_lastUpdatedBy(self)

    def _get_hasOutofDateChildReferences(self) -> "bool":
        r"""Gets if this datafile has Children (referenced components) that are out of date (not the latest version)."""
        return _core.DataFile__get_hasOutofDateChildReferences(self)

    def _get_hasChildReferences(self) -> "bool":
        r"""Gets if this datafile has children, (i.e. a Fusion 360 Design containing referenced components)."""
        return _core.DataFile__get_hasChildReferences(self)

    def _get_hasParentReferences(self) -> "bool":
        r"""Gets if this datafile has parents, (i.e. this is a child being referenced in another Fusion 360 design)."""
        return _core.DataFile__get_hasParentReferences(self)

    def _get_childReferences(self) -> "adsk::core::Ptr< adsk::core::DataFiles >":
        r"""Returns a collection of DataFiles that are the children (referenced designs) this datafile references."""
        return _core.DataFile__get_childReferences(self)

    def _get_parentReferences(self) -> "adsk::core::Ptr< adsk::core::DataFiles >":
        r"""Returns a collection DataFiles collection that are the parents (designs that reference) this datafile."""
        return _core.DataFile__get_parentReferences(self)

    def _get_publicLink(self) -> "std::string":
        r"""Returns a short url of this data file which can be shared with others."""
        return _core.DataFile__get_publicLink(self)

    def _get_dateCreated(self) -> "size_t":
        r"""
        Returns the date when this data file was created as UNIX epoch time. UNIX epoch time
        is the number of seconds since January 1, 1970 (midnight UTC/GMT).
        In Python you can import the standard time module to work with UNIX epoch time.
        In C++ you can use functions in time.h and std::chrono to work with UNIX epoch time.
        """
        return _core.DataFile__get_dateCreated(self)

    def _get_versionId(self) -> "std::string":
        r"""
        Returns the version ID for this DataFile. This is the same id used in the
        Forge Data Management API for an Item and is in the unencoded form and will
        look similar to this: 'urn:adsk.wipqa:fs.file:vf.W3syIw1lQAW-5vWObMdYnA?version=2'
        """
        return _core.DataFile__get_versionId(self)

    def _get_objectType(self) -> "char const *":
        return _core.DataFile__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.DataFile__get_isValid(self)

# Register DataFile in _core:
_core.DataFile_swigregister(DataFile)

def DataFile_classType() -> "char const *":
    return _core.DataFile_classType()


DataFile.name = property(DataFile._get_name, DataFile._set_name, doc="Gets and sets the displayed name of this item.")


DataFile.description = property(DataFile._get_description, doc="Gets and sets the description information associated with this item.")


DataFile.parentFolder = property(DataFile._get_parentFolder, doc="Returns the parent folder this item is contained within.")


DataFile.parentProject = property(DataFile._get_parentProject, doc="Returns the parent project that this item is in.")


DataFile.id = property(DataFile._get_id, doc="Returns the unique ID for this DataFile. This is the same id used in the\nForge Data Management API for an Item and is in the unencoded form and will\nlook similar to this: 'urn:adsk.wipprod:dm.lineage:hC6k4hndRWaeIVhIjvHu8w'")


DataFile.versionNumber = property(DataFile._get_versionNumber, doc="Gets the version number of this DataFile.")


DataFile.versions = property(DataFile._get_versions, doc="Gets the other version of this item.")


DataFile.latestVersionNumber = property(DataFile._get_latestVersionNumber, doc="Gets the latest version number for this DataFile.")


DataFile.latestVersion = property(DataFile._get_latestVersion, doc="Returns the latest version of the DataFile. It can return a reference\nto the same DataFile is this DataFile is the latest version.")


DataFile.fileExtension = property(DataFile._get_fileExtension, doc="Gets the file extension for this data file. The file type can be inferred from this.")


DataFile.isInUse = property(DataFile._get_isInUse, doc="Gets if this DataFile is currently in use (opened for edit) by any other user.")


DataFile.inUseBy = property(DataFile._get_inUseBy, doc="Returns the array of users that are currently using (have open for edit) this data file.")


DataFile.createdBy = property(DataFile._get_createdBy, doc="Returns the User that created this data file.")


DataFile.lastUpdatedBy = property(DataFile._get_lastUpdatedBy, doc="Returns the User that last updated this data file")


DataFile.hasOutofDateChildReferences = property(DataFile._get_hasOutofDateChildReferences, doc="Gets if this datafile has Children (referenced components) that are out of date (not the latest version).")


DataFile.hasChildReferences = property(DataFile._get_hasChildReferences, doc="Gets if this datafile has children, (i.e. a Fusion 360 Design containing referenced components).")


DataFile.hasParentReferences = property(DataFile._get_hasParentReferences, doc="Gets if this datafile has parents, (i.e. this is a child being referenced in another Fusion 360 design).")


DataFile.childReferences = property(DataFile._get_childReferences, doc="Returns a collection of DataFiles that are the children (referenced designs) this datafile references.")


DataFile.parentReferences = property(DataFile._get_parentReferences, doc="Returns a collection DataFiles collection that are the parents (designs that reference) this datafile.")


DataFile.publicLink = property(DataFile._get_publicLink, doc="Returns a short url of this data file which can be shared with others.")


DataFile.dateCreated = property(DataFile._get_dateCreated, doc="Returns the date when this data file was created as UNIX epoch time. UNIX epoch time\nis the number of seconds since January 1, 1970 (midnight UTC/GMT).\nIn Python you can import the standard time module to work with UNIX epoch time.\nIn C++ you can use functions in time.h and std::chrono to work with UNIX epoch time.")


DataFile.versionId = property(DataFile._get_versionId, doc="Returns the version ID for this DataFile. This is the same id used in the\nForge Data Management API for an Item and is in the unencoded form and will\nlook similar to this: 'urn:adsk.wipqa:fs.file:vf.W3syIw1lQAW-5vWObMdYnA?version=2'")


DataFile.cast = lambda arg: arg if isinstance(arg, DataFile) else None

class DataFileFuture(Base):
    r"""Used to check the state and get back the results of a file upload."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::DataFileFuture *":
        return _core.DataFileFuture___deref__(self)

    def __eq__(self, rhs: "DataFileFuture") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.DataFileFuture___eq__(self, rhs)


    def __ne__(self, rhs: "DataFileFuture") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.DataFileFuture___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.DataFileFuture_classType()
    __swig_destroy__ = _core.delete_DataFileFuture

    def _get_dataFile(self) -> "adsk::core::Ptr< adsk::core::DataFile >":
        r"""
        Returns the DataFile when the upload is complete (uplodeState returns UploadFinished).
        Returns null if the upload is still running or has failed.
        """
        return _core.DataFileFuture__get_dataFile(self)

    def _get_uploadState(self) -> "adsk::core::UploadStates":
        r"""Returns the current state of the upload."""
        return _core.DataFileFuture__get_uploadState(self)

    def _get_objectType(self) -> "char const *":
        return _core.DataFileFuture__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.DataFileFuture__get_isValid(self)

# Register DataFileFuture in _core:
_core.DataFileFuture_swigregister(DataFileFuture)

def DataFileFuture_classType() -> "char const *":
    return _core.DataFileFuture_classType()


DataFileFuture.dataFile = property(DataFileFuture._get_dataFile, doc="Returns the DataFile when the upload is complete (uplodeState returns UploadFinished).\nReturns null if the upload is still running or has failed.")


DataFileFuture.uploadState = property(DataFileFuture._get_uploadState, doc="Returns the current state of the upload.")


DataFileFuture.cast = lambda arg: arg if isinstance(arg, DataFileFuture) else None

class DataFiles(Base):
    r"""Returns the items within a folder. This includes everything in a folder except for other folders."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::DataFiles *":
        return _core.DataFiles___deref__(self)

    def __eq__(self, rhs: "DataFiles") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.DataFiles___eq__(self, rhs)


    def __ne__(self, rhs: "DataFiles") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.DataFiles___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.DataFiles___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::DataFile >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.DataFiles___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.DataFiles_classType()
    __swig_destroy__ = _core.delete_DataFiles

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::DataFile >":
        r"""
        Returns the specified data file. 
        index : The index of the file to return. The first file in the list has an index of 0. 
        Returns the specified file or null if an invalid index was specified.
        """
        return _core.DataFiles_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of data items in this collection."""
        return _core.DataFiles__get_count(self)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::DataFile >":
        r"""
        Returns the file specified using the ID or version ID of the file. 
        id : The ID or version ID of the file to return. This is the same ID used by
        the Forge Data Management API. 
        Returns the file or null if a file with the specified ID is not found.
        """
        return _core.DataFiles_itemById(self, id)

    def asArray(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFile >,std::allocator< adsk::core::Ptr< adsk::core::DataFile > > >":
        r"""
        Get the current list of all files. 
        Returns the current list of all files.
        """
        return _core.DataFiles_asArray(self)

    def _get_objectType(self) -> "char const *":
        return _core.DataFiles__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.DataFiles__get_isValid(self)

# Register DataFiles in _core:
_core.DataFiles_swigregister(DataFiles)

def DataFiles_classType() -> "char const *":
    return _core.DataFiles_classType()


DataFiles.count = property(DataFiles._get_count, doc="The number of data items in this collection.")


DataFiles.cast = lambda arg: arg if isinstance(arg, DataFiles) else None

class DataFolder(Base):
    r"""A data folder that contains a collection of data items."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::DataFolder *":
        return _core.DataFolder___deref__(self)

    def __eq__(self, rhs: "DataFolder") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.DataFolder___eq__(self, rhs)


    def __ne__(self, rhs: "DataFolder") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.DataFolder___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.DataFolder_classType()
    __swig_destroy__ = _core.delete_DataFolder

    def _get_name(self) -> "std::string":
        r"""Gets and sets the displayed name of this folder."""
        return _core.DataFolder__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the displayed name of this folder."""
        return _core.DataFolder__set_name(self, value)

    def _get_dataFiles(self) -> "adsk::core::Ptr< adsk::core::DataFiles >":
        r"""
        Returns a collection containing all of the items within this folder, excluding folders.
        Use the dataFolders property to get the folders.
        """
        return _core.DataFolder__get_dataFiles(self)

    def _get_dataFolders(self) -> "adsk::core::Ptr< adsk::core::DataFolders >":
        r"""Returns a collection containing all of the folders within this folder."""
        return _core.DataFolder__get_dataFolders(self)

    def _get_parentFolder(self) -> "adsk::core::Ptr< adsk::core::DataFolder >":
        r"""
        Returns the parent folder this folder is contained within. Returns null
        if this is the project's root folder.
        """
        return _core.DataFolder__get_parentFolder(self)

    def _get_parentProject(self) -> "adsk::core::Ptr< adsk::core::DataProject >":
        r"""Returns the parent project that owns this folder."""
        return _core.DataFolder__get_parentProject(self)

    def _get_isRoot(self) -> "bool":
        r"""Indicates if this folder is the root folder within the parent project."""
        return _core.DataFolder__get_isRoot(self)

    def uploadFile(self, filename: "std::string const &") -> "adsk::core::Ptr< adsk::core::DataFileFuture >":
        r"""
        Uploads a single file to this directory. 
        filename : The full filename of the file to upload. 
        The upload process is asynchronous which means that this method
        will return before the upload process had completed. The returned
        DataFileFuture object can be used to check on the current state of the
        upload to determine if it is still uploading, is complete, or has failed.
        If it is complete the final DataFinal can be retrieved through the
        DataFileFuture object.
        """
        return _core.DataFolder_uploadFile(self, filename)

    def uploadAssembly(self, filenames: "StringVector") -> "adsk::core::Ptr< adsk::core::DataFileFuture >":
        r"""
        Uploads a set of files that represent an assembly There should only
        be a single top-level assembly file but there can be any number of other
        files that represent subassemblies. 
        filenames : An array of strings that contains the list of all of the files that
        are part of the assembly. The name of the the top-level assembly file
        must be the first file in the array. 
        The upload process is asynchronous which means that this method
        will return before the upload process had completed. The returned
        DataFileFuture object can be used to check on the current state of the
        upload to determine if it is still uploading, is complete, or has failed.
        If it is complete the final DataFinal can be retrieved through the
        DataFileFuture object.
        """
        return _core.DataFolder_uploadAssembly(self, filenames)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this folder item. 
        Returns true if the deletion was successful.
        """
        return _core.DataFolder_deleteMe(self)

    def _get_id(self) -> "std::string":
        r"""
        Returns the unique ID for this folder. This is the same id used in the
        Forge Data Management API.
        """
        return _core.DataFolder__get_id(self)

    def _get_objectType(self) -> "char const *":
        return _core.DataFolder__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.DataFolder__get_isValid(self)

# Register DataFolder in _core:
_core.DataFolder_swigregister(DataFolder)

def DataFolder_classType() -> "char const *":
    return _core.DataFolder_classType()


DataFolder.name = property(DataFolder._get_name, DataFolder._set_name, doc="Gets and sets the displayed name of this folder.")


DataFolder.dataFiles = property(DataFolder._get_dataFiles, doc="Returns a collection containing all of the items within this folder, excluding folders.\nUse the dataFolders property to get the folders.")


DataFolder.dataFolders = property(DataFolder._get_dataFolders, doc="Returns a collection containing all of the folders within this folder.")


DataFolder.parentFolder = property(DataFolder._get_parentFolder, doc="Returns the parent folder this folder is contained within. Returns null\nif this is the project's root folder.")


DataFolder.parentProject = property(DataFolder._get_parentProject, doc="Returns the parent project that owns this folder.")


DataFolder.isRoot = property(DataFolder._get_isRoot, doc="Indicates if this folder is the root folder within the parent project.")


DataFolder.id = property(DataFolder._get_id, doc="Returns the unique ID for this folder. This is the same id used in the\nForge Data Management API.")


DataFolder.cast = lambda arg: arg if isinstance(arg, DataFolder) else None

class DataFolders(Base):
    r"""Collection object the provides a list of data folders."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::DataFolders *":
        return _core.DataFolders___deref__(self)

    def __eq__(self, rhs: "DataFolders") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.DataFolders___eq__(self, rhs)


    def __ne__(self, rhs: "DataFolders") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.DataFolders___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.DataFolders___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::DataFolder >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.DataFolders___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.DataFolders_classType()
    __swig_destroy__ = _core.delete_DataFolders

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::DataFolder >":
        r"""
        Returns the specified folder. 
        index : The index of the folder to return. The first folder in the list has an index of 0. 
        Returns the item or null if an invalid index was specified.
        """
        return _core.DataFolders_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::core::DataFolder >":
        r"""
        Returns the folder specified using the name of the folder. 
        name : The name of the folder to return. 
        Returns the folder or null if a folder of the specified name is not found.
        """
        return _core.DataFolders_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of folders in this collection."""
        return _core.DataFolders__get_count(self)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::DataFolder >":
        r"""
        Returns the folder specified using the ID of the folder. 
        id : The ID of the folder to return. This is the same ID used by
        the Forge Data Management API. 
        Returns the folder or null if a folder with the specified ID is not found.
        """
        return _core.DataFolders_itemById(self, id)

    def add(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::core::DataFolder >":
        r"""
        Creates a new folder within the parent folder. 
        name : The name of the folder. This must be unique with respect to the other folders within the parent folder. 
        Returns the created DataFolder or null if the creation failed.
        """
        return _core.DataFolders_add(self, name)

    def asArray(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataFolder >,std::allocator< adsk::core::Ptr< adsk::core::DataFolder > > >":
        r"""
        Get the current list of all folders. 
        Returns the current list of all folders.
        """
        return _core.DataFolders_asArray(self)

    def _get_objectType(self) -> "char const *":
        return _core.DataFolders__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.DataFolders__get_isValid(self)

# Register DataFolders in _core:
_core.DataFolders_swigregister(DataFolders)

def DataFolders_classType() -> "char const *":
    return _core.DataFolders_classType()


DataFolders.count = property(DataFolders._get_count, doc="The number of folders in this collection.")


DataFolders.cast = lambda arg: arg if isinstance(arg, DataFolders) else None

class DataHub(Base):
    r"""Represents a hub within the data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::DataHub *":
        return _core.DataHub___deref__(self)

    def __eq__(self, rhs: "DataHub") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.DataHub___eq__(self, rhs)


    def __ne__(self, rhs: "DataHub") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.DataHub___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.DataHub_classType()
    __swig_destroy__ = _core.delete_DataHub

    def _get_name(self) -> "std::string":
        r"""Returns the name of the hub."""
        return _core.DataHub__get_name(self)

    def _get_dataProjects(self) -> "adsk::core::Ptr< adsk::core::DataProjects >":
        r"""Returns the projects within this hub."""
        return _core.DataHub__get_dataProjects(self)

    def _get_hubType(self) -> "adsk::core::HubTypes":
        r"""Gets if this hub is a Personal (PersonalHubType) or Team (TeamHubType) type hub."""
        return _core.DataHub__get_hubType(self)

    def _get_id(self) -> "std::string":
        r"""
        Returns the unique ID for this hub. This is the same id used in the
        Forge Data Management API in an unencoded form and will look something like
        this: 'a.45637'.
        """
        return _core.DataHub__get_id(self)

    def _get_objectType(self) -> "char const *":
        return _core.DataHub__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.DataHub__get_isValid(self)

# Register DataHub in _core:
_core.DataHub_swigregister(DataHub)

def DataHub_classType() -> "char const *":
    return _core.DataHub_classType()


DataHub.name = property(DataHub._get_name, doc="Returns the name of the hub.")


DataHub.dataProjects = property(DataHub._get_dataProjects, doc="Returns the projects within this hub.")


DataHub.hubType = property(DataHub._get_hubType, doc="Gets if this hub is a Personal (PersonalHubType) or Team (TeamHubType) type hub.")


DataHub.id = property(DataHub._get_id, doc="Returns the unique ID for this hub. This is the same id used in the\nForge Data Management API in an unencoded form and will look something like\nthis: 'a.45637'.")


DataHub.cast = lambda arg: arg if isinstance(arg, DataHub) else None

class DataHubs(Base):
    r"""Collection object that provides a list of all available hubs."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::DataHubs *":
        return _core.DataHubs___deref__(self)

    def __eq__(self, rhs: "DataHubs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.DataHubs___eq__(self, rhs)


    def __ne__(self, rhs: "DataHubs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.DataHubs___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.DataHubs___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::DataHub >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.DataHubs___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.DataHubs_classType()
    __swig_destroy__ = _core.delete_DataHubs

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::DataHub >":
        r"""
        Returns the specified hub. 
        index : The index of the hub to return. The first hub in the list has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.DataHubs_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of hubs in this collection."""
        return _core.DataHubs__get_count(self)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::DataHub >":
        r"""
        Returns the hub specified using the ID of the hub. 
        id : The ID of the hub to return. This is the same ID used by
        the Forge Data Management API. 
        Returns the hub or null if a hub with the specified ID is not found.
        """
        return _core.DataHubs_itemById(self, id)

    def asArray(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataHub >,std::allocator< adsk::core::Ptr< adsk::core::DataHub > > >":
        r"""
        Get the current list of all hubs. 
        Returns the current list of all hubs.
        """
        return _core.DataHubs_asArray(self)

    def _get_objectType(self) -> "char const *":
        return _core.DataHubs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.DataHubs__get_isValid(self)

# Register DataHubs in _core:
_core.DataHubs_swigregister(DataHubs)

def DataHubs_classType() -> "char const *":
    return _core.DataHubs_classType()


DataHubs.count = property(DataHubs._get_count, doc="The number of hubs in this collection.")


DataHubs.cast = lambda arg: arg if isinstance(arg, DataHubs) else None

class DataProject(Base):
    r"""Represents the master branch project within a hub."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::DataProject *":
        return _core.DataProject___deref__(self)

    def __eq__(self, rhs: "DataProject") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.DataProject___eq__(self, rhs)


    def __ne__(self, rhs: "DataProject") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.DataProject___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.DataProject_classType()
    __swig_destroy__ = _core.delete_DataProject

    def _get_name(self) -> "std::string":
        r"""Gets and sets the name of the project."""
        return _core.DataProject__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the name of the project."""
        return _core.DataProject__set_name(self, value)

    def _get_rootFolder(self) -> "adsk::core::Ptr< adsk::core::DataFolder >":
        r"""
        Returns the project's root folder. This provides access to all of the 
        folders and the files in the top level of the project.
        """
        return _core.DataProject__get_rootFolder(self)

    def _get_id(self) -> "std::string":
        r"""
        Returns the unique ID for this project. This is the same id used in the
        Forge Data Management API in an unencoded form and will look something like
        this: 'a.45637'.
        """
        return _core.DataProject__get_id(self)

    def _get_parentHub(self) -> "adsk::core::Ptr< adsk::core::DataHub >":
        r"""Returns the parent DataHub of this project."""
        return _core.DataProject__get_parentHub(self)

    def _get_objectType(self) -> "char const *":
        return _core.DataProject__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.DataProject__get_isValid(self)

# Register DataProject in _core:
_core.DataProject_swigregister(DataProject)

def DataProject_classType() -> "char const *":
    return _core.DataProject_classType()


DataProject.name = property(DataProject._get_name, DataProject._set_name, doc="Gets and sets the name of the project.")


DataProject.rootFolder = property(DataProject._get_rootFolder, doc="Returns the project's root folder. This provides access to all of the\nfolders and the files in the top level of the project.")


DataProject.id = property(DataProject._get_id, doc="Returns the unique ID for this project. This is the same id used in the\nForge Data Management API in an unencoded form and will look something like\nthis: 'a.45637'.")


DataProject.parentHub = property(DataProject._get_parentHub, doc="Returns the parent DataHub of this project.")


DataProject.cast = lambda arg: arg if isinstance(arg, DataProject) else None

class DataProjects(Base):
    r"""Collection object that provides a list of all available projects."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::DataProjects *":
        return _core.DataProjects___deref__(self)

    def __eq__(self, rhs: "DataProjects") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.DataProjects___eq__(self, rhs)


    def __ne__(self, rhs: "DataProjects") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.DataProjects___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.DataProjects___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::DataProject >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.DataProjects___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.DataProjects_classType()
    __swig_destroy__ = _core.delete_DataProjects

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::DataProject >":
        r"""
        Returns the specified project. 
        index : The index of the project to return. The first project in the list has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.DataProjects_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of projects in this collection."""
        return _core.DataProjects__get_count(self)

    def add(self, *args) -> "adsk::core::Ptr< adsk::core::DataProject >":
        r"""
        Creates a new project in the parent hub. 
        name : The name of the project. This is the name visible to the user. 
        purpose : Optional description of the purpose of the project. An empty string can be used to not specify a purpose. 
        contributors : Optional list of contributors where the list consists of email addresses separated by a comma. 
        An empty string can be used to not specify any contributors. 
        Returns the created DataProject object or null if the creation failed.
        """
        return _core.DataProjects_add(self, *args)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::DataProject >":
        r"""
        Returns the project specified using the ID of the project. 
        id : The ID of the project to return. This is the same ID used by
        the Forge Data Management API. 
        Returns the project or null if a project with the specified ID is not found.
        """
        return _core.DataProjects_itemById(self, id)

    def asArray(self) -> "std::vector< adsk::core::Ptr< adsk::core::DataProject >,std::allocator< adsk::core::Ptr< adsk::core::DataProject > > >":
        r"""
        Get the current list of all projects. 
        Returns the current list of all projects.
        """
        return _core.DataProjects_asArray(self)

    def _get_objectType(self) -> "char const *":
        return _core.DataProjects__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.DataProjects__get_isValid(self)

# Register DataProjects in _core:
_core.DataProjects_swigregister(DataProjects)

def DataProjects_classType() -> "char const *":
    return _core.DataProjects_classType()


DataProjects.count = property(DataProjects._get_count, doc="The number of projects in this collection.")


DataProjects.cast = lambda arg: arg if isinstance(arg, DataProjects) else None

class DefaultUnitsPreferences(Base):
    r"""
    The base class for the default units preference. There is a derived class
    supported by each product where the specific preference values are exposed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::DefaultUnitsPreferences *":
        return _core.DefaultUnitsPreferences___deref__(self)

    def __eq__(self, rhs: "DefaultUnitsPreferences") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.DefaultUnitsPreferences___eq__(self, rhs)


    def __ne__(self, rhs: "DefaultUnitsPreferences") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.DefaultUnitsPreferences___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.DefaultUnitsPreferences_classType()
    __swig_destroy__ = _core.delete_DefaultUnitsPreferences

    def _get_name(self) -> "std::string":
        r"""Returns the name of this DefaultUnitPreferences object."""
        return _core.DefaultUnitsPreferences__get_name(self)

    def _get_objectType(self) -> "char const *":
        return _core.DefaultUnitsPreferences__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.DefaultUnitsPreferences__get_isValid(self)

# Register DefaultUnitsPreferences in _core:
_core.DefaultUnitsPreferences_swigregister(DefaultUnitsPreferences)

def DefaultUnitsPreferences_classType() -> "char const *":
    return _core.DefaultUnitsPreferences_classType()


DefaultUnitsPreferences.name = property(DefaultUnitsPreferences._get_name, doc="Returns the name of this DefaultUnitPreferences object.")


DefaultUnitsPreferences.cast = lambda arg: arg if isinstance(arg, DefaultUnitsPreferences) else None

class DefaultUnitsPreferencesCollection(Base):
    r"""A collection that provides access to product specific unit preference objects."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::DefaultUnitsPreferencesCollection *":
        return _core.DefaultUnitsPreferencesCollection___deref__(self)

    def __eq__(self, rhs: "DefaultUnitsPreferencesCollection") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.DefaultUnitsPreferencesCollection___eq__(self, rhs)


    def __ne__(self, rhs: "DefaultUnitsPreferencesCollection") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.DefaultUnitsPreferencesCollection___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.DefaultUnitsPreferencesCollection___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::DefaultUnitsPreferences >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.DefaultUnitsPreferencesCollection___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.DefaultUnitsPreferencesCollection_classType()
    __swig_destroy__ = _core.delete_DefaultUnitsPreferencesCollection

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::DefaultUnitsPreferences >":
        r"""
        Function that returns the specified DefaultUnitPreferences object using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.DefaultUnitsPreferencesCollection_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::core::DefaultUnitsPreferences >":
        r"""
        Returns the DefaultUnitsPreference object with the specified name. 
        name : The name of the DefaultUnitsPreference to return. 
        Returns the DefaultUnitsPreference object or null if if an invalid name was specified.
        """
        return _core.DefaultUnitsPreferencesCollection_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""Returns the number of DefaultUnitsPreference objects."""
        return _core.DefaultUnitsPreferencesCollection__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _core.DefaultUnitsPreferencesCollection__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.DefaultUnitsPreferencesCollection__get_isValid(self)

# Register DefaultUnitsPreferencesCollection in _core:
_core.DefaultUnitsPreferencesCollection_swigregister(DefaultUnitsPreferencesCollection)

def DefaultUnitsPreferencesCollection_classType() -> "char const *":
    return _core.DefaultUnitsPreferencesCollection_classType()


DefaultUnitsPreferencesCollection.count = property(DefaultUnitsPreferencesCollection._get_count, doc="Returns the number of DefaultUnitsPreference objects.")


DefaultUnitsPreferencesCollection.cast = lambda arg: arg if isinstance(arg, DefaultUnitsPreferencesCollection) else None

class Document(Base):
    r"""Object that represents an open document. This is the base class for all document types."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Document *":
        return _core.Document___deref__(self)

    def __eq__(self, rhs: "Document") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Document___eq__(self, rhs)


    def __ne__(self, rhs: "Document") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Document___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Document_classType()
    __swig_destroy__ = _core.delete_Document

    def activate(self) -> "bool":
        r"""
        Causes this document to become the active document in the user interface. 
        Returns true if the activation was successful.
        """
        return _core.Document_activate(self)

    def _get_name(self) -> "std::string":
        r"""Gets and sets the name of the document."""
        return _core.Document__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the name of the document."""
        return _core.Document__set_name(self, value)

    def close(self, saveChanges: "bool") -> "bool":
        r"""
        Closes this document. 
        saveChanges : This argument defines what the behavior of the close is when the document
        has been modified. If the document hasn't been modified then this argument
        is ignored and the document is closed. If the document has been modified
        and this argument is false then Fusion 360 will close the document and lose
        any changes. If the document has been modified and this argument is true then
        it will prompt the user if they want to save the changes or not, just the same
        as if the user was to interactively close the document. 
        Returns true if closing the document was successful.
        """
        return _core.Document_close(self, saveChanges)

    def _get_isModified(self) -> "bool":
        r"""Property that indicates if the document has been modified since it was last saved."""
        return _core.Document__get_isModified(self)

    def _get_isSaved(self) -> "bool":
        r"""
        Property that indicates if this document has been saved or not. The initial save of
        a document requires that the name and location be specified and requires the saveAs method
        to be used. If the document has been saved then the save method can be used to save changes made.
        """
        return _core.Document__get_isSaved(self)

    def save(self, description: "std::string const &") -> "bool":
        r"""
        Saves a version of the current document. You must use the SaveAs method the first
        time a document is saved. You can determine if a document has been saved by checking
        the value of the isSaved property. 
        description : The version description for this document 
        Returns true if saving the document was successful.
        """
        return _core.Document_save(self, description)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Application >":
        r"""Returns the parent Application object."""
        return _core.Document__get_parent(self)

    def saveAs(self, name: "std::string const &", dataFolder: "DataFolder", description: "std::string const &", tag: "std::string const &") -> "bool":
        r"""
        Performs a Save As on this document. This saves the currently open document to the specified
        location and this document becomes the saved document. If this is a new document that has 
        never been saved you must use the SaveAs method in order to specify the location and name. You
        can determine if the document has been saved by checking the value of the isSaved property. 
        name : The name to use for this document. If this is an empty string, Fusion 360 will use the default name
        assigned when the document was created. 
        dataFolder : The data folder to save this document to. 
        description : The description string of the document. This can be an empty string. 
        tag : The tag string of the document. This can be an empty string. 
        Returns true if the save as was successful.
        """
        return _core.Document_saveAs(self, name, dataFolder, description, tag)

    def _get_products(self) -> "adsk::core::Ptr< adsk::core::Products >":
        r"""Returns the products associated with this document."""
        return _core.Document__get_products(self)

    def _get_isActive(self) -> "bool":
        r"""Gets if this document is the active document in the user interface."""
        return _core.Document__get_isActive(self)

    def _get_isVisible(self) -> "bool":
        r"""Gets if a currently open document is open as visible."""
        return _core.Document__get_isVisible(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this document."""
        return _core.Document__get_attributes(self)

    def _get_dataFile(self) -> "adsk::core::Ptr< adsk::core::DataFile >":
        r"""Gets the DataFile that represents this document in A360."""
        return _core.Document__get_dataFile(self)

    def _get_version(self) -> "std::string":
        r"""Returns the Fusion 360 version this document was last saved with."""
        return _core.Document__get_version(self)

    def _get_documentReferences(self) -> "adsk::core::Ptr< adsk::core::DocumentReferences >":
        r"""
        Returns a collection containing the documents directly referenced
        by this document.
        """
        return _core.Document__get_documentReferences(self)

    def _get_isUpToDate(self) -> "bool":
        r"""
        Indicates if any references in the assembly are out of date. This is the API 
        equivalent to the 'Out of Date' notification displayed in the Quick Access Toolbar.
        """
        return _core.Document__get_isUpToDate(self)

    def _get_allDocumentReferences(self) -> "adsk::core::Ptr< adsk::core::DocumentReferences >":
        r"""
        Returns a collection containing all of the documents referenced directly
        by this document and those referenced by all sub-assemblies.
        """
        return _core.Document__get_allDocumentReferences(self)

    def _get_objectType(self) -> "char const *":
        return _core.Document__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Document__get_isValid(self)

# Register Document in _core:
_core.Document_swigregister(Document)

def Document_classType() -> "char const *":
    return _core.Document_classType()


Document.name = property(Document._get_name, Document._set_name, doc="Gets and sets the name of the document.")


Document.isModified = property(Document._get_isModified, doc="Property that indicates if the document has been modified since it was last saved.")


Document.isSaved = property(Document._get_isSaved, doc="Property that indicates if this document has been saved or not. The initial save of\na document requires that the name and location be specified and requires the saveAs method\nto be used. If the document has been saved then the save method can be used to save changes made.")


Document.parent = property(Document._get_parent, doc="Returns the parent Application object.")


Document.products = property(Document._get_products, doc="Returns the products associated with this document.")


Document.isActive = property(Document._get_isActive, doc="Gets if this document is the active document in the user interface.")


Document.isVisible = property(Document._get_isVisible, doc="Gets if a currently open document is open as visible.")


Document.attributes = property(Document._get_attributes, doc="Returns the collection of attributes associated with this document.")


Document.dataFile = property(Document._get_dataFile, doc="Gets the DataFile that represents this document in A360.")


Document.version = property(Document._get_version, doc="Returns the Fusion 360 version this document was last saved with.")


Document.documentReferences = property(Document._get_documentReferences, doc="Returns a collection containing the documents directly referenced\nby this document.")


Document.isUpToDate = property(Document._get_isUpToDate, doc="Indicates if any references in the assembly are out of date. This is the API\nequivalent to the 'Out of Date' notification displayed in the Quick Access Toolbar.")


Document.allDocumentReferences = property(Document._get_allDocumentReferences, doc="Returns a collection containing all of the documents referenced directly\nby this document and those referenced by all sub-assemblies.")


Document.cast = lambda arg: arg if isinstance(arg, Document) else None

class DocumentEventHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notify(self, eventArgs: "DocumentEventArgs") -> "void":
        return _core.DocumentEventHandler_notify(self, eventArgs)

    def __init__(self):
        if self.__class__ == DocumentEventHandler:
            _self = None
        else:
            _self = self
        _core.DocumentEventHandler_swiginit(self, _core.new_DocumentEventHandler(_self, ))
    __swig_destroy__ = _core.delete_DocumentEventHandler
    def __disown__(self):
        self.this.disown()
        _core.disown_DocumentEventHandler(self)
        return weakref.proxy(self)

# Register DocumentEventHandler in _core:
_core.DocumentEventHandler_swigregister(DocumentEventHandler)


DocumentEventHandler.cast = lambda arg: arg if isinstance(arg, DocumentEventHandler) else None

class DocumentReference(Base):
    r"""Represents a reference to a document from another document."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::DocumentReference *":
        return _core.DocumentReference___deref__(self)

    def __eq__(self, rhs: "DocumentReference") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.DocumentReference___eq__(self, rhs)


    def __ne__(self, rhs: "DocumentReference") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.DocumentReference___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.DocumentReference_classType()
    __swig_destroy__ = _core.delete_DocumentReference

    def _get_dataFile(self) -> "adsk::core::Ptr< adsk::core::DataFile >":
        r"""The dataFile on A360 that this object references."""
        return _core.DocumentReference__get_dataFile(self)

    def _get_referencedDocument(self) -> "adsk::core::Ptr< adsk::core::Document >":
        r"""The document currently open in Fusion 360 that this object references."""
        return _core.DocumentReference__get_referencedDocument(self)

    def _get_version(self) -> "int":
        r"""
        Gets and sets the version of the dataFile on A360 that this document currently represents.
        Setting this property will cause all occurrences referencing this document to update to
        that version.
        """
        return _core.DocumentReference__get_version(self)

    def _set_version(self, value: "int") -> "bool":
        r"""
        Gets and sets the version of the dataFile on A360 that this document currently represents.
        Setting this property will cause all occurrences referencing this document to update to
        that version.
        """
        return _core.DocumentReference__set_version(self, value)

    def _get_parentDocument(self) -> "adsk::core::Ptr< adsk::core::Document >":
        r"""The document that is doing the referencing and owns this reference."""
        return _core.DocumentReference__get_parentDocument(self)

    def _get_isOutOfDate(self) -> "bool":
        r"""
        Indicates if this reference is out of date, meaning that the reference
        is not referencing the latest version.
        """
        return _core.DocumentReference__get_isOutOfDate(self)

    def getLatestVersion(self) -> "bool":
        r"""
        Updates the reference to use the latest version. This is only useful
        when the isOutOfDate property is true. 
        Returns true if getting the latest version was successful.
        """
        return _core.DocumentReference_getLatestVersion(self)

    def _get_objectType(self) -> "char const *":
        return _core.DocumentReference__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.DocumentReference__get_isValid(self)

# Register DocumentReference in _core:
_core.DocumentReference_swigregister(DocumentReference)

def DocumentReference_classType() -> "char const *":
    return _core.DocumentReference_classType()


DocumentReference.dataFile = property(DocumentReference._get_dataFile, doc="The dataFile on A360 that this object references.")


DocumentReference.referencedDocument = property(DocumentReference._get_referencedDocument, doc="The document currently open in Fusion 360 that this object references.")


DocumentReference.version = property(DocumentReference._get_version, DocumentReference._set_version, doc="Gets and sets the version of the dataFile on A360 that this document currently represents.\nSetting this property will cause all occurrences referencing this document to update to\nthat version.")


DocumentReference.parentDocument = property(DocumentReference._get_parentDocument, doc="The document that is doing the referencing and owns this reference.")


DocumentReference.isOutOfDate = property(DocumentReference._get_isOutOfDate, doc="Indicates if this reference is out of date, meaning that the reference\nis not referencing the latest version.")


DocumentReference.cast = lambda arg: arg if isinstance(arg, DocumentReference) else None

class DocumentReferences(Base):
    r"""Provides access to the list of documents referenced from a document."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::DocumentReferences *":
        return _core.DocumentReferences___deref__(self)

    def __eq__(self, rhs: "DocumentReferences") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.DocumentReferences___eq__(self, rhs)


    def __ne__(self, rhs: "DocumentReferences") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.DocumentReferences___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.DocumentReferences___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::DocumentReference >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.DocumentReferences___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.DocumentReferences_classType()
    __swig_destroy__ = _core.delete_DocumentReferences

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::DocumentReference >":
        r"""
        Returns the specified DocumentReference. 
        index : The index of the object to return where the first one in the collection has an index of 0. 
        Returns the specified DocumentReference or null if an invalid index was specified.
        """
        return _core.DocumentReferences_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of DocumentReference objects in this collection."""
        return _core.DocumentReferences__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _core.DocumentReferences__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.DocumentReferences__get_isValid(self)

# Register DocumentReferences in _core:
_core.DocumentReferences_swigregister(DocumentReferences)

def DocumentReferences_classType() -> "char const *":
    return _core.DocumentReferences_classType()


DocumentReferences.count = property(DocumentReferences._get_count, doc="The number of DocumentReference objects in this collection.")


DocumentReferences.cast = lambda arg: arg if isinstance(arg, DocumentReferences) else None

class Documents(Base):
    r"""
    The Documents object provides access to all of the currently open documents and
    provides methods to create and open documents.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Documents *":
        return _core.Documents___deref__(self)

    def __eq__(self, rhs: "Documents") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Documents___eq__(self, rhs)


    def __ne__(self, rhs: "Documents") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Documents___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.Documents___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::Document >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.Documents___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.Documents_classType()
    __swig_destroy__ = _core.delete_Documents

    def add(self, *args) -> "adsk::core::Ptr< adsk::core::Document >":
        r"""
        Creates and opens a new document of the specified type. 
        documentType : A value from the DocumentTypes enum that specifies the type of document to create. 
        visible : Optional argument specifying is the document should be visible or not. Currently, documents can only
        be created visibly so this argument must always be true. 
        options : Various options that are supported that are specific to the document type. See the documentation
        for the DocumentTypes enum for information about the options supported for the various types. 
        Returns the created document
        """
        return _core.Documents_add(self, *args)

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::Document >":
        r"""
        Function that returns the specified document using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.Documents_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of currently open files."""
        return _core.Documents__get_count(self)

    def open(self, dataFile: "DataFile", visible: "bool"=True) -> "adsk::core::Ptr< adsk::core::Document >":
        r"""
        Opens an item that has previously been saved. 
        dataFile : The item to open. 
        visible : Specifies if the document should be opened visibly or not. Currently, documents can only
        be opened visibly so this argument must always be true. 
        Returns the open document or null if the open failed.
        """
        return _core.Documents_open(self, dataFile, visible)

    def _get_objectType(self) -> "char const *":
        return _core.Documents__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Documents__get_isValid(self)

# Register Documents in _core:
_core.Documents_swigregister(Documents)

def Documents_classType() -> "char const *":
    return _core.Documents_classType()


Documents.count = property(Documents._get_count, doc="Returns the number of currently open files.")


Documents.cast = lambda arg: arg if isinstance(arg, Documents) else None

class Event(Base):
    r"""
    Objects can have several Event properties that fire when
    some 'event' occurs. Clients can attach EventHandlers
    to one or more Events and they get notified when the 'event' occurs.
    This is a base class - classes like DocumentEvent add type safety
    (i.e. only allow the correct type of handler to be added to them).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Event *":
        return _core.Event___deref__(self)

    def __eq__(self, rhs: "Event") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Event___eq__(self, rhs)


    def __ne__(self, rhs: "Event") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Event___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Event_classType()
    __swig_destroy__ = _core.delete_Event

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _core.Event__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.Event__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _core.Event__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Event__get_isValid(self)

# Register Event in _core:
_core.Event_swigregister(Event)

def Event_classType() -> "char const *":
    return _core.Event_classType()


Event.name = property(Event._get_name, doc="The name of the event - e.g. 'DocumentOpening'")


Event.sender = property(Event._get_sender, doc="The object that is firing the event. For example, in the case of a command\ninput event this will return the command.")


Event.cast = lambda arg: arg if isinstance(arg, Event) else None

class EventArgs(Base):
    r"""
    When an event handler is called, it is passed 
    an EventArgs object that describes the 'event'.
    This is a base class - classes like DocumentEventArgs add more information on
    the 'event'.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::EventArgs *":
        return _core.EventArgs___deref__(self)

    def __eq__(self, rhs: "EventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.EventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "EventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.EventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.EventArgs_classType()
    __swig_destroy__ = _core.delete_EventArgs

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _core.EventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _core.EventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.EventArgs__get_isValid(self)

# Register EventArgs in _core:
_core.EventArgs_swigregister(EventArgs)

def EventArgs_classType() -> "char const *":
    return _core.EventArgs_classType()


EventArgs.firingEvent = property(EventArgs._get_firingEvent, doc="The event that the firing is in response to.")


EventArgs.cast = lambda arg: arg if isinstance(arg, EventArgs) else None

class FavoriteAppearances(Base):
    r"""Collection of the favorite appearances."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::FavoriteAppearances *":
        return _core.FavoriteAppearances___deref__(self)

    def __eq__(self, rhs: "FavoriteAppearances") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.FavoriteAppearances___eq__(self, rhs)


    def __ne__(self, rhs: "FavoriteAppearances") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.FavoriteAppearances___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.FavoriteAppearances___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::Appearance >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.FavoriteAppearances___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.FavoriteAppearances_classType()
    __swig_destroy__ = _core.delete_FavoriteAppearances

    def item(self, index: "int") -> "adsk::core::Ptr< adsk::core::Appearance >":
        r"""
        Returns the specified Appearance using an index into the collection. 
        index : The index of the appearance to return where the first item in the collection is 0. 
        Returns the specified appearance or null if an invalid index is specified.
        """
        return _core.FavoriteAppearances_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of Appearances in the collection."""
        return _core.FavoriteAppearances__get_count(self)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::core::Appearance >":
        r"""
        Returns the specified appearance using the name as seen in the user interface. This often isn't
        a reliable way of accessing a specific appearance because appearances are not required to be unique. 
        name : The name of the appearance to return,. 
        Returns the specified appearance or null if there isn't a matching name.
        """
        return _core.FavoriteAppearances_itemByName(self, name)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::Appearance >":
        r"""
        Returns the Appearance by it's internal unique ID. 
        id : The ID of the appearance to return. 
        Returns the specified appearance or null if there isn't a matching ID.
        """
        return _core.FavoriteAppearances_itemById(self, id)

    def add(self, appearance: "Appearance") -> "adsk::core::Ptr< adsk::core::Appearance >":
        r"""
        Adds an existing appearance to the Favorites list 
        appearance : The appearance to be added to the favorites list. This can come from a Library or from a Design. 
        Returns the Appearance added to the favorites list or null if the operation failed.
        """
        return _core.FavoriteAppearances_add(self, appearance)

    def _get_objectType(self) -> "char const *":
        return _core.FavoriteAppearances__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.FavoriteAppearances__get_isValid(self)

# Register FavoriteAppearances in _core:
_core.FavoriteAppearances_swigregister(FavoriteAppearances)

def FavoriteAppearances_classType() -> "char const *":
    return _core.FavoriteAppearances_classType()


FavoriteAppearances.count = property(FavoriteAppearances._get_count, doc="The number of Appearances in the collection.")


FavoriteAppearances.cast = lambda arg: arg if isinstance(arg, FavoriteAppearances) else None

class FavoriteMaterials(Base):
    r"""Collection of the favorite materials."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::FavoriteMaterials *":
        return _core.FavoriteMaterials___deref__(self)

    def __eq__(self, rhs: "FavoriteMaterials") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.FavoriteMaterials___eq__(self, rhs)


    def __ne__(self, rhs: "FavoriteMaterials") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.FavoriteMaterials___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.FavoriteMaterials___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::Material >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.FavoriteMaterials___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.FavoriteMaterials_classType()
    __swig_destroy__ = _core.delete_FavoriteMaterials

    def item(self, index: "int") -> "adsk::core::Ptr< adsk::core::Material >":
        r"""
        Returns the specified Material using an index into the collection. 
        index : The index of the material to return where the first item in the collection is 0. 
        Returns the specified material or null if an invalid index is specified.
        """
        return _core.FavoriteMaterials_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of Materials in the collection."""
        return _core.FavoriteMaterials__get_count(self)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::core::Material >":
        r"""
        Returns the specified Material using the name as seen in the user interface. This often isn't
        a reliable way of accessing a specific material because materials are not required to be unique. 
        name : The name of the material to return,. 
        Returns the specified material or null if there isn't a matching name.
        """
        return _core.FavoriteMaterials_itemByName(self, name)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::Material >":
        r"""
        Returns the Material by it's internal unique ID. 
        id : The ID of the material to return. 
        Returns the specified material or null if there isn't a matching ID.
        """
        return _core.FavoriteMaterials_itemById(self, id)

    def add(self, material: "Material") -> "adsk::core::Ptr< adsk::core::Material >":
        r"""
        Adds an existing material to the Favorites list 
        material : The material to be added to the favorites list. This can come from a Library or from a Design. 
        Returns the Material added to the favorites list or null if the operation failed.
        """
        return _core.FavoriteMaterials_add(self, material)

    def _get_objectType(self) -> "char const *":
        return _core.FavoriteMaterials__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.FavoriteMaterials__get_isValid(self)

# Register FavoriteMaterials in _core:
_core.FavoriteMaterials_swigregister(FavoriteMaterials)

def FavoriteMaterials_classType() -> "char const *":
    return _core.FavoriteMaterials_classType()


FavoriteMaterials.count = property(FavoriteMaterials._get_count, doc="The number of Materials in the collection.")


FavoriteMaterials.cast = lambda arg: arg if isinstance(arg, FavoriteMaterials) else None

class FileDialog(Base):
    r"""
    Provides access to a file dialog. A file dialog can be used to prompt the user
    for file names to open or save to.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::FileDialog *":
        return _core.FileDialog___deref__(self)

    def __eq__(self, rhs: "FileDialog") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.FileDialog___eq__(self, rhs)


    def __ne__(self, rhs: "FileDialog") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.FileDialog___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.FileDialog_classType()
    __swig_destroy__ = _core.delete_FileDialog

    def _get_title(self) -> "std::string":
        r"""Gets or sets the title displayed on the dialog."""
        return _core.FileDialog__get_title(self)

    def _set_title(self, value: "std::string const &") -> "bool":
        r"""Gets or sets the title displayed on the dialog."""
        return _core.FileDialog__set_title(self, value)

    def _get_filename(self) -> "std::string":
        r"""
        Gets the filename specified by the user in the dialog. This property is 
        used after the ShowOpen or ShowSave methods have been called to retrieve
        the filename specified by the user. The file name includes both the 
        file path and the extension.
        If ShowOpen was used and IsMultiSelectEnabled is true, then this property will
        only display the first filename selected and the Filenames property should be
        used instead to retrieved the full list. Is ShowSave was used, then only a
        single file name is ever returned.
        """
        return _core.FileDialog__get_filename(self)

    def _get_filenames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Gets the filenames specified by the user in the dialog. This property is 
        used after the ShowOpen or ShowSave methods have been called to retrieve
        the filenames specified by the user. Each file name includes both the 
        file path and the extension.
        If ShowOpen is used and IsMultiSelectEnabled is true, the user is able to select
        more than one file. This property returns all of the files that were selected. If
        ShowSave is used or IsMultiSelectEnabled is false then this array will contain
        the single file name.
        """
        return _core.FileDialog__get_filenames(self)

    def _get_filter(self) -> "std::string":
        r"""
        Gets or sets the current file name filter string, which determines the choices 
        that appear in the 'Save as file type' or 'Files of type' box in the dialog box.
        For each filtering option, the filter string contains a description of the filter 
        and the filter pattern as specified in parentheses and seperated by semi-colons. Multiple
        filters are seperated by a double semi-colon. These are illustrated below.
        The following is an example of a filter string: 
        Text files (*.txt);;All files (*.*) 
        You can add several filter patterns to a filter by separating the file types with semicolons, for example: 
        Image Files (*.BMP;*.JPG;*.GIF);;All files (*.*)
        """
        return _core.FileDialog__get_filter(self)

    def _set_filter(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the current file name filter string, which determines the choices 
        that appear in the 'Save as file type' or 'Files of type' box in the dialog box.
        For each filtering option, the filter string contains a description of the filter 
        and the filter pattern as specified in parentheses and seperated by semi-colons. Multiple
        filters are seperated by a double semi-colon. These are illustrated below.
        The following is an example of a filter string: 
        Text files (*.txt);;All files (*.*) 
        You can add several filter patterns to a filter by separating the file types with semicolons, for example: 
        Image Files (*.BMP;*.JPG;*.GIF);;All files (*.*)
        """
        return _core.FileDialog__set_filter(self, value)

    def _get_filterIndex(self) -> "int":
        r"""
        Gets or sets the index of the filter currently selected in the file dialog box. Use the FilterIndex 
        property to set which filtering option is shown first to the user. You can also use the value of 
        FilterIndex after showing the file dialog to perform special file operations depending upon the filter chosen.
        The first item in the filter list is index 0.
        """
        return _core.FileDialog__get_filterIndex(self)

    def _set_filterIndex(self, value: "int") -> "bool":
        r"""
        Gets or sets the index of the filter currently selected in the file dialog box. Use the FilterIndex 
        property to set which filtering option is shown first to the user. You can also use the value of 
        FilterIndex after showing the file dialog to perform special file operations depending upon the filter chosen.
        The first item in the filter list is index 0.
        """
        return _core.FileDialog__set_filterIndex(self, value)

    def _get_initialDirectory(self) -> "std::string":
        r"""Gets or sets the initial directory displayed by the file dialog box."""
        return _core.FileDialog__get_initialDirectory(self)

    def _set_initialDirectory(self, value: "std::string const &") -> "bool":
        r"""Gets or sets the initial directory displayed by the file dialog box."""
        return _core.FileDialog__set_initialDirectory(self, value)

    def _get_isMultiSelectEnabled(self) -> "bool":
        r"""Gets or sets a value indicating whether the dialog box allows multiple files to be selected."""
        return _core.FileDialog__get_isMultiSelectEnabled(self)

    def _set_isMultiSelectEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets a value indicating whether the dialog box allows multiple files to be selected."""
        return _core.FileDialog__set_isMultiSelectEnabled(self, value)

    def showOpen(self) -> "adsk::core::DialogResults":
        r"""
        Displays a modal open dialog, allowing the user to select one or more files. The return value
        can be used to determine if the dialog was cancelled without selecting a file. The Filename
        and Filenames properties can be used to get the selected files. 
        Returns an enum value indicating which button was clicked on the dialog.
        """
        return _core.FileDialog_showOpen(self)

    def showSave(self) -> "adsk::core::DialogResults":
        r"""
        Displays a modal save dialog, allowing the user to specify a file. The return value
        can be used to determine if the dialog was cancelled without selecting a file. The Filename
        and Filenames properties can be used to get the selected files. 
        Returns an enum value indicating which button was clicked on the dialog.
        """
        return _core.FileDialog_showSave(self)

    def _get_initialFilename(self) -> "std::string":
        r"""
        Gets or sets the initial filename displayed when the dialog is first displayed.
        When a new FileDialog object is created this defaults to an empty string so no
        initial filename is specified. 
        If the showOpen option is used, the file must 
        already exist in the directory specified by the initialDirectory property. If 
        it doesn't exist, the initial filename will not be used.
        """
        return _core.FileDialog__get_initialFilename(self)

    def _set_initialFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the initial filename displayed when the dialog is first displayed.
        When a new FileDialog object is created this defaults to an empty string so no
        initial filename is specified. 
        If the showOpen option is used, the file must 
        already exist in the directory specified by the initialDirectory property. If 
        it doesn't exist, the initial filename will not be used.
        """
        return _core.FileDialog__set_initialFilename(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.FileDialog__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.FileDialog__get_isValid(self)

# Register FileDialog in _core:
_core.FileDialog_swigregister(FileDialog)

def FileDialog_classType() -> "char const *":
    return _core.FileDialog_classType()


FileDialog.title = property(FileDialog._get_title, FileDialog._set_title, doc="Gets or sets the title displayed on the dialog.")


FileDialog.filename = property(FileDialog._get_filename, doc="Gets the filename specified by the user in the dialog. This property is\nused after the ShowOpen or ShowSave methods have been called to retrieve\nthe filename specified by the user. The file name includes both the\nfile path and the extension.\nIf ShowOpen was used and IsMultiSelectEnabled is true, then this property will\nonly display the first filename selected and the Filenames property should be\nused instead to retrieved the full list. Is ShowSave was used, then only a\nsingle file name is ever returned.")


FileDialog.filenames = property(FileDialog._get_filenames, doc="Gets the filenames specified by the user in the dialog. This property is\nused after the ShowOpen or ShowSave methods have been called to retrieve\nthe filenames specified by the user. Each file name includes both the\nfile path and the extension.\nIf ShowOpen is used and IsMultiSelectEnabled is true, the user is able to select\nmore than one file. This property returns all of the files that were selected. If\nShowSave is used or IsMultiSelectEnabled is false then this array will contain\nthe single file name.")


FileDialog.filter = property(FileDialog._get_filter, FileDialog._set_filter, doc="Gets or sets the current file name filter string, which determines the choices\nthat appear in the 'Save as file type' or 'Files of type' box in the dialog box.\nFor each filtering option, the filter string contains a description of the filter\nand the filter pattern as specified in parentheses and seperated by semi-colons. Multiple\nfilters are seperated by a double semi-colon. These are illustrated below.\nThe following is an example of a filter string:\nText files (*.txt);;All files (*.*)\nYou can add several filter patterns to a filter by separating the file types with semicolons, for example:\nImage Files (*.BMP;*.JPG;*.GIF);;All files (*.*)")


FileDialog.filterIndex = property(FileDialog._get_filterIndex, FileDialog._set_filterIndex, doc="Gets or sets the index of the filter currently selected in the file dialog box. Use the FilterIndex\nproperty to set which filtering option is shown first to the user. You can also use the value of\nFilterIndex after showing the file dialog to perform special file operations depending upon the filter chosen.\nThe first item in the filter list is index 0.")


FileDialog.initialDirectory = property(FileDialog._get_initialDirectory, FileDialog._set_initialDirectory, doc="Gets or sets the initial directory displayed by the file dialog box.")


FileDialog.isMultiSelectEnabled = property(FileDialog._get_isMultiSelectEnabled, FileDialog._set_isMultiSelectEnabled, doc="Gets or sets a value indicating whether the dialog box allows multiple files to be selected.")


FileDialog.initialFilename = property(FileDialog._get_initialFilename, FileDialog._set_initialFilename, doc="Gets or sets the initial filename displayed when the dialog is first displayed.\nWhen a new FileDialog object is created this defaults to an empty string so no\ninitial filename is specified.\nIf the showOpen option is used, the file must\nalready exist in the directory specified by the initialDirectory property. If\nit doesn't exist, the initial filename will not be used.")


FileDialog.cast = lambda arg: arg if isinstance(arg, FileDialog) else None

class FolderDialog(Base):
    r"""Provides access to a folder selection dialog to allow the user to select a folder."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::FolderDialog *":
        return _core.FolderDialog___deref__(self)

    def __eq__(self, rhs: "FolderDialog") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.FolderDialog___eq__(self, rhs)


    def __ne__(self, rhs: "FolderDialog") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.FolderDialog___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.FolderDialog_classType()
    __swig_destroy__ = _core.delete_FolderDialog

    def _get_title(self) -> "std::string":
        r"""Gets or sets the title displayed on the dialog."""
        return _core.FolderDialog__get_title(self)

    def _set_title(self, value: "std::string const &") -> "bool":
        r"""Gets or sets the title displayed on the dialog."""
        return _core.FolderDialog__set_title(self, value)

    def _get_folder(self) -> "std::string":
        r"""
        Gets the folder selected by the user in the dialog. This property is 
        used after the ShowDialog method has been called to retrieve the folder
        specified by the user.
        """
        return _core.FolderDialog__get_folder(self)

    def _get_initialDirectory(self) -> "std::string":
        r"""Gets or sets the initial directory displayed by the file dialog box."""
        return _core.FolderDialog__get_initialDirectory(self)

    def _set_initialDirectory(self, value: "std::string const &") -> "bool":
        r"""Gets or sets the initial directory displayed by the file dialog box."""
        return _core.FolderDialog__set_initialDirectory(self, value)

    def showDialog(self) -> "adsk::core::DialogResults":
        r"""
        Displays a modal dialog allowing the user to select a folder. The return value
        can be used to determine if the dialog was cancelled without selecting a foldre. 
        the folder property can be used to get the selected folder. 
        Returns an enum value indicating which button was clicked on the dialog.
        """
        return _core.FolderDialog_showDialog(self)

    def _get_objectType(self) -> "char const *":
        return _core.FolderDialog__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.FolderDialog__get_isValid(self)

# Register FolderDialog in _core:
_core.FolderDialog_swigregister(FolderDialog)

def FolderDialog_classType() -> "char const *":
    return _core.FolderDialog_classType()


FolderDialog.title = property(FolderDialog._get_title, FolderDialog._set_title, doc="Gets or sets the title displayed on the dialog.")


FolderDialog.folder = property(FolderDialog._get_folder, doc="Gets the folder selected by the user in the dialog. This property is\nused after the ShowDialog method has been called to retrieve the folder\nspecified by the user.")


FolderDialog.initialDirectory = property(FolderDialog._get_initialDirectory, FolderDialog._set_initialDirectory, doc="Gets or sets the initial directory displayed by the file dialog box.")


FolderDialog.cast = lambda arg: arg if isinstance(arg, FolderDialog) else None

class GeneralPreferences(Base):
    r"""Provides access to the general preferences."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::GeneralPreferences *":
        return _core.GeneralPreferences___deref__(self)

    def __eq__(self, rhs: "GeneralPreferences") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.GeneralPreferences___eq__(self, rhs)


    def __ne__(self, rhs: "GeneralPreferences") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.GeneralPreferences___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.GeneralPreferences_classType()
    __swig_destroy__ = _core.delete_GeneralPreferences

    def _get_userLanguage(self) -> "adsk::core::UserLanguages":
        r"""
        Gets and sets the current language. Setting the language does not
        take effect until the next time Fusion 360 is started.
        """
        return _core.GeneralPreferences__get_userLanguage(self)

    def _set_userLanguage(self, value: "UserLanguages") -> "bool":
        r"""
        Gets and sets the current language. Setting the language does not
        take effect until the next time Fusion 360 is started.
        """
        return _core.GeneralPreferences__set_userLanguage(self, value)

    def _get_offlineCachePeriod(self) -> "double":
        r"""Gets and sets the length of time, in days, that the offline cache of a document will remain."""
        return _core.GeneralPreferences__get_offlineCachePeriod(self)

    def _set_offlineCachePeriod(self, value: "double") -> "bool":
        r"""Gets and sets the length of time, in days, that the offline cache of a document will remain."""
        return _core.GeneralPreferences__set_offlineCachePeriod(self, value)

    def _get_graphicsDriver(self) -> "adsk::core::GraphicsDrivers":
        r"""Gets and sets the graphics driver used to display the graphics."""
        return _core.GeneralPreferences__get_graphicsDriver(self)

    def _set_graphicsDriver(self, value: "GraphicsDrivers") -> "bool":
        r"""Gets and sets the graphics driver used to display the graphics."""
        return _core.GeneralPreferences__set_graphicsDriver(self, value)

    def _get_isAutomaticSaveOnCloseEnabled(self) -> "bool":
        r"""Gets and sets if the file is automatically saved on close."""
        return _core.GeneralPreferences__get_isAutomaticSaveOnCloseEnabled(self)

    def _set_isAutomaticSaveOnCloseEnabled(self, value: "bool") -> "bool":
        r"""Gets and sets if the file is automatically saved on close."""
        return _core.GeneralPreferences__set_isAutomaticSaveOnCloseEnabled(self, value)

    def _get_isAutomaticVersioningEnabled(self) -> "bool":
        r"""Gets and sets if a version of the file is automatically saved using a background thread."""
        return _core.GeneralPreferences__get_isAutomaticVersioningEnabled(self)

    def _set_isAutomaticVersioningEnabled(self, value: "bool") -> "bool":
        r"""Gets and sets if a version of the file is automatically saved using a background thread."""
        return _core.GeneralPreferences__set_isAutomaticVersioningEnabled(self, value)

    def _get_automateVersioningTimeInterval(self) -> "int":
        r"""Gets and sets the interval, in minutes, for automatic versioning."""
        return _core.GeneralPreferences__get_automateVersioningTimeInterval(self)

    def _set_automateVersioningTimeInterval(self, value: "int") -> "bool":
        r"""Gets and sets the interval, in minutes, for automatic versioning."""
        return _core.GeneralPreferences__set_automateVersioningTimeInterval(self, value)

    def _get_defaultModelingOrientation(self) -> "adsk::core::DefaultModelingOrientations":
        r"""Gets and sets the default for which direction is considered 'up'."""
        return _core.GeneralPreferences__get_defaultModelingOrientation(self)

    def _set_defaultModelingOrientation(self, value: "DefaultModelingOrientations") -> "bool":
        r"""Gets and sets the default for which direction is considered 'up'."""
        return _core.GeneralPreferences__set_defaultModelingOrientation(self, value)

    def _get_areTooltipsShown(self) -> "bool":
        r"""Gets and sets if tooltips are shown."""
        return _core.GeneralPreferences__get_areTooltipsShown(self)

    def _set_areTooltipsShown(self, value: "bool") -> "bool":
        r"""Gets and sets if tooltips are shown."""
        return _core.GeneralPreferences__set_areTooltipsShown(self, value)

    def _get_isCommandPromptShown(self) -> "bool":
        r"""Gets and sets if the command prompt is shown."""
        return _core.GeneralPreferences__get_isCommandPromptShown(self)

    def _set_isCommandPromptShown(self, value: "bool") -> "bool":
        r"""Gets and sets if the command prompt is shown."""
        return _core.GeneralPreferences__set_isCommandPromptShown(self, value)

    def _get_areTipsAndTricksShown(self) -> "bool":
        r"""Gets and sets if in command tips and tricks are shown."""
        return _core.GeneralPreferences__get_areTipsAndTricksShown(self)

    def _set_areTipsAndTricksShown(self, value: "bool") -> "bool":
        r"""Gets and sets if in command tips and tricks are shown."""
        return _core.GeneralPreferences__set_areTipsAndTricksShown(self, value)

    def _get_areInCommandErrorsAndWarningsShown(self) -> "bool":
        r"""Gets and sets if in command errors and warnings are shown."""
        return _core.GeneralPreferences__get_areInCommandErrorsAndWarningsShown(self)

    def _set_areInCommandErrorsAndWarningsShown(self, value: "bool") -> "bool":
        r"""Gets and sets if in command errors and warnings are shown."""
        return _core.GeneralPreferences__set_areInCommandErrorsAndWarningsShown(self, value)

    def _get_areAutodesk360NotificationsShown(self) -> "bool":
        r"""Gets and sets if Autodesk 360 notifications are shown."""
        return _core.GeneralPreferences__get_areAutodesk360NotificationsShown(self)

    def _set_areAutodesk360NotificationsShown(self, value: "bool") -> "bool":
        r"""Gets and sets if Autodesk 360 notifications are shown."""
        return _core.GeneralPreferences__set_areAutodesk360NotificationsShown(self, value)

    def _get_isGestureBasedViewNavigationUsed(self) -> "bool":
        r"""Gets and sets if gesture based view navigation is used."""
        return _core.GeneralPreferences__get_isGestureBasedViewNavigationUsed(self)

    def _set_isGestureBasedViewNavigationUsed(self, value: "bool") -> "bool":
        r"""Gets and sets if gesture based view navigation is used."""
        return _core.GeneralPreferences__set_isGestureBasedViewNavigationUsed(self, value)

    def _get_isZoomDirectionReversed(self) -> "bool":
        r"""Gets and sets if the direction of the zoom is reversed."""
        return _core.GeneralPreferences__get_isZoomDirectionReversed(self)

    def _set_isZoomDirectionReversed(self, value: "bool") -> "bool":
        r"""Gets and sets if the direction of the zoom is reversed."""
        return _core.GeneralPreferences__set_isZoomDirectionReversed(self, value)

    def _get_isCameraPivotEnabled(self) -> "bool":
        r"""Gets and sets if zoom and orbit commands use camera pivot point for transition."""
        return _core.GeneralPreferences__get_isCameraPivotEnabled(self)

    def _set_isCameraPivotEnabled(self, value: "bool") -> "bool":
        r"""Gets and sets if zoom and orbit commands use camera pivot point for transition."""
        return _core.GeneralPreferences__set_isCameraPivotEnabled(self, value)

    def _get_defaultOrbit(self) -> "adsk::core::DefaultOrbits":
        r"""Get and sets the type of orbit."""
        return _core.GeneralPreferences__get_defaultOrbit(self)

    def _set_defaultOrbit(self, value: "DefaultOrbits") -> "bool":
        r"""Get and sets the type of orbit."""
        return _core.GeneralPreferences__set_defaultOrbit(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.GeneralPreferences__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.GeneralPreferences__get_isValid(self)

# Register GeneralPreferences in _core:
_core.GeneralPreferences_swigregister(GeneralPreferences)

def GeneralPreferences_classType() -> "char const *":
    return _core.GeneralPreferences_classType()


GeneralPreferences.userLanguage = property(GeneralPreferences._get_userLanguage, GeneralPreferences._set_userLanguage, doc="Gets and sets the current language. Setting the language does not\ntake effect until the next time Fusion 360 is started.")


GeneralPreferences.offlineCachePeriod = property(GeneralPreferences._get_offlineCachePeriod, GeneralPreferences._set_offlineCachePeriod, doc="Gets and sets the length of time, in days, that the offline cache of a document will remain.")


GeneralPreferences.graphicsDriver = property(GeneralPreferences._get_graphicsDriver, GeneralPreferences._set_graphicsDriver, doc="Gets and sets the graphics driver used to display the graphics.")


GeneralPreferences.isAutomaticSaveOnCloseEnabled = property(GeneralPreferences._get_isAutomaticSaveOnCloseEnabled, GeneralPreferences._set_isAutomaticSaveOnCloseEnabled, doc="Gets and sets if the file is automatically saved on close.")


GeneralPreferences.isAutomaticVersioningEnabled = property(GeneralPreferences._get_isAutomaticVersioningEnabled, GeneralPreferences._set_isAutomaticVersioningEnabled, doc="Gets and sets if a version of the file is automatically saved using a background thread.")


GeneralPreferences.automateVersioningTimeInterval = property(GeneralPreferences._get_automateVersioningTimeInterval, GeneralPreferences._set_automateVersioningTimeInterval, doc="Gets and sets the interval, in minutes, for automatic versioning.")


GeneralPreferences.defaultModelingOrientation = property(GeneralPreferences._get_defaultModelingOrientation, GeneralPreferences._set_defaultModelingOrientation, doc="Gets and sets the default for which direction is considered 'up'.")


GeneralPreferences.areTooltipsShown = property(GeneralPreferences._get_areTooltipsShown, GeneralPreferences._set_areTooltipsShown, doc="Gets and sets if tooltips are shown.")


GeneralPreferences.isCommandPromptShown = property(GeneralPreferences._get_isCommandPromptShown, GeneralPreferences._set_isCommandPromptShown, doc="Gets and sets if the command prompt is shown.")


GeneralPreferences.areTipsAndTricksShown = property(GeneralPreferences._get_areTipsAndTricksShown, GeneralPreferences._set_areTipsAndTricksShown, doc="Gets and sets if in command tips and tricks are shown.")


GeneralPreferences.areInCommandErrorsAndWarningsShown = property(GeneralPreferences._get_areInCommandErrorsAndWarningsShown, GeneralPreferences._set_areInCommandErrorsAndWarningsShown, doc="Gets and sets if in command errors and warnings are shown.")


GeneralPreferences.areAutodesk360NotificationsShown = property(GeneralPreferences._get_areAutodesk360NotificationsShown, GeneralPreferences._set_areAutodesk360NotificationsShown, doc="Gets and sets if Autodesk 360 notifications are shown.")


GeneralPreferences.isGestureBasedViewNavigationUsed = property(GeneralPreferences._get_isGestureBasedViewNavigationUsed, GeneralPreferences._set_isGestureBasedViewNavigationUsed, doc="Gets and sets if gesture based view navigation is used.")


GeneralPreferences.isZoomDirectionReversed = property(GeneralPreferences._get_isZoomDirectionReversed, GeneralPreferences._set_isZoomDirectionReversed, doc="Gets and sets if the direction of the zoom is reversed.")


GeneralPreferences.isCameraPivotEnabled = property(GeneralPreferences._get_isCameraPivotEnabled, GeneralPreferences._set_isCameraPivotEnabled, doc="Gets and sets if zoom and orbit commands use camera pivot point for transition.")


GeneralPreferences.defaultOrbit = property(GeneralPreferences._get_defaultOrbit, GeneralPreferences._set_defaultOrbit, doc="Get and sets the type of orbit.")


GeneralPreferences.cast = lambda arg: arg if isinstance(arg, GeneralPreferences) else None

class GraphicsPreferences(Base):
    r"""The GraphicsPreferences object provides access to the various graphics related preferences."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::GraphicsPreferences *":
        return _core.GraphicsPreferences___deref__(self)

    def __eq__(self, rhs: "GraphicsPreferences") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.GraphicsPreferences___eq__(self, rhs)


    def __ne__(self, rhs: "GraphicsPreferences") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.GraphicsPreferences___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.GraphicsPreferences_classType()
    __swig_destroy__ = _core.delete_GraphicsPreferences

    def _get_minimumFramesPerSecond(self) -> "double":
        r"""Gets and sets the minimum frames per second."""
        return _core.GraphicsPreferences__get_minimumFramesPerSecond(self)

    def _set_minimumFramesPerSecond(self, value: "double") -> "bool":
        r"""Gets and sets the minimum frames per second."""
        return _core.GraphicsPreferences__set_minimumFramesPerSecond(self, value)

    def _get_selectionDisplayStyle(self) -> "adsk::core::SelectionDisplayStyles":
        r"""Gets and sets the style of display to use for selections."""
        return _core.GraphicsPreferences__get_selectionDisplayStyle(self)

    def _set_selectionDisplayStyle(self, value: "SelectionDisplayStyles") -> "bool":
        r"""Gets and sets the style of display to use for selections."""
        return _core.GraphicsPreferences__set_selectionDisplayStyle(self, value)

    def _get_degradedSelectionDisplayStyle(self) -> "adsk::core::DegradedSelectionDisplayStyles":
        r"""Gets and sets the style of display for degraded selections."""
        return _core.GraphicsPreferences__get_degradedSelectionDisplayStyle(self)

    def _set_degradedSelectionDisplayStyle(self, value: "DegradedSelectionDisplayStyles") -> "bool":
        r"""Gets and sets the style of display for degraded selections."""
        return _core.GraphicsPreferences__set_degradedSelectionDisplayStyle(self, value)

    def _get_transparencyEffects(self) -> "adsk::core::TransparencyDisplayEffects":
        r"""Gets and sets the style of display for transparency effects."""
        return _core.GraphicsPreferences__get_transparencyEffects(self)

    def _set_transparencyEffects(self, value: "TransparencyDisplayEffects") -> "bool":
        r"""Gets and sets the style of display for transparency effects."""
        return _core.GraphicsPreferences__set_transparencyEffects(self, value)

    def _get_autoThrottleEffects(self) -> "bool":
        r"""Gets and sets if automatically disable or degrade visual effects to keep the video memory pressure under a safe threshold."""
        return _core.GraphicsPreferences__get_autoThrottleEffects(self)

    def _set_autoThrottleEffects(self, value: "bool") -> "bool":
        r"""Gets and sets if automatically disable or degrade visual effects to keep the video memory pressure under a safe threshold."""
        return _core.GraphicsPreferences__set_autoThrottleEffects(self, value)

    def _get_hiddenEdgeDimming(self) -> "int":
        r"""
        Gets and sets the dimming percentage to use for hidden edges.
        the value is a percentage expressed by a value between 0 and 100.
        """
        return _core.GraphicsPreferences__get_hiddenEdgeDimming(self)

    def _set_hiddenEdgeDimming(self, value: "int") -> "bool":
        r"""
        Gets and sets the dimming percentage to use for hidden edges.
        the value is a percentage expressed by a value between 0 and 100.
        """
        return _core.GraphicsPreferences__set_hiddenEdgeDimming(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.GraphicsPreferences__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.GraphicsPreferences__get_isValid(self)

# Register GraphicsPreferences in _core:
_core.GraphicsPreferences_swigregister(GraphicsPreferences)

def GraphicsPreferences_classType() -> "char const *":
    return _core.GraphicsPreferences_classType()


GraphicsPreferences.minimumFramesPerSecond = property(GraphicsPreferences._get_minimumFramesPerSecond, GraphicsPreferences._set_minimumFramesPerSecond, doc="Gets and sets the minimum frames per second.")


GraphicsPreferences.selectionDisplayStyle = property(GraphicsPreferences._get_selectionDisplayStyle, GraphicsPreferences._set_selectionDisplayStyle, doc="Gets and sets the style of display to use for selections.")


GraphicsPreferences.degradedSelectionDisplayStyle = property(GraphicsPreferences._get_degradedSelectionDisplayStyle, GraphicsPreferences._set_degradedSelectionDisplayStyle, doc="Gets and sets the style of display for degraded selections.")


GraphicsPreferences.transparencyEffects = property(GraphicsPreferences._get_transparencyEffects, GraphicsPreferences._set_transparencyEffects, doc="Gets and sets the style of display for transparency effects.")


GraphicsPreferences.autoThrottleEffects = property(GraphicsPreferences._get_autoThrottleEffects, GraphicsPreferences._set_autoThrottleEffects, doc="Gets and sets if automatically disable or degrade visual effects to keep the video memory pressure under a safe threshold.")


GraphicsPreferences.hiddenEdgeDimming = property(GraphicsPreferences._get_hiddenEdgeDimming, GraphicsPreferences._set_hiddenEdgeDimming, doc="Gets and sets the dimming percentage to use for hidden edges.\nthe value is a percentage expressed by a value between 0 and 100.")


GraphicsPreferences.cast = lambda arg: arg if isinstance(arg, GraphicsPreferences) else None

class GridPreferences(Base):
    r"""The GridPreferences object provides access to grid related preferences."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::GridPreferences *":
        return _core.GridPreferences___deref__(self)

    def __eq__(self, rhs: "GridPreferences") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.GridPreferences___eq__(self, rhs)


    def __ne__(self, rhs: "GridPreferences") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.GridPreferences___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.GridPreferences_classType()
    __swig_destroy__ = _core.delete_GridPreferences

    def _get_isLayoutGridLockEnabled(self) -> "bool":
        r"""Gets and sets if the layout grid lock is enabled."""
        return _core.GridPreferences__get_isLayoutGridLockEnabled(self)

    def _set_isLayoutGridLockEnabled(self, value: "bool") -> "bool":
        r"""Gets and sets if the layout grid lock is enabled."""
        return _core.GridPreferences__set_isLayoutGridLockEnabled(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.GridPreferences__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.GridPreferences__get_isValid(self)

# Register GridPreferences in _core:
_core.GridPreferences_swigregister(GridPreferences)

def GridPreferences_classType() -> "char const *":
    return _core.GridPreferences_classType()


GridPreferences.isLayoutGridLockEnabled = property(GridPreferences._get_isLayoutGridLockEnabled, GridPreferences._set_isLayoutGridLockEnabled, doc="Gets and sets if the layout grid lock is enabled.")


GridPreferences.cast = lambda arg: arg if isinstance(arg, GridPreferences) else None

class HTMLEventHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notify(self, eventArgs: "HTMLEventArgs") -> "void":
        return _core.HTMLEventHandler_notify(self, eventArgs)

    def __init__(self):
        if self.__class__ == HTMLEventHandler:
            _self = None
        else:
            _self = self
        _core.HTMLEventHandler_swiginit(self, _core.new_HTMLEventHandler(_self, ))
    __swig_destroy__ = _core.delete_HTMLEventHandler
    def __disown__(self):
        self.this.disown()
        _core.disown_HTMLEventHandler(self)
        return weakref.proxy(self)

# Register HTMLEventHandler in _core:
_core.HTMLEventHandler_swigregister(HTMLEventHandler)


HTMLEventHandler.cast = lambda arg: arg if isinstance(arg, HTMLEventHandler) else None

class ImportManager(Base):
    r"""Provides access to functionality to support importing various modeling formats into Fusion 360."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ImportManager *":
        return _core.ImportManager___deref__(self)

    def __eq__(self, rhs: "ImportManager") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ImportManager___eq__(self, rhs)


    def __ne__(self, rhs: "ImportManager") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ImportManager___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ImportManager_classType()
    __swig_destroy__ = _core.delete_ImportManager

    def createIGESImportOptions(self, filename: "std::string const &") -> "adsk::core::Ptr< adsk::core::IGESImportOptions >":
        r"""
        Creates an IGESImportOptions object that is used to import a design from IGES format. Creation
        of the IGESImportOptions object does not perform the import. You must pass this object to one of the
        ImportManager import methods to perform the import. The IGESImportOptions supports any available
        options when importing from IGES format. 
        filename : The filename or url of the IGES file to be imported. 
        The created IGESImportOptions object or null if the creation failed.
        """
        return _core.ImportManager_createIGESImportOptions(self, filename)

    def createSTEPImportOptions(self, filename: "std::string const &") -> "adsk::core::Ptr< adsk::core::STEPImportOptions >":
        r"""
        Creates an STEPImportOptions object that's used to import a design from STEP format. Creation
        of the STEPImportOptions object does not perform the import. You must pass this object to one of the
        ImportManager import methods to perform the import. The STEPImportOptions supports any available
        options when importing from STEP format. 
        filename : The filename or url of the STEP file to be imported. 
        The created STEPImportOptions object or null if the creation failed.
        """
        return _core.ImportManager_createSTEPImportOptions(self, filename)

    def createSATImportOptions(self, filename: "std::string const &") -> "adsk::core::Ptr< adsk::core::SATImportOptions >":
        r"""
        Creates an SATImportOptions object that's used to import a design from SAT format. Creation
        of the SATImportOptions object does not perform the import. You must pass this object to one of the
        ImportManager import methods to perform the import. The SATImportOptions supports any available
        options when importing from SAT format. 
        filename : The filename or url of the SAT file to be imported. 
        The created SATImportOptions object or null if the creation failed.
        """
        return _core.ImportManager_createSATImportOptions(self, filename)

    def createSMTImportOptions(self, filename: "std::string const &") -> "adsk::core::Ptr< adsk::core::SMTImportOptions >":
        r"""
        Creates an SMTImportOptions object that's used to import a design from SMT format. Creation
        of the SMTImportOptions object does not perform the import. You must pass this object to one of the
        ImportManager import methods to perform the import. The SMTImportOptions supports any available
        options when importing from SMT format. 
        filename : The filename or url of the SMT file to be imported. 
        The created SMTImportOptions object or null if the creation failed.
        """
        return _core.ImportManager_createSMTImportOptions(self, filename)

    def createFusionArchiveImportOptions(self, filename: "std::string const &") -> "adsk::core::Ptr< adsk::core::FusionArchiveImportOptions >":
        r"""
        Creates an FusionArchiveImportOptions object that is used to import a design from a Fusion 360 archive format. Creation
        of the FusionArchiveImportOptions object does not perform the import. You must pass this object to one of the
        ImportManager import methods to perform the import. The FusionArchiveImportOptions supports any available
        options when importing from Fusion 360 archive format. 
        filename : The filename or url of the Fusion 360 archive file to be imported. 
        .f3z files and .f3d files containing externally referenced designs are currently not supported. 
        The created FusionArchiveImportOptions object or null if the creation failed.
        """
        return _core.ImportManager_createFusionArchiveImportOptions(self, filename)

    def importToNewDocument(self, importOptions: "ImportOptions") -> "adsk::core::Ptr< adsk::core::Document >":
        r"""
        Executes the import operation to import a file (of the format specified by the input ImportOptions object) 
        to a new document.
        ***This method does not currently support the DXF2DImportOptions ImportOptions object.*** 
        importOptions : An ImportOptions object that is created using one of the create methods on the ImportManager object. This
        defines the type of file and any available options supported for that file type. 
        Returns the newly created Document object or null if the creation failed.
        A new unnamed, unsaved document will be opened in Fusion 360 as a result.
        """
        return _core.ImportManager_importToNewDocument(self, importOptions)

    def importToTarget(self, importOptions: "ImportOptions", target: "Base") -> "bool":
        r"""
        Executes the import operation to import a file (of the format specified by the input ImportOptions object) 
        into an existing component in an existing design. 
        importOptions : An ImportOptions object that is created using one of the create methods on the ImportManager object. This
        defines the type of file and any available options supported for that file type.
        Supplying a DXF2DImportOptions object will result in the creation of one or more sketches 
        (depending on the layers in the DXF file) in the target component. 
        target : Currently supports importing to a Fusion 360 Component. 
        Returns true if the import was successful.
        """
        return _core.ImportManager_importToTarget(self, importOptions, target)

    def createDXF2DImportOptions(self, filename: "std::string const &", planarEntity: "Base") -> "adsk::core::Ptr< adsk::core::DXF2DImportOptions >":
        r"""
        Creates a DXF2DImportOptions object that is used to import 2D data to create sketches. Creation
        of the createDXF2DImportOptions object does not perform the import. You must pass this object to the
        ImportManager.importToTarget method to perform the import. The sketches created as a result of
        the import are available through the 'results' property of the DXF2DImportOptions. 
        filename : The filename of the DXF file to be imported. 
        planarEntity : The construction plane or planar face that defines the plane that the resulting sketches will
        be created on. 
        The created DXF2DImportOptions object or null if the creation failed.
        """
        return _core.ImportManager_createDXF2DImportOptions(self, filename, planarEntity)

    def importToTarget2(self, importOptions: "ImportOptions", target: "Base") -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Executes the import operation to import a file (of the format specified by the input ImportOptions object) 
        into an existing component in an existing design and returns the imported objects. 
        importOptions : An ImportOptions object that is created using one of the create methods on the ImportManager object. This
        defines the type of file and any available options supported for that file type.
        Supplying a DXF2DImportOptions object will result in the creation of one or more sketches 
        (depending on the layers in the DXF file) in the target component. 
        target : Currently supports importing to a Fusion 360 Component. 
        Returns an ObjectCollection containing the results of whatever was created as a result of the import.
        null is returned in the case of failure.
        """
        return _core.ImportManager_importToTarget2(self, importOptions, target)

    def _get_objectType(self) -> "char const *":
        return _core.ImportManager__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ImportManager__get_isValid(self)

# Register ImportManager in _core:
_core.ImportManager_swigregister(ImportManager)

def ImportManager_classType() -> "char const *":
    return _core.ImportManager_classType()


ImportManager.cast = lambda arg: arg if isinstance(arg, ImportManager) else None

class ImportOptions(Base):
    r"""
    The base class for the different import types. This class is never directly used
    in an import because you need the specific import type to specify the type of
    import to be performed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ImportOptions *":
        return _core.ImportOptions___deref__(self)

    def __eq__(self, rhs: "ImportOptions") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ImportOptions___eq__(self, rhs)


    def __ne__(self, rhs: "ImportOptions") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ImportOptions___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ImportOptions_classType()
    __swig_destroy__ = _core.delete_ImportOptions

    def _get_filename(self) -> "std::string":
        r"""Gets and sets the filename or url of the file to be imported."""
        return _core.ImportOptions__get_filename(self)

    def _set_filename(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the filename or url of the file to be imported."""
        return _core.ImportOptions__set_filename(self, value)

    def _get_isViewFit(self) -> "bool":
        r"""
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.ImportOptions__get_isViewFit(self)

    def _set_isViewFit(self, value: "bool") -> "bool":
        r"""
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.ImportOptions__set_isViewFit(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.ImportOptions__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ImportOptions__get_isValid(self)

# Register ImportOptions in _core:
_core.ImportOptions_swigregister(ImportOptions)

def ImportOptions_classType() -> "char const *":
    return _core.ImportOptions_classType()


ImportOptions.filename = property(ImportOptions._get_filename, ImportOptions._set_filename, doc="Gets and sets the filename or url of the file to be imported.")


ImportOptions.isViewFit = property(ImportOptions._get_isViewFit, ImportOptions._set_isViewFit, doc="Specifies if the camera should be adjusted to fit the geometry of the import.\nThis defaults to true, which will cause a change in the current view. Setting this\nto false will leave the view as-is and just import the geometry.")


ImportOptions.cast = lambda arg: arg if isinstance(arg, ImportOptions) else None

class InputChangedEventHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notify(self, eventArgs: "InputChangedEventArgs") -> "void":
        return _core.InputChangedEventHandler_notify(self, eventArgs)

    def __init__(self):
        if self.__class__ == InputChangedEventHandler:
            _self = None
        else:
            _self = self
        _core.InputChangedEventHandler_swiginit(self, _core.new_InputChangedEventHandler(_self, ))
    __swig_destroy__ = _core.delete_InputChangedEventHandler
    def __disown__(self):
        self.this.disown()
        _core.disown_InputChangedEventHandler(self)
        return weakref.proxy(self)

# Register InputChangedEventHandler in _core:
_core.InputChangedEventHandler_swigregister(InputChangedEventHandler)


InputChangedEventHandler.cast = lambda arg: arg if isinstance(arg, InputChangedEventHandler) else None

class KeyboardEventHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notify(self, eventArgs: "KeyboardEventArgs") -> "void":
        return _core.KeyboardEventHandler_notify(self, eventArgs)

    def __init__(self):
        if self.__class__ == KeyboardEventHandler:
            _self = None
        else:
            _self = self
        _core.KeyboardEventHandler_swiginit(self, _core.new_KeyboardEventHandler(_self, ))
    __swig_destroy__ = _core.delete_KeyboardEventHandler
    def __disown__(self):
        self.this.disown()
        _core.disown_KeyboardEventHandler(self)
        return weakref.proxy(self)

# Register KeyboardEventHandler in _core:
_core.KeyboardEventHandler_swigregister(KeyboardEventHandler)


KeyboardEventHandler.cast = lambda arg: arg if isinstance(arg, KeyboardEventHandler) else None

class LinearMarkingMenu(Base):
    r"""
    Represents the linear marking menu which is the vertical menu that's displayed when the user right-clicks
    within Fusion 360. This supports customizing the contents of the context menu.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::LinearMarkingMenu *":
        return _core.LinearMarkingMenu___deref__(self)

    def __eq__(self, rhs: "LinearMarkingMenu") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.LinearMarkingMenu___eq__(self, rhs)


    def __ne__(self, rhs: "LinearMarkingMenu") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.LinearMarkingMenu___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.LinearMarkingMenu_classType()
    __swig_destroy__ = _core.delete_LinearMarkingMenu

    def _get_controls(self) -> "adsk::core::Ptr< adsk::core::ToolbarControls >":
        r"""
        Return the collection of top-level controls in the context menu. It's possible to have 
        drop-down controls (fly-outs) that provide access to additional conrols. You can 
        remove and add controls to customize the contents of the context menu.
        """
        return _core.LinearMarkingMenu__get_controls(self)

    def clear(self) -> "bool":
        r"""
        Completely clears the contents of the context menu. If left in this state, the
        context menu will not be displayed. 
        Returns true if the clear was successful.
        """
        return _core.LinearMarkingMenu_clear(self)

    def _get_objectType(self) -> "char const *":
        return _core.LinearMarkingMenu__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.LinearMarkingMenu__get_isValid(self)

# Register LinearMarkingMenu in _core:
_core.LinearMarkingMenu_swigregister(LinearMarkingMenu)

def LinearMarkingMenu_classType() -> "char const *":
    return _core.LinearMarkingMenu_classType()


LinearMarkingMenu.controls = property(LinearMarkingMenu._get_controls, doc="Return the collection of top-level controls in the context menu. It's possible to have\ndrop-down controls (fly-outs) that provide access to additional conrols. You can\nremove and add controls to customize the contents of the context menu.")


LinearMarkingMenu.cast = lambda arg: arg if isinstance(arg, LinearMarkingMenu) else None

class ListItem(Base):
    r"""Represents a single item in a check box list or a drop-down command input."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ListItem *":
        return _core.ListItem___deref__(self)

    def __eq__(self, rhs: "ListItem") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ListItem___eq__(self, rhs)


    def __ne__(self, rhs: "ListItem") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ListItem___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ListItem_classType()
    __swig_destroy__ = _core.delete_ListItem

    def _get_name(self) -> "std::string":
        r"""
        Gets or sets the name of this item as displayed in the list. If
        this control is a separator (isSeparator is true) or it's a button row, 
        setting this property is ignored and getting it will return an empty string.
        """
        return _core.ListItem__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the name of this item as displayed in the list. If
        this control is a separator (isSeparator is true) or it's a button row, 
        setting this property is ignored and getting it will return an empty string.
        """
        return _core.ListItem__set_name(self, value)

    def _get_icon(self) -> "std::string":
        r"""
        Gets or sets the location for the icon file used for this item in the list.
        This is the path to a directory that contains the image files associated 
        with this item. This is only valid when this is a standard list or button row and is
        ignored for check box lists, radio control lists, and radio button groups.
        """
        return _core.ListItem__get_icon(self)

    def _set_icon(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the location for the icon file used for this item in the list.
        This is the path to a directory that contains the image files associated 
        with this item. This is only valid when this is a standard list or button row and is
        ignored for check box lists, radio control lists, and radio button groups.
        """
        return _core.ListItem__set_icon(self, value)

    def _get_isSelected(self) -> "bool":
        r"""
        Gets or sets whether this item is selected. If the item is
        being displayed as a check box, this controls whether it is 
        checked or not. If it's a drop-down list or button row it controls whether
        this is the single selected item. Setting a drop-down list, button row item, or radio button 
        from a group to be selected will unselect the currently selected item.
        For a standard list, this will get or set the single item currently
        selected. For a separator, setting this property is ignored and
        it will always return false.
        """
        return _core.ListItem__get_isSelected(self)

    def _set_isSelected(self, value: "bool") -> "bool":
        r"""
        Gets or sets whether this item is selected. If the item is
        being displayed as a check box, this controls whether it is 
        checked or not. If it's a drop-down list or button row it controls whether
        this is the single selected item. Setting a drop-down list, button row item, or radio button 
        from a group to be selected will unselect the currently selected item.
        For a standard list, this will get or set the single item currently
        selected. For a separator, setting this property is ignored and
        it will always return false.
        """
        return _core.ListItem__set_isSelected(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this item from the list. 
        Returns true if the delete was successful.
        """
        return _core.ListItem_deleteMe(self)

    def _get_index(self) -> "int":
        r"""Gets the index position within the list of this item."""
        return _core.ListItem__get_index(self)

    def _get_parentList(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets the parent CheckBoxListControlDefinition or object."""
        return _core.ListItem__get_parentList(self)

    def _get_isSeparator(self) -> "bool":
        r"""Gets if this control is a separator."""
        return _core.ListItem__get_isSeparator(self)

    def _get_objectType(self) -> "char const *":
        return _core.ListItem__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ListItem__get_isValid(self)

# Register ListItem in _core:
_core.ListItem_swigregister(ListItem)

def ListItem_classType() -> "char const *":
    return _core.ListItem_classType()


ListItem.name = property(ListItem._get_name, ListItem._set_name, doc="Gets or sets the name of this item as displayed in the list. If\nthis control is a separator (isSeparator is true) or it's a button row,\nsetting this property is ignored and getting it will return an empty string.")


ListItem.icon = property(ListItem._get_icon, ListItem._set_icon, doc="Gets or sets the location for the icon file used for this item in the list.\nThis is the path to a directory that contains the image files associated\nwith this item. This is only valid when this is a standard list or button row and is\nignored for check box lists, radio control lists, and radio button groups.")


ListItem.isSelected = property(ListItem._get_isSelected, ListItem._set_isSelected, doc="Gets or sets whether this item is selected. If the item is\nbeing displayed as a check box, this controls whether it is\nchecked or not. If it's a drop-down list or button row it controls whether\nthis is the single selected item. Setting a drop-down list, button row item, or radio button\nfrom a group to be selected will unselect the currently selected item.\nFor a standard list, this will get or set the single item currently\nselected. For a separator, setting this property is ignored and\nit will always return false.")


ListItem.index = property(ListItem._get_index, doc="Gets the index position within the list of this item.")


ListItem.parentList = property(ListItem._get_parentList, doc="Gets the parent CheckBoxListControlDefinition or object.")


ListItem.isSeparator = property(ListItem._get_isSeparator, doc="Gets if this control is a separator.")


ListItem.cast = lambda arg: arg if isinstance(arg, ListItem) else None

class ListItems(Base):
    r"""
    Provides access to the list of items in a check box list. This object supports the ability to add
    items to the list and iterate through the existing items.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ListItems *":
        return _core.ListItems___deref__(self)

    def __eq__(self, rhs: "ListItems") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ListItems___eq__(self, rhs)


    def __ne__(self, rhs: "ListItems") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ListItems___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.ListItems___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::ListItem >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.ListItems___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.ListItems_classType()
    __swig_destroy__ = _core.delete_ListItems

    def add(self, *args) -> "adsk::core::Ptr< adsk::core::ListItem >":
        r"""
        Adds a new item to the list. 
        name : The name of this item as it is displayed in the list. 
        isSelected : Sets whether this item is selected or not. If this list is associated with a control
        or input that can only have one item selected any other selected items will be unselected
        and this one will be the only selected item. 
        icon : The path to the icon directory. 
        beforeIndex : The position of the item within the list. This value indicates the index of the current
        item to insert this new item just before. For example, a value of 0 will insert it before
        the first item in the list. An index of -1 will position the button at the bottom of the list. 
        Returns the new ListControlItem or null in the case of a failure.
        """
        return _core.ListItems_add(self, *args)

    def addSeparator(self, beforeIndex: "int") -> "adsk::core::Ptr< adsk::core::ListItem >":
        r"""
        Adds a separator to the list. This is not supported for button rows. 
        beforeIndex : The position of the item within the list. This value indicates the index of the current
        item to insert this new item just before. For example, a value of 0 will insert it before
        the first item in the list. An index of -1 will position the button at the bottom of the list. 
        Returns the new ListControlItem or null in the case of a failure.
        """
        return _core.ListItems_addSeparator(self, beforeIndex)

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::ListItem >":
        r"""
        Returns the specified check box list item using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.ListItems_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Gets the number of items in the collection."""
        return _core.ListItems__get_count(self)

    def clear(self) -> "bool":
        r"""
        Clears all of the items from the list. 
        Returns true if successful.
        """
        return _core.ListItems_clear(self)

    def _get_objectType(self) -> "char const *":
        return _core.ListItems__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ListItems__get_isValid(self)

# Register ListItems in _core:
_core.ListItems_swigregister(ListItems)

def ListItems_classType() -> "char const *":
    return _core.ListItems_classType()


ListItems.count = property(ListItems._get_count, doc="Gets the number of items in the collection.")


ListItems.cast = lambda arg: arg if isinstance(arg, ListItems) else None

class MarkingMenuEventHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notify(self, eventArgs: "MarkingMenuEventArgs") -> "void":
        return _core.MarkingMenuEventHandler_notify(self, eventArgs)

    def __init__(self):
        if self.__class__ == MarkingMenuEventHandler:
            _self = None
        else:
            _self = self
        _core.MarkingMenuEventHandler_swiginit(self, _core.new_MarkingMenuEventHandler(_self, ))
    __swig_destroy__ = _core.delete_MarkingMenuEventHandler
    def __disown__(self):
        self.this.disown()
        _core.disown_MarkingMenuEventHandler(self)
        return weakref.proxy(self)

# Register MarkingMenuEventHandler in _core:
_core.MarkingMenuEventHandler_swigregister(MarkingMenuEventHandler)


MarkingMenuEventHandler.cast = lambda arg: arg if isinstance(arg, MarkingMenuEventHandler) else None

class Material(Base):
    r"""A material."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Material *":
        return _core.Material___deref__(self)

    def __eq__(self, rhs: "Material") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Material___eq__(self, rhs)


    def __ne__(self, rhs: "Material") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Material___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Material_classType()
    __swig_destroy__ = _core.delete_Material

    def _get_appearance(self) -> "adsk::core::Ptr< adsk::core::Appearance >":
        r"""Gets the Appearance of this material."""
        return _core.Material__get_appearance(self)

    def _get_id(self) -> "std::string":
        r"""Returns the unique internal ID of this material."""
        return _core.Material__get_id(self)

    def _get_isUsed(self) -> "bool":
        r"""Returns true if this material is used in the Design"""
        return _core.Material__get_isUsed(self)

    def _get_materialProperties(self) -> "adsk::core::Ptr< adsk::core::Properties >":
        r"""Returns the collection of material properties associated with this material."""
        return _core.Material__get_materialProperties(self)

    def _get_name(self) -> "std::string":
        r"""
        Returns the name of this Material. This is the name of the material as seen in the user interface.
        The name can only be edited if the material is in a Design or the favorites list.
        """
        return _core.Material__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""
        Returns the name of this Material. This is the name of the material as seen in the user interface.
        The name can only be edited if the material is in a Design or the favorites list.
        """
        return _core.Material__set_name(self, value)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the Parent object (a Library or a Design)."""
        return _core.Material__get_parent(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the material from the Design. This method only applies to materials
        in a Design that are unused 
        Returns true if the delete was successful.
        """
        return _core.Material_deleteMe(self)

    def copyTo(self, target: "Base") -> "adsk::core::Ptr< adsk::core::Material >":
        r"""
        Copies this material to the specified target.
        ***Depricated Method: Use the addByCopyMethod on the Materials object instead, where you can rename the copied Material*** 
        target : The target can be a Design or MaterialFavorites object. 
        Returns the new copy of the material or null if the copy failed.
        """
        return _core.Material_copyTo(self, target)

    def _get_objectType(self) -> "char const *":
        return _core.Material__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Material__get_isValid(self)

# Register Material in _core:
_core.Material_swigregister(Material)

def Material_classType() -> "char const *":
    return _core.Material_classType()


Material.appearance = property(Material._get_appearance, doc="Gets the Appearance of this material.")


Material.id = property(Material._get_id, doc="Returns the unique internal ID of this material.")


Material.isUsed = property(Material._get_isUsed, doc="Returns true if this material is used in the Design")


Material.materialProperties = property(Material._get_materialProperties, doc="Returns the collection of material properties associated with this material.")


Material.name = property(Material._get_name, Material._set_name, doc="Returns the name of this Material. This is the name of the material as seen in the user interface.\nThe name can only be edited if the material is in a Design or the favorites list.")


Material.parent = property(Material._get_parent, doc="Returns the Parent object (a Library or a Design).")


Material.cast = lambda arg: arg if isinstance(arg, Material) else None

class MaterialLibraries(Base):
    r"""
    The MaterialLibraries collection object provides access to 
    currently loaded Material and Appearance libraries
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::MaterialLibraries *":
        return _core.MaterialLibraries___deref__(self)

    def __eq__(self, rhs: "MaterialLibraries") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.MaterialLibraries___eq__(self, rhs)


    def __ne__(self, rhs: "MaterialLibraries") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.MaterialLibraries___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.MaterialLibraries___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::MaterialLibrary >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.MaterialLibraries___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.MaterialLibraries_classType()
    __swig_destroy__ = _core.delete_MaterialLibraries

    def item(self, index: "int") -> "adsk::core::Ptr< adsk::core::MaterialLibrary >":
        r"""
        Method that returns the specified Material Library using an index into the collection. 
        index : The index of the item within the collection. The first item has an index of 0. 
        Returns the specified material library or null if an invalid index was specified.
        """
        return _core.MaterialLibraries_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of Material Libraries in the collection."""
        return _core.MaterialLibraries__get_count(self)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::core::MaterialLibrary >":
        r"""
        Returns the specified Material Library using the name as seen in the user interface. 
        name : The name of the library to return. 
        Returns the specified material library or null if there's no match on the name.
        """
        return _core.MaterialLibraries_itemByName(self, name)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::MaterialLibrary >":
        r"""
        Returns the Material Library at the specified ID. 
        id : The ID of the library to return. 
        Returns the specified material library or null if there's no match on the ID.
        """
        return _core.MaterialLibraries_itemById(self, id)

    def load(self, filename: "std::string const &") -> "adsk::core::Ptr< adsk::core::MaterialLibrary >":
        r"""
        Loads the specified existing local material library. Fusion 360 remembers which libraries have
        been loaded from one session to the next so you should check to see if the local library
        is already loaded or not before loading it again. 
        filename : The full filename of the .adsklib material file. 
        Returns the MaterialLibrary object representing the opened library or null in the case of failure.
        """
        return _core.MaterialLibraries_load(self, filename)

    def _get_objectType(self) -> "char const *":
        return _core.MaterialLibraries__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.MaterialLibraries__get_isValid(self)

# Register MaterialLibraries in _core:
_core.MaterialLibraries_swigregister(MaterialLibraries)

def MaterialLibraries_classType() -> "char const *":
    return _core.MaterialLibraries_classType()


MaterialLibraries.count = property(MaterialLibraries._get_count, doc="The number of Material Libraries in the collection.")


MaterialLibraries.cast = lambda arg: arg if isinstance(arg, MaterialLibraries) else None

class MaterialLibrary(Base):
    r"""A material library."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::MaterialLibrary *":
        return _core.MaterialLibrary___deref__(self)

    def __eq__(self, rhs: "MaterialLibrary") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.MaterialLibrary___eq__(self, rhs)


    def __ne__(self, rhs: "MaterialLibrary") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.MaterialLibrary___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.MaterialLibrary_classType()
    __swig_destroy__ = _core.delete_MaterialLibrary

    def _get_name(self) -> "std::string":
        r"""
        Property that gets the name of this Library. This is the localized name
        shown in the user interface.
        """
        return _core.MaterialLibrary__get_name(self)

    def _get_id(self) -> "std::string":
        r"""The unique internal ID of this Library."""
        return _core.MaterialLibrary__get_id(self)

    def _get_appearances(self) -> "adsk::core::Ptr< adsk::core::Appearances >":
        r"""Returns the appearances defined within this library."""
        return _core.MaterialLibrary__get_appearances(self)

    def _get_materials(self) -> "adsk::core::Ptr< adsk::core::Materials >":
        r"""Returns the materials defined within this library."""
        return _core.MaterialLibrary__get_materials(self)

    def _get_isNative(self) -> "bool":
        r"""
        Gets if this is a native material library. Native libraries are
        those that are delivered with Fusion 360 and are always available. And
        non-native libraries are user created. If This returns True then there 
        are some limitations to what can be done with the library. For example, 
        if this is a native material library it cannot be unloaded.
        """
        return _core.MaterialLibrary__get_isNative(self)

    def unload(self) -> "bool":
        r"""
        Unloads this material from Fusion 360. Only non-native material libraries
        can be unloaded. You can determine this by checking the isNative property. 
        Returns True if the library was successfully unloaded.
        """
        return _core.MaterialLibrary_unload(self)

    def _get_objectType(self) -> "char const *":
        return _core.MaterialLibrary__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.MaterialLibrary__get_isValid(self)

# Register MaterialLibrary in _core:
_core.MaterialLibrary_swigregister(MaterialLibrary)

def MaterialLibrary_classType() -> "char const *":
    return _core.MaterialLibrary_classType()


MaterialLibrary.name = property(MaterialLibrary._get_name, doc="Property that gets the name of this Library. This is the localized name\nshown in the user interface.")


MaterialLibrary.id = property(MaterialLibrary._get_id, doc="The unique internal ID of this Library.")


MaterialLibrary.appearances = property(MaterialLibrary._get_appearances, doc="Returns the appearances defined within this library.")


MaterialLibrary.materials = property(MaterialLibrary._get_materials, doc="Returns the materials defined within this library.")


MaterialLibrary.isNative = property(MaterialLibrary._get_isNative, doc="Gets if this is a native material library. Native libraries are\nthose that are delivered with Fusion 360 and are always available. And\nnon-native libraries are user created. If This returns True then there\nare some limitations to what can be done with the library. For example,\nif this is a native material library it cannot be unloaded.")


MaterialLibrary.cast = lambda arg: arg if isinstance(arg, MaterialLibrary) else None

class MaterialPreferences(Base):
    r"""Provides access to the material related preferences."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::MaterialPreferences *":
        return _core.MaterialPreferences___deref__(self)

    def __eq__(self, rhs: "MaterialPreferences") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.MaterialPreferences___eq__(self, rhs)


    def __ne__(self, rhs: "MaterialPreferences") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.MaterialPreferences___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.MaterialPreferences_classType()
    __swig_destroy__ = _core.delete_MaterialPreferences

    def _get_defaultMaterial(self) -> "adsk::core::Ptr< adsk::core::Material >":
        r"""Gets and sets the default material."""
        return _core.MaterialPreferences__get_defaultMaterial(self)

    def _set_defaultMaterial(self, value: "Material") -> "bool":
        r"""Gets and sets the default material."""
        return _core.MaterialPreferences__set_defaultMaterial(self, value)

    def _get_appearanceOverride(self) -> "adsk::core::Ptr< adsk::core::Appearance >":
        r"""
        Gets and sets an appearance override.
        This property return null indicating that there is no override, or be set to null to remove
        the current appearance override.
        """
        return _core.MaterialPreferences__get_appearanceOverride(self)

    def _set_appearanceOverride(self, value: "Appearance") -> "bool":
        r"""
        Gets and sets an appearance override.
        This property return null indicating that there is no override, or be set to null to remove
        the current appearance override.
        """
        return _core.MaterialPreferences__set_appearanceOverride(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.MaterialPreferences__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.MaterialPreferences__get_isValid(self)

# Register MaterialPreferences in _core:
_core.MaterialPreferences_swigregister(MaterialPreferences)

def MaterialPreferences_classType() -> "char const *":
    return _core.MaterialPreferences_classType()


MaterialPreferences.defaultMaterial = property(MaterialPreferences._get_defaultMaterial, MaterialPreferences._set_defaultMaterial, doc="Gets and sets the default material.")


MaterialPreferences.appearanceOverride = property(MaterialPreferences._get_appearanceOverride, MaterialPreferences._set_appearanceOverride, doc="Gets and sets an appearance override.\nThis property return null indicating that there is no override, or be set to null to remove\nthe current appearance override.")


MaterialPreferences.cast = lambda arg: arg if isinstance(arg, MaterialPreferences) else None

class Materials(Base):
    r"""Collection of materials within a Library or Design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Materials *":
        return _core.Materials___deref__(self)

    def __eq__(self, rhs: "Materials") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Materials___eq__(self, rhs)


    def __ne__(self, rhs: "Materials") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Materials___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.Materials___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::Material >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.Materials___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.Materials_classType()
    __swig_destroy__ = _core.delete_Materials

    def item(self, index: "int") -> "adsk::core::Ptr< adsk::core::Material >":
        r"""
        Returns the specified Material using an index into the collection. 
        index : The index of the material to return where the first item in the collection is 0. 
        Returns the specified material or null if an invalid index is specified.
        """
        return _core.Materials_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of Materials in the collection."""
        return _core.Materials__get_count(self)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::core::Material >":
        r"""
        Returns the specified Material using the name as seen in the user interface. This often isn't
        a reliable way of accessing a specific material because materials are not required to be unique. 
        name : The name of the material to return,. 
        Returns the specified material or null if there isn't a matching name.
        """
        return _core.Materials_itemByName(self, name)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::Material >":
        r"""
        Returns the Material by it's internal unique ID. 
        id : The ID of the material to return. 
        Returns the specified material or null if there isn't a matching ID.
        """
        return _core.Materials_itemById(self, id)

    def addByCopy(self, materialToCopy: "Material", name: "std::string const &") -> "adsk::core::Ptr< adsk::core::Material >":
        r"""
        Add a Material to a Design by copying an existing Material from Favorites, a Library or from the 
        Materials stored in the Design. This method currently only applies to the Materials collection from a Design and 
        cannot be used to copy a Material to a library. 
        materialToCopy : The Material you want to copy. The Material to copy can be from Favorites, a Library or from the 
        materials stored in the Design. 
        name : The Material name to apply to the copy. 
        Returns the newly created Material or null if the copy operation failed.
        """
        return _core.Materials_addByCopy(self, materialToCopy, name)

    def _get_objectType(self) -> "char const *":
        return _core.Materials__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Materials__get_isValid(self)

# Register Materials in _core:
_core.Materials_swigregister(Materials)

def Materials_classType() -> "char const *":
    return _core.Materials_classType()


Materials.count = property(Materials._get_count, doc="The number of Materials in the collection.")


Materials.cast = lambda arg: arg if isinstance(arg, Materials) else None

class Matrix2D(Base):
    r"""
    Transient 2D 3x3 matrix. This object is a wrapper over 2D matrix data and is used as way to pass matrix data
    in and out of the API and as a convenience when operating on matrix data.
    They are created statically using the create method of the Matrix2D class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Matrix2D *":
        return _core.Matrix2D___deref__(self)

    def __eq__(self, rhs: "Matrix2D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Matrix2D___eq__(self, rhs)


    def __ne__(self, rhs: "Matrix2D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Matrix2D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Matrix2D_classType()

    @staticmethod
    def create() -> "adsk::core::Ptr< adsk::core::Matrix2D >":
        return _core.Matrix2D_create()
    __swig_destroy__ = _core.delete_Matrix2D

    def setToIdentity(self) -> "bool":
        r"""
        Resets this matrix to be an identity matrix. 
        Returns true if successful.
        """
        return _core.Matrix2D_setToIdentity(self)

    def invert(self) -> "bool":
        r"""
        Invert this matrix. 
        Returns true if successful.
        """
        return _core.Matrix2D_invert(self)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Matrix2D >":
        r"""
        Creates an independent copy of this matrix. 
        Returns the new matrix copy.
        """
        return _core.Matrix2D_copy(self)

    def _get_determinant(self) -> "double":
        r"""
        Returns the determinant of the matrix. 
        Returns the determinant value of this matrix.
        """
        return _core.Matrix2D__get_determinant(self)

    def transformBy(self, matrix: "Matrix2D") -> "bool":
        r"""
        Transforms this matrix using the input matrix. 
        matrix : The transformation matrix. 
        Returns true if successful.
        """
        return _core.Matrix2D_transformBy(self, matrix)

    def getCell(self, row: "int", column: "int") -> "double":
        r"""
        Gets the value of the specified cell in the 3x3 matrix. 
        row : The index of the row. The first row has in index of 0 
        column : The index of the column. The first column has an index of 0 
        Returns the value at [row][column].
        """
        return _core.Matrix2D_getCell(self, row, column)

    def setCell(self, row: "int", column: "int", value: "double") -> "bool":
        r"""
        Sets the specified cell in the 3x3 matrix to the specified value. 
        row : The index of the row. The first row has in index of 0 
        column : The index of the column. The first column has an index of 0 
        value : The new value of the cell. 
        Returns true if successful.
        """
        return _core.Matrix2D_setCell(self, row, column, value)

    def getAsCoordinateSystem(self) -> "void":
        r"""
        Gets the matrix data as the components that define a coordinate system. 
        origin : The output origin point of the coordinate system. 
        xAxis : The output x axis direction of the coordinate system. 
        yAxis : The output y axis direction of the coordinate system.
        """
        return _core.Matrix2D_getAsCoordinateSystem(self)

    def asArray(self) -> "std::vector< double,std::allocator< double > >":
        r"""
        Returns the contents of the matrix as a 9 element array. 
        Returns the array of matrix values.
        """
        return _core.Matrix2D_asArray(self)

    def setWithCoordinateSystem(self, origin: "Point2D", xAxis: "Vector2D", yAxis: "Vector2D") -> "bool":
        r"""
        Reset this matrix to align with a specific coordinate system. 
        origin : The origin point of the coordinate system. 
        xAxis : The x axis direction of the coordinate system. 
        yAxis : The y axis direction of the coordinate system. 
        Returns true if successful.
        """
        return _core.Matrix2D_setWithCoordinateSystem(self, origin, xAxis, yAxis)

    def setWithArray(self, cells: "DoubleVector") -> "bool":
        r"""
        Sets the contents of the array using a 9 element array. 
        cells : The array of cell values. 
        Returns true if successful.
        """
        return _core.Matrix2D_setWithArray(self, cells)

    def isEqualTo(self, matrix: "Matrix2D") -> "bool":
        r"""
        Compares this matrix with another matrix and returns True if they're identical. 
        matrix : The matrix to compare to. 
        Returns true if the matrix is equal to this matrix.
        """
        return _core.Matrix2D_isEqualTo(self, matrix)

    def setToAlignCoordinateSystems(self, fromOrigin: "Point2D", fromXAxis: "Vector2D", fromYAxis: "Vector2D", toOrigin: "Point2D", toXAxis: "Vector2D", toYAxis: "Vector2D") -> "bool":
        r"""
        Sets this matrix to be the matrix that maps from the 'from' coordinate system to the 'to' coordinate system. 
        fromOrigin : The origin point of the from coordinate system. 
        fromXAxis : The x axis direction of the from coordinate system. 
        fromYAxis : The y axis direction of the from coordinate system. 
        toOrigin : The origin point of the to coordinate system. 
        toXAxis : The x axis direction of the to coordinate system. 
        toYAxis : The y axis direction of the to coordinate system. 
        Returns true if successful.
        """
        return _core.Matrix2D_setToAlignCoordinateSystems(self, fromOrigin, fromXAxis, fromYAxis, toOrigin, toXAxis, toYAxis)

    def setToRotateTo(self, _from: "Vector2D", to: "Vector2D") -> "bool":
        r"""
        Sets to the matrix of rotation that would align the 'from' vector with the 'to' vector. 
        from : The from vector. 
        to : The to vector. 
        Returns true if successful.
        """
        return _core.Matrix2D_setToRotateTo(self, _from, to)

    def setToRotation(self, angle: "double", origin: "Point2D") -> "bool":
        r"""
        Sets this matrix to the matrix of rotation by the specified angle, through the specified origin. 
        angle : The rotation angle in radians. 
        origin : The origin point of the rotation. 
        Returns true if successful.
        """
        return _core.Matrix2D_setToRotation(self, angle, origin)

    def _get_objectType(self) -> "char const *":
        return _core.Matrix2D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Matrix2D__get_isValid(self)

# Register Matrix2D in _core:
_core.Matrix2D_swigregister(Matrix2D)

def Matrix2D_classType() -> "char const *":
    return _core.Matrix2D_classType()

def Matrix2D_create() -> "adsk::core::Ptr< adsk::core::Matrix2D >":
    return _core.Matrix2D_create()


Matrix2D.determinant = property(Matrix2D._get_determinant, doc="Returns the determinant of the matrix.\nReturns the determinant value of this matrix.")


Matrix2D.cast = lambda arg: arg if isinstance(arg, Matrix2D) else None

class Matrix3D(Base):
    r"""
    Transient 3D 4x4 matrix. This object is a wrapper over 3D matrix data and is used as way to pass matrix data
    in and out of the API and as a convenience when operating on matrix data.
    They are created statically using the create method of the Matrix3D class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Matrix3D *":
        return _core.Matrix3D___deref__(self)

    def __eq__(self, rhs: "Matrix3D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Matrix3D___eq__(self, rhs)


    def __ne__(self, rhs: "Matrix3D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Matrix3D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Matrix3D_classType()

    @staticmethod
    def create() -> "adsk::core::Ptr< adsk::core::Matrix3D >":
        return _core.Matrix3D_create()
    __swig_destroy__ = _core.delete_Matrix3D

    def setToIdentity(self) -> "bool":
        r"""
        Resets this matrix to an identify matrix. 
        Returns true if successful.
        """
        return _core.Matrix3D_setToIdentity(self)

    def invert(self) -> "bool":
        r"""
        Inverts this matrix. 
        Returns true if successful.
        """
        return _core.Matrix3D_invert(self)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >":
        r"""
        Creates an independent copy of this matrix. 
        Returns the new matrix copy.
        """
        return _core.Matrix3D_copy(self)

    def _get_determinant(self) -> "double":
        r"""Returns the determinant of the matrix."""
        return _core.Matrix3D__get_determinant(self)

    def transformBy(self, matrix: "Matrix3D") -> "bool":
        r"""
        Transforms this matrix using the input matrix. 
        matrix : The transformation matrix. 
        Returns true if successful.
        """
        return _core.Matrix3D_transformBy(self, matrix)

    def getAsCoordinateSystem(self) -> "void":
        r"""
        Gets the matrix data as the components that define a coordinate system. 
        origin : The output origin point of the coordinate system. 
        xAxis : The output x axis direction of the coordinate system. 
        yAxis : The output y axis direction of the coordinate system. 
        zAxis : The output z axis direction of the coordinate system.
        """
        return _core.Matrix3D_getAsCoordinateSystem(self)

    def setWithCoordinateSystem(self, origin: "Point3D", xAxis: "Vector3D", yAxis: "Vector3D", zAxis: "Vector3D") -> "bool":
        r"""
        Sets the matrix based on the components of a coordinate system. 
        origin : The origin point of the coordinate system. 
        xAxis : The x axis direction of the coordinate system. 
        yAxis : The y axis direction of the coordinate system. 
        zAxis : The z axis direction of the coordinate system. 
        Returns true if successful.
        """
        return _core.Matrix3D_setWithCoordinateSystem(self, origin, xAxis, yAxis, zAxis)

    def getCell(self, row: "int", column: "int") -> "double":
        r"""
        Gets the value of the specified cell in the 4x4 matrix. 
        row : The index of the row. The first row has in index of 0 
        column : The index of the column. The first column has an index of 0 
        The cell value at [row][column].
        """
        return _core.Matrix3D_getCell(self, row, column)

    def setCell(self, row: "int", column: "int", value: "double") -> "bool":
        r"""
        Sets the specified cell in the 4x4 matrix to the specified value. 
        row : The index of the row. The first row has in index of 0 
        column : The index of the column. The first column has an index of 0 
        value : The new cell value. 
        Returns true if successful.
        """
        return _core.Matrix3D_setCell(self, row, column, value)

    def asArray(self) -> "std::vector< double,std::allocator< double > >":
        r"""
        Returns the contents of the matrix as a 16 element array. 
        Returns the array of cell values.
        """
        return _core.Matrix3D_asArray(self)

    def setWithArray(self, cells: "DoubleVector") -> "bool":
        r"""
        Sets the contents of the array using a 16 element array. 
        cells : The array of cell values. 
        Returns true if successful.
        """
        return _core.Matrix3D_setWithArray(self, cells)

    def isEqualTo(self, matrix: "Matrix3D") -> "bool":
        r"""
        Compares this matrix with another matrix and returns True if they're identical. 
        matrix : The matrix to compare this matrix to. 
        Returns true if the matrices are equal.
        """
        return _core.Matrix3D_isEqualTo(self, matrix)

    def _get_translation(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Gets and sets the translation component of the matrix."""
        return _core.Matrix3D__get_translation(self)

    def _set_translation(self, value: "Vector3D") -> "bool":
        r"""Gets and sets the translation component of the matrix."""
        return _core.Matrix3D__set_translation(self, value)

    def setToAlignCoordinateSystems(self, fromOrigin: "Point3D", fromXAxis: "Vector3D", fromYAxis: "Vector3D", fromZAxis: "Vector3D", toOrigin: "Point3D", toXAxis: "Vector3D", toYAxis: "Vector3D", toZAxis: "Vector3D") -> "bool":
        r"""
        Sets this matrix to be the matrix that maps from the 'from' coordinate system to the 'to' coordinate system. 
        fromOrigin : The origin point of the from coordinate system. 
        fromXAxis : The x axis direction of the from coordinate system. 
        fromYAxis : The y axis direction of the from coordinate system. 
        fromZAxis : The z axis direction of the from coordinate system. 
        toOrigin : The origin point of the to coordinate system. 
        toXAxis : The x axis direction of the to coordinate system. 
        toYAxis : The y axis direction of the to coordinate system. 
        toZAxis : The z axis direction of the to coordinate system. 
        Returns true if successful.
        """
        return _core.Matrix3D_setToAlignCoordinateSystems(self, fromOrigin, fromXAxis, fromYAxis, fromZAxis, toOrigin, toXAxis, toYAxis, toZAxis)

    def setToRotateTo(self, *args) -> "bool":
        r"""
        Sets to the matrix of rotation that would align the 'from' vector with the 'to' vector. The optional 
        axis argument may be used when the two vectors are perpendicular and in opposite directions to 
        specify a specific solution, but is otherwise ignored 
        from : The vector to rotate from. 
        to : The vector to rotate to. 
        axis : The optional axis vector to disambiguate the rotation axis. 
        Returns true if successful.
        """
        return _core.Matrix3D_setToRotateTo(self, *args)

    def setToRotation(self, angle: "double", axis: "Vector3D", origin: "Point3D") -> "bool":
        r"""
        Sets this matrix to the matrix of rotation by the specified angle, through the specified origin, around the specified axis 
        angle : The rotation angle in radians. 
        axis : The axis of rotation. 
        origin : The origin point of the axis of rotation. 
        Returns true if successful.
        """
        return _core.Matrix3D_setToRotation(self, angle, axis, origin)

    def _get_objectType(self) -> "char const *":
        return _core.Matrix3D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Matrix3D__get_isValid(self)

# Register Matrix3D in _core:
_core.Matrix3D_swigregister(Matrix3D)

def Matrix3D_classType() -> "char const *":
    return _core.Matrix3D_classType()

def Matrix3D_create() -> "adsk::core::Ptr< adsk::core::Matrix3D >":
    return _core.Matrix3D_create()


Matrix3D.determinant = property(Matrix3D._get_determinant, doc="Returns the determinant of the matrix.")


Matrix3D.translation = property(Matrix3D._get_translation, Matrix3D._set_translation, doc="Gets and sets the translation component of the matrix.")


Matrix3D.cast = lambda arg: arg if isinstance(arg, Matrix3D) else None

class MeasureManager(Base):
    r"""
    The MeasurementManager class provides some generic measurement utilities that
    can be used for most entity types.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::MeasureManager *":
        return _core.MeasureManager___deref__(self)

    def __eq__(self, rhs: "MeasureManager") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.MeasureManager___eq__(self, rhs)


    def __ne__(self, rhs: "MeasureManager") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.MeasureManager___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.MeasureManager_classType()
    __swig_destroy__ = _core.delete_MeasureManager

    def getOrientedBoundingBox(self, geometry: "Base", lengthVector: "Vector3D", widthVector: "Vector3D") -> "adsk::core::Ptr< adsk::core::OrientedBoundingBox3D >":
        r"""
        Calculates an oriented bounding box for the input geometry. The bounding box is tight fitting
        to the input geometry and is particularly useful when you want to calculate a bounding box that 
        is not oriented to be parallel to the model x-y-z plane.
        The height direction is automatically determined using the length and width directions. 
        geometry : The geometry to calculate the bounding box for. This can be any of the B-Rep related entities. 
        lengthVector : The direction the length of the oriented bounding box will be measured in. The magnitude of the vector
        is ignored and only the direction is used. 
        widthVector : The direction the width of the oriented bounding box will be measured in. The magnitude of the vector
        is ignored and only the direction is used. This must be perpendicular to the length vector. 
        Returns an OrientedBoundingBox3D object which provides the information that defines an oriented bounding box.
        """
        return _core.MeasureManager_getOrientedBoundingBox(self, geometry, lengthVector, widthVector)

    def measureMinimumDistance(self, geometryOne: "Base", geometryTwo: "Base") -> "adsk::core::Ptr< adsk::core::MeasureResults >":
        r"""
        Measures the minimum distance between the two input geometries. 
        geometryOne : The first geometry to measure from. This can be an Occurrence, any B-Rep entity (BRepBody, BRepFace, BRepEdge, BRepVertex, etc.), 
        any construction geometry, any sketch entities, and any temporary 3D geometry (Cylinder, Plane, Line3D, etc.). 
        geometryTwo : The second geometry to measure to. This can be an Occurrence, any B-Rep entity (BRepBody, BRepFace, BRepEdge, BRepVertex, etc.), 
        any construction geometry, any sketch entities, and any temporary 3D geometry (Cylinder, Plane, Line3D, etc.). 
        A MeasureResults object that contains the distance and the two points on the geometry that the distance that
        was measured between them in centimeters.
        """
        return _core.MeasureManager_measureMinimumDistance(self, geometryOne, geometryTwo)

    def measureAngle(self, *args) -> "adsk::core::Ptr< adsk::core::MeasureResults >":
        r"""
        Measures the angle between the input geometry. 
        geometryOne : The first geometry to measure the angle to. This can be any 3D point geometry (Construction Point, Vertex, SketchPoint, or Point3D),
        any 3D linear geometry (Construction Axis, linear BRepEdge, SketchLine, Line3D, or InfiniteLine3D), or any planar geometry (Construction Plane, planar BRepFace, or Plane). 
        geometryTwo : The second geometry to measure the angle to. This can be any 3D point geometry (Construction Point, Vertex, SketchPoint, or Point3D),
        any 3D linear geometry (Construction Axis, linear BRepEdge, SketchLine, Line3D, or InfiniteLine3D), or any planar geometry (Construction Plane, planar BRepFace, or Plane). 
        geometryThree : The optional third geometry to measure the angle to. This is only used when the first two geometries
        are points and this defines the third point. When three points define a triangle, the apex of the
        triangle is defined by the second point. A point can be defined by a Cosntruction Point, Vertex, SketchPoint, or Point3D object. 
        A MeasureResults object that contains the angle and the two points on the geometry that the angle
        that was measured between them in radians.
        """
        return _core.MeasureManager_measureAngle(self, *args)

    def _get_objectType(self) -> "char const *":
        return _core.MeasureManager__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.MeasureManager__get_isValid(self)

# Register MeasureManager in _core:
_core.MeasureManager_swigregister(MeasureManager)

def MeasureManager_classType() -> "char const *":
    return _core.MeasureManager_classType()


MeasureManager.cast = lambda arg: arg if isinstance(arg, MeasureManager) else None

class MeasureResults(Base):
    r"""Provides measurement results from the various measurement methods available on the MeasureManager object."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::MeasureResults *":
        return _core.MeasureResults___deref__(self)

    def __eq__(self, rhs: "MeasureResults") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.MeasureResults___eq__(self, rhs)


    def __ne__(self, rhs: "MeasureResults") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.MeasureResults___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.MeasureResults_classType()
    __swig_destroy__ = _core.delete_MeasureResults

    def _get_value(self) -> "double":
        r"""
        The measurement value. If the measurement is a distance this value will be in centimeters.
        If it's an angle then it will be in radians.
        """
        return _core.MeasureResults__get_value(self)

    def _get_positionOne(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""
        For a distance measurement, this is the point on the first entity where the measurement was made from.
        For an angle measurement this is one of the three points defining the angle.
        """
        return _core.MeasureResults__get_positionOne(self)

    def _get_positionTwo(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""
        For a distance measurement, this is the point on the second entity where the measurement was made to.
        For an angle measurement this is one of the three points defining the angle.
        """
        return _core.MeasureResults__get_positionTwo(self)

    def _get_positionThree(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""This point is only used for angle measurements and is one of the three points defining the angle."""
        return _core.MeasureResults__get_positionThree(self)

    def _get_objectType(self) -> "char const *":
        return _core.MeasureResults__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.MeasureResults__get_isValid(self)

# Register MeasureResults in _core:
_core.MeasureResults_swigregister(MeasureResults)

def MeasureResults_classType() -> "char const *":
    return _core.MeasureResults_classType()


MeasureResults.value = property(MeasureResults._get_value, doc="The measurement value. If the measurement is a distance this value will be in centimeters.\nIf it's an angle then it will be in radians.")


MeasureResults.positionOne = property(MeasureResults._get_positionOne, doc="For a distance measurement, this is the point on the first entity where the measurement was made from.\nFor an angle measurement this is one of the three points defining the angle.")


MeasureResults.positionTwo = property(MeasureResults._get_positionTwo, doc="For a distance measurement, this is the point on the second entity where the measurement was made to.\nFor an angle measurement this is one of the three points defining the angle.")


MeasureResults.positionThree = property(MeasureResults._get_positionThree, doc="This point is only used for angle measurements and is one of the three points defining the angle.")


MeasureResults.cast = lambda arg: arg if isinstance(arg, MeasureResults) else None

class MouseEventHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notify(self, eventArgs: "MouseEventArgs") -> "void":
        return _core.MouseEventHandler_notify(self, eventArgs)

    def __init__(self):
        if self.__class__ == MouseEventHandler:
            _self = None
        else:
            _self = self
        _core.MouseEventHandler_swiginit(self, _core.new_MouseEventHandler(_self, ))
    __swig_destroy__ = _core.delete_MouseEventHandler
    def __disown__(self):
        self.this.disown()
        _core.disown_MouseEventHandler(self)
        return weakref.proxy(self)

# Register MouseEventHandler in _core:
_core.MouseEventHandler_swigregister(MouseEventHandler)


MouseEventHandler.cast = lambda arg: arg if isinstance(arg, MouseEventHandler) else None

class NamedValues(Base):
    r"""Wraps a list of named values."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::NamedValues *":
        return _core.NamedValues___deref__(self)

    def __eq__(self, rhs: "NamedValues") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.NamedValues___eq__(self, rhs)


    def __ne__(self, rhs: "NamedValues") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.NamedValues___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.NamedValues___len__(self)

    @staticmethod
    def classType() -> "char const *":
        return _core.NamedValues_classType()

    @staticmethod
    def create() -> "adsk::core::Ptr< adsk::core::NamedValues >":
        return _core.NamedValues_create()
    __swig_destroy__ = _core.delete_NamedValues

    def add(self, name: "std::string const &", value: "ValueInput") -> "bool":
        r"""
        Adds a name value pair to the NamedValues object 
        name : A name for the name value pair 
        value : A ValueInput object that defines the value of the name value pair 
        Returns true if the name value pair is added successfully.
        """
        return _core.NamedValues_add(self, name, value)

    def _get_count(self) -> "size_t":
        r"""Returns the number of name value pairs in this object."""
        return _core.NamedValues__get_count(self)

    def getByIndex(self, index: "int") -> "bool":
        r"""
        Function that returns the name and ValueInput object of a name value pair
        by specifying an index number 
        index : The index of the name value pair to return. The first pair in the collection 
        has an index of 0. 
        name : The name 
        value : The ValueInput object 
        Returns true if successful
        """
        return _core.NamedValues_getByIndex(self, index)

    def getValueByName(self, name: "std::string const &") -> "bool":
        r"""
        Function that returns the ValueInput object of a name value pair
        by specifying its name 
        name : The name of the name value pair to return the ValueInput object from 
        value : The ValueInput object 
        Returns true if successful
        """
        return _core.NamedValues_getValueByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _core.NamedValues__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.NamedValues__get_isValid(self)

# Register NamedValues in _core:
_core.NamedValues_swigregister(NamedValues)

def NamedValues_classType() -> "char const *":
    return _core.NamedValues_classType()

def NamedValues_create() -> "adsk::core::Ptr< adsk::core::NamedValues >":
    return _core.NamedValues_create()


NamedValues.count = property(NamedValues._get_count, doc="Returns the number of name value pairs in this object.")


NamedValues.cast = lambda arg: arg if isinstance(arg, NamedValues) else None

class NavigationEventHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notify(self, eventArgs: "NavigationEventArgs") -> "void":
        return _core.NavigationEventHandler_notify(self, eventArgs)

    def __init__(self):
        if self.__class__ == NavigationEventHandler:
            _self = None
        else:
            _self = self
        _core.NavigationEventHandler_swiginit(self, _core.new_NavigationEventHandler(_self, ))
    __swig_destroy__ = _core.delete_NavigationEventHandler
    def __disown__(self):
        self.this.disown()
        _core.disown_NavigationEventHandler(self)
        return weakref.proxy(self)

# Register NavigationEventHandler in _core:
_core.NavigationEventHandler_swigregister(NavigationEventHandler)


NavigationEventHandler.cast = lambda arg: arg if isinstance(arg, NavigationEventHandler) else None

class NetworkPreferences(Base):
    r"""The NetworkPreferences object provides access to network related preferences."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::NetworkPreferences *":
        return _core.NetworkPreferences___deref__(self)

    def __eq__(self, rhs: "NetworkPreferences") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.NetworkPreferences___eq__(self, rhs)


    def __ne__(self, rhs: "NetworkPreferences") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.NetworkPreferences___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.NetworkPreferences_classType()
    __swig_destroy__ = _core.delete_NetworkPreferences

    def _get_networkProxySetting(self) -> "adsk::core::NetworkProxySettings":
        r"""Gets and sets the network proxy setting."""
        return _core.NetworkPreferences__get_networkProxySetting(self)

    def _set_networkProxySetting(self, value: "NetworkProxySettings") -> "bool":
        r"""Gets and sets the network proxy setting."""
        return _core.NetworkPreferences__set_networkProxySetting(self, value)

    def _get_proxyHost(self) -> "std::string":
        r"""Gets and sets the proxy host."""
        return _core.NetworkPreferences__get_proxyHost(self)

    def _set_proxyHost(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the proxy host."""
        return _core.NetworkPreferences__set_proxyHost(self, value)

    def _get_proxyPort(self) -> "int":
        r"""Gets and sets the proxy host."""
        return _core.NetworkPreferences__get_proxyPort(self)

    def _set_proxyPort(self, value: "int") -> "bool":
        r"""Gets and sets the proxy host."""
        return _core.NetworkPreferences__set_proxyPort(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.NetworkPreferences__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.NetworkPreferences__get_isValid(self)

# Register NetworkPreferences in _core:
_core.NetworkPreferences_swigregister(NetworkPreferences)

def NetworkPreferences_classType() -> "char const *":
    return _core.NetworkPreferences_classType()


NetworkPreferences.networkProxySetting = property(NetworkPreferences._get_networkProxySetting, NetworkPreferences._set_networkProxySetting, doc="Gets and sets the network proxy setting.")


NetworkPreferences.proxyHost = property(NetworkPreferences._get_proxyHost, NetworkPreferences._set_proxyHost, doc="Gets and sets the proxy host.")


NetworkPreferences.proxyPort = property(NetworkPreferences._get_proxyPort, NetworkPreferences._set_proxyPort, doc="Gets and sets the proxy host.")


NetworkPreferences.cast = lambda arg: arg if isinstance(arg, NetworkPreferences) else None

class ObjectCollection(Base):
    r"""Generic collection used to handle lists of any object type."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ObjectCollection *":
        return _core.ObjectCollection___deref__(self)

    def __eq__(self, rhs: "ObjectCollection") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ObjectCollection___eq__(self, rhs)


    def __ne__(self, rhs: "ObjectCollection") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ObjectCollection___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.ObjectCollection___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::Base >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.ObjectCollection___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.ObjectCollection_classType()

    @staticmethod
    def create() -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        return _core.ObjectCollection_create()
    __swig_destroy__ = _core.delete_ObjectCollection

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Function that returns the specified object using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.ObjectCollection_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of occurrences in the collection."""
        return _core.ObjectCollection__get_count(self)

    def add(self, item: "Base") -> "bool":
        r"""
        Adds an object to the end of the collection. 
        Duplicates can be added to the collection. 
        item : The item to add to the list. 
        Returns false if the item was not added.
        """
        return _core.ObjectCollection_add(self, item)

    def removeByItem(self, item: "Base") -> "bool":
        r"""
        Function that removes an item from the collection. 
        item : The object to remove from the collection. 
        Returns true if the removal was successful.
        """
        return _core.ObjectCollection_removeByItem(self, item)

    def removeByIndex(self, index: "size_t") -> "bool":
        r"""
        Function that removes an item from the list. 
        Will fail if the list is read only. 
        index : The index of the item to remove from the collection. The first item has an index of 0. 
        Returns true if the removal was successful.
        """
        return _core.ObjectCollection_removeByIndex(self, index)

    def find(self, item: "Base", startIndex: "size_t"=0) -> "int":
        r"""
        Finds the specified component in the collection. 
        item : The item to search for within the collection. 
        startIndex : The index to begin the search. 
        Returns the index of the found item. If not found, -1 is returned.
        """
        return _core.ObjectCollection_find(self, item, startIndex)

    def contains(self, item: "Base") -> "bool":
        r"""
        Returns whether the specified object exists within the collection. 
        item : The item to look for in the collection. 
        Returns true if the specified item is found in the collection.
        """
        return _core.ObjectCollection_contains(self, item)

    def clear(self) -> "bool":
        r"""
        Clears the entire contents of the collection. 
        Returns true if successful.
        """
        return _core.ObjectCollection_clear(self)

    def _get_objectType(self) -> "char const *":
        return _core.ObjectCollection__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ObjectCollection__get_isValid(self)

# Register ObjectCollection in _core:
_core.ObjectCollection_swigregister(ObjectCollection)

def ObjectCollection_classType() -> "char const *":
    return _core.ObjectCollection_classType()

def ObjectCollection_create() -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
    return _core.ObjectCollection_create()


ObjectCollection.count = property(ObjectCollection._get_count, doc="Returns the number of occurrences in the collection.")


ObjectCollection.cast = lambda arg: arg if isinstance(arg, ObjectCollection) else None

class OrientedBoundingBox3D(Base):
    r"""
    Transient object that represents an oriented 3D bounding box. An oriented 3D bounding box is a rectangular box that
    can be in any orientation in model space. They are created statically using the create method of the OrientedBoundingBox3D class
    and are used by some functions to return oriented box information.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::OrientedBoundingBox3D *":
        return _core.OrientedBoundingBox3D___deref__(self)

    def __eq__(self, rhs: "OrientedBoundingBox3D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.OrientedBoundingBox3D___eq__(self, rhs)


    def __ne__(self, rhs: "OrientedBoundingBox3D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.OrientedBoundingBox3D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.OrientedBoundingBox3D_classType()

    @staticmethod
    def create(centerPoint: "Point3D", lengthDirection: "Vector3D", widthDirection: "Vector3D", length: "double", width: "double", height: "double") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
        return _core.OrientedBoundingBox3D_create(centerPoint, lengthDirection, widthDirection, length, width, height)
    __swig_destroy__ = _core.delete_OrientedBoundingBox3D

    def _get_centerPoint(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets the centerPoint point of the oriented box."""
        return _core.OrientedBoundingBox3D__get_centerPoint(self)

    def _set_centerPoint(self, value: "Point3D") -> "bool":
        r"""Gets and sets the centerPoint point of the oriented box."""
        return _core.OrientedBoundingBox3D__set_centerPoint(self, value)

    def setOrientation(self, lengthDirection: "Vector3D", widthDirection: "Vector3D") -> "bool":
        r"""
        Sets the orientation of the oriented bouding box. 
        lengthDirection : A Vector3D object that defines the direction of the length of the oriented bounding box. The magnitude of
        the vector is ignored and just the direction is used. 
        widthDirection : A Vector3D object that defines the direction of the width of the oriented bounding box. The magnitude of
        the vector is ignored and just the direction is used. The width direction must be perpendicular to
        the length direction.
        """
        return _core.OrientedBoundingBox3D_setOrientation(self, lengthDirection, widthDirection)

    def _get_lengthDirection(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Gets the direction of the length of the oriented bounding box.
        A unit vector is always returned.
        """
        return _core.OrientedBoundingBox3D__get_lengthDirection(self)

    def _get_length(self) -> "double":
        r"""Gets and sets the length of the oriented bounding box in centimeters."""
        return _core.OrientedBoundingBox3D__get_length(self)

    def _set_length(self, value: "double") -> "bool":
        r"""Gets and sets the length of the oriented bounding box in centimeters."""
        return _core.OrientedBoundingBox3D__set_length(self, value)

    def _get_widthDirection(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Gets the direction of the width of the oriented bounding box.
        A unit vector is always returned.
        """
        return _core.OrientedBoundingBox3D__get_widthDirection(self)

    def _get_width(self) -> "double":
        r"""Gets and sets the width of the oriented bounding box in centimeters."""
        return _core.OrientedBoundingBox3D__get_width(self)

    def _set_width(self, value: "double") -> "bool":
        r"""Gets and sets the width of the oriented bounding box in centimeters."""
        return _core.OrientedBoundingBox3D__set_width(self, value)

    def _get_heightDirection(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Gets the direction of the height of the oriented bounding box.
        A unit vector is always returned.
        """
        return _core.OrientedBoundingBox3D__get_heightDirection(self)

    def _get_height(self) -> "double":
        r"""Gets and sets the height of the oriented bounding box in centimeters."""
        return _core.OrientedBoundingBox3D__get_height(self)

    def _set_height(self, value: "double") -> "bool":
        r"""Gets and sets the height of the oriented bounding box in centimeters."""
        return _core.OrientedBoundingBox3D__set_height(self, value)

    def contains(self, point: "Point3D") -> "bool":
        r"""
        Determines if the specified point lies within the oriented bounding box. 
        point : The point to test containment with. 
        Returns true if the point lies within the bounding box.
        """
        return _core.OrientedBoundingBox3D_contains(self, point)

    def copy(self) -> "adsk::core::Ptr< adsk::core::OrientedBoundingBox3D >":
        r"""
        Create a copy of this oriented bounding box. 
        Returns the new oriented bounding box copy.
        """
        return _core.OrientedBoundingBox3D_copy(self)

    def _get_objectType(self) -> "char const *":
        return _core.OrientedBoundingBox3D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.OrientedBoundingBox3D__get_isValid(self)

# Register OrientedBoundingBox3D in _core:
_core.OrientedBoundingBox3D_swigregister(OrientedBoundingBox3D)

def OrientedBoundingBox3D_classType() -> "char const *":
    return _core.OrientedBoundingBox3D_classType()

def OrientedBoundingBox3D_create(centerPoint: "Point3D", lengthDirection: "Vector3D", widthDirection: "Vector3D", length: "double", width: "double", height: "double") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
    return _core.OrientedBoundingBox3D_create(centerPoint, lengthDirection, widthDirection, length, width, height)


OrientedBoundingBox3D.centerPoint = property(OrientedBoundingBox3D._get_centerPoint, OrientedBoundingBox3D._set_centerPoint, doc="Gets and sets the centerPoint point of the oriented box.")


OrientedBoundingBox3D.lengthDirection = property(OrientedBoundingBox3D._get_lengthDirection, doc="Gets the direction of the length of the oriented bounding box.\nA unit vector is always returned.")


OrientedBoundingBox3D.length = property(OrientedBoundingBox3D._get_length, OrientedBoundingBox3D._set_length, doc="Gets and sets the length of the oriented bounding box in centimeters.")


OrientedBoundingBox3D.widthDirection = property(OrientedBoundingBox3D._get_widthDirection, doc="Gets the direction of the width of the oriented bounding box.\nA unit vector is always returned.")


OrientedBoundingBox3D.width = property(OrientedBoundingBox3D._get_width, OrientedBoundingBox3D._set_width, doc="Gets and sets the width of the oriented bounding box in centimeters.")


OrientedBoundingBox3D.heightDirection = property(OrientedBoundingBox3D._get_heightDirection, doc="Gets the direction of the height of the oriented bounding box.\nA unit vector is always returned.")


OrientedBoundingBox3D.height = property(OrientedBoundingBox3D._get_height, OrientedBoundingBox3D._set_height, doc="Gets and sets the height of the oriented bounding box in centimeters.")


OrientedBoundingBox3D.cast = lambda arg: arg if isinstance(arg, OrientedBoundingBox3D) else None

class Palette(Base):
    r"""
    A Palette is a floating or docked dialog in Fusion 360. The browser is an
    example of a built-in palette. The contents of a custom palette are
    created by displaying an html file.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Palette *":
        return _core.Palette___deref__(self)

    def __eq__(self, rhs: "Palette") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Palette___eq__(self, rhs)


    def __ne__(self, rhs: "Palette") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Palette___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Palette_classType()
    __swig_destroy__ = _core.delete_Palette

    def _get_id(self) -> "std::string":
        r"""Gets The unique, language independent, ID of this palette."""
        return _core.Palette__get_id(self)

    def _get_isVisible(self) -> "bool":
        r"""Gets and sets whether this palette is currently being displayed in the user interface."""
        return _core.Palette__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets and sets whether this palette is currently being displayed in the user interface."""
        return _core.Palette__set_isVisible(self, value)

    def _get_htmlFileURL(self) -> "std::string":
        r"""Gets and sets the URL to the html file currently being displayed. This can be local or on the web."""
        return _core.Palette__get_htmlFileURL(self)

    def _set_htmlFileURL(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the URL to the html file currently being displayed. This can be local or on the web."""
        return _core.Palette__set_htmlFileURL(self, value)

    def sendInfoToHTML(self, action: "std::string const &", data: "std::string const &") -> "std::string":
        r"""
        <p>Sends the string to the JavaScript associated with the loaded HTML. A variation of the
        event handler below should be implemented in the JavaScript associated with the HTML to
        receive the data. The event will be triggered by Fusion 360 whenever the sendInfoToHTML method 
        is called.</p>
        <pre class='api-code'>window.fusionJavaScriptHandler = {
        handle: function(actionString, dataString){
        confirm('Action from Fusion: ' + actionString);
        confirm('Data from Fusion: ' + dataString);
        // Build up JSON return string.
        var result = {};
        result.status = 'OK';
        var response = JSON.stringify(result);
        return response;
        }
        };</pre> 
        <p>Your JavaScript code should always return something in response because an empty string
        response is assumed to be a failure.</p> 
        action : The 'action' string to pass to the JavaScript associated with the HTML. This string can be 
        anything but will typically be JSON formatted information. 
        data : The 'data' string to pass to the JavaScript associated with the HTML. This string can be 
        anything but will typically be JSON formatted information. 
        Returns a string that can be anything that your JavaScript code generates. The JavaScript
        should always return some content because an empty string is used to indicate a failure.
        If useNewWebBrowser flag is set to true while creating the palette control this API call
        will be asynchronous and an empty string is returned. Response will come in data field of HTMLEvent with action
        equal to 'response'.
        """
        return _core.Palette_sendInfoToHTML(self, action, data)

    def _get_incomingFromHTML(self) -> "adsk::core::Ptr< adsk::core::HTMLEvent >":
        r"""
        This event is fired when the JavaScript associated with the HTML calls the 
        adsk.fusionSendData function. This allows the HTML to communicate with the add-in by
        passing information to the add-in.
        """
        return _core.Palette__get_incomingFromHTML(self)

    def _get_closed(self) -> "adsk::core::Ptr< adsk::core::UserInterfaceGeneralEvent >":
        r"""
        This event is fired when the user clicks the 'Close' button on the palette. You can choose
        if the 'Close' button is available or not when you initially create the palette. When a
        palette is closed, it still exists but is change to invisible so you can still interact with it and
        retrieve any needed information and can make it visible again. Use the deleteMe method to
        delete the palette.
        """
        return _core.Palette__get_closed(self)

    def _get_name(self) -> "std::string":
        r"""
        Gets and set the name of the palette as seen in the user interface. The name of native palletes
        cannot be set.
        """
        return _core.Palette__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""
        Gets and set the name of the palette as seen in the user interface. The name of native palletes
        cannot be set.
        """
        return _core.Palette__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this palette. Fusion 360 native palettes cannot be deleted. Use the
        isNative property to determine if this is a native or API created palette. 
        Returns true if the delete was successful.
        """
        return _core.Palette_deleteMe(self)

    def _get_isNative(self) -> "bool":
        r"""
        Indicates if this is one of the standard Fusion 360 palettes or a custom palette
        created through the API. If true, it is a standard Fusion 360 palette and will
        have some restrictions on changing its properties and cannot be deleted.
        """
        return _core.Palette__get_isNative(self)

    def _get_dockingOption(self) -> "adsk::core::PaletteDockingOptions":
        r"""Defines the docking behavior for this palette. This controls how the user is allowed to dock the palette."""
        return _core.Palette__get_dockingOption(self)

    def _set_dockingOption(self, value: "PaletteDockingOptions") -> "bool":
        r"""Defines the docking behavior for this palette. This controls how the user is allowed to dock the palette."""
        return _core.Palette__set_dockingOption(self, value)

    def _get_dockingState(self) -> "adsk::core::PaletteDockingStates":
        r"""Gets and sets how the palette is currented docked."""
        return _core.Palette__get_dockingState(self)

    def _set_dockingState(self, value: "PaletteDockingStates") -> "bool":
        r"""Gets and sets how the palette is currented docked."""
        return _core.Palette__set_dockingState(self, value)

    def _get_width(self) -> "int":
        r"""
        Gets and sets the width of the palette. Setting this property may not always set the width. Depending on
        how the palette is docked or snapped, the width may not be editable.
        """
        return _core.Palette__get_width(self)

    def _set_width(self, value: "int") -> "bool":
        r"""
        Gets and sets the width of the palette. Setting this property may not always set the width. Depending on
        how the palette is docked or snapped, the width may not be editable.
        """
        return _core.Palette__set_width(self, value)

    def _get_height(self) -> "int":
        r"""
        Gets and sets the height of the palette. Setting this property may not always set the height. Depending on
        how the palette is docked or snapped, the height may not be editable.
        """
        return _core.Palette__get_height(self)

    def _set_height(self, value: "int") -> "bool":
        r"""
        Gets and sets the height of the palette. Setting this property may not always set the height. Depending on
        how the palette is docked or snapped, the height may not be editable.
        """
        return _core.Palette__set_height(self, value)

    def setPosition(self, left: "int", top: "int") -> "bool":
        r"""
        Sets the position of the palette. If the palette is docked or snapped, this will result in changing it
        to be floating. 
        left : The position of the left side of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the left side of the screen and not the 
        Fusion 360 window. 
        top : The position of the top of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the top of the screen and not the 
        Fusion 360 window. 
        Returns true if setting the position was successful.
        """
        return _core.Palette_setPosition(self, left, top)

    def setSize(self, width: "int", height: "int") -> "bool":
        r"""
        Sets the size of the palette. This is best used for a floating palette because either the width or
        height can be locked when a palette is docked. 
        width : Specifies the width of the palette. Depending on how the palette is docked or snapped, the width 
        may not be editable. 
        height : Specifies the height of the palette. Depending on how the palette is docked or snapped, the height 
        may not be editable. 
        Returns true if the sizing was succesful. It is still considered a success even if the width or
        height could not be changed because of how the palette is docked or snapped.
        """
        return _core.Palette_setSize(self, width, height)

    def _get_left(self) -> "int":
        r"""
        Gets and sets the left side of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the left side of the screen and not the 
        Fusion 360 window.
        """
        return _core.Palette__get_left(self)

    def _set_left(self, value: "int") -> "bool":
        r"""
        Gets and sets the left side of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the left side of the screen and not the 
        Fusion 360 window.
        """
        return _core.Palette__set_left(self, value)

    def _get_top(self) -> "int":
        r"""
        Gets and sets the top of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the top of the screen and not the 
        Fusion 360 window.
        """
        return _core.Palette__get_top(self)

    def _set_top(self, value: "int") -> "bool":
        r"""
        Gets and sets the top of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the top of the screen and not the 
        Fusion 360 window.
        """
        return _core.Palette__set_top(self, value)

    def snapTo(self, palette: "Palette", snapOption: "PaletteSnapOptions") -> "bool":
        r"""
        Snaps this palette to another palette. 
        palette : Specifies the palette to snap to. 
        snapOption : Specifies how this palette should be snapped to the other palette. 
        Returns true if the palette was successfully snapped to the other palette.
        """
        return _core.Palette_snapTo(self, palette, snapOption)

    def setMinimumSize(self, width: "int", height: "int") -> "bool":
        r"""
        Sets the minimum size of the palette. The user cannot resize it to be smaller than
        this size. This does not change the current size of the palette unless the palette
        is already smaller than this size.
        Calling this method and setting the width and height to zero, removes the minimum
        size restriction. 
        width : Specifies the minimum width of the palette. 
        height : Specifies the minimum height of the palette. 
        Returns true if setting the minimum size was succesful.
        """
        return _core.Palette_setMinimumSize(self, width, height)

    def setMaximumSize(self, width: "int", height: "int") -> "bool":
        r"""
        Sets the maximum size of the palette. The user cannot resize it to be larger than
        this size. This does not change the current size of the palette unless the palette
        is already larger than this size.
        Calling this method and setting the width and height to zero, removes the maximum
        size restriction. 
        width : Specifies the maximum width of the palette. 
        height : Specifies the maximum height of the palette. 
        Returns true if setting the maximum size was succesful.
        """
        return _core.Palette_setMaximumSize(self, width, height)

    def _get_navigatingURL(self) -> "adsk::core::Ptr< adsk::core::NavigationEvent >":
        r"""
        This event is fired when a navigation event occurs on the page. This allows the add-in to determine
        how this navigation should be handled by the browser.
        """
        return _core.Palette__get_navigatingURL(self)

    def _get_objectType(self) -> "char const *":
        return _core.Palette__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Palette__get_isValid(self)

# Register Palette in _core:
_core.Palette_swigregister(Palette)

def Palette_classType() -> "char const *":
    return _core.Palette_classType()


Palette.id = property(Palette._get_id, doc="Gets The unique, language independent, ID of this palette.")


Palette.isVisible = property(Palette._get_isVisible, Palette._set_isVisible, doc="Gets and sets whether this palette is currently being displayed in the user interface.")


Palette.htmlFileURL = property(Palette._get_htmlFileURL, Palette._set_htmlFileURL, doc="Gets and sets the URL to the html file currently being displayed. This can be local or on the web.")


Palette.incomingFromHTML = property(Palette._get_incomingFromHTML, doc="This event is fired when the JavaScript associated with the HTML calls the\nadsk.fusionSendData function. This allows the HTML to communicate with the add-in by\npassing information to the add-in.")


Palette.closed = property(Palette._get_closed, doc="This event is fired when the user clicks the 'Close' button on the palette. You can choose\nif the 'Close' button is available or not when you initially create the palette. When a\npalette is closed, it still exists but is change to invisible so you can still interact with it and\nretrieve any needed information and can make it visible again. Use the deleteMe method to\ndelete the palette.")


Palette.name = property(Palette._get_name, Palette._set_name, doc="Gets and set the name of the palette as seen in the user interface. The name of native palletes\ncannot be set.")


Palette.isNative = property(Palette._get_isNative, doc="Indicates if this is one of the standard Fusion 360 palettes or a custom palette\ncreated through the API. If true, it is a standard Fusion 360 palette and will\nhave some restrictions on changing its properties and cannot be deleted.")


Palette.dockingOption = property(Palette._get_dockingOption, Palette._set_dockingOption, doc="Defines the docking behavior for this palette. This controls how the user is allowed to dock the palette.")


Palette.dockingState = property(Palette._get_dockingState, Palette._set_dockingState, doc="Gets and sets how the palette is currented docked.")


Palette.width = property(Palette._get_width, Palette._set_width, doc="Gets and sets the width of the palette. Setting this property may not always set the width. Depending on\nhow the palette is docked or snapped, the width may not be editable.")


Palette.height = property(Palette._get_height, Palette._set_height, doc="Gets and sets the height of the palette. Setting this property may not always set the height. Depending on\nhow the palette is docked or snapped, the height may not be editable.")


Palette.left = property(Palette._get_left, Palette._set_left, doc="Gets and sets the left side of the palette relative to screen space and in pixels. Because palettes can be\npositioned outside of the Fusion 360 window, a value of zero indicates the left side of the screen and not the\nFusion 360 window.")


Palette.top = property(Palette._get_top, Palette._set_top, doc="Gets and sets the top of the palette relative to screen space and in pixels. Because palettes can be\npositioned outside of the Fusion 360 window, a value of zero indicates the top of the screen and not the\nFusion 360 window.")


Palette.navigatingURL = property(Palette._get_navigatingURL, doc="This event is fired when a navigation event occurs on the page. This allows the add-in to determine\nhow this navigation should be handled by the browser.")


Palette.cast = lambda arg: arg if isinstance(arg, Palette) else None

class Palettes(Base):
    r"""Provides access to a set of palettes, which are docked or floating windows that display html."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Palettes *":
        return _core.Palettes___deref__(self)

    def __eq__(self, rhs: "Palettes") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Palettes___eq__(self, rhs)


    def __ne__(self, rhs: "Palettes") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Palettes___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.Palettes___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::Palette >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.Palettes___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.Palettes_classType()
    __swig_destroy__ = _core.delete_Palettes

    def add(self, id: "std::string const &", name: "std::string const &", htmlFileURL: "std::string const &", isVisible: "bool", showCloseButton: "bool", isResizable: "bool", width: "int"=200, height: "int"=200, useNewWebBrowser: "bool"=False) -> "adsk::core::Ptr< adsk::core::Palette >":
        r"""
        Creates a new Palette. 
        id : The unique id for this palette. The id must be unique with respect to all of the palettes. 
        name : The displayed name of this palette. This is the name visible in the user interface. 
        htmlFileURL : Specifies the url to the HTML file that will be displayed in the pallete. This can be a local file or on the web. 
        isVisible : Specifies if the palette is initially visible or not. It's useful to create it invisisibly, change other desired
        properties and then use the isVisible property to finally make it visible to the user. 
        showCloseButton : Specifies if a 'Close' button should be displayed on the palette to allow the user to easily close it. 
        isResizable : Specifies if the palette can be resized by the user or not. 
        width : Specifies the width of the palette in pixels. If no width is specified a default width will be used. 
        height : Specifies the height of the palette in pixels. If no height is specified a default height will be used. 
        useNewWebBrowser : Specifies true to use new browser in the palette. This is false by default to support existing clients.
        Support for old browser is deprecated and will be taken out soon. 
        Returns the newly created palette or null in the case the creation failed.
        """
        return _core.Palettes_add(self, id, name, htmlFileURL, isVisible, showCloseButton, isResizable, width, height, useNewWebBrowser)

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::Palette >":
        r"""
        Returns the specified palette using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.Palettes_item(self, index)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::Palette >":
        r"""
        Returns the palette at the specified ID. 
        id : The Id of the palette within the collection to return. 
        Returns the palette of the specified id or null if no palette has the specified id.
        """
        return _core.Palettes_itemById(self, id)

    def _get_count(self) -> "size_t":
        r"""Gets the number of Palettes."""
        return _core.Palettes__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _core.Palettes__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Palettes__get_isValid(self)

# Register Palettes in _core:
_core.Palettes_swigregister(Palettes)

def Palettes_classType() -> "char const *":
    return _core.Palettes_classType()


Palettes.count = property(Palettes._get_count, doc="Gets the number of Palettes.")


Palettes.cast = lambda arg: arg if isinstance(arg, Palettes) else None

class Point2D(Base):
    r"""
    Transient 2D point. A transient point is not displayed or saved in a document.
    Transient 2D points are used as a wrapper to work with raw 2D point information.
    They are created statically using the create methods of the Point2D class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Point2D *":
        return _core.Point2D___deref__(self)

    def __eq__(self, rhs: "Point2D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Point2D___eq__(self, rhs)


    def __ne__(self, rhs: "Point2D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Point2D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Point2D_classType()

    @staticmethod
    def create(x: "double"=0, y: "double"=0) -> "adsk::core::Ptr< adsk::core::Point2D >":
        return _core.Point2D_create(x, y)
    __swig_destroy__ = _core.delete_Point2D

    def _get_x(self) -> "double":
        r"""Gets and sets the X coordinate of the point."""
        return _core.Point2D__get_x(self)

    def _set_x(self, value: "double") -> "bool":
        r"""Gets and sets the X coordinate of the point."""
        return _core.Point2D__set_x(self, value)

    def _get_y(self) -> "double":
        r"""Gets and sets the Y coordinate of the point."""
        return _core.Point2D__get_y(self)

    def _set_y(self, value: "double") -> "bool":
        r"""Gets and sets the Y coordinate of the point."""
        return _core.Point2D__set_y(self, value)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Point2D >":
        r"""
        Creates and returns a copy of this point object. 
        Returns an independent copy of this point object.
        """
        return _core.Point2D_copy(self)

    def getData(self) -> "bool":
        r"""
        Gets the data defining the point. 
        x : The output x coordinate of the point. 
        y : The output y coordinate of the point. 
        Returns true if successful.
        """
        return _core.Point2D_getData(self)

    def distanceTo(self, point: "Point2D") -> "double":
        r"""
        Returns the distance from this point to another point. 
        point : The point to measure the distance to 
        Returns the distance to the point.
        """
        return _core.Point2D_distanceTo(self, point)

    def asArray(self) -> "std::vector< double,std::allocator< double > >":
        r"""
        Get coordinate data of the point 
        Returns the coordinate data of the point as an array
        """
        return _core.Point2D_asArray(self)

    def isEqualTo(self, point: "Point2D") -> "bool":
        r"""
        Checks to see if this point and another point are equal (have identical coordinates).
        The comparison is done within the modeling tolerance which can be found with the
        Application.pointTolerance property. If you want to compare two points with any other
        tolerance you can use the isEqualToByTolerance method. 
        point : The point to compare for equality 
        Returns true if the points are equal. (have identical coordinates)
        """
        return _core.Point2D_isEqualTo(self, point)

    def setWithArray(self, coordinates: "DoubleVector") -> "bool":
        r"""
        Sets the coordinates of the point using an array as input. 
        coordinates : An array that defines the coordinates of the point 
        Returns true if successful
        """
        return _core.Point2D_setWithArray(self, coordinates)

    def set(self, x: "double", y: "double") -> "bool":
        r"""
        Sets the coordinates of the point by specifying the x, y coordinates. 
        x : The x coordinate of the point. 
        y : The y coordinate of the point. 
        Returns true if successful
        """
        return _core.Point2D_set(self, x, y)

    def transformBy(self, matrix: "Matrix2D") -> "bool":
        r"""
        Transforms the point using the provided matrix. 
        matrix : The Matrix2D object that defines the transformation 
        Returns true if successful
        """
        return _core.Point2D_transformBy(self, matrix)

    def asVector(self) -> "adsk::core::Ptr< adsk::core::Vector2D >":
        r"""
        Defines a vector using the coordinates of the point. 
        Returns a Vector2D object
        """
        return _core.Point2D_asVector(self)

    def translateBy(self, vector: "Vector2D") -> "bool":
        r"""
        Translates the point using the provided vector. 
        vector : The vector to use to translate the point 
        Returns true if successful
        """
        return _core.Point2D_translateBy(self, vector)

    def vectorTo(self, point: "Point2D") -> "adsk::core::Ptr< adsk::core::Vector2D >":
        r"""
        Returns a vector from this point to another point. 
        point : The other point to use to create the vector 
        Returns a Vector2D object
        """
        return _core.Point2D_vectorTo(self, point)

    def isEqualToByTolerance(self, point: "Point2D", tolerance: "double") -> "bool":
        r"""
        Checks to see if this point and another point are equal within the specified tolerance. 
        point : The point to compare for equality. 
        tolerance : The tolerance, in centimeters, to use when comparing the two points. 
        Returns true if the points are equal (have identical coordinates).
        """
        return _core.Point2D_isEqualToByTolerance(self, point, tolerance)

    def _get_objectType(self) -> "char const *":
        return _core.Point2D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Point2D__get_isValid(self)

# Register Point2D in _core:
_core.Point2D_swigregister(Point2D)

def Point2D_classType() -> "char const *":
    return _core.Point2D_classType()

def Point2D_create(x: "double"=0, y: "double"=0) -> "adsk::core::Ptr< adsk::core::Point2D >":
    return _core.Point2D_create(x, y)


Point2D.x = property(Point2D._get_x, Point2D._set_x, doc="Gets and sets the X coordinate of the point.")


Point2D.y = property(Point2D._get_y, Point2D._set_y, doc="Gets and sets the Y coordinate of the point.")


Point2D.cast = lambda arg: arg if isinstance(arg, Point2D) else None

class Point3D(Base):
    r"""
    Transient 3D point. A transient point is not displayed or saved in a document. 
    Transient 3D points are used as a wrapper to work with raw 3D point information.
    They are created statically using the create method of the Point3D class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Point3D *":
        return _core.Point3D___deref__(self)

    def __eq__(self, rhs: "Point3D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Point3D___eq__(self, rhs)


    def __ne__(self, rhs: "Point3D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Point3D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Point3D_classType()

    @staticmethod
    def create(x: "double"=0, y: "double"=0, z: "double"=0) -> "adsk::core::Ptr< adsk::core::Point3D >":
        return _core.Point3D_create(x, y, z)
    __swig_destroy__ = _core.delete_Point3D

    def distanceTo(self, point: "Point3D") -> "double":
        r"""
        Returns the distance from this point to another point. 
        point : The point to measure the distance to. 
        Returns the distance to the point.
        """
        return _core.Point3D_distanceTo(self, point)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""
        Creates and returns a copy of this point object. 
        Returns an independent copy of this point object.
        """
        return _core.Point3D_copy(self)

    def asArray(self) -> "std::vector< double,std::allocator< double > >":
        r"""
        Get coordinate data of the point. 
        Returns the coordinate data of the point as an array [x, y, z].
        """
        return _core.Point3D_asArray(self)

    def isEqualTo(self, point: "Point3D") -> "bool":
        r"""
        Checks to see if this point and another point are equal (have identical coordinates).
        The comparison is done within the modeling tolerance which can be found with the
        Application.pointTolerance property. If you want to compare two points with any other
        tolerance you can use the isEqualToByTolerance method. 
        point : The point to compare for equality. 
        Returns true if the points are equal (have identical coordinates).
        """
        return _core.Point3D_isEqualTo(self, point)

    def setWithArray(self, coordinates: "DoubleVector") -> "bool":
        r"""
        Sets the coordinates of the point using an array as input. 
        coordinates : An array that defines the coordinates of the point [x, y, z]. 
        Returns true if successful.
        """
        return _core.Point3D_setWithArray(self, coordinates)

    def transformBy(self, matrix: "Matrix3D") -> "bool":
        r"""
        Transforms the point using the provided matrix. 
        matrix : The Matrix3D object that defines the transformation. 
        Returns true if successful.
        """
        return _core.Point3D_transformBy(self, matrix)

    def _get_x(self) -> "double":
        r"""Gets and sets the X coordinate of the point."""
        return _core.Point3D__get_x(self)

    def _set_x(self, value: "double") -> "bool":
        r"""Gets and sets the X coordinate of the point."""
        return _core.Point3D__set_x(self, value)

    def _get_y(self) -> "double":
        r"""Gets and sets the Y coordinate of the point."""
        return _core.Point3D__get_y(self)

    def _set_y(self, value: "double") -> "bool":
        r"""Gets and sets the Y coordinate of the point."""
        return _core.Point3D__set_y(self, value)

    def _get_z(self) -> "double":
        r"""Gets and sets the Z coordinate of the point."""
        return _core.Point3D__get_z(self)

    def _set_z(self, value: "double") -> "bool":
        r"""Gets and sets the Z coordinate of the point."""
        return _core.Point3D__set_z(self, value)

    def asVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Defines a vector using the coordinates of the point. 
        Returns a Vector2D object.
        """
        return _core.Point3D_asVector(self)

    def translateBy(self, vector: "Vector3D") -> "bool":
        r"""
        Translates the point using the provided vector. 
        vector : The vector to use to translate the point. 
        Returns true if successful.
        """
        return _core.Point3D_translateBy(self, vector)

    def getData(self) -> "bool":
        r"""
        Gets the data defining the point. 
        x : The output x coordinate of the point. 
        y : The output y coordinate of the point. 
        z : The output z coordinate of the point. 
        Returns true if successful.
        """
        return _core.Point3D_getData(self)

    def set(self, x: "double", y: "double", z: "double") -> "bool":
        r"""
        Sets the data defining the point. 
        x : The x coordinate of the point. 
        y : The y coordinate of the point. 
        z : The z coordinate of the point. 
        Returns true if successful.
        """
        return _core.Point3D_set(self, x, y, z)

    def vectorTo(self, point: "Point3D") -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Returns a vector from this point to another point. 
        point : The other point to use to create the vector. 
        Returns a Vector3D object.
        """
        return _core.Point3D_vectorTo(self, point)

    def isEqualToByTolerance(self, point: "Point3D", tolerance: "double") -> "bool":
        r"""
        Checks to see if this point and another point are equal within the specified tolerance. 
        point : The point to compare for equality. 
        tolerance : The tolerance, in centimeters, to use when comparing the two points. 
        Returns true if the points are equal (have identical coordinates).
        """
        return _core.Point3D_isEqualToByTolerance(self, point, tolerance)

    def _get_objectType(self) -> "char const *":
        return _core.Point3D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Point3D__get_isValid(self)

# Register Point3D in _core:
_core.Point3D_swigregister(Point3D)

def Point3D_classType() -> "char const *":
    return _core.Point3D_classType()

def Point3D_create(x: "double"=0, y: "double"=0, z: "double"=0) -> "adsk::core::Ptr< adsk::core::Point3D >":
    return _core.Point3D_create(x, y, z)


Point3D.x = property(Point3D._get_x, Point3D._set_x, doc="Gets and sets the X coordinate of the point.")


Point3D.y = property(Point3D._get_y, Point3D._set_y, doc="Gets and sets the Y coordinate of the point.")


Point3D.z = property(Point3D._get_z, Point3D._set_z, doc="Gets and sets the Z coordinate of the point.")


Point3D.cast = lambda arg: arg if isinstance(arg, Point3D) else None

class Preferences(Base):
    r"""
    The Preferences object provides access to the various preference related objects
    for getting and setting the various preference values.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Preferences *":
        return _core.Preferences___deref__(self)

    def __eq__(self, rhs: "Preferences") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Preferences___eq__(self, rhs)


    def __ne__(self, rhs: "Preferences") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Preferences___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Preferences_classType()
    __swig_destroy__ = _core.delete_Preferences

    def _get_generalPreferences(self) -> "adsk::core::Ptr< adsk::core::GeneralPreferences >":
        r"""Gets the GeneralPreferences object."""
        return _core.Preferences__get_generalPreferences(self)

    def _get_materialPreferences(self) -> "adsk::core::Ptr< adsk::core::MaterialPreferences >":
        r"""Gets the MaterialPreferences object."""
        return _core.Preferences__get_materialPreferences(self)

    def _get_graphicsPreferences(self) -> "adsk::core::Ptr< adsk::core::GraphicsPreferences >":
        r"""Gets the GraphicsPreferences object."""
        return _core.Preferences__get_graphicsPreferences(self)

    def _get_networkPreferences(self) -> "adsk::core::Ptr< adsk::core::NetworkPreferences >":
        r"""Gets the NetworkPreferences object."""
        return _core.Preferences__get_networkPreferences(self)

    def _get_unitAndValuePreferences(self) -> "adsk::core::Ptr< adsk::core::UnitAndValuePreferences >":
        r"""Gets the UnitAndValuePreferences object."""
        return _core.Preferences__get_unitAndValuePreferences(self)

    def _get_defaultUnitsPreferences(self) -> "adsk::core::Ptr< adsk::core::DefaultUnitsPreferencesCollection >":
        r"""Gets the DefaultUnitsPreferences object."""
        return _core.Preferences__get_defaultUnitsPreferences(self)

    def _get_productPreferences(self) -> "adsk::core::Ptr< adsk::core::ProductPreferencesCollection >":
        r"""Gets the ProductPreferences object."""
        return _core.Preferences__get_productPreferences(self)

    def _get_gridPreferences(self) -> "adsk::core::Ptr< adsk::core::GridPreferences >":
        r"""Gets the GridPreferences object."""
        return _core.Preferences__get_gridPreferences(self)

    def _get_productUsageData(self) -> "adsk::core::Ptr< adsk::core::ProductUsageData >":
        r"""Gets the ProductUsageData object."""
        return _core.Preferences__get_productUsageData(self)

    def _get_objectType(self) -> "char const *":
        return _core.Preferences__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Preferences__get_isValid(self)

# Register Preferences in _core:
_core.Preferences_swigregister(Preferences)

def Preferences_classType() -> "char const *":
    return _core.Preferences_classType()


Preferences.generalPreferences = property(Preferences._get_generalPreferences, doc="Gets the GeneralPreferences object.")


Preferences.materialPreferences = property(Preferences._get_materialPreferences, doc="Gets the MaterialPreferences object.")


Preferences.graphicsPreferences = property(Preferences._get_graphicsPreferences, doc="Gets the GraphicsPreferences object.")


Preferences.networkPreferences = property(Preferences._get_networkPreferences, doc="Gets the NetworkPreferences object.")


Preferences.unitAndValuePreferences = property(Preferences._get_unitAndValuePreferences, doc="Gets the UnitAndValuePreferences object.")


Preferences.defaultUnitsPreferences = property(Preferences._get_defaultUnitsPreferences, doc="Gets the DefaultUnitsPreferences object.")


Preferences.productPreferences = property(Preferences._get_productPreferences, doc="Gets the ProductPreferences object.")


Preferences.gridPreferences = property(Preferences._get_gridPreferences, doc="Gets the GridPreferences object.")


Preferences.productUsageData = property(Preferences._get_productUsageData, doc="Gets the ProductUsageData object.")


Preferences.cast = lambda arg: arg if isinstance(arg, Preferences) else None

class Product(Base):
    r"""
    The base class for the various product specific containers. For
    Fusion 360 this is the Design object. For manufacturing this is a CAM object.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Product *":
        return _core.Product___deref__(self)

    def __eq__(self, rhs: "Product") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Product___eq__(self, rhs)


    def __ne__(self, rhs: "Product") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Product___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Product_classType()
    __swig_destroy__ = _core.delete_Product

    def _get_parentDocument(self) -> "adsk::core::Ptr< adsk::core::Document >":
        r"""Returns the parent Document object."""
        return _core.Product__get_parentDocument(self)

    def _get_unitsManager(self) -> "adsk::core::Ptr< adsk::core::UnitsManager >":
        r"""Returns the UnitsManager object associated with this product."""
        return _core.Product__get_unitsManager(self)

    def _get_workspaces(self) -> "adsk::core::Ptr< adsk::core::WorkspaceList >":
        r"""Returns the workspaces associated with this product."""
        return _core.Product__get_workspaces(self)

    def _get_productType(self) -> "std::string":
        r"""
        Returns the product type name of this product. A list of all of
        the possible product types can be obtained by using the 
        Application.supportedProductTypes property.
        """
        return _core.Product__get_productType(self)

    def findAttributes(self, groupName: "std::string const &", attributeName: "std::string const &") -> "std::vector< adsk::core::Ptr< adsk::core::Attribute >,std::allocator< adsk::core::Ptr< adsk::core::Attribute > > >":
        r"""
        Find attributes attached to objects in this product that match the group and or attribute name.
        This does not find attributes attached directly to the Product or Document objects but finds the
        attributes attached to entities within the product.
        The search string for both the groupName and attributeName arguments can be either an absolute 
        name value, or a regular expression. With an absolute name, the search string must match the
        entire groupName or attributeName, including case. An empty string will match everything.
        For example if you have an attribute group named 'MyStuff' that contains the attribute 'Length1', 
        using the search string 'MyStuff' as the group name and 'Length1' as the attribute name will 
        find the attributes with those names. Searching for 'MyStuff' as the group name and '' as the
        attribute name will find all attributes that have 'MyStuff' as the group name.
        Regular expressions provide a more flexible way of searching. To use a regular expression, 
        prefix the input string for the groupName or attributeName arguments with 're:'. The regular
        expression much match the entire group or attribute name. For example if you have a group that
        contains attributes named 'Length1', 'Length2', 'Width1', and 'Width2' and want to find any 
        of the length attributes you can use a regular expression using the string 're:Length.*'. For more
        information on attributes see the Attributes topic in the user manual. 
        groupName : The search string for the group name. See above for more details. 
        attributeName : The search string for the attribute name. See above for more details. 
        An array of Attribute objects that were found. An empty array is returned if no attributes were found.
        """
        return _core.Product_findAttributes(self, groupName, attributeName)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this product."""
        return _core.Product__get_attributes(self)

    def deleteEntities(self, entities: "ObjectCollection") -> "bool":
        r"""
        Deletes the specified set of entities that are associated with this product. 
        entities : An ObjectCollection containing the list of entities to delete. 
        Returns True if any of the entities provided in the list were deleted. If
        entities were specified that can't be deleted or aren't owned by this product,
        they are ignored.
        """
        return _core.Product_deleteEntities(self, entities)

    def _get_objectType(self) -> "char const *":
        return _core.Product__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Product__get_isValid(self)

# Register Product in _core:
_core.Product_swigregister(Product)

def Product_classType() -> "char const *":
    return _core.Product_classType()


Product.parentDocument = property(Product._get_parentDocument, doc="Returns the parent Document object.")


Product.unitsManager = property(Product._get_unitsManager, doc="Returns the UnitsManager object associated with this product.")


Product.workspaces = property(Product._get_workspaces, doc="Returns the workspaces associated with this product.")


Product.productType = property(Product._get_productType, doc="Returns the product type name of this product. A list of all of\nthe possible product types can be obtained by using the\nApplication.supportedProductTypes property.")


Product.attributes = property(Product._get_attributes, doc="Returns the collection of attributes associated with this product.")


Product.cast = lambda arg: arg if isinstance(arg, Product) else None

class ProductPreferences(Base):
    r"""
    The base class for the general product preferences. There is a derived class
    for each product where the specific preference values are exposed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ProductPreferences *":
        return _core.ProductPreferences___deref__(self)

    def __eq__(self, rhs: "ProductPreferences") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ProductPreferences___eq__(self, rhs)


    def __ne__(self, rhs: "ProductPreferences") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ProductPreferences___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ProductPreferences_classType()
    __swig_destroy__ = _core.delete_ProductPreferences

    def _get_name(self) -> "std::string":
        r"""Returns the name of this ProductPreferences object."""
        return _core.ProductPreferences__get_name(self)

    def _get_objectType(self) -> "char const *":
        return _core.ProductPreferences__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ProductPreferences__get_isValid(self)

# Register ProductPreferences in _core:
_core.ProductPreferences_swigregister(ProductPreferences)

def ProductPreferences_classType() -> "char const *":
    return _core.ProductPreferences_classType()


ProductPreferences.name = property(ProductPreferences._get_name, doc="Returns the name of this ProductPreferences object.")


ProductPreferences.cast = lambda arg: arg if isinstance(arg, ProductPreferences) else None

class ProductPreferencesCollection(Base):
    r"""A collection that provides access to product specific preference objects."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ProductPreferencesCollection *":
        return _core.ProductPreferencesCollection___deref__(self)

    def __eq__(self, rhs: "ProductPreferencesCollection") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ProductPreferencesCollection___eq__(self, rhs)


    def __ne__(self, rhs: "ProductPreferencesCollection") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ProductPreferencesCollection___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.ProductPreferencesCollection___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::ProductPreferences >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.ProductPreferencesCollection___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.ProductPreferencesCollection_classType()
    __swig_destroy__ = _core.delete_ProductPreferencesCollection

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::ProductPreferences >":
        r"""
        Function that returns the specified ProfductPreferences object using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.ProductPreferencesCollection_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::core::ProductPreferences >":
        r"""
        Returns the ProductPreference object with the specified name. 
        name : The name of the ProductPreferences to return. 
        Returns the ProductPreferences object or null if if an invalid name was specified.
        """
        return _core.ProductPreferencesCollection_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""Returns the number of ProductPreference objects."""
        return _core.ProductPreferencesCollection__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _core.ProductPreferencesCollection__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ProductPreferencesCollection__get_isValid(self)

# Register ProductPreferencesCollection in _core:
_core.ProductPreferencesCollection_swigregister(ProductPreferencesCollection)

def ProductPreferencesCollection_classType() -> "char const *":
    return _core.ProductPreferencesCollection_classType()


ProductPreferencesCollection.count = property(ProductPreferencesCollection._get_count, doc="Returns the number of ProductPreference objects.")


ProductPreferencesCollection.cast = lambda arg: arg if isinstance(arg, ProductPreferencesCollection) else None

class Products(Base):
    r"""The Products object provides access to all of the products that exist in the document."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Products *":
        return _core.Products___deref__(self)

    def __eq__(self, rhs: "Products") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Products___eq__(self, rhs)


    def __ne__(self, rhs: "Products") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Products___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.Products___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::Product >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.Products___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.Products_classType()
    __swig_destroy__ = _core.delete_Products

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::Product >":
        r"""
        Function that returns the specified product using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.Products_item(self, index)

    def itemByProductType(self, productType: "std::string const &") -> "adsk::core::Ptr< adsk::core::Product >":
        r"""
        Returns the specified product, if it exists within this document. 
        productType : The product type string. For example, to get the product that represents the design data
        you use 'DesignProductType' or to get the product that represent the CAM data you use 'CAMProductType'.
        A complete list of available products can be obtained by using the Application.supportedProductTypes property. 
        Returns the specified item or null if the specified productType does not exist within this document.
        """
        return _core.Products_itemByProductType(self, productType)

    def _get_count(self) -> "size_t":
        r"""Returns the number of products within the collection."""
        return _core.Products__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _core.Products__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Products__get_isValid(self)

# Register Products in _core:
_core.Products_swigregister(Products)

def Products_classType() -> "char const *":
    return _core.Products_classType()


Products.count = property(Products._get_count, doc="Returns the number of products within the collection.")


Products.cast = lambda arg: arg if isinstance(arg, Products) else None

class ProductUsageData(Base):
    r"""Provides access to the product usage data settings."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ProductUsageData *":
        return _core.ProductUsageData___deref__(self)

    def __eq__(self, rhs: "ProductUsageData") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ProductUsageData___eq__(self, rhs)


    def __ne__(self, rhs: "ProductUsageData") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ProductUsageData___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ProductUsageData_classType()
    __swig_destroy__ = _core.delete_ProductUsageData

    def _get_isTrackingToImproveSoftwareEnabled(self) -> "bool":
        r"""Gets and sets if tracking to improve the software is enabled."""
        return _core.ProductUsageData__get_isTrackingToImproveSoftwareEnabled(self)

    def _set_isTrackingToImproveSoftwareEnabled(self, value: "bool") -> "bool":
        r"""Gets and sets if tracking to improve the software is enabled."""
        return _core.ProductUsageData__set_isTrackingToImproveSoftwareEnabled(self, value)

    def _get_isTrackingToImproveCommunicationEnabled(self) -> "bool":
        r"""Gets and sets if tracking to improve communication is enabled."""
        return _core.ProductUsageData__get_isTrackingToImproveCommunicationEnabled(self)

    def _set_isTrackingToImproveCommunicationEnabled(self, value: "bool") -> "bool":
        r"""Gets and sets if tracking to improve communication is enabled."""
        return _core.ProductUsageData__set_isTrackingToImproveCommunicationEnabled(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.ProductUsageData__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ProductUsageData__get_isValid(self)

# Register ProductUsageData in _core:
_core.ProductUsageData_swigregister(ProductUsageData)

def ProductUsageData_classType() -> "char const *":
    return _core.ProductUsageData_classType()


ProductUsageData.isTrackingToImproveSoftwareEnabled = property(ProductUsageData._get_isTrackingToImproveSoftwareEnabled, ProductUsageData._set_isTrackingToImproveSoftwareEnabled, doc="Gets and sets if tracking to improve the software is enabled.")


ProductUsageData.isTrackingToImproveCommunicationEnabled = property(ProductUsageData._get_isTrackingToImproveCommunicationEnabled, ProductUsageData._set_isTrackingToImproveCommunicationEnabled, doc="Gets and sets if tracking to improve communication is enabled.")


ProductUsageData.cast = lambda arg: arg if isinstance(arg, ProductUsageData) else None

class ProgressDialog(Base):
    r"""Provides access to the progress dialog."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ProgressDialog *":
        return _core.ProgressDialog___deref__(self)

    def __eq__(self, rhs: "ProgressDialog") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ProgressDialog___eq__(self, rhs)


    def __ne__(self, rhs: "ProgressDialog") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ProgressDialog___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ProgressDialog_classType()
    __swig_destroy__ = _core.delete_ProgressDialog

    def show(self, title: "std::string const &", message: "std::string const &", minimumValue: "int", maximumValue: "int", delay: "int"=0) -> "bool":
        r"""
        Displays the progress dialog that includes a progress bar that can be used to display a continually updated 
        message indicating the progress of a process that will take more than a few seconds. 
        The progress is determined by comparing the current progress value with the minimum and maximum values. 
        title : Sets the title for the progress dialog 
        message : The message to display along with the progress bar. The following symbols can be used
        to display values. '%p' is replaced by the percentage completed. '%v' is replaced
        by the current value. %m is replaced by the total number of steps. For example, the
        message 'Processing section %v of %m.' will result in the message 'Processing section
        1 of 10.' to be displayed if the maximum value is 10 and the current value is 1. 
        minimumValue : The minimum value of the progress bar. This is used along with the maximum value and the 
        progress value to compute the current percentage complete. This is also the initial 
        progress value when the progress bar is first displayed. 
        maximumValue : The maximum value of the progress bar. This is used along with the minimum value and the 
        progress value to compute the current percentage complete. 
        delay : Specifies the time interval in seconds to delay displaying the Progress Dialog. This provides a way to hide 
        the progress dialog before it actually gets displayed, which is useful for cases where the progress of the 
        operation being tracked completes quickly and there is no need to indicate progress to the user. 
        Returns true if successful.
        """
        return _core.ProgressDialog_show(self, title, message, minimumValue, maximumValue, delay)

    def hide(self) -> "bool":
        r"""
        Hides the progress dialog. This should be used when the process has completed. 
        Returns true if successful.
        """
        return _core.ProgressDialog_hide(self)

    def _get_title(self) -> "std::string":
        r"""Gets and sets the title of the progress dialog"""
        return _core.ProgressDialog__get_title(self)

    def _set_title(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the title of the progress dialog"""
        return _core.ProgressDialog__set_title(self, value)

    def _get_message(self) -> "std::string":
        r"""
        Gets and sets the message to display along with the progress bar. The following symbols can be used
        to display values. '%p' is replaced by the percentage completed. '%v' is replaced
        by the current value. %m is replaced by the total number of steps. For example, the
        message 'Processing section %v of %m.' will result in the message 'Processing section
        1 of 10.' to be displayed if the maximum value is 10 and the current value is 1.
        Specify an empty string ('') for no message to appear along with the progress panel.
        """
        return _core.ProgressDialog__get_message(self)

    def _set_message(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the message to display along with the progress bar. The following symbols can be used
        to display values. '%p' is replaced by the percentage completed. '%v' is replaced
        by the current value. %m is replaced by the total number of steps. For example, the
        message 'Processing section %v of %m.' will result in the message 'Processing section
        1 of 10.' to be displayed if the maximum value is 10 and the current value is 1.
        Specify an empty string ('') for no message to appear along with the progress panel.
        """
        return _core.ProgressDialog__set_message(self, value)

    def _get_minimumValue(self) -> "int":
        r"""
        The minimum value of the progress bar. This is used along with the maximum value and the 
        progress value to compute the current percentage complete. This is also the initial 
        progress value when the progress bar is first displayed.
        """
        return _core.ProgressDialog__get_minimumValue(self)

    def _set_minimumValue(self, value: "int") -> "bool":
        r"""
        The minimum value of the progress bar. This is used along with the maximum value and the 
        progress value to compute the current percentage complete. This is also the initial 
        progress value when the progress bar is first displayed.
        """
        return _core.ProgressDialog__set_minimumValue(self, value)

    def _get_maximumValue(self) -> "int":
        r"""
        The maximum value of the progress bar. This is used along with the minimum value and the 
        progress value to compute the current percentage complete.
        """
        return _core.ProgressDialog__get_maximumValue(self)

    def _set_maximumValue(self, value: "int") -> "bool":
        r"""
        The maximum value of the progress bar. This is used along with the minimum value and the 
        progress value to compute the current percentage complete.
        """
        return _core.ProgressDialog__set_maximumValue(self, value)

    def _get_progressValue(self) -> "int":
        r"""
        Gets and sets the current progress bar value. Progress is determined based on this value relative to
        the minimum and maximum values. This will update the values displayed
        in the message string.
        """
        return _core.ProgressDialog__get_progressValue(self)

    def _set_progressValue(self, value: "int") -> "bool":
        r"""
        Gets and sets the current progress bar value. Progress is determined based on this value relative to
        the minimum and maximum values. This will update the values displayed
        in the message string.
        """
        return _core.ProgressDialog__set_progressValue(self, value)

    def _get_isCancelButtonShown(self) -> "bool":
        r"""Gets and sets if the cancel button is included in the dialog. This is false by default."""
        return _core.ProgressDialog__get_isCancelButtonShown(self)

    def _set_isCancelButtonShown(self, value: "bool") -> "bool":
        r"""Gets and sets if the cancel button is included in the dialog. This is false by default."""
        return _core.ProgressDialog__set_isCancelButtonShown(self, value)

    def _get_wasCancelled(self) -> "bool":
        r"""Indicates if the cancel button was selected the last time the Progress Dialog was shown."""
        return _core.ProgressDialog__get_wasCancelled(self)

    def _get_cancelButtonText(self) -> "std::string":
        r"""Sets the text label on the Cancel button. The default text label is 'Cancel'."""
        return _core.ProgressDialog__get_cancelButtonText(self)

    def _set_cancelButtonText(self, value: "std::string const &") -> "bool":
        r"""Sets the text label on the Cancel button. The default text label is 'Cancel'."""
        return _core.ProgressDialog__set_cancelButtonText(self, value)

    def _get_isBackgroundTranslucent(self) -> "bool":
        r"""Gets and sets if the dialog background is translucent. This is false by default"""
        return _core.ProgressDialog__get_isBackgroundTranslucent(self)

    def _set_isBackgroundTranslucent(self, value: "bool") -> "bool":
        r"""Gets and sets if the dialog background is translucent. This is false by default"""
        return _core.ProgressDialog__set_isBackgroundTranslucent(self, value)

    def _get_isShowing(self) -> "bool":
        r"""Gets if the Progress Dialog is currently being displayed"""
        return _core.ProgressDialog__get_isShowing(self)

    def reset(self) -> "bool":
        r"""
        Method that resets the progress bar. The progress bar 'rewinds' and shows no progress.
        This is the same as setting the progress value to the minimum value. 
        Returns true if successful
        """
        return _core.ProgressDialog_reset(self)

    def _get_objectType(self) -> "char const *":
        return _core.ProgressDialog__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ProgressDialog__get_isValid(self)

# Register ProgressDialog in _core:
_core.ProgressDialog_swigregister(ProgressDialog)

def ProgressDialog_classType() -> "char const *":
    return _core.ProgressDialog_classType()


ProgressDialog.title = property(ProgressDialog._get_title, ProgressDialog._set_title, doc="Gets and sets the title of the progress dialog")


ProgressDialog.message = property(ProgressDialog._get_message, ProgressDialog._set_message, doc="Gets and sets the message to display along with the progress bar. The following symbols can be used\nto display values. '%p' is replaced by the percentage completed. '%v' is replaced\nby the current value. %m is replaced by the total number of steps. For example, the\nmessage 'Processing section %v of %m.' will result in the message 'Processing section\n1 of 10.' to be displayed if the maximum value is 10 and the current value is 1.\nSpecify an empty string ('') for no message to appear along with the progress panel.")


ProgressDialog.minimumValue = property(ProgressDialog._get_minimumValue, ProgressDialog._set_minimumValue, doc="The minimum value of the progress bar. This is used along with the maximum value and the\nprogress value to compute the current percentage complete. This is also the initial\nprogress value when the progress bar is first displayed.")


ProgressDialog.maximumValue = property(ProgressDialog._get_maximumValue, ProgressDialog._set_maximumValue, doc="The maximum value of the progress bar. This is used along with the minimum value and the\nprogress value to compute the current percentage complete.")


ProgressDialog.progressValue = property(ProgressDialog._get_progressValue, ProgressDialog._set_progressValue, doc="Gets and sets the current progress bar value. Progress is determined based on this value relative to\nthe minimum and maximum values. This will update the values displayed\nin the message string.")


ProgressDialog.isCancelButtonShown = property(ProgressDialog._get_isCancelButtonShown, ProgressDialog._set_isCancelButtonShown, doc="Gets and sets if the cancel button is included in the dialog. This is false by default.")


ProgressDialog.wasCancelled = property(ProgressDialog._get_wasCancelled, doc="Indicates if the cancel button was selected the last time the Progress Dialog was shown.")


ProgressDialog.cancelButtonText = property(ProgressDialog._get_cancelButtonText, ProgressDialog._set_cancelButtonText, doc="Sets the text label on the Cancel button. The default text label is 'Cancel'.")


ProgressDialog.isBackgroundTranslucent = property(ProgressDialog._get_isBackgroundTranslucent, ProgressDialog._set_isBackgroundTranslucent, doc="Gets and sets if the dialog background is translucent. This is false by default")


ProgressDialog.isShowing = property(ProgressDialog._get_isShowing, doc="Gets if the Progress Dialog is currently being displayed")


ProgressDialog.cast = lambda arg: arg if isinstance(arg, ProgressDialog) else None

class Properties(Base):
    r"""A collection of properties that are associated with a material or appearance."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Properties *":
        return _core.Properties___deref__(self)

    def __eq__(self, rhs: "Properties") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Properties___eq__(self, rhs)


    def __ne__(self, rhs: "Properties") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Properties___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.Properties___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::Property >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.Properties___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.Properties_classType()
    __swig_destroy__ = _core.delete_Properties

    def item(self, index: "int") -> "adsk::core::Ptr< adsk::core::Property >":
        r"""
        Returns the specified property from the collection using an index into the collection. 
        index : The index of the property within the collection where the first item is 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.Properties_item(self, index)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::Property >":
        r"""
        Returns the specified property from the collection using the unique ID of the property. 
        id : The unique ID of the property. 
        Returns the specified property or null if the ID doesn't match a property within the collection.
        """
        return _core.Properties_itemById(self, id)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::core::Property >":
        r"""
        Returns the specified Property using the name of the property. 
        name : The name of the property to return. This is the name as seen in the user interface. 
        Returns the specified property or null if the name doesn't match a property within the collection.
        """
        return _core.Properties_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""Returns the number of properties within the collection."""
        return _core.Properties__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _core.Properties__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Properties__get_isValid(self)

# Register Properties in _core:
_core.Properties_swigregister(Properties)

def Properties_classType() -> "char const *":
    return _core.Properties_classType()


Properties.count = property(Properties._get_count, doc="Returns the number of properties within the collection.")


Properties.cast = lambda arg: arg if isinstance(arg, Properties) else None

class Property(Base):
    r"""The base class for the specific property types used by materials and appearances."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Property *":
        return _core.Property___deref__(self)

    def __eq__(self, rhs: "Property") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Property___eq__(self, rhs)


    def __ne__(self, rhs: "Property") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Property___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Property_classType()
    __swig_destroy__ = _core.delete_Property

    def _get_name(self) -> "std::string":
        r"""
        Returns the name of this property as seen in the user interface. This name is localized
        and can change based on the current language
        """
        return _core.Property__get_name(self)

    def _get_isReadOnly(self) -> "bool":
        r"""Indicates if this property is read-only. If True any attempted edits will fail."""
        return _core.Property__get_isReadOnly(self)

    def _get_id(self) -> "std::string":
        r"""Returns the unique ID of this property."""
        return _core.Property__get_id(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the parent of this property."""
        return _core.Property__get_parent(self)

    def _get_objectType(self) -> "char const *":
        return _core.Property__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Property__get_isValid(self)

# Register Property in _core:
_core.Property_swigregister(Property)

def Property_classType() -> "char const *":
    return _core.Property_classType()


Property.name = property(Property._get_name, doc="Returns the name of this property as seen in the user interface. This name is localized\nand can change based on the current language")


Property.isReadOnly = property(Property._get_isReadOnly, doc="Indicates if this property is read-only. If True any attempted edits will fail.")


Property.id = property(Property._get_id, doc="Returns the unique ID of this property.")


Property.parent = property(Property._get_parent, doc="Returns the parent of this property.")


Property.cast = lambda arg: arg if isinstance(arg, Property) else None

class RadialMarkingMenu(Base):
    r"""
    Represents the marking menu which is the round menu that's displayed when the user right-clicks
    within Fusion 360. This supports customizing the contents of the marking menu.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::RadialMarkingMenu *":
        return _core.RadialMarkingMenu___deref__(self)

    def __eq__(self, rhs: "RadialMarkingMenu") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.RadialMarkingMenu___eq__(self, rhs)


    def __ne__(self, rhs: "RadialMarkingMenu") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.RadialMarkingMenu___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.RadialMarkingMenu_classType()
    __swig_destroy__ = _core.delete_RadialMarkingMenu

    def create(self, text: "std::string const &") -> "adsk::core::Ptr< adsk::core::RadialMarkingMenu >":
        r"""
        This is used to create a sub-menu in a marking menu. This method creates a new, 
        empty marking menu which can then be assigned to a position in the displayed
        marking menu to define the sub-menu. 
        text : The text that will be displayed in the parent menu to access this menu. 
        Returns the newly created marking menu or null in the case of a failure.
        """
        return _core.RadialMarkingMenu_create(self, text)

    def _get_text(self) -> "std::string":
        r"""
        Gets and sets the text that is displayed in the parent marking menu to access a 
        sub marking menu. This property is not used for the main marking menu and will
        return an empty string and setting it will have no effect.
        """
        return _core.RadialMarkingMenu__get_text(self)

    def _set_text(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the text that is displayed in the parent marking menu to access a 
        sub marking menu. This property is not used for the main marking menu and will
        return an empty string and setting it will have no effect.
        """
        return _core.RadialMarkingMenu__set_text(self, value)

    def clear(self) -> "bool":
        r"""
        Completely clears the contents of the marking menu. If left in this state, the
        marking menu will not be displayed. 
        Returns true if the clear was successful.
        """
        return _core.RadialMarkingMenu_clear(self)

    def _get_eastCommand(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the command definition that's displayed in the East position (right) of
        the marking menu. Setting this to null indicates that the East position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__get_eastCommand(self)

    def _set_eastCommand(self, value: "Base") -> "bool":
        r"""
        Gets and sets the command definition that's displayed in the East position (right) of
        the marking menu. Setting this to null indicates that the East position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__set_eastCommand(self, value)

    def _get_northCommand(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the command definition that's displayed in the North position (top) of the
        marking menu. Setting this to null indicates that the North position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__get_northCommand(self)

    def _set_northCommand(self, value: "Base") -> "bool":
        r"""
        Gets and sets the command definition that's displayed in the North position (top) of the
        marking menu. Setting this to null indicates that the North position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__set_northCommand(self, value)

    def _get_northeastCommand(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the command definition that's displayed in the Northeast position (top-right) of
        the marking menu. Setting this to null indicates that the Northeast position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__get_northeastCommand(self)

    def _set_northeastCommand(self, value: "Base") -> "bool":
        r"""
        Gets and sets the command definition that's displayed in the Northeast position (top-right) of
        the marking menu. Setting this to null indicates that the Northeast position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__set_northeastCommand(self, value)

    def _get_westCommand(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the command definition that's displayed in the West position (left) of 
        the marking menu. Setting this to null indicates that the West position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__get_westCommand(self)

    def _set_westCommand(self, value: "Base") -> "bool":
        r"""
        Gets and sets the command definition that's displayed in the West position (left) of 
        the marking menu. Setting this to null indicates that the West position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__set_westCommand(self, value)

    def _get_northwestCommand(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the command definition that's displayed in the Northwest position (upper-left) of
        the marking menu. Setting this to null indicates that the Northwest position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__get_northwestCommand(self)

    def _set_northwestCommand(self, value: "Base") -> "bool":
        r"""
        Gets and sets the command definition that's displayed in the Northwest position (upper-left) of
        the marking menu. Setting this to null indicates that the Northwest position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__set_northwestCommand(self, value)

    def _get_southwestCommand(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the command definition that's displayed in the Southwest position (bottom-left) of
        the marking menu. Setting this to null indicates that the Southwest position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__get_southwestCommand(self)

    def _set_southwestCommand(self, value: "Base") -> "bool":
        r"""
        Gets and sets the command definition that's displayed in the Southwest position (bottom-left) of
        the marking menu. Setting this to null indicates that the Southwest position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__set_southwestCommand(self, value)

    def _get_southCommand(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the command definition that's displayed in the South position (bottom) of
        the marking menu. Setting this to null indicates that the South position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__get_southCommand(self)

    def _set_southCommand(self, value: "Base") -> "bool":
        r"""
        Gets and sets the command definition that's displayed in the South position (bottom) of
        the marking menu. Setting this to null indicates that the South position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__set_southCommand(self, value)

    def _get_southeastCommand(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the command definition that's displayed in the Southeast position (bottom-right) of
        the marking menu. Setting this to null indicates that the Southeast position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__get_southeastCommand(self)

    def _set_southeastCommand(self, value: "Base") -> "bool":
        r"""
        Gets and sets the command definition that's displayed in the Southeast position (bottom-right) of
        the marking menu. Setting this to null indicates that the Southeast position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__set_southeastCommand(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.RadialMarkingMenu__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.RadialMarkingMenu__get_isValid(self)

# Register RadialMarkingMenu in _core:
_core.RadialMarkingMenu_swigregister(RadialMarkingMenu)

def RadialMarkingMenu_classType() -> "char const *":
    return _core.RadialMarkingMenu_classType()


RadialMarkingMenu.text = property(RadialMarkingMenu._get_text, RadialMarkingMenu._set_text, doc="Gets and sets the text that is displayed in the parent marking menu to access a\nsub marking menu. This property is not used for the main marking menu and will\nreturn an empty string and setting it will have no effect.")


RadialMarkingMenu.eastCommand = property(RadialMarkingMenu._get_eastCommand, RadialMarkingMenu._set_eastCommand, doc="Gets and sets the command definition that's displayed in the East position (right) of\nthe marking menu. Setting this to null indicates that the East position should be empty.\nThis can also return or be set with a MarkingMenu object which is used to have a sub-menu.\nNew marking menus can be created using the create method and then assigned\nto the desired position in the marking menu.")


RadialMarkingMenu.northCommand = property(RadialMarkingMenu._get_northCommand, RadialMarkingMenu._set_northCommand, doc="Gets and sets the command definition that's displayed in the North position (top) of the\nmarking menu. Setting this to null indicates that the North position should be empty.\nThis can also return or be set with a MarkingMenu object which is used to have a sub-menu.\nNew marking menus can be created using the create method and then assigned\nto the desired position in the marking menu.")


RadialMarkingMenu.northeastCommand = property(RadialMarkingMenu._get_northeastCommand, RadialMarkingMenu._set_northeastCommand, doc="Gets and sets the command definition that's displayed in the Northeast position (top-right) of\nthe marking menu. Setting this to null indicates that the Northeast position should be empty.\nThis can also return or be set with a MarkingMenu object which is used to have a sub-menu.\nNew marking menus can be created using the create method and then assigned\nto the desired position in the marking menu.")


RadialMarkingMenu.westCommand = property(RadialMarkingMenu._get_westCommand, RadialMarkingMenu._set_westCommand, doc="Gets and sets the command definition that's displayed in the West position (left) of\nthe marking menu. Setting this to null indicates that the West position should be empty.\nThis can also return or be set with a MarkingMenu object which is used to have a sub-menu.\nNew marking menus can be created using the create method and then assigned\nto the desired position in the marking menu.")


RadialMarkingMenu.northwestCommand = property(RadialMarkingMenu._get_northwestCommand, RadialMarkingMenu._set_northwestCommand, doc="Gets and sets the command definition that's displayed in the Northwest position (upper-left) of\nthe marking menu. Setting this to null indicates that the Northwest position should be empty.\nThis can also return or be set with a MarkingMenu object which is used to have a sub-menu.\nNew marking menus can be created using the create method and then assigned\nto the desired position in the marking menu.")


RadialMarkingMenu.southwestCommand = property(RadialMarkingMenu._get_southwestCommand, RadialMarkingMenu._set_southwestCommand, doc="Gets and sets the command definition that's displayed in the Southwest position (bottom-left) of\nthe marking menu. Setting this to null indicates that the Southwest position should be empty.\nThis can also return or be set with a MarkingMenu object which is used to have a sub-menu.\nNew marking menus can be created using the create method and then assigned\nto the desired position in the marking menu.")


RadialMarkingMenu.southCommand = property(RadialMarkingMenu._get_southCommand, RadialMarkingMenu._set_southCommand, doc="Gets and sets the command definition that's displayed in the South position (bottom) of\nthe marking menu. Setting this to null indicates that the South position should be empty.\nThis can also return or be set with a MarkingMenu object which is used to have a sub-menu.\nNew marking menus can be created using the create method and then assigned\nto the desired position in the marking menu.")


RadialMarkingMenu.southeastCommand = property(RadialMarkingMenu._get_southeastCommand, RadialMarkingMenu._set_southeastCommand, doc="Gets and sets the command definition that's displayed in the Southeast position (bottom-right) of\nthe marking menu. Setting this to null indicates that the Southeast position should be empty.\nThis can also return or be set with a MarkingMenu object which is used to have a sub-menu.\nNew marking menus can be created using the create method and then assigned\nto the desired position in the marking menu.")


RadialMarkingMenu.cast = lambda arg: arg if isinstance(arg, RadialMarkingMenu) else None

class Selection(Base):
    r"""Provides access to a selection of an entity in the user interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Selection *":
        return _core.Selection___deref__(self)

    def __eq__(self, rhs: "Selection") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Selection___eq__(self, rhs)


    def __ne__(self, rhs: "Selection") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Selection___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Selection_classType()
    __swig_destroy__ = _core.delete_Selection

    def _get_entity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets the selected entity."""
        return _core.Selection__get_entity(self)

    def _get_point(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets the selection point on the object."""
        return _core.Selection__get_point(self)

    def _get_objectType(self) -> "char const *":
        return _core.Selection__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Selection__get_isValid(self)

# Register Selection in _core:
_core.Selection_swigregister(Selection)

def Selection_classType() -> "char const *":
    return _core.Selection_classType()


Selection.entity = property(Selection._get_entity, doc="Gets the selected entity.")


Selection.point = property(Selection._get_point, doc="Gets the selection point on the object.")


Selection.cast = lambda arg: arg if isinstance(arg, Selection) else None

class SelectionEventHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notify(self, eventArgs: "SelectionEventArgs") -> "void":
        return _core.SelectionEventHandler_notify(self, eventArgs)

    def __init__(self):
        if self.__class__ == SelectionEventHandler:
            _self = None
        else:
            _self = self
        _core.SelectionEventHandler_swiginit(self, _core.new_SelectionEventHandler(_self, ))
    __swig_destroy__ = _core.delete_SelectionEventHandler
    def __disown__(self):
        self.this.disown()
        _core.disown_SelectionEventHandler(self)
        return weakref.proxy(self)

# Register SelectionEventHandler in _core:
_core.SelectionEventHandler_swigregister(SelectionEventHandler)


SelectionEventHandler.cast = lambda arg: arg if isinstance(arg, SelectionEventHandler) else None

class Selections(Base):
    r"""Provides access to and control over the set of selected entities in the user interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Selections *":
        return _core.Selections___deref__(self)

    def __eq__(self, rhs: "Selections") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Selections___eq__(self, rhs)


    def __ne__(self, rhs: "Selections") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Selections___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.Selections___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::Selection >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.Selections___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.Selections_classType()
    __swig_destroy__ = _core.delete_Selections

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::Selection >":
        r"""
        Returns the specified selection using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.Selections_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Gets the number of entities currently selected."""
        return _core.Selections__get_count(self)

    def _get_all(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""Gets or sets all entities currently selected."""
        return _core.Selections__get_all(self)

    def _set_all(self, value: "ObjectCollection") -> "bool":
        r"""Gets or sets all entities currently selected."""
        return _core.Selections__set_all(self, value)

    def add(self, entity: "Base") -> "bool":
        r"""
        Adds the entity to the set of currently selected entities.
        The user will see the entity become selected in the user interface. 
        entity : The entity to select and add to this selection set. 
        Returns true if successful.
        """
        return _core.Selections_add(self, entity)

    def clear(self) -> "bool":
        r"""
        Clears the selection set so no entities are currently selected. 
        Returns true if successful.
        """
        return _core.Selections_clear(self)

    def removeBySelection(self, selection: "Selection") -> "bool":
        r"""
        Removes the specified selection from the set of selected entities. 
        selection : The selection to remove. 
        Returns true if the item was removed or not currently selected.
        """
        return _core.Selections_removeBySelection(self, selection)

    def removeByEntity(self, entity: "Base") -> "bool":
        r"""
        Removes the selections that are associated with the specified entity from the set of selected entities. 
        entity : The entity to remove selections of. 
        Returns true if the item was removed or not currently selected.
        """
        return _core.Selections_removeByEntity(self, entity)

    def removeByIndex(self, index: "int") -> "bool":
        r"""
        Removes an item from the set of selected entities. 
        index : The index of the selection to remove. 
        Returns true if the item was removed successfully.
        """
        return _core.Selections_removeByIndex(self, index)

    def asArray(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection >,std::allocator< adsk::core::Ptr< adsk::core::Selection > > >":
        r"""
        Returns an array containing all of the current selections. This is
        useful in cases where you need to iterate over the set of selected entities but need
        to create or edit data as you process each one. Selections are fragile and creation and
        edit operations will clear the selections so you won't have access to the complete list 
        after processing the first one. 
        Returns an array of all of the current selections. Selection objects are returned so
        you'll need to call their entity properties to get the actual selected entity.
        """
        return _core.Selections_asArray(self)

    def _get_objectType(self) -> "char const *":
        return _core.Selections__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Selections__get_isValid(self)

# Register Selections in _core:
_core.Selections_swigregister(Selections)

def Selections_classType() -> "char const *":
    return _core.Selections_classType()


Selections.count = property(Selections._get_count, doc="Gets the number of entities currently selected.")


Selections.all = property(Selections._get_all, Selections._set_all, doc="Gets or sets all entities currently selected.")


Selections.cast = lambda arg: arg if isinstance(arg, Selections) else None

class Surface(Base):
    r"""
    Describes a two-dimensional topological, manifold in three-dimensional space. 
    It is used as the underlying geometry for a BRepFace.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Surface *":
        return _core.Surface___deref__(self)

    def __eq__(self, rhs: "Surface") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Surface___eq__(self, rhs)


    def __ne__(self, rhs: "Surface") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Surface___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Surface_classType()
    __swig_destroy__ = _core.delete_Surface

    def _get_surfaceType(self) -> "adsk::core::SurfaceTypes":
        r"""Returns the surface type."""
        return _core.Surface__get_surfaceType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::SurfaceEvaluator >":
        r"""Returns the surface evaluator."""
        return _core.Surface__get_evaluator(self)

    def transformBy(self, matrix: "Matrix3D") -> "bool":
        r"""
        Updates this surface by transforming it with a given input matrix. 
        matrix : A 3D matrix that defines the transform to apply to the surface. 
        Returns true if the transform was successful.
        """
        return _core.Surface_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.Surface__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Surface__get_isValid(self)

# Register Surface in _core:
_core.Surface_swigregister(Surface)

def Surface_classType() -> "char const *":
    return _core.Surface_classType()


Surface.surfaceType = property(Surface._get_surfaceType, doc="Returns the surface type.")


Surface.evaluator = property(Surface._get_evaluator, doc="Returns the surface evaluator.")


Surface.cast = lambda arg: arg if isinstance(arg, Surface) else None

class SurfaceEvaluator(Base):
    r"""
    Surface evaluator that is obtained from a transient surface and allows you to perform
    various evaluations on the surface.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::SurfaceEvaluator *":
        return _core.SurfaceEvaluator___deref__(self)

    def __eq__(self, rhs: "SurfaceEvaluator") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.SurfaceEvaluator___eq__(self, rhs)


    def __ne__(self, rhs: "SurfaceEvaluator") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.SurfaceEvaluator___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.SurfaceEvaluator_classType()
    __swig_destroy__ = _core.delete_SurfaceEvaluator

    def _get_isClosedInU(self) -> "bool":
        r"""Indicates if the surface is closed (forms a loop) in the U direction"""
        return _core.SurfaceEvaluator__get_isClosedInU(self)

    def _get_isClosedInV(self) -> "bool":
        r"""Indicates if the surface is closed (forms a loop) in the V direction"""
        return _core.SurfaceEvaluator__get_isClosedInV(self)

    def getModelCurveFromParametricCurve(self, parametricCurve: "Curve2D") -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Creates the 3D equivalent curve in model space, of a 2D curve defined in the 
        parametric space of the surface. 
        parametricCurve : The parameter space curve to map into this surface's parameter space. 
        Returns an ObjectCollection containing one or more curves. 
        When the SufaceEvaluatior is obtained from a face, and the curve cuts across internal 
        boundaries of the face, multiple curves are returned. The returned curves are trimmed 
        to the boundaries of the face. 
        If the SurfaceEvaluator is obtained from a geometry object, a single curve returned 
        because there are no boundaries with which to trim the curve. 
        The type of curve(s) returned depends on the shape of the input curve and surface.
        """
        return _core.SurfaceEvaluator_getModelCurveFromParametricCurve(self, parametricCurve)

    def getIsoCurve(self, parameter: "double", isUDirection: "bool") -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets (by extraction) a curve that follows a constant u or v parameter along the surface. 
        The curve will have the same properties as the surface in the direction of the extraction. 
        For example, when a curve is extracted from the periodic direction of a surface, the extracted 
        curve will also be periodic. 
        The type of curve returned is dependent on the shape the surface. 
        parameter : The parameter at which to extract the curve 
        isUDirection : A bool that indicates whether to extract the curve from the U or V direction 
        Returns an ObjectCollection that contains one or more curves. 
        Multiple curves are returned when the SurfaceEvaluator is obtained from a Face 
        and the curve cuts across internal boundaries. The resulting curves are trimmed to the 
        boundaries of the Face. 
        When the SurfaceEvaluator is obtained from a geometry object, a single curve is returned 
        because there are no boundaries to trim the curve. 
        The type of curve(s) returned is dependent on the shape of the surface.
        """
        return _core.SurfaceEvaluator_getIsoCurve(self, parameter, isUDirection)

    def getCurvatures(self, parameters: "Point2DVector") -> "bool":
        r"""
        Get the curvature values at a number of parameter positions on the surface. 
        parameters : The array of parameter positions to return curvature information at.
        Each parameter position must be with the range of the parameter extents as verified by isParameterOnFace. 
        maxTangents : The output array of directions of maximum curvature at each position on the surface.
        The length of this array will be the same as the length of the parameters array provided. 
        maxCurvatures : The output array of the magnitude of the maximum curvature at each position on the surface.
        The length of this array will be the same as the length of the parameters array provided. 
        minCurvatures : The output array of the magnitude of the minimum curvature at each position on the surface.
        The minimum curvature direction is perpendicular to the maximum curvature tangent directions.
        The length of this array will be the same as the length of the parameters array provided. 
        Returns true if the curvatures were successfully returned.
        """
        return _core.SurfaceEvaluator_getCurvatures(self, parameters)

    def getCurvature(self, parameter: "Point2D") -> "bool":
        r"""
        Get the curvature values at a parameter positions on the surface. 
        parameter : The parameter positions to return curvature information at. 
        maxTangent : The output directions of maximum curvature at the position on the surface. 
        maxCurvature : The output magnitude of the maximum curvature at the position on the surface. 
        minCurvature : The output magnitude of the minimum curvature at the position on the surface.
        The minimum curvature direction is perpendicular to the maximum curvature tangent directions. 
        Returns true if the curvature was successfully returned.
        """
        return _core.SurfaceEvaluator_getCurvature(self, parameter)

    def getNormalsAtParameters(self, parameters: "Point2DVector") -> "bool":
        r"""
        Gets the surface normal at a number of parameter positions on the surface. 
        parameters : The array of parameter positions to return the normal at.
        Each parameter position must be with the range of the parameter extents as verified by isParameterOnFace. 
        normals : The output array of normals for each parameter position on the surface.
        The length of this array will be the same as the length of the parameters array provided. 
        Returns true if the normals were successfully returned.
        """
        return _core.SurfaceEvaluator_getNormalsAtParameters(self, parameters)

    def getNormalAtParameter(self, parameter: "Point2D") -> "bool":
        r"""
        Gets the surface normal at a parameter position on the surface. 
        parameter : The parameter position to return the normal at.
        The parameter position must be with the range of the parameter extents as verified by isParameterOnFace. 
        normal : The output normal for the parameter position on the surface. 
        Returns true if the normal was successfully returned.
        """
        return _core.SurfaceEvaluator_getNormalAtParameter(self, parameter)

    def getNormalsAtPoints(self, points: "Point3DVector") -> "bool":
        r"""
        Gets the surface normal at a number of positions on the surface. 
        points : The array of points to return the normal at.
        For reliable results each point should lie on the surface. 
        normals : The output array of normals for each point on the surface.
        The length of this array will be the same as the length of the points array provided. 
        Returns true if the normals were successfully returned.
        """
        return _core.SurfaceEvaluator_getNormalsAtPoints(self, points)

    def getNormalAtPoint(self, point: "Point3D") -> "bool":
        r"""
        Gets the surface normal at a point on the surface. 
        point : The point to return the normal at.
        For reliable results the point should lie on the surface. 
        normal : The output normal for the point on the surface. 
        Returns true if the normal was successfully returned.
        """
        return _core.SurfaceEvaluator_getNormalAtPoint(self, point)

    def getParametersAtPoints(self, points: "Point3DVector") -> "bool":
        r"""
        Get the parameter positions that correspond to a set of points on the surface.
        For reliable results, the points should lie on the surface within model tolerance.
        If the points do not lie on the surface, the parameter of the nearest point on the surface will generally be returned. 
        points : An array of points to get the surface parameter values at. 
        parameters : The output array of parameter positions corresponding to the set of points.
        The length of this array will be equal to the length of the points array specified. 
        Returns true if the parameters were successfully returned.
        """
        return _core.SurfaceEvaluator_getParametersAtPoints(self, points)

    def getParameterAtPoint(self, point: "Point3D") -> "bool":
        r"""
        Get the parameter position that correspond to a point on the surface.
        For reliable results, the point should lie on the surface within model tolerance.
        If the point does not lie on the surface, the parameter of the nearest point on the surface will generally be returned. 
        point : The point to get the curve parameter value at. 
        parameter : The output parameter position corresponding to the point. 
        Returns true of the parameter was successfully returned.
        """
        return _core.SurfaceEvaluator_getParameterAtPoint(self, point)

    def getPointsAtParameters(self, parameters: "Point2DVector") -> "bool":
        r"""
        Get the points on the surface that correspond to evaluating a set of parameter positions on the surface. 
        parameters : The array of parameter positions to evaluate the surface position at.
        Each parameter position must be within the range of the parameter extents as verified by isParameterOnFace. 
        points : The output array of points corresponding to evaluating the curve at that parameter position.
        The length of this array will be equal to the length of the parameters array specified. 
        Returns true if the points were successfully returned.
        """
        return _core.SurfaceEvaluator_getPointsAtParameters(self, parameters)

    def getPointAtParameter(self, parameter: "Point2D") -> "bool":
        r"""
        Get the point on the surface that correspond to evaluating a parameter position on the surface. 
        parameter : The parameter positions to evaluate the surface position at.
        The parameter position must be within the range of the parameter extents as verified by isParameterOnFace. 
        point : The output point corresponding to evaluating the curve at that parameter position. 
        Returns true if the point was successfully returned.
        """
        return _core.SurfaceEvaluator_getPointAtParameter(self, parameter)

    def getParamAnomaly(self) -> "bool":
        r"""
        Gets details about anomalies in parameter space of the surface.
        This includes information about periodic intervals, singularities, or unbounded parameter ranges. 
        periodicityU : The output array with information about the period of the surface in U.
        periodicityU[0] will contain the period of the surface in U.
        If periodicityU[0] is 0, the surface is not periodic in U.
        If the surface is periodic in U, peridocityU[1] will contain the parameter value at the start of the principle period. 
        periodicityV : The output array with information about the period of the surface in V.
        periodicityV[0] will contain the period of the surface in V.
        If periodicityV[0] is 0, the surface is not periodic in V.
        If the surface is periodic in V, peridocityV[1] will contain the parameter value at the start of the principle period. 
        singularitiesU : The output array parameter values of singularities in U.
        If this array is empty, there are no singularities in U. 
        singularitiesV : The output array parameter values of singularities in V.
        If this array is empty, there are no singularities in V. 
        unboundedParameters : The output array that indicates if the parameter range is unbounded in U or V.
        unboundedParameters[0] will be true if U is unbounded.
        unboundedParameters[1] will be true if V is unbounded. 
        Returns true if the parameter anomalies were successfully returned.
        """
        return _core.SurfaceEvaluator_getParamAnomaly(self)

    def getFirstDerivatives(self, parameters: "Point2DVector") -> "bool":
        r"""
        Get the first derivatives of the surface at the specified parameter positions. 
        parameters : The array of parameter positions to get the surface first derivative at.
        Each parameter position must be within the range of the parameter extents as verified by isParameterOnFace. 
        partialsU : The output array of first derivative U partial vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        partialsV : The output array of first derivative V partial vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        Returns true if the first derivatives were successfully returned.
        """
        return _core.SurfaceEvaluator_getFirstDerivatives(self, parameters)

    def getFirstDerivative(self, parameter: "Point2D") -> "bool":
        r"""
        Get the first derivative of the surface at the specified parameter position. 
        parameter : The parameter positions to get the surface first derivative at.
        The parameter position must be within the range of the parameter extents as verified by isParameterOnFace. 
        partialU : The output first derivative U partial vector at the parameter position specified. 
        partialV : The output first derivative V partial vector at the parameter position specified. 
        Returns true if the first derivative was successfully returned.
        """
        return _core.SurfaceEvaluator_getFirstDerivative(self, parameter)

    def getSecondDerivatives(self, parameters: "Point2DVector") -> "bool":
        r"""
        Get the second derivatives of the surface at the specified parameter positions. 
        parameters : The array of parameter positions to get the surface second derivative at.
        Each parameter position must be within the range of the parameter extents as verified by isParameterOnFace. 
        partialsUU : The output array of second derivative UU partial vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        partialsUV : The output array of second derivative UV mixed partial vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        partialsVV : The output array of second derivative VV partial vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        Returns true if the second derivatives were successfully returned.
        """
        return _core.SurfaceEvaluator_getSecondDerivatives(self, parameters)

    def getSecondDerivative(self, parameter: "Point2D") -> "bool":
        r"""
        Get the second derivative of the surface at the specified parameter position. 
        parameter : The parameter position to get the surface second derivative at.
        The parameter position must be within the range of the parameter extents as verified by isParameterOnFace. 
        partialUU : The output second derivative UU partial vector at each parameter position specified. 
        partialUV : The output second derivative UV mixed partial vector at each parameter position specified. 
        partialVV : The output second derivative VV partial vector at each parameter position specified. 
        Returns true if the second derivative was successfully returned.
        """
        return _core.SurfaceEvaluator_getSecondDerivative(self, parameter)

    def getThirdDerivatives(self, parameters: "Point2DVector") -> "bool":
        r"""
        Get the third derivatives of the surface at the specified parameter positions. 
        parameters : The array of parameter positions to get the surface third derivative at.
        Each parameter position must be within the range of the parameter extents as verified by isParameterOnFace. 
        partialsUUU : The output array of third derivative UUU partial vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        partialsVVV : The output array of third derivative VVV partial vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        Returns true if the third derivatives were successfully returned.
        """
        return _core.SurfaceEvaluator_getThirdDerivatives(self, parameters)

    def getThirdDerivative(self, parameter: "Point2D") -> "bool":
        r"""
        Get the third derivative of the surface at the specified parameter position. 
        parameter : The parameter position to get the surface third derivative at.
        The parameter position must be within the range of the parameter extents as verified by isParameterOnFace. 
        partialUUU : The output third derivative UUU partial vector at each parameter position specified. 
        partialVVV : The output third derivative VVV partial vector at each parameter position specified. 
        Returns true if the third derivative was successfully returned.
        """
        return _core.SurfaceEvaluator_getThirdDerivative(self, parameter)

    def isParameterOnFace(self, parameter: "Point2D") -> "bool":
        r"""
        Determines if the specified parameter position lies with the parametric range of the surface. 
        parameter : The parameter position to test. 
        Returns true if the parameter position lies within the valid parametric range of the surface.
        """
        return _core.SurfaceEvaluator_isParameterOnFace(self, parameter)

    def parametricRange(self) -> "adsk::core::Ptr< adsk::core::BoundingBox2D >":
        r"""
        Returns the parametric range of the surface.
        If the surface is periodic in a direction, the range is set to the principle period's range.
        If the surface is only upper bounded in a direction, the lower bound is set to -double-max.
        If the surface is only lower bounded in a direction, the upper bound is set to double-max.
        If the surface is unbounded in a direction, the lower bound and upper bound of the range will both be zero. 
        Returns the bounding box with the parameter extents, with the X value being the U range, and the Y value being the V range.
        """
        return _core.SurfaceEvaluator_parametricRange(self)

    def _get_area(self) -> "double":
        r"""
        Returns the area of the surface. This is typically used when the SurfaceEvaluator is associated
        with a BRepFace object where it is always valid. This can fail in the case where the SurfaceEvaluator is
        associated with one of the geometry classes, (Plane, Cylinder, Cone, EllipticalCone, or EllipticalCylinder 
        object), because these surfaces are unbounded. A BRepFace, even one of these shapes, is bounded by its 
        edges and has a well-defined area.
        """
        return _core.SurfaceEvaluator__get_area(self)

    def _get_objectType(self) -> "char const *":
        return _core.SurfaceEvaluator__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.SurfaceEvaluator__get_isValid(self)

# Register SurfaceEvaluator in _core:
_core.SurfaceEvaluator_swigregister(SurfaceEvaluator)

def SurfaceEvaluator_classType() -> "char const *":
    return _core.SurfaceEvaluator_classType()


SurfaceEvaluator.isClosedInU = property(SurfaceEvaluator._get_isClosedInU, doc="Indicates if the surface is closed (forms a loop) in the U direction")


SurfaceEvaluator.isClosedInV = property(SurfaceEvaluator._get_isClosedInV, doc="Indicates if the surface is closed (forms a loop) in the V direction")


SurfaceEvaluator.area = property(SurfaceEvaluator._get_area, doc="Returns the area of the surface. This is typically used when the SurfaceEvaluator is associated\nwith a BRepFace object where it is always valid. This can fail in the case where the SurfaceEvaluator is\nassociated with one of the geometry classes, (Plane, Cylinder, Cone, EllipticalCone, or EllipticalCylinder\nobject), because these surfaces are unbounded. A BRepFace, even one of these shapes, is bounded by its\nedges and has a well-defined area.")


SurfaceEvaluator.cast = lambda arg: arg if isinstance(arg, SurfaceEvaluator) else None

class Toolbar(Base):
    r"""Provides access to a toolbar in the user interface. A toolbar is a collection of toolbar controls."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Toolbar *":
        return _core.Toolbar___deref__(self)

    def __eq__(self, rhs: "Toolbar") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Toolbar___eq__(self, rhs)


    def __ne__(self, rhs: "Toolbar") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Toolbar___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Toolbar_classType()
    __swig_destroy__ = _core.delete_Toolbar

    def _get_id(self) -> "std::string":
        r"""
        Gets the unique ID of the toolbar that can be used programmatically
        to find a specific toolbar.
        """
        return _core.Toolbar__get_id(self)

    def _get_parentUserInterface(self) -> "adsk::core::Ptr< adsk::core::UserInterface >":
        r"""Gets the owning UserInterface object."""
        return _core.Toolbar__get_parentUserInterface(self)

    def _get_controls(self) -> "adsk::core::Ptr< adsk::core::ToolbarControls >":
        r"""Gets the controls in this toolbar."""
        return _core.Toolbar__get_controls(self)

    def _get_objectType(self) -> "char const *":
        return _core.Toolbar__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Toolbar__get_isValid(self)

# Register Toolbar in _core:
_core.Toolbar_swigregister(Toolbar)

def Toolbar_classType() -> "char const *":
    return _core.Toolbar_classType()


Toolbar.id = property(Toolbar._get_id, doc="Gets the unique ID of the toolbar that can be used programmatically\nto find a specific toolbar.")


Toolbar.parentUserInterface = property(Toolbar._get_parentUserInterface, doc="Gets the owning UserInterface object.")


Toolbar.controls = property(Toolbar._get_controls, doc="Gets the controls in this toolbar.")


Toolbar.cast = lambda arg: arg if isinstance(arg, Toolbar) else None

class ToolbarControl(Base):
    r"""The base class for all toolbar controls."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ToolbarControl *":
        return _core.ToolbarControl___deref__(self)

    def __eq__(self, rhs: "ToolbarControl") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ToolbarControl___eq__(self, rhs)


    def __ne__(self, rhs: "ToolbarControl") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ToolbarControl___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ToolbarControl_classType()
    __swig_destroy__ = _core.delete_ToolbarControl

    def _get_id(self) -> "std::string":
        r"""
        Gets the unique ID of this control. The ID is unique with respect to the other
        controls within the same panel, toolbar, or drop-down control.
        """
        return _core.ToolbarControl__get_id(self)

    def _get_index(self) -> "size_t":
        r"""Gets the position of this control within the list of controls within the panel, toolbar, or drop-down control."""
        return _core.ToolbarControl__get_index(self)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this control is currently visible."""
        return _core.ToolbarControl__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this control is currently visible."""
        return _core.ToolbarControl__set_isVisible(self, value)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets the Parent object. When associated with a toolbar (right or left QAT or the Nav Bar) this
        returns the parent Toolbar object. When associated with a panel it returns the parent ToolbarPanel object.
        When associated with a control (DropDownControl) it returns the parent control.
        """
        return _core.ToolbarControl__get_parent(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the ToolbarControl 
        Returns a boolean indicating if the deletion was successful.
        """
        return _core.ToolbarControl_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.ToolbarControl__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ToolbarControl__get_isValid(self)

# Register ToolbarControl in _core:
_core.ToolbarControl_swigregister(ToolbarControl)

def ToolbarControl_classType() -> "char const *":
    return _core.ToolbarControl_classType()


ToolbarControl.id = property(ToolbarControl._get_id, doc="Gets the unique ID of this control. The ID is unique with respect to the other\ncontrols within the same panel, toolbar, or drop-down control.")


ToolbarControl.index = property(ToolbarControl._get_index, doc="Gets the position of this control within the list of controls within the panel, toolbar, or drop-down control.")


ToolbarControl.isVisible = property(ToolbarControl._get_isVisible, ToolbarControl._set_isVisible, doc="Gets or sets if this control is currently visible.")


ToolbarControl.parent = property(ToolbarControl._get_parent, doc="Gets the Parent object. When associated with a toolbar (right or left QAT or the Nav Bar) this\nreturns the parent Toolbar object. When associated with a panel it returns the parent ToolbarPanel object.\nWhen associated with a control (DropDownControl) it returns the parent control.")


ToolbarControl.cast = lambda arg: arg if isinstance(arg, ToolbarControl) else None

class ToolbarControlList(Base):
    r"""Provides access to a list of toolbar controls."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ToolbarControlList *":
        return _core.ToolbarControlList___deref__(self)

    def __eq__(self, rhs: "ToolbarControlList") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ToolbarControlList___eq__(self, rhs)


    def __ne__(self, rhs: "ToolbarControlList") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ToolbarControlList___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.ToolbarControlList___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::ToolbarControl >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.ToolbarControlList___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.ToolbarControlList_classType()
    __swig_destroy__ = _core.delete_ToolbarControlList

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::ToolbarControl >":
        r"""
        Returns the ToolbarControl at the specified index.
        When iterating by index, the controls are returned
        in the same order as they are shown in the user interface. 
        index : The index of the control within the collection to return. The first item in the
        collection has in index of 0. 
        Returns the ToolbarControl at the specified index or null if an invalid index was specified.
        """
        return _core.ToolbarControlList_item(self, index)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::ToolbarControl >":
        r"""
        Returns the ToolbarControl at the specified ID. 
        id : The ID of the control within the collection to return. 
        Returns the ToolbarControl with the specified ID or null if no control has this ID.
        """
        return _core.ToolbarControlList_itemById(self, id)

    def _get_count(self) -> "size_t":
        r"""Gets the number of toolbar controls."""
        return _core.ToolbarControlList__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _core.ToolbarControlList__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ToolbarControlList__get_isValid(self)

# Register ToolbarControlList in _core:
_core.ToolbarControlList_swigregister(ToolbarControlList)

def ToolbarControlList_classType() -> "char const *":
    return _core.ToolbarControlList_classType()


ToolbarControlList.count = property(ToolbarControlList._get_count, doc="Gets the number of toolbar controls.")


ToolbarControlList.cast = lambda arg: arg if isinstance(arg, ToolbarControlList) else None

class ToolbarControls(Base):
    r"""ToolbarControls is a collection of ToolbarControl objects displayed in a toolbar or menu."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ToolbarControls *":
        return _core.ToolbarControls___deref__(self)

    def __eq__(self, rhs: "ToolbarControls") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ToolbarControls___eq__(self, rhs)


    def __ne__(self, rhs: "ToolbarControls") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ToolbarControls___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.ToolbarControls___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::ToolbarControl >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.ToolbarControls___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.ToolbarControls_classType()
    __swig_destroy__ = _core.delete_ToolbarControls

    def _get_count(self) -> "size_t":
        r"""Gets the number of controls in the collection."""
        return _core.ToolbarControls__get_count(self)

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::ToolbarControl >":
        r"""
        Returns the ToolbarControl at the specified index.
        When iterating by index, the controls are returned
        in the same order as they are shown in the user interface. 
        index : The index of the control within the collection to return. The first item in the
        collection has in index of 0. 
        Returns the ToolbarControl at the specified index or null if an invalid index was specified.
        """
        return _core.ToolbarControls_item(self, index)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::ToolbarControl >":
        r"""
        Returns the ToolbarControl at the specified ID. 
        id : The ID of the control within the collection to return. 
        Returns the ToolbarControl with the specified ID or null if no control has this ID.
        """
        return _core.ToolbarControls_itemById(self, id)

    def addCommand(self, *args) -> "adsk::core::Ptr< adsk::core::CommandControl >":
        r"""
        Adds a button to the controls in the toolbar, panel, or drop-down. The ID of the created
        command control is inherited from the associated command definition. 
        commandDefinition : The associated CommandDefinition that defines the resources and receives events related to this control. 
        positionID : Specifies the reference id of the control to position this control relative to.
        Not setting this value indicates that the control will be created at the end of all other controls in toolbar. The isBefore
        parameter specifies whether to place the control before or after the reference control. 
        isBefore : Specifies whether to place the control before or after the reference control specified by the positionID parameter.
        This argument is ignored is positionID is not specified. 
        Returns the newly created CommandControl object or null if the creation fails.
        """
        return _core.ToolbarControls_addCommand(self, *args)

    def addDropDown(self, *args) -> "adsk::core::Ptr< adsk::core::DropDownControl >":
        r"""
        Adds a drop-down to the controls in the toolbar, panel, or drop-down. When the drop-down is initially created it will be empty.
        you can get the associated ToolbarControls object from the DropDownControl to add additional controls to the drop-down. 
        text : The text displayed for the drop-down in a menu. For a drop-down in a toolbar this argument is ignored
        because an icon is used. 
        resourceFolder : The resource folder containing the image used for the icon when the drop-down is in a toolbar. 
        id : Optional unique ID for the control. It must be unique with respect to other controls in this collection. 
        If the default empty string is provided, Fusion 360 will create a unique ID. 
        positionID : Specifies the reference id of the control to position this control relative to.
        Not setting this value indicates that the control will be created at the end of all other controls in toolbar. The isBefore
        parameter specifies whether to place the control before or after the reference control. 
        isBefore : Specifies whether to place the control before or after the reference control specified by the positionID parameter.
        This argument is ignored is positionID is not specified. 
        Returns the newly created DropDownControl object or null if the creation fails.
        """
        return _core.ToolbarControls_addDropDown(self, *args)

    def addSeparator(self, *args) -> "adsk::core::Ptr< adsk::core::SeparatorControl >":
        r"""
        Adds a separator to the controls in the toolbar, panel, or drop-down. 
        id : Optional unique ID for the control. It must be unique with respect to other controls in this collection. 
        If the default empty string is provided, Fusion 360 will create a unique ID. 
        positionID : Specifies the reference id of the control to position this separator control relative to.
        Not setting this value indicates that the separator control will be created at the end of all other controls in toolbar. 
        The isBefore parameter specifies whether to place the control before or after the reference control. 
        isBefore : Specifies whether to place the separator control before or after the reference control specified by the positionID parameter.
        This argument is ignored is positionID is not specified. 
        Returns the newly created separator controls or null if the creation fails.
        """
        return _core.ToolbarControls_addSeparator(self, *args)

    def addSplitButton(self, *args) -> "adsk::core::Ptr< adsk::core::SplitButtonControl >":
        r"""
        Adds a split button to the controls in a toolbar. A split button has two active areas that the user can click;
        the main button portion and the drop-down arrow. Clicking the main button, executes the displayed command.
        Clicking the drop-down displays the drop-down with additional commands.
        The split button itself does not fire any events, but the buttons within it will fire events to their associated
        command definitions. 
        defaultDefinition : A command definition that will be used to create the main button. A button will also be created in the drop-down 
        for this definition. 
        additionalDefinitions : An array of command definitions that will be used to create the buttons on the drop-down. 
        showLastUsed : Specifies if the split button should have the behavior where the command shown on the main button changes 
        to the last executed command. 
        id : Optional unique ID for the control. It must be unique with respect to other controls in this collection. 
        If the default empty string is provided, Fusion 360 will create a unique ID. 
        positionID : Specifies the reference id of the control to position this control relative to.
        Not setting this value indicates that the control will be created at the end of all other controls in toolbar. The isBefore
        parameter specifies whether to place the control before or after the reference control. 
        isBefore : Specifies whether to place the control before or after the reference control specified by the positionID parameter.
        This argument is ignored is positionID is not specified 
        Returns the newly created SplitButtonControl object or null if the creation fails.
        """
        return _core.ToolbarControls_addSplitButton(self, *args)

    def _get_objectType(self) -> "char const *":
        return _core.ToolbarControls__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ToolbarControls__get_isValid(self)

# Register ToolbarControls in _core:
_core.ToolbarControls_swigregister(ToolbarControls)

def ToolbarControls_classType() -> "char const *":
    return _core.ToolbarControls_classType()


ToolbarControls.count = property(ToolbarControls._get_count, doc="Gets the number of controls in the collection.")


ToolbarControls.cast = lambda arg: arg if isinstance(arg, ToolbarControls) else None

class ToolbarPanel(Base):
    r"""Toolbar panels are the panels shown in the command toolbar."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ToolbarPanel *":
        return _core.ToolbarPanel___deref__(self)

    def __eq__(self, rhs: "ToolbarPanel") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ToolbarPanel___eq__(self, rhs)


    def __ne__(self, rhs: "ToolbarPanel") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ToolbarPanel___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ToolbarPanel_classType()
    __swig_destroy__ = _core.delete_ToolbarPanel

    def _get_id(self) -> "std::string":
        r"""Gets The unique, language independent, ID of this panel."""
        return _core.ToolbarPanel__get_id(self)

    def _get_index(self) -> "size_t":
        r"""
        Gets the position this panel is in within the toolbar.
        The first panel is at position 0. This value is with respect
        to the complete list of panels so this value could be outside
        of the expected range if you have a collection of panels
        associated with a workspace, which is a subset of the entire
        list of panels.
        """
        return _core.ToolbarPanel__get_index(self)

    def _get_isVisible(self) -> "bool":
        r"""
        Gets whether this panel is currently being displayed in the user interface.
        Visibility of a panel is controlled by it being associated with the currently
        active workspace.
        """
        return _core.ToolbarPanel__get_isVisible(self)

    def _get_name(self) -> "std::string":
        r"""Gets the name of the panel as seen in the user interface."""
        return _core.ToolbarPanel__get_name(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this toolbar panel. 
        Returns true if the delete was successful.
        """
        return _core.ToolbarPanel_deleteMe(self)

    def _get_controls(self) -> "adsk::core::Ptr< adsk::core::ToolbarControls >":
        r"""
        Gets the controls associated with this panel. These are all in the panel's
        drop-down (assuming their visible property is true) and are selectively shown
        within the panel.
        """
        return _core.ToolbarPanel__get_controls(self)

    def _get_parentUserInterface(self) -> "adsk::core::Ptr< adsk::core::UserInterface >":
        r"""Gets the parent UserInterface object."""
        return _core.ToolbarPanel__get_parentUserInterface(self)

    def _get_promotedControls(self) -> "adsk::core::Ptr< adsk::core::ToolbarControlList >":
        r"""
        Gets the controls in the panel that have been promoted. Promoted
        controls are the controls that are displayed within the panel.
        """
        return _core.ToolbarPanel__get_promotedControls(self)

    def _get_relatedWorkspaces(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""Gets or sets the set of workspaces that this panel is displayed for."""
        return _core.ToolbarPanel__get_relatedWorkspaces(self)

    def _set_relatedWorkspaces(self, value: "ObjectCollection") -> "bool":
        r"""Gets or sets the set of workspaces that this panel is displayed for."""
        return _core.ToolbarPanel__set_relatedWorkspaces(self, value)

    def _get_productType(self) -> "std::string":
        r"""Returns the name of the product this toolbar panel is associated with."""
        return _core.ToolbarPanel__get_productType(self)

    def indexWithinTab(self, tabId: "std::string const &") -> "size_t":
        r"""
        Gets the position this panel is in within the toolbar tab.
        The first panel in the tab is at position 0.
        """
        return _core.ToolbarPanel_indexWithinTab(self, tabId)

    def _get_objectType(self) -> "char const *":
        return _core.ToolbarPanel__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ToolbarPanel__get_isValid(self)

# Register ToolbarPanel in _core:
_core.ToolbarPanel_swigregister(ToolbarPanel)

def ToolbarPanel_classType() -> "char const *":
    return _core.ToolbarPanel_classType()


ToolbarPanel.id = property(ToolbarPanel._get_id, doc="Gets The unique, language independent, ID of this panel.")


ToolbarPanel.index = property(ToolbarPanel._get_index, doc="Gets the position this panel is in within the toolbar.\nThe first panel is at position 0. This value is with respect\nto the complete list of panels so this value could be outside\nof the expected range if you have a collection of panels\nassociated with a workspace, which is a subset of the entire\nlist of panels.")


ToolbarPanel.isVisible = property(ToolbarPanel._get_isVisible, doc="Gets whether this panel is currently being displayed in the user interface.\nVisibility of a panel is controlled by it being associated with the currently\nactive workspace.")


ToolbarPanel.name = property(ToolbarPanel._get_name, doc="Gets the name of the panel as seen in the user interface.")


ToolbarPanel.controls = property(ToolbarPanel._get_controls, doc="Gets the controls associated with this panel. These are all in the panel's\ndrop-down (assuming their visible property is true) and are selectively shown\nwithin the panel.")


ToolbarPanel.parentUserInterface = property(ToolbarPanel._get_parentUserInterface, doc="Gets the parent UserInterface object.")


ToolbarPanel.promotedControls = property(ToolbarPanel._get_promotedControls, doc="Gets the controls in the panel that have been promoted. Promoted\ncontrols are the controls that are displayed within the panel.")


ToolbarPanel.relatedWorkspaces = property(ToolbarPanel._get_relatedWorkspaces, ToolbarPanel._set_relatedWorkspaces, doc="Gets or sets the set of workspaces that this panel is displayed for.")


ToolbarPanel.productType = property(ToolbarPanel._get_productType, doc="Returns the name of the product this toolbar panel is associated with.")


ToolbarPanel.cast = lambda arg: arg if isinstance(arg, ToolbarPanel) else None

class ToolbarPanelList(Base):
    r"""A ToolbarPanelList is a list of ToolbarPanel objects."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ToolbarPanelList *":
        return _core.ToolbarPanelList___deref__(self)

    def __eq__(self, rhs: "ToolbarPanelList") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ToolbarPanelList___eq__(self, rhs)


    def __ne__(self, rhs: "ToolbarPanelList") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ToolbarPanelList___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.ToolbarPanelList___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::ToolbarPanel >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.ToolbarPanelList___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.ToolbarPanelList_classType()
    __swig_destroy__ = _core.delete_ToolbarPanelList

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::ToolbarPanel >":
        r"""
        Returns the specified work space using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.ToolbarPanelList_item(self, index)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::ToolbarPanel >":
        r"""
        Returns the ToolbarPanel of the specified ID. 
        id : The ID of the ToolbarPanel to get. 
        Returns the specified ToolbarPanel or null in the case where there isn't a ToolbarPanel with the specified ID.
        """
        return _core.ToolbarPanelList_itemById(self, id)

    def _get_count(self) -> "size_t":
        r"""Gets the number of toolbar panels in the collection."""
        return _core.ToolbarPanelList__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _core.ToolbarPanelList__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ToolbarPanelList__get_isValid(self)

# Register ToolbarPanelList in _core:
_core.ToolbarPanelList_swigregister(ToolbarPanelList)

def ToolbarPanelList_classType() -> "char const *":
    return _core.ToolbarPanelList_classType()


ToolbarPanelList.count = property(ToolbarPanelList._get_count, doc="Gets the number of toolbar panels in the collection.")


ToolbarPanelList.cast = lambda arg: arg if isinstance(arg, ToolbarPanelList) else None

class ToolbarPanels(Base):
    r"""
    Provides access to a set of toolbar panels. Many toolbar panels exist and their
    visibility is determined by the active workspace. A panel can be associated with one
    or more workspaces and when the associated workspace is active, the panel is made visible.
    This collection is associated with a workspace and possibly a tab in the toolbar for that workspace.
    If this collection is from a toolbar tab, the collection order is the left-to-right order
    of panels in the toolbar tab.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ToolbarPanels *":
        return _core.ToolbarPanels___deref__(self)

    def __eq__(self, rhs: "ToolbarPanels") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ToolbarPanels___eq__(self, rhs)


    def __ne__(self, rhs: "ToolbarPanels") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ToolbarPanels___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.ToolbarPanels___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::ToolbarPanel >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.ToolbarPanels___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.ToolbarPanels_classType()
    __swig_destroy__ = _core.delete_ToolbarPanels

    def add(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarPanel >":
        r"""
        Creates a new ToolbarPanel. The panel is initially empty. 
        Use the associated ToolbarControls collection to add buttons.
        If this collection is associated with a tab, the new panel will be added to that tab.
        If this collection is not associated with a tab, the new panel will be added to the end of the 'Tools' Tab. 
        A 'Tools' tab will be created for you if it does not currently exist for this collection's workspace. 
        id : The unique id for this panel. The id must be unique with respect to all of the panels. 
        name : The displayed name of this panel. This is the name visible in the user interface. 
        positionID : Specifies the id of the panel to position this panel relative to.
        Not setting this value indicates that the panel will be created at the end of all other panels. The isBefore
        parameter specifies whether to place the panel before or after this panel. 
        isBefore : Specifies whether to place the panel before or after the panel specified by the positionID argument. 
        This argument is ignored is positionID is not specified 
        Returns the newly created panel or null in the case the creation failed.
        """
        return _core.ToolbarPanels_add(self, *args)

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::ToolbarPanel >":
        r"""
        Returns the specified toolbar panel using an index into the collection.
        When iterating by index, the panels are returned in the same order as they are shown in the user interface. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.ToolbarPanels_item(self, index)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::ToolbarPanel >":
        r"""
        Returns the ToolbarPanel at the specified ID. 
        id : The Id of the panel within the collection to return. 
        Returns the ToolbarPanel of the specified id or null no panel has the specified id.
        """
        return _core.ToolbarPanels_itemById(self, id)

    def _get_count(self) -> "size_t":
        r"""Gets the number of ToolbarPanels."""
        return _core.ToolbarPanels__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _core.ToolbarPanels__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ToolbarPanels__get_isValid(self)

# Register ToolbarPanels in _core:
_core.ToolbarPanels_swigregister(ToolbarPanels)

def ToolbarPanels_classType() -> "char const *":
    return _core.ToolbarPanels_classType()


ToolbarPanels.count = property(ToolbarPanels._get_count, doc="Gets the number of ToolbarPanels.")


ToolbarPanels.cast = lambda arg: arg if isinstance(arg, ToolbarPanels) else None

class Toolbars(Base):
    r"""Provides access to the toolbars. These are currently the right and left QAT's and the NavBar."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Toolbars *":
        return _core.Toolbars___deref__(self)

    def __eq__(self, rhs: "Toolbars") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Toolbars___eq__(self, rhs)


    def __ne__(self, rhs: "Toolbars") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Toolbars___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.Toolbars___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::Toolbar >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.Toolbars___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.Toolbars_classType()
    __swig_destroy__ = _core.delete_Toolbars

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::Toolbar >":
        r"""
        Returns the specified toolbar using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.Toolbars_item(self, index)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::Toolbar >":
        r"""
        Returns the Toolbar of the specified ID. 
        id : The Id of the toolbar to return. 
        Returns the toolbar with the specified ID or null if there's not a toolbar with the specified ID.
        """
        return _core.Toolbars_itemById(self, id)

    def _get_count(self) -> "size_t":
        r"""Gets the number of Toolbar objects in the collection."""
        return _core.Toolbars__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _core.Toolbars__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Toolbars__get_isValid(self)

# Register Toolbars in _core:
_core.Toolbars_swigregister(Toolbars)

def Toolbars_classType() -> "char const *":
    return _core.Toolbars_classType()


Toolbars.count = property(Toolbars._get_count, doc="Gets the number of Toolbar objects in the collection.")


Toolbars.cast = lambda arg: arg if isinstance(arg, Toolbars) else None

class ToolbarTab(Base):
    r"""Toolbar tabs are the tabs shown in the command toolbar."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ToolbarTab *":
        return _core.ToolbarTab___deref__(self)

    def __eq__(self, rhs: "ToolbarTab") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ToolbarTab___eq__(self, rhs)


    def __ne__(self, rhs: "ToolbarTab") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ToolbarTab___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ToolbarTab_classType()
    __swig_destroy__ = _core.delete_ToolbarTab

    def _get_id(self) -> "std::string":
        r"""Gets The unique, language independent, ID of this tab."""
        return _core.ToolbarTab__get_id(self)

    def _get_index(self) -> "size_t":
        r"""
        Gets the position this tab is in within the toolbar.
        The first tab is at position 0. This value is with respect
        to the complete list of tabs so this value could be outside
        of the expected range if you have a collection of tabs
        associated with a workspace, which is a subset of the entire
        list of tabs.
        """
        return _core.ToolbarTab__get_index(self)

    def _get_isVisible(self) -> "bool":
        r"""Gets whether this tab is currently being displayed in the user interface."""
        return _core.ToolbarTab__get_isVisible(self)

    def _get_name(self) -> "std::string":
        r"""Gets the name of the tab as seen in the user interface."""
        return _core.ToolbarTab__get_name(self)

    def _get_toolbarPanels(self) -> "adsk::core::Ptr< adsk::core::ToolbarPanels >":
        r"""
        Gets the collection containing the panels associated with this tab.
        It's through this collection that you can add new toolbar panels.
        """
        return _core.ToolbarTab__get_toolbarPanels(self)

    def _get_parentUserInterface(self) -> "adsk::core::Ptr< adsk::core::UserInterface >":
        r"""Gets the parent UserInterface object."""
        return _core.ToolbarTab__get_parentUserInterface(self)

    def _get_productType(self) -> "std::string":
        r"""Returns the name of the product this toolbar tab is associated with."""
        return _core.ToolbarTab__get_productType(self)

    def _get_isActive(self) -> "bool":
        r"""Gets if this toolbar tab is currently active - i.e. displayed."""
        return _core.ToolbarTab__get_isActive(self)

    def activate(self) -> "bool":
        r"""
        Activate this toolbar tab. 
        Boolean return that indicates if the activation was successful or not.
        """
        return _core.ToolbarTab_activate(self)

    def _get_isNative(self) -> "bool":
        r"""Gets if this tab is native to Fusion 360 or was created via the API."""
        return _core.ToolbarTab__get_isNative(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this tab. Fusion 360 native tabs cannot be deleted. Use the
        isNative property to determine if this is a native or API created tab. 
        Returns true if the delete was successful.
        """
        return _core.ToolbarTab_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.ToolbarTab__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ToolbarTab__get_isValid(self)

# Register ToolbarTab in _core:
_core.ToolbarTab_swigregister(ToolbarTab)

def ToolbarTab_classType() -> "char const *":
    return _core.ToolbarTab_classType()


ToolbarTab.id = property(ToolbarTab._get_id, doc="Gets The unique, language independent, ID of this tab.")


ToolbarTab.index = property(ToolbarTab._get_index, doc="Gets the position this tab is in within the toolbar.\nThe first tab is at position 0. This value is with respect\nto the complete list of tabs so this value could be outside\nof the expected range if you have a collection of tabs\nassociated with a workspace, which is a subset of the entire\nlist of tabs.")


ToolbarTab.isVisible = property(ToolbarTab._get_isVisible, doc="Gets whether this tab is currently being displayed in the user interface.")


ToolbarTab.name = property(ToolbarTab._get_name, doc="Gets the name of the tab as seen in the user interface.")


ToolbarTab.toolbarPanels = property(ToolbarTab._get_toolbarPanels, doc="Gets the collection containing the panels associated with this tab.\nIt's through this collection that you can add new toolbar panels.")


ToolbarTab.parentUserInterface = property(ToolbarTab._get_parentUserInterface, doc="Gets the parent UserInterface object.")


ToolbarTab.productType = property(ToolbarTab._get_productType, doc="Returns the name of the product this toolbar tab is associated with.")


ToolbarTab.isActive = property(ToolbarTab._get_isActive, doc="Gets if this toolbar tab is currently active - i.e. displayed.")


ToolbarTab.isNative = property(ToolbarTab._get_isNative, doc="Gets if this tab is native to Fusion 360 or was created via the API.")


ToolbarTab.cast = lambda arg: arg if isinstance(arg, ToolbarTab) else None

class ToolbarTabList(Base):
    r"""A ToolbarTabList is a list of ToolbarTab objects."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ToolbarTabList *":
        return _core.ToolbarTabList___deref__(self)

    def __eq__(self, rhs: "ToolbarTabList") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ToolbarTabList___eq__(self, rhs)


    def __ne__(self, rhs: "ToolbarTabList") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ToolbarTabList___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.ToolbarTabList___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::ToolbarTab >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.ToolbarTabList___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.ToolbarTabList_classType()
    __swig_destroy__ = _core.delete_ToolbarTabList

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::ToolbarTab >":
        r"""
        Returns the specified tab using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.ToolbarTabList_item(self, index)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::ToolbarTab >":
        r"""
        Returns the ToolbarTab of the specified ID. 
        id : The ID of the ToolbarTab to get. 
        Returns the specified ToolbarTab or null in the case where there isn't a ToolbarTab with the specified ID.
        """
        return _core.ToolbarTabList_itemById(self, id)

    def _get_count(self) -> "size_t":
        r"""Gets the number of toolbar tabs in the collection."""
        return _core.ToolbarTabList__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _core.ToolbarTabList__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ToolbarTabList__get_isValid(self)

# Register ToolbarTabList in _core:
_core.ToolbarTabList_swigregister(ToolbarTabList)

def ToolbarTabList_classType() -> "char const *":
    return _core.ToolbarTabList_classType()


ToolbarTabList.count = property(ToolbarTabList._get_count, doc="Gets the number of toolbar tabs in the collection.")


ToolbarTabList.cast = lambda arg: arg if isinstance(arg, ToolbarTabList) else None

class ToolbarTabs(Base):
    r"""Provides access to a set of toolbar tabs."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ToolbarTabs *":
        return _core.ToolbarTabs___deref__(self)

    def __eq__(self, rhs: "ToolbarTabs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ToolbarTabs___eq__(self, rhs)


    def __ne__(self, rhs: "ToolbarTabs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ToolbarTabs___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.ToolbarTabs___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::ToolbarTab >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.ToolbarTabs___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.ToolbarTabs_classType()
    __swig_destroy__ = _core.delete_ToolbarTabs

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::ToolbarTab >":
        r"""
        Returns the specified toolbar tab using an index into the collection.
        When iterating by index, the tabs are returned in the same order as they are shown in the user interface. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.ToolbarTabs_item(self, index)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::ToolbarTab >":
        r"""
        Returns the ToolbarTab at the specified ID. 
        id : The Id of the tab within the collection to return. 
        Returns the ToolbarTab of the specified id or null if no tab has the specified id.
        """
        return _core.ToolbarTabs_itemById(self, id)

    def _get_count(self) -> "size_t":
        r"""Gets the number of ToolbarTabs."""
        return _core.ToolbarTabs__get_count(self)

    def add(self, id: "std::string const &", name: "std::string const &") -> "adsk::core::Ptr< adsk::core::ToolbarTab >":
        r"""
        Creates a new ToolbarTab. The tab is initially empty.
        This method appends the tab to the end of the collection. 
        id : The unique id for this tab. The id must be unique with respect to all of the tabs. 
        name : The displayed name of this tab. This is the name visible in the user interface. 
        Returns the newly created tab or null in the case the creation failed.
        """
        return _core.ToolbarTabs_add(self, id, name)

    def _get_objectType(self) -> "char const *":
        return _core.ToolbarTabs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ToolbarTabs__get_isValid(self)

# Register ToolbarTabs in _core:
_core.ToolbarTabs_swigregister(ToolbarTabs)

def ToolbarTabs_classType() -> "char const *":
    return _core.ToolbarTabs_classType()


ToolbarTabs.count = property(ToolbarTabs._get_count, doc="Gets the number of ToolbarTabs.")


ToolbarTabs.cast = lambda arg: arg if isinstance(arg, ToolbarTabs) else None

class UnitAndValuePreferences(Base):
    r"""
    The UnitAndValuePreferences object provides access to unit and value precision
    related preferences.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::UnitAndValuePreferences *":
        return _core.UnitAndValuePreferences___deref__(self)

    def __eq__(self, rhs: "UnitAndValuePreferences") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.UnitAndValuePreferences___eq__(self, rhs)


    def __ne__(self, rhs: "UnitAndValuePreferences") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.UnitAndValuePreferences___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.UnitAndValuePreferences_classType()
    __swig_destroy__ = _core.delete_UnitAndValuePreferences

    def _get_generalPrecision(self) -> "int":
        r"""
        Gets and sets the general precision for distance values. This 
        value specifies the number of decimals to display.
        """
        return _core.UnitAndValuePreferences__get_generalPrecision(self)

    def _set_generalPrecision(self, value: "int") -> "bool":
        r"""
        Gets and sets the general precision for distance values. This 
        value specifies the number of decimals to display.
        """
        return _core.UnitAndValuePreferences__set_generalPrecision(self, value)

    def _get_angularPrecision(self) -> "int":
        r"""
        Gets and sets the angular precision. This 
        value specifies the number of decimals to display.
        """
        return _core.UnitAndValuePreferences__get_angularPrecision(self)

    def _set_angularPrecision(self, value: "int") -> "bool":
        r"""
        Gets and sets the angular precision. This 
        value specifies the number of decimals to display.
        """
        return _core.UnitAndValuePreferences__set_angularPrecision(self, value)

    def _get_scientificNotationPrecision(self) -> "int":
        r"""
        Gets and sets the number scientific notation precision. This 
        value specifies the number of decimals to display.
        """
        return _core.UnitAndValuePreferences__get_scientificNotationPrecision(self)

    def _set_scientificNotationPrecision(self, value: "int") -> "bool":
        r"""
        Gets and sets the number scientific notation precision. This 
        value specifies the number of decimals to display.
        """
        return _core.UnitAndValuePreferences__set_scientificNotationPrecision(self, value)

    def _get_footAndInchDisplayFormat(self) -> "adsk::core::FootAndInchDisplayFormats":
        r"""Gets and sets the foot and inch display format."""
        return _core.UnitAndValuePreferences__get_footAndInchDisplayFormat(self)

    def _set_footAndInchDisplayFormat(self, value: "FootAndInchDisplayFormats") -> "bool":
        r"""Gets and sets the foot and inch display format."""
        return _core.UnitAndValuePreferences__set_footAndInchDisplayFormat(self, value)

    def _get_degreeDisplayFormat(self) -> "adsk::core::DegreeDisplayFormats":
        r"""Gets and sets the degree display format."""
        return _core.UnitAndValuePreferences__get_degreeDisplayFormat(self)

    def _set_degreeDisplayFormat(self, value: "DegreeDisplayFormats") -> "bool":
        r"""Gets and sets the degree display format."""
        return _core.UnitAndValuePreferences__set_degreeDisplayFormat(self, value)

    def _get_isPeriodDecimalPoint(self) -> "bool":
        r"""Gets and sets if the decimal is a period or comma."""
        return _core.UnitAndValuePreferences__get_isPeriodDecimalPoint(self)

    def _set_isPeriodDecimalPoint(self, value: "bool") -> "bool":
        r"""Gets and sets if the decimal is a period or comma."""
        return _core.UnitAndValuePreferences__set_isPeriodDecimalPoint(self, value)

    def _get_areAbbreviationsForUnitDisplayed(self) -> "bool":
        r"""Gets and sets if abbreviations are used for units display."""
        return _core.UnitAndValuePreferences__get_areAbbreviationsForUnitDisplayed(self)

    def _set_areAbbreviationsForUnitDisplayed(self, value: "bool") -> "bool":
        r"""Gets and sets if abbreviations are used for units display."""
        return _core.UnitAndValuePreferences__set_areAbbreviationsForUnitDisplayed(self, value)

    def _get_areSymbolsForUnitDisplayed(self) -> "bool":
        r"""Gets and sets if symbols are used for units display."""
        return _core.UnitAndValuePreferences__get_areSymbolsForUnitDisplayed(self)

    def _set_areSymbolsForUnitDisplayed(self, value: "bool") -> "bool":
        r"""Gets and sets if symbols are used for units display."""
        return _core.UnitAndValuePreferences__set_areSymbolsForUnitDisplayed(self, value)

    def _get_isScientificNotationUsed(self) -> "bool":
        r"""Gets and sets if scientific notation is used when displaying numbers."""
        return _core.UnitAndValuePreferences__get_isScientificNotationUsed(self)

    def _set_isScientificNotationUsed(self, value: "bool") -> "bool":
        r"""Gets and sets if scientific notation is used when displaying numbers."""
        return _core.UnitAndValuePreferences__set_isScientificNotationUsed(self, value)

    def _get_useScientficNotationAbove(self) -> "int":
        r"""
        Gets and sets the number of whole digits that will be displayed before
        switching to scientific notation.
        """
        return _core.UnitAndValuePreferences__get_useScientficNotationAbove(self)

    def _set_useScientficNotationAbove(self, value: "int") -> "bool":
        r"""
        Gets and sets the number of whole digits that will be displayed before
        switching to scientific notation.
        """
        return _core.UnitAndValuePreferences__set_useScientficNotationAbove(self, value)

    def _get_useScientficNotationBelow(self) -> "int":
        r"""
        Gets and sets the number of non zero decimal places that will be 
        displayed before switching to scientific notation.
        """
        return _core.UnitAndValuePreferences__get_useScientficNotationBelow(self)

    def _set_useScientficNotationBelow(self, value: "int") -> "bool":
        r"""
        Gets and sets the number of non zero decimal places that will be 
        displayed before switching to scientific notation.
        """
        return _core.UnitAndValuePreferences__set_useScientficNotationBelow(self, value)

    def _get_areTrailingZerosHidden(self) -> "bool":
        r"""Gets and sets if trailing zeros are hidden when displaying numbers."""
        return _core.UnitAndValuePreferences__get_areTrailingZerosHidden(self)

    def _set_areTrailingZerosHidden(self, value: "bool") -> "bool":
        r"""Gets and sets if trailing zeros are hidden when displaying numbers."""
        return _core.UnitAndValuePreferences__set_areTrailingZerosHidden(self, value)

    def _get_minimumPrecisionWhenHidingZeros(self) -> "int":
        r"""
        Gets and sets the minimum number of digits to the right of the decimal to display 
        before hiding trailing zeros.
        """
        return _core.UnitAndValuePreferences__get_minimumPrecisionWhenHidingZeros(self)

    def _set_minimumPrecisionWhenHidingZeros(self, value: "int") -> "bool":
        r"""
        Gets and sets the minimum number of digits to the right of the decimal to display 
        before hiding trailing zeros.
        """
        return _core.UnitAndValuePreferences__set_minimumPrecisionWhenHidingZeros(self, value)

    def _get_materialDisplayUnit(self) -> "adsk::core::MaterialDisplayUnits":
        r"""Gets and sets the units types to use when displaying values."""
        return _core.UnitAndValuePreferences__get_materialDisplayUnit(self)

    def _set_materialDisplayUnit(self, value: "MaterialDisplayUnits") -> "bool":
        r"""Gets and sets the units types to use when displaying values."""
        return _core.UnitAndValuePreferences__set_materialDisplayUnit(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.UnitAndValuePreferences__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.UnitAndValuePreferences__get_isValid(self)

# Register UnitAndValuePreferences in _core:
_core.UnitAndValuePreferences_swigregister(UnitAndValuePreferences)

def UnitAndValuePreferences_classType() -> "char const *":
    return _core.UnitAndValuePreferences_classType()


UnitAndValuePreferences.generalPrecision = property(UnitAndValuePreferences._get_generalPrecision, UnitAndValuePreferences._set_generalPrecision, doc="Gets and sets the general precision for distance values. This\nvalue specifies the number of decimals to display.")


UnitAndValuePreferences.angularPrecision = property(UnitAndValuePreferences._get_angularPrecision, UnitAndValuePreferences._set_angularPrecision, doc="Gets and sets the angular precision. This\nvalue specifies the number of decimals to display.")


UnitAndValuePreferences.scientificNotationPrecision = property(UnitAndValuePreferences._get_scientificNotationPrecision, UnitAndValuePreferences._set_scientificNotationPrecision, doc="Gets and sets the number scientific notation precision. This\nvalue specifies the number of decimals to display.")


UnitAndValuePreferences.footAndInchDisplayFormat = property(UnitAndValuePreferences._get_footAndInchDisplayFormat, UnitAndValuePreferences._set_footAndInchDisplayFormat, doc="Gets and sets the foot and inch display format.")


UnitAndValuePreferences.degreeDisplayFormat = property(UnitAndValuePreferences._get_degreeDisplayFormat, UnitAndValuePreferences._set_degreeDisplayFormat, doc="Gets and sets the degree display format.")


UnitAndValuePreferences.isPeriodDecimalPoint = property(UnitAndValuePreferences._get_isPeriodDecimalPoint, UnitAndValuePreferences._set_isPeriodDecimalPoint, doc="Gets and sets if the decimal is a period or comma.")


UnitAndValuePreferences.areAbbreviationsForUnitDisplayed = property(UnitAndValuePreferences._get_areAbbreviationsForUnitDisplayed, UnitAndValuePreferences._set_areAbbreviationsForUnitDisplayed, doc="Gets and sets if abbreviations are used for units display.")


UnitAndValuePreferences.areSymbolsForUnitDisplayed = property(UnitAndValuePreferences._get_areSymbolsForUnitDisplayed, UnitAndValuePreferences._set_areSymbolsForUnitDisplayed, doc="Gets and sets if symbols are used for units display.")


UnitAndValuePreferences.isScientificNotationUsed = property(UnitAndValuePreferences._get_isScientificNotationUsed, UnitAndValuePreferences._set_isScientificNotationUsed, doc="Gets and sets if scientific notation is used when displaying numbers.")


UnitAndValuePreferences.useScientficNotationAbove = property(UnitAndValuePreferences._get_useScientficNotationAbove, UnitAndValuePreferences._set_useScientficNotationAbove, doc="Gets and sets the number of whole digits that will be displayed before\nswitching to scientific notation.")


UnitAndValuePreferences.useScientficNotationBelow = property(UnitAndValuePreferences._get_useScientficNotationBelow, UnitAndValuePreferences._set_useScientficNotationBelow, doc="Gets and sets the number of non zero decimal places that will be\ndisplayed before switching to scientific notation.")


UnitAndValuePreferences.areTrailingZerosHidden = property(UnitAndValuePreferences._get_areTrailingZerosHidden, UnitAndValuePreferences._set_areTrailingZerosHidden, doc="Gets and sets if trailing zeros are hidden when displaying numbers.")


UnitAndValuePreferences.minimumPrecisionWhenHidingZeros = property(UnitAndValuePreferences._get_minimumPrecisionWhenHidingZeros, UnitAndValuePreferences._set_minimumPrecisionWhenHidingZeros, doc="Gets and sets the minimum number of digits to the right of the decimal to display\nbefore hiding trailing zeros.")


UnitAndValuePreferences.materialDisplayUnit = property(UnitAndValuePreferences._get_materialDisplayUnit, UnitAndValuePreferences._set_materialDisplayUnit, doc="Gets and sets the units types to use when displaying values.")


UnitAndValuePreferences.cast = lambda arg: arg if isinstance(arg, UnitAndValuePreferences) else None

class UnitsManager(Base):
    r"""
    Utility class used to work with Values and control default units. 
    Internal values are held in SI units (e.g. seconds, radians, kg for time, angle, mass) 
    with the exception that all lengths are in cm rather than meter and this affects derived 
    units (e.g. velocity is cm/s, volume is cm^3).
    Units are specified flexibility via strings (e.g. 'cm', 'in', 'inch', 'cm^3', 'cm*cm*cm', 'mph', 'mps' 'm/s').
    Units like length can be defaulted based on the design settings if the user does not explicitly 
    specify units - so '3' can be 3 inches, mm or cm depending on what the design
    settings are.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::UnitsManager *":
        return _core.UnitsManager___deref__(self)

    def __eq__(self, rhs: "UnitsManager") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.UnitsManager___eq__(self, rhs)


    def __ne__(self, rhs: "UnitsManager") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.UnitsManager___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.UnitsManager_classType()
    __swig_destroy__ = _core.delete_UnitsManager

    def _get_product(self) -> "adsk::core::Ptr< adsk::core::Product >":
        r"""Returns the parent Product."""
        return _core.UnitsManager__get_product(self)

    def isValidExpression(self, expression: "std::string const &", units: "std::string const &") -> "bool":
        r"""
        Checks to see if the given expression is valid. 
        expression : 
        units : The units to use when validating the expression. 
        Returns True if it is a valid expression.
        """
        return _core.UnitsManager_isValidExpression(self, expression, units)

    def evaluateExpression(self, *args) -> "double":
        r"""
        Gets the value (in internal units) of the expression. 
        expression : EvaluateExpression('1cm + 1in') -> 3.54
        EvaluateExpression('1') -> -> depends on the DistanceUnits, with 'mm' it gives 0.1 
        units : If not supplied the units will default to the default length specified in the preferences. 
        Returns -1 AND GetLastError will return ExpressionError in the event of an error.
        """
        return _core.UnitsManager_evaluateExpression(self, *args)

    def convert(self, valueInInputUnits: "double", inputUnits: "std::string const &", outputUnits: "std::string const &") -> "double":
        r"""
        Converts a value from one unit to another. The input and output unit specifiers must be compatible.
        For example, 'in' (inches) and 'cm' (centimeters) will work because they both define length. 
        So Convert(1.5, 'in', 'ft') -> 0.125
        Convert(1.5, unitsManager.defaultLengthUnits, 'cm') -> depends on the current default distance units, with 'mm' it gives 0.15
        So Convert(1.5, 'in', 'kg') -> -1 and GetLastError returns ExpressionError (to denote error)
        So Convert(1, 'in', 'internalUnits') -> 2.54
        So Convert(1, 'internalUnits', 'in') -> 0.3937... 
        valueInInputUnits : The value to convert 
        inputUnits : The units of the value to convert 
        outputUnits : The units to convert the value to 
        Returns -1 AND GetLastError returns ExpressionError in the event of an error.
        """
        return _core.UnitsManager_convert(self, valueInInputUnits, inputUnits, outputUnits)

    def formatInternalValue(self, *args) -> "std::string":
        r"""
        Formats the internal value as a string. The output string is formatted using the current 
        unit settings in preferences. The preferences control the number of decimal places, whether 
        units are abbreviated and several other things.
        FormatInternalValue(1.5, 'in') -> '0.591 in'
        FormatInternalValue(1.5, 'in', false) -> '0.591'
        FormatInternalValue(1.5, 'mm', true) -> '15.00 mm'
        FormatInternalValue(1.5) -> depends on DistanceUnits, might be '15.0 mm' 
        internalValue : The internal value to format. 
        displayUnits : The units to display the value in. If not supplied the units will default to the default length specified in the preferences. 
        showUnits : Specify false to exclude units from the format. The default is true. 
        Returns an empty string if the units are incorrectly specified.
        """
        return _core.UnitsManager_formatInternalValue(self, *args)

    def formatUnits(self, units: "std::string const &") -> "std::string":
        r"""
        Formats the unit according to the user preferences
        'centimeter' -> 'cm'
        'inch' -> 'in'
        'cm* cm *cm / s' -> , 'cm^3 / s' 
        units : The unit to use when converting the value into a string. 
        Returns an empty string and GetLastError returns ExpressionError in the event of an error.
        """
        return _core.UnitsManager_formatUnits(self, units)

    def standardizeExpression(self, *args) -> "std::string":
        r"""
        Standardizes the expression in terms of spacing and user preferences. 
        StandardizeExpression('1.5') -> depends on distance units, but with mmight be '1.5 mm'
        StandardizeExpression('1.5', 'in') -> '1.5 in'
        StandardizeExpression('1.5 cm + 1.50001 centimeter') -> '1.5 cm + 1.50001 cm'
        StandardizeExpression('1.5', 'm * m * m / s') -> '1.5 m^3 /s' 
        expression : The expression to standardize 
        units : The units to apply to the standardized expression. If not supplied the units will default to the default length specified in the preferences. 
        Returns an empty string AND GetLastError returns ExpressionError in the event of an error.
        """
        return _core.UnitsManager_standardizeExpression(self, *args)

    def _get_internalUnits(self) -> "std::string":
        r"""
        Returns a string that represents internal units - i.e. 'internalUnits'. 
        This can be used when performing conversions via Convert.
        """
        return _core.UnitsManager__get_internalUnits(self)

    def _get_defaultLengthUnits(self) -> "std::string":
        r"""
        Returns the unit strings for the current default length unit as specified in preferences. - e.g. 'cm' or 'in'
        This is the string that is being used by Fusion 360 to represent the current length unit and is affected
        by the preference settings that let the user choose whether abbrevations and symbols can be used. This means
        that inch length units can be returned as inch, in, or '. If you need a consistent way of determing the current
        length unit, the distanceDisplayUnits of the FusionUnitsManager object returns an enum value.
        """
        return _core.UnitsManager__get_defaultLengthUnits(self)

    def _get_objectType(self) -> "char const *":
        return _core.UnitsManager__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.UnitsManager__get_isValid(self)

# Register UnitsManager in _core:
_core.UnitsManager_swigregister(UnitsManager)

def UnitsManager_classType() -> "char const *":
    return _core.UnitsManager_classType()


UnitsManager.product = property(UnitsManager._get_product, doc="Returns the parent Product.")


UnitsManager.internalUnits = property(UnitsManager._get_internalUnits, doc="Returns a string that represents internal units - i.e. 'internalUnits'.\nThis can be used when performing conversions via Convert.")


UnitsManager.defaultLengthUnits = property(UnitsManager._get_defaultLengthUnits, doc="Returns the unit strings for the current default length unit as specified in preferences. - e.g. 'cm' or 'in'\nThis is the string that is being used by Fusion 360 to represent the current length unit and is affected\nby the preference settings that let the user choose whether abbrevations and symbols can be used. This means\nthat inch length units can be returned as inch, in, or '. If you need a consistent way of determing the current\nlength unit, the distanceDisplayUnits of the FusionUnitsManager object returns an enum value.")


UnitsManager.cast = lambda arg: arg if isinstance(arg, UnitsManager) else None

class User(Base):
    r"""A class that represents a Fusion 360 User"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::User *":
        return _core.User___deref__(self)

    def __eq__(self, rhs: "User") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.User___eq__(self, rhs)


    def __ne__(self, rhs: "User") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.User___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.User_classType()
    __swig_destroy__ = _core.delete_User

    def _get_userName(self) -> "std::string":
        r"""Returns the Username associated with this user's Autodesk account"""
        return _core.User__get_userName(self)

    def _get_displayName(self) -> "std::string":
        r"""Returns display name of the user. (i.e. the name that shows up in the Fusion 360 UI)"""
        return _core.User__get_displayName(self)

    def _get_userId(self) -> "std::string":
        r"""
        Returns the user's internal Autodesk account name.
        This can be used by applications sold through the Autodesk Exchange Store to verify that the user has in 
        fact purchased the product.
        """
        return _core.User__get_userId(self)

    def _get_email(self) -> "std::string":
        r"""Get the email associated with this users Fusion 360 account"""
        return _core.User__get_email(self)

    def _get_objectType(self) -> "char const *":
        return _core.User__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.User__get_isValid(self)

# Register User in _core:
_core.User_swigregister(User)

def User_classType() -> "char const *":
    return _core.User_classType()


User.userName = property(User._get_userName, doc="Returns the Username associated with this user's Autodesk account")


User.displayName = property(User._get_displayName, doc="Returns display name of the user. (i.e. the name that shows up in the Fusion 360 UI)")


User.userId = property(User._get_userId, doc="Returns the user's internal Autodesk account name.\nThis can be used by applications sold through the Autodesk Exchange Store to verify that the user has in\nfact purchased the product.")


User.email = property(User._get_email, doc="Get the email associated with this users Fusion 360 account")


User.cast = lambda arg: arg if isinstance(arg, User) else None

class UserInterface(Base):
    r"""Provides access to the user-interface related objects and functionality."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::UserInterface *":
        return _core.UserInterface___deref__(self)

    def __eq__(self, rhs: "UserInterface") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.UserInterface___eq__(self, rhs)


    def __ne__(self, rhs: "UserInterface") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.UserInterface___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.UserInterface_classType()
    __swig_destroy__ = _core.delete_UserInterface

    def messageBox(self, *args) -> "adsk::core::DialogResults":
        r"""
        Display a modal message box with the provided text. 
        text : The message text to display in the dialog. 
        title : If the optional title argument is provided, it sets the title for the dialog, otherwise the default product name is used. 
        buttons : The optional buttons array can be used to specify which buttons to display on the dialog.
        The first button provided is the default action.
        If buttons are not specified, the dialog will default to a single OK button. 
        icon : The optional icon argument can be used to specify which icon to display, otherwise the default of no icon is used. 
        The button pressed to dismiss the dialog is returned.
        """
        return _core.UserInterface_messageBox(self, *args)

    def inputBox(self, *args) -> "std::string":
        r"""
        Displays a modal dialog to get string input from the user. 
        prompt : The message text to display in the dialog. 
        cancelled : Indicates if the dialog was cancelled. 
        title : Sets the title for the dialog if specified, otherwise the default product name is used. 
        defaultValue : The default string that's shown when the dialog is initially displayed, otherwise the input box is empty. 
        Returns the string entered by the user but because the user can click Cancel, the cancelled argument should be tested before using the string.
        """
        return _core.UserInterface_inputBox(self, *args)

    def selectEntity(self, prompt: "std::string const &", filter: "std::string const &") -> "adsk::core::Ptr< adsk::core::Selection >":
        r"""
        Supports the selection of a single entity. This provides a simple way to prompt
        the user for a selection in a script. If you need more control over the selection a command
        should be created and a SelectionCommandInput used. 
        prompt : The prompt displayed to the user during the selection. 
        filter : A string defining the types of entities valid for selection. The valid list of selection filters can be found here: <a href='SelectionFilters_UM.htm'>Selection Filters</a>. 
        You can combine multiple types by using a comma delimiter. For example,
        the string 'PlanarFaces,ConstructionPlanes' will allow the selection of either a planar face or a construction plane. 
        Returns a Selection object that provides access the selected entity through it's 'entity'
        property along with the location in space where the entity was selected. Returns null if the selection was aborted.
        """
        return _core.UserInterface_selectEntity(self, prompt, filter)

    def createFileDialog(self) -> "adsk::core::Ptr< adsk::core::FileDialog >":
        r"""
        Creates a new FileDialog object which provides the ability to show a standard file selection dialog
        to the user. 
        Returns the created FileDialog object that you can use to define the contents of and display a standard file dialog.
        """
        return _core.UserInterface_createFileDialog(self)

    def _get_activeSelections(self) -> "adsk::core::Ptr< adsk::core::Selections >":
        r"""Gets the current set of selected objects."""
        return _core.UserInterface__get_activeSelections(self)

    def _get_activeWorkspace(self) -> "adsk::core::Ptr< adsk::core::Workspace >":
        r"""
        Gets the active workspace. The active workspace is the one currently active in the user interface. 
        This can be null if there is no active product.
        """
        return _core.UserInterface__get_activeWorkspace(self)

    def _get_commandDefinitions(self) -> "adsk::core::Ptr< adsk::core::CommandDefinitions >":
        r"""
        Gets all of the command definitions currently defined. This is all 
        command definitions both internal and those defined through the API.
        """
        return _core.UserInterface__get_commandDefinitions(self)

    def _get_toolbars(self) -> "adsk::core::Ptr< adsk::core::Toolbars >":
        r"""
        Gets a collection that provides access to the toolbars. This includes
        the left and right QAT, and the Navbar.
        """
        return _core.UserInterface__get_toolbars(self)

    def _get_workspaces(self) -> "adsk::core::Ptr< adsk::core::Workspaces >":
        r"""Gets all of the workspaces currently available."""
        return _core.UserInterface__get_workspaces(self)

    def workspacesByProductType(self, productType: "std::string const &") -> "adsk::core::Ptr< adsk::core::WorkspaceList >":
        r"""
        Returns all of the workspaces associated with the specified product. 
        productType : The name of the product that you want the associated workspaces for. The full list
        of available products can be obtained by using the Application.supportedProductTypes property. 
        Returns a list of the associated work spaces.
        """
        return _core.UserInterface_workspacesByProductType(self, productType)

    def _get_allToolbarPanels(self) -> "adsk::core::Ptr< adsk::core::ToolbarPanelList >":
        r"""
        Gets all of the toolbar panels. This returns all of the panels
        available, regardless of which workspace or product they're associated with.
        """
        return _core.UserInterface__get_allToolbarPanels(self)

    def _get_workspacePreActivate(self) -> "adsk::core::Ptr< adsk::core::WorkspaceEvent >":
        r"""
        The workspacePreActivate event fires at the VERY start of a workspace being activated.
        The client can add or remove WorkspaceEventHandlers from the WorkspaceEvent.
        """
        return _core.UserInterface__get_workspacePreActivate(self)

    def _get_workspaceActivated(self) -> "adsk::core::Ptr< adsk::core::WorkspaceEvent >":
        r"""
        The workspaceActivated event fires at the VERY end of a workspace being activated.
        The client can add or remove WorkspaceEventHandlers from the WorkspaceEvent.
        """
        return _core.UserInterface__get_workspaceActivated(self)

    def _get_workspacePreDeactivate(self) -> "adsk::core::Ptr< adsk::core::WorkspaceEvent >":
        r"""
        The workspacePreDeactivate event fires at the VERY start of a workspace being deactivated.
        The client can add or remove WorkspaceEventHandlers from the WorkspaceEvent.
        """
        return _core.UserInterface__get_workspacePreDeactivate(self)

    def _get_workspaceDeactivated(self) -> "adsk::core::Ptr< adsk::core::WorkspaceEvent >":
        r"""
        The workspaceDeactivated event fires at the VERY end of a workspace being deactivated.
        The client can add or remove WorkspaceEventHandlers from the WorkspaceEvent.
        """
        return _core.UserInterface__get_workspaceDeactivated(self)

    def toolbarPanelsByProductType(self, productType: "std::string const &") -> "adsk::core::Ptr< adsk::core::ToolbarPanelList >":
        r"""
        Gets all of the toolbar panels associated with the specified product. 
        productType : The name of the product that you want the associated workspaces for. The full list
        of available products can be obtained by using the Application.supportedProductTypes property. 
        Returns a list of the toolbars associated with the specified product.
        """
        return _core.UserInterface_toolbarPanelsByProductType(self, productType)

    def _get_activeCommand(self) -> "std::string":
        r"""Gets the id of the command definition from the active command (the one that is currently running)"""
        return _core.UserInterface__get_activeCommand(self)

    def terminateActiveCommand(self) -> "bool":
        r"""
        Method that causes the currently active (running) command to be terminated 
        Returns true if terminating the active command was successful.
        """
        return _core.UserInterface_terminateActiveCommand(self)

    def _get_commandStarting(self) -> "adsk::core::Ptr< adsk::core::ApplicationCommandEvent >":
        r"""
        The commandStarting event fires when a request for a command to be executed has been
        received but before the command is executed. Through this event, it's possible to 
        cancel the command from being executed.
        """
        return _core.UserInterface__get_commandStarting(self)

    def _get_commandCreated(self) -> "adsk::core::Ptr< adsk::core::ApplicationCommandEvent >":
        r"""The commandCreated event fires immediately after the command is created."""
        return _core.UserInterface__get_commandCreated(self)

    def _get_commandTerminated(self) -> "adsk::core::Ptr< adsk::core::ApplicationCommandEvent >":
        r"""Gets an event that is fired when a command is terminated."""
        return _core.UserInterface__get_commandTerminated(self)

    def createProgressDialog(self) -> "adsk::core::Ptr< adsk::core::ProgressDialog >":
        r"""
        Creates a new ProgressDialog object that you can use to display and control a progress dialog. 
        Returns the created ProgressDialog object that you can use to define the contents of and display a progress dialog.
        """
        return _core.UserInterface_createProgressDialog(self)

    def _get_markingMenuDisplaying(self) -> "adsk::core::Ptr< adsk::core::MarkingMenuEvent >":
        r"""
        The markingMenuDisplaying event fires just before the marking menu and context menus are displayed. The
        marking menu is the round menu displayed when the user right-clicks the mouse within Fusion 360. The context
        menu is the vertical menu displayed. The event provides both the marking menu and the context menu so you
        can examine and edit the contents of either one or both of them before they are displayed. Fusion 360 will then
        display the marking and context menu that you've customized. If either one is empty it will not be displayed.
        """
        return _core.UserInterface__get_markingMenuDisplaying(self)

    def _get_palettes(self) -> "adsk::core::Ptr< adsk::core::Palettes >":
        r"""
        Returns the collection object that provides access to all of the existing
        palettes and provides the functionality to create new custom palettes.
        """
        return _core.UserInterface__get_palettes(self)

    def createFolderDialog(self) -> "adsk::core::Ptr< adsk::core::FolderDialog >":
        r"""
        Creates a new FolderDialog object which provides the ability to show a standard folder selection dialog
        to the user. 
        Returns the created FolderDialog object that you can use to define the contents of and display a standard folder dialog.
        """
        return _core.UserInterface_createFolderDialog(self)

    def _get_allToolbarTabs(self) -> "adsk::core::Ptr< adsk::core::ToolbarTabList >":
        r"""
        Gets all of the toolbar tabs. This returns all of the tabs
        available, regardless of which workspace or product they're associated with.
        """
        return _core.UserInterface__get_allToolbarTabs(self)

    def toolbarTabsByProductType(self, productType: "std::string const &") -> "adsk::core::Ptr< adsk::core::ToolbarTabList >":
        r"""
        Gets all of the toolbar tabs associated with the specified product. 
        productType : The name of the product that you want the associated tabs for. The full list
        of available products can be obtained by using the Application.supportedProductTypes property. 
        Returns a list of the tabs associated with the specified product.
        """
        return _core.UserInterface_toolbarTabsByProductType(self, productType)

    def _get_isTabbedToolbarUI(self) -> "bool":
        r"""
        Returns true if Tabbed Toolbars are being used. 
        Returns true if using Tabbed Toolbars.
        """
        return _core.UserInterface__get_isTabbedToolbarUI(self)

    def _get_activeSelectionChanged(self) -> "adsk::core::Ptr< adsk::core::ActiveSelectionEvent >":
        r"""
        This event fires whenever the contents of the active selection changes. This occurs as the user
        selects or unselects entities while using the Fusion 360 Select command. The Select command
        is the default command that is always running if no other command is active. Pressing Escape 
        terminates the currently active command and starts the Select command. If the Select command is
        running and you press Escape, it terminates the current Select command and starts a new one.
        This event is only associated with the selection associated with the Select command and does not
        fire when any other command is running. The event fires when there is any change to the active
        selection, including when the selection is cleared when the Select command is terminated. It is
        also fired when the user clicks in an open area of the canvas to clear the current selection.
        """
        return _core.UserInterface__get_activeSelectionChanged(self)

    def getText(self, module: "std::string const &", id: "std::string const &", defaultValue: "std::string const &") -> "std::string":
        r"""
        Get the localized text for a specific application text string. The set of text strings are available
        are listed in the .xml files in the application's StringTable folders. 
        module : The module name. This is the same as the StringTable .xml file without the .xml extension. 
        id : The id of the text. This is the same as the 'commandName' field in the StringTable .xml file. 
        defaultValue : A default string value to return if the module or string id is not found in the current locale. 
        The localized string or the defaultValue if one is not found.
        """
        return _core.UserInterface_getText(self, module, id, defaultValue)

    def _get_objectType(self) -> "char const *":
        return _core.UserInterface__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.UserInterface__get_isValid(self)

# Register UserInterface in _core:
_core.UserInterface_swigregister(UserInterface)

def UserInterface_classType() -> "char const *":
    return _core.UserInterface_classType()


UserInterface.activeSelections = property(UserInterface._get_activeSelections, doc="Gets the current set of selected objects.")


UserInterface.activeWorkspace = property(UserInterface._get_activeWorkspace, doc="Gets the active workspace. The active workspace is the one currently active in the user interface.\nThis can be null if there is no active product.")


UserInterface.commandDefinitions = property(UserInterface._get_commandDefinitions, doc="Gets all of the command definitions currently defined. This is all\ncommand definitions both internal and those defined through the API.")


UserInterface.toolbars = property(UserInterface._get_toolbars, doc="Gets a collection that provides access to the toolbars. This includes\nthe left and right QAT, and the Navbar.")


UserInterface.workspaces = property(UserInterface._get_workspaces, doc="Gets all of the workspaces currently available.")


UserInterface.allToolbarPanels = property(UserInterface._get_allToolbarPanels, doc="Gets all of the toolbar panels. This returns all of the panels\navailable, regardless of which workspace or product they're associated with.")


UserInterface.workspacePreActivate = property(UserInterface._get_workspacePreActivate, doc="The workspacePreActivate event fires at the VERY start of a workspace being activated.\nThe client can add or remove WorkspaceEventHandlers from the WorkspaceEvent.")


UserInterface.workspaceActivated = property(UserInterface._get_workspaceActivated, doc="The workspaceActivated event fires at the VERY end of a workspace being activated.\nThe client can add or remove WorkspaceEventHandlers from the WorkspaceEvent.")


UserInterface.workspacePreDeactivate = property(UserInterface._get_workspacePreDeactivate, doc="The workspacePreDeactivate event fires at the VERY start of a workspace being deactivated.\nThe client can add or remove WorkspaceEventHandlers from the WorkspaceEvent.")


UserInterface.workspaceDeactivated = property(UserInterface._get_workspaceDeactivated, doc="The workspaceDeactivated event fires at the VERY end of a workspace being deactivated.\nThe client can add or remove WorkspaceEventHandlers from the WorkspaceEvent.")


UserInterface.activeCommand = property(UserInterface._get_activeCommand, doc="Gets the id of the command definition from the active command (the one that is currently running)")


UserInterface.commandStarting = property(UserInterface._get_commandStarting, doc="The commandStarting event fires when a request for a command to be executed has been\nreceived but before the command is executed. Through this event, it's possible to\ncancel the command from being executed.")


UserInterface.commandCreated = property(UserInterface._get_commandCreated, doc="The commandCreated event fires immediately after the command is created.")


UserInterface.commandTerminated = property(UserInterface._get_commandTerminated, doc="Gets an event that is fired when a command is terminated.")


UserInterface.markingMenuDisplaying = property(UserInterface._get_markingMenuDisplaying, doc="The markingMenuDisplaying event fires just before the marking menu and context menus are displayed. The\nmarking menu is the round menu displayed when the user right-clicks the mouse within Fusion 360. The context\nmenu is the vertical menu displayed. The event provides both the marking menu and the context menu so you\ncan examine and edit the contents of either one or both of them before they are displayed. Fusion 360 will then\ndisplay the marking and context menu that you've customized. If either one is empty it will not be displayed.")


UserInterface.palettes = property(UserInterface._get_palettes, doc="Returns the collection object that provides access to all of the existing\npalettes and provides the functionality to create new custom palettes.")


UserInterface.allToolbarTabs = property(UserInterface._get_allToolbarTabs, doc="Gets all of the toolbar tabs. This returns all of the tabs\navailable, regardless of which workspace or product they're associated with.")


UserInterface.isTabbedToolbarUI = property(UserInterface._get_isTabbedToolbarUI, doc="Returns true if Tabbed Toolbars are being used.\nReturns true if using Tabbed Toolbars.")


UserInterface.activeSelectionChanged = property(UserInterface._get_activeSelectionChanged, doc="This event fires whenever the contents of the active selection changes. This occurs as the user\nselects or unselects entities while using the Fusion 360 Select command. The Select command\nis the default command that is always running if no other command is active. Pressing Escape\nterminates the currently active command and starts the Select command. If the Select command is\nrunning and you press Escape, it terminates the current Select command and starts a new one.\nThis event is only associated with the selection associated with the Select command and does not\nfire when any other command is running. The event fires when there is any change to the active\nselection, including when the selection is cleared when the Select command is terminated. It is\nalso fired when the user clicks in an open area of the canvas to clear the current selection.")


UserInterface.cast = lambda arg: arg if isinstance(arg, UserInterface) else None

class UserInterfaceGeneralEventHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notify(self, eventArgs: "UserInterfaceGeneralEventArgs") -> "void":
        return _core.UserInterfaceGeneralEventHandler_notify(self, eventArgs)

    def __init__(self):
        if self.__class__ == UserInterfaceGeneralEventHandler:
            _self = None
        else:
            _self = self
        _core.UserInterfaceGeneralEventHandler_swiginit(self, _core.new_UserInterfaceGeneralEventHandler(_self, ))
    __swig_destroy__ = _core.delete_UserInterfaceGeneralEventHandler
    def __disown__(self):
        self.this.disown()
        _core.disown_UserInterfaceGeneralEventHandler(self)
        return weakref.proxy(self)

# Register UserInterfaceGeneralEventHandler in _core:
_core.UserInterfaceGeneralEventHandler_swigregister(UserInterfaceGeneralEventHandler)


UserInterfaceGeneralEventHandler.cast = lambda arg: arg if isinstance(arg, UserInterfaceGeneralEventHandler) else None

class ValidateInputsEventHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notify(self, eventArgs: "ValidateInputsEventArgs") -> "void":
        return _core.ValidateInputsEventHandler_notify(self, eventArgs)

    def __init__(self):
        if self.__class__ == ValidateInputsEventHandler:
            _self = None
        else:
            _self = self
        _core.ValidateInputsEventHandler_swiginit(self, _core.new_ValidateInputsEventHandler(_self, ))
    __swig_destroy__ = _core.delete_ValidateInputsEventHandler
    def __disown__(self):
        self.this.disown()
        _core.disown_ValidateInputsEventHandler(self)
        return weakref.proxy(self)

# Register ValidateInputsEventHandler in _core:
_core.ValidateInputsEventHandler_swigregister(ValidateInputsEventHandler)


ValidateInputsEventHandler.cast = lambda arg: arg if isinstance(arg, ValidateInputsEventHandler) else None

class ValueInput(Base):
    r"""
    A ValueInput provides a flexible way of specifying a string, a double, a boolean, or object reference.
    No semantics are associated with a ValueInput (e.g. is the string valid, can the string
    be converted to a double) - it is merely a way of supplying information in 
    either string, double, boolean or object reference form as a function parameter. 
    ValueInput objects are typically used to specify things like an extrude depth, or hole dia, etc.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ValueInput *":
        return _core.ValueInput___deref__(self)

    def __eq__(self, rhs: "ValueInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ValueInput___eq__(self, rhs)


    def __ne__(self, rhs: "ValueInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ValueInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ValueInput_classType()

    @staticmethod
    def createByReal(realValue: "double") -> "adsk::core::Ptr< adsk::core::ValueInput >":
        return _core.ValueInput_createByReal(realValue)

    @staticmethod
    def createByString(stringValue: "std::string const &") -> "adsk::core::Ptr< adsk::core::ValueInput >":
        return _core.ValueInput_createByString(stringValue)

    @staticmethod
    def createByObject(objectReference: "Base") -> "adsk::core::Ptr< adsk::core::ValueInput >":
        return _core.ValueInput_createByObject(objectReference)

    @staticmethod
    def createByBoolean(booleanValue: "bool") -> "adsk::core::Ptr< adsk::core::ValueInput >":
        return _core.ValueInput_createByBoolean(booleanValue)
    __swig_destroy__ = _core.delete_ValueInput

    def _get_realValue(self) -> "double":
        r"""
        Gets the real value, if there is one.
        Returns -1 AND GetLastError returns ValueNotOfType if there is no real value.
        You can use the valueType property to determine which value type is currently used.
        """
        return _core.ValueInput__get_realValue(self)

    def _get_stringValue(self) -> "std::string":
        r"""
        Gets the string value, if there is one.
        Returns an empty string AND GetLastError returns ValueNotOfType if there is no string value.
        You can use the valueType property to determine which value type is currently used.
        """
        return _core.ValueInput__get_stringValue(self)

    def _get_objectReference(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets the object being referenced, if there is one.
        Returns null AND GetLastError returns ValueNotOfType if there is no object reference.
        You can use the valueType property to determine which value type is currently used.
        """
        return _core.ValueInput__get_objectReference(self)

    def _get_valueType(self) -> "adsk::core::ValueTypes":
        r"""Returns the type of value this ValueInput currently represents."""
        return _core.ValueInput__get_valueType(self)

    def _get_booleanValue(self) -> "bool":
        r"""
        Gets the boolean value, if there is one.
        Returns false AND GetLastError returns ValueNotOfType if there is no boolean value.
        You can use the valueType property to determine which value type is currently used.
        """
        return _core.ValueInput__get_booleanValue(self)

    def _get_objectType(self) -> "char const *":
        return _core.ValueInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ValueInput__get_isValid(self)

# Register ValueInput in _core:
_core.ValueInput_swigregister(ValueInput)

def ValueInput_classType() -> "char const *":
    return _core.ValueInput_classType()

def ValueInput_createByReal(realValue: "double") -> "adsk::core::Ptr< adsk::core::ValueInput >":
    return _core.ValueInput_createByReal(realValue)

def ValueInput_createByString(stringValue: "std::string const &") -> "adsk::core::Ptr< adsk::core::ValueInput >":
    return _core.ValueInput_createByString(stringValue)

def ValueInput_createByObject(objectReference: "Base") -> "adsk::core::Ptr< adsk::core::ValueInput >":
    return _core.ValueInput_createByObject(objectReference)

def ValueInput_createByBoolean(booleanValue: "bool") -> "adsk::core::Ptr< adsk::core::ValueInput >":
    return _core.ValueInput_createByBoolean(booleanValue)


ValueInput.realValue = property(ValueInput._get_realValue, doc="Gets the real value, if there is one.\nReturns -1 AND GetLastError returns ValueNotOfType if there is no real value.\nYou can use the valueType property to determine which value type is currently used.")


ValueInput.stringValue = property(ValueInput._get_stringValue, doc="Gets the string value, if there is one.\nReturns an empty string AND GetLastError returns ValueNotOfType if there is no string value.\nYou can use the valueType property to determine which value type is currently used.")


ValueInput.objectReference = property(ValueInput._get_objectReference, doc="Gets the object being referenced, if there is one.\nReturns null AND GetLastError returns ValueNotOfType if there is no object reference.\nYou can use the valueType property to determine which value type is currently used.")


ValueInput.valueType = property(ValueInput._get_valueType, doc="Returns the type of value this ValueInput currently represents.")


ValueInput.booleanValue = property(ValueInput._get_booleanValue, doc="Gets the boolean value, if there is one.\nReturns false AND GetLastError returns ValueNotOfType if there is no boolean value.\nYou can use the valueType property to determine which value type is currently used.")


ValueInput.cast = lambda arg: arg if isinstance(arg, ValueInput) else None

class Vector2D(Base):
    r"""
    Transient 2D vector. This object is a wrapper for 2D vector data and is used to 
    pass vector data in and out of the API.
    They are created statically using the create method of the Vector2D class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Vector2D *":
        return _core.Vector2D___deref__(self)

    def __eq__(self, rhs: "Vector2D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Vector2D___eq__(self, rhs)


    def __ne__(self, rhs: "Vector2D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Vector2D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Vector2D_classType()

    @staticmethod
    def create(x: "double"=0, y: "double"=0) -> "adsk::core::Ptr< adsk::core::Vector2D >":
        return _core.Vector2D_create(x, y)
    __swig_destroy__ = _core.delete_Vector2D

    def add(self, vector: "Vector2D") -> "bool":
        r"""
        Add a vector to this vector. 
        vector : The vector to add to this vector. 
        Returns true if successful.
        """
        return _core.Vector2D_add(self, vector)

    def angleTo(self, vector: "Vector2D") -> "double":
        r"""
        Gets the angle between this vector and another vector. 
        vector : The vector to measure the angle to. 
        Returns the angle in radians.
        """
        return _core.Vector2D_angleTo(self, vector)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Vector2D >":
        r"""
        Creates and returns an independent copy of this Vector2D object. 
        Returns a new Vector2D object that is a copy of this Vector2D object.
        """
        return _core.Vector2D_copy(self)

    def dotProduct(self, vector: "Vector2D") -> "double":
        r"""
        Calculates the Dot Product of this vector and an input vector. 
        vector : The vector to use in the dot product calculation. 
        Returns the dot product of the two vectors.
        """
        return _core.Vector2D_dotProduct(self, vector)

    def asArray(self) -> "std::vector< double,std::allocator< double > >":
        r"""
        Returns the vector values as an array [x, y]. 
        Returns an array of the vector's values [x, y].
        """
        return _core.Vector2D_asArray(self)

    def isEqualTo(self, vector: "Vector2D") -> "bool":
        r"""
        Compare this vector with another to check for equality. 
        vector : The vector to compare with for equality. 
        Returns true if the vectors are equal.
        """
        return _core.Vector2D_isEqualTo(self, vector)

    def isParallelTo(self, vector: "Vector2D") -> "bool":
        r"""
        Compare this vector with another to check for parallelism. 
        vector : The vector to compare with for parallelism. 
        Returns true if the vectors are parallel.
        """
        return _core.Vector2D_isParallelTo(self, vector)

    def isPerpendicularTo(self, vector: "Vector2D") -> "bool":
        r"""
        Compare this vector with another to check for perpendicularity. 
        vector : The vector to compare with for perpendicularity. 
        Returns true if the vectors are perpendicular.
        """
        return _core.Vector2D_isPerpendicularTo(self, vector)

    def _get_length(self) -> "double":
        r"""Gets the length of the vector."""
        return _core.Vector2D__get_length(self)

    def normalize(self) -> "bool":
        r"""
        Normalizes the vector.
        Normalization makes the vector length equal to one.
        The vector should not be zero length. 
        Returns true if successful.
        """
        return _core.Vector2D_normalize(self)

    def setWithArray(self, coordinates: "DoubleVector") -> "bool":
        r"""
        Sets the definition of the vector by specifying an array containing the x and y coordinates. 
        coordinates : An array that specifies the values for the x and y coordinates of the vector. 
        Returns true if successful
        """
        return _core.Vector2D_setWithArray(self, coordinates)

    def scaleBy(self, scale: "double") -> "bool":
        r"""
        Scales the vector by specifying a scaling factor. 
        scale : The scale factor to multiple the vector by (i.e. 1.5). 
        Returns true if successful.
        """
        return _core.Vector2D_scaleBy(self, scale)

    def subtract(self, vector: "Vector2D") -> "bool":
        r"""
        Subtract a vector from this vector. 
        vector : The vector to subtract from this vector. 
        Returns true if successful.
        """
        return _core.Vector2D_subtract(self, vector)

    def transformBy(self, matrix: "Matrix2D") -> "bool":
        r"""
        Transforms the vector by specifying a 2D transformation matrix. 
        matrix : The Matrix2D object that defines the transformation. 
        Returns true if successful.
        """
        return _core.Vector2D_transformBy(self, matrix)

    def asPoint(self) -> "adsk::core::Ptr< adsk::core::Point2D >":
        r"""
        Return a point with the same x and y values as this vector. 
        Returns the new point.
        """
        return _core.Vector2D_asPoint(self)

    def _get_x(self) -> "double":
        r"""Gets and sets the X coordinate of the vector."""
        return _core.Vector2D__get_x(self)

    def _set_x(self, value: "double") -> "bool":
        r"""Gets and sets the X coordinate of the vector."""
        return _core.Vector2D__set_x(self, value)

    def _get_y(self) -> "double":
        r"""Gets and sets the Y coordinate of the vector."""
        return _core.Vector2D__get_y(self)

    def _set_y(self, value: "double") -> "bool":
        r"""Gets and sets the Y coordinate of the vector."""
        return _core.Vector2D__set_y(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.Vector2D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Vector2D__get_isValid(self)

# Register Vector2D in _core:
_core.Vector2D_swigregister(Vector2D)

def Vector2D_classType() -> "char const *":
    return _core.Vector2D_classType()

def Vector2D_create(x: "double"=0, y: "double"=0) -> "adsk::core::Ptr< adsk::core::Vector2D >":
    return _core.Vector2D_create(x, y)


Vector2D.length = property(Vector2D._get_length, doc="Gets the length of the vector.")


Vector2D.x = property(Vector2D._get_x, Vector2D._set_x, doc="Gets and sets the X coordinate of the vector.")


Vector2D.y = property(Vector2D._get_y, Vector2D._set_y, doc="Gets and sets the Y coordinate of the vector.")


Vector2D.cast = lambda arg: arg if isinstance(arg, Vector2D) else None

class Vector3D(Base):
    r"""
    Transient 3D vector. This object is a wrapper over 3D vector data and is used as way to pass vector data
    in and out of the API and as a convenience when operating on vector data.
    They are created statically using the create method of the Vector3D class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Vector3D *":
        return _core.Vector3D___deref__(self)

    def __eq__(self, rhs: "Vector3D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Vector3D___eq__(self, rhs)


    def __ne__(self, rhs: "Vector3D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Vector3D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Vector3D_classType()

    @staticmethod
    def create(x: "double"=0, y: "double"=0, z: "double"=0) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        return _core.Vector3D_create(x, y, z)
    __swig_destroy__ = _core.delete_Vector3D

    def add(self, vector: "Vector3D") -> "bool":
        r"""
        Adds a vector to this vector. 
        vector : The vector to add to this vector. 
        Returns true if successful.
        """
        return _core.Vector3D_add(self, vector)

    def angleTo(self, vector: "Vector3D") -> "double":
        r"""
        Determines the angle between this vector and the specified vector. 
        vector : The vector to measure the angle to. 
        The angle in radians between this vector and the specified vector.
        """
        return _core.Vector3D_angleTo(self, vector)

    def asPoint(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""
        Returns a new point with the same coordinate values as this vector. 
        Return the new point.
        """
        return _core.Vector3D_asPoint(self)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Creates a copy of this vector. 
        Returns the new vector copy.
        """
        return _core.Vector3D_copy(self)

    def crossProduct(self, vector: "Vector3D") -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Returns the cross product between this vector and the specified vector. 
        vector : The vector to take the cross product to. 
        Returns the vector cross product.
        """
        return _core.Vector3D_crossProduct(self, vector)

    def dotProduct(self, vector: "Vector3D") -> "double":
        r"""
        Returns the dot product between this vector and the specified vector. 
        vector : The vector to take the dot product to. 
        Returns the dot product value.
        """
        return _core.Vector3D_dotProduct(self, vector)

    def asArray(self) -> "std::vector< double,std::allocator< double > >":
        r"""
        Returns the vector coordinates as an array [x, y, z]. 
        Returns the array of vector coordinates [x, y, z].
        """
        return _core.Vector3D_asArray(self)

    def isEqualTo(self, vector: "Vector3D") -> "bool":
        r"""
        Determines if this vector is equal to the specified vector. 
        vector : The vector to test equality to. 
        Returns true if the vectors are equal.
        """
        return _core.Vector3D_isEqualTo(self, vector)

    def isParallelTo(self, vector: "Vector3D") -> "bool":
        r"""
        Determines if the input vector is parallel with this vector. 
        vector : The vector to test parallelism to. 
        Returns true if the vectors are parallel.
        """
        return _core.Vector3D_isParallelTo(self, vector)

    def isPerpendicularTo(self, vector: "Vector3D") -> "bool":
        r"""
        Determines if the input vector is perpendicular to this vector. 
        vector : The vector to test perpendicularity to. 
        Returns true if the vectors are perpendicular.
        """
        return _core.Vector3D_isPerpendicularTo(self, vector)

    def _get_length(self) -> "double":
        r"""Get the length of this vector."""
        return _core.Vector3D__get_length(self)

    def normalize(self) -> "bool":
        r"""
        Makes this vector of unit length.
        This vector should not be zero length. 
        Returns true if successful.
        """
        return _core.Vector3D_normalize(self)

    def setWithArray(self, coordinates: "DoubleVector") -> "bool":
        r"""
        Reset this vector with the coordinate values in an array [x, y, z]. 
        coordinates : The array of coordinate values. 
        Returns true if successful.
        """
        return _core.Vector3D_setWithArray(self, coordinates)

    def scaleBy(self, scale: "double") -> "bool":
        r"""
        Scale this vector by the specified product. 
        scale : The scale value. 
        Returns true if successful.
        """
        return _core.Vector3D_scaleBy(self, scale)

    def subtract(self, vector: "Vector3D") -> "bool":
        r"""
        Subtract a vector from this vector. 
        vector : The vector to subtract. 
        Returns true if successful.
        """
        return _core.Vector3D_subtract(self, vector)

    def transformBy(self, matrix: "Matrix3D") -> "bool":
        r"""
        Transform this vector by the specified matrix. 
        matrix : The transformation matrix. 
        Returns true if successful.
        """
        return _core.Vector3D_transformBy(self, matrix)

    def _get_x(self) -> "double":
        r"""The x value."""
        return _core.Vector3D__get_x(self)

    def _set_x(self, value: "double") -> "bool":
        r"""The x value."""
        return _core.Vector3D__set_x(self, value)

    def _get_y(self) -> "double":
        r"""The y value."""
        return _core.Vector3D__get_y(self)

    def _set_y(self, value: "double") -> "bool":
        r"""The y value."""
        return _core.Vector3D__set_y(self, value)

    def _get_z(self) -> "double":
        r"""The z value."""
        return _core.Vector3D__get_z(self)

    def _set_z(self, value: "double") -> "bool":
        r"""The z value."""
        return _core.Vector3D__set_z(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.Vector3D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Vector3D__get_isValid(self)

# Register Vector3D in _core:
_core.Vector3D_swigregister(Vector3D)

def Vector3D_classType() -> "char const *":
    return _core.Vector3D_classType()

def Vector3D_create(x: "double"=0, y: "double"=0, z: "double"=0) -> "adsk::core::Ptr< adsk::core::Vector3D >":
    return _core.Vector3D_create(x, y, z)


Vector3D.length = property(Vector3D._get_length, doc="Get the length of this vector.")


Vector3D.x = property(Vector3D._get_x, Vector3D._set_x, doc="The x value.")


Vector3D.y = property(Vector3D._get_y, Vector3D._set_y, doc="The y value.")


Vector3D.z = property(Vector3D._get_z, Vector3D._set_z, doc="The z value.")


Vector3D.cast = lambda arg: arg if isinstance(arg, Vector3D) else None

class Viewport(Base):
    r"""A viewport within Fusion 360. A viewport is the window where the model is displayed."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Viewport *":
        return _core.Viewport___deref__(self)

    def __eq__(self, rhs: "Viewport") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Viewport___eq__(self, rhs)


    def __ne__(self, rhs: "Viewport") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Viewport___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Viewport_classType()
    __swig_destroy__ = _core.delete_Viewport

    def refresh(self) -> "bool":
        r"""
        Forces the view to refresh. It is sometimes useful to force a refresh to 
        be able to see edits that have been made using the API. 
        Returns true if the operation was successful.
        """
        return _core.Viewport_refresh(self)

    def _get_camera(self) -> "adsk::core::Ptr< adsk::core::Camera >":
        r"""
        Gets and sets the camera associated with the view.
        The camera returned is a copy of the current camera
        settings of the view. Editing the properties of the
        camera will have no affect on the viewport until the 
        camera is assigned back to the viewport.
        """
        return _core.Viewport__get_camera(self)

    def _set_camera(self, value: "Camera") -> "bool":
        r"""
        Gets and sets the camera associated with the view.
        The camera returned is a copy of the current camera
        settings of the view. Editing the properties of the
        camera will have no affect on the viewport until the 
        camera is assigned back to the viewport.
        """
        return _core.Viewport__set_camera(self, value)

    def _get_height(self) -> "int":
        r"""Returns the height of the viewport in pixels."""
        return _core.Viewport__get_height(self)

    def _get_width(self) -> "int":
        r"""Returns the width of the viewport in pixels."""
        return _core.Viewport__get_width(self)

    def _get_isFullScreen(self) -> "bool":
        r"""Gets and sets if the view is in full screen mode."""
        return _core.Viewport__get_isFullScreen(self)

    def _set_isFullScreen(self, value: "bool") -> "bool":
        r"""Gets and sets if the view is in full screen mode."""
        return _core.Viewport__set_isFullScreen(self, value)

    def saveAsImageFile(self, filename: "std::string const &", width: "int", height: "int") -> "bool":
        r"""
        Saves the current view to the specified image file. The view is re-rendered to the specified size and not
        just scaled from the existing view. This allows you to generate higher resolution images than you could
        do with just a screen capture. 
        filename : The full filename, including the path, of the image file. The type of image file to be created is inferred from the extension of the filename. 
        width : The width in pixels of the output image. A value of zero indicates that the current width of the viewport is to be used. 
        height : The height in pixels of the output image. A value of zero indicates that the current height of the viewport is to be used. 
        Returns true if the operation was successful.
        """
        return _core.Viewport_saveAsImageFile(self, filename, width, height)

    def _get_visualStyle(self) -> "adsk::core::VisualStyles":
        r"""Gets and sets the current visual style being used."""
        return _core.Viewport__get_visualStyle(self)

    def _set_visualStyle(self, value: "VisualStyles") -> "bool":
        r"""Gets and sets the current visual style being used."""
        return _core.Viewport__set_visualStyle(self, value)

    def fit(self) -> "bool":
        r"""
        Forces a camera change so that all of the graphics are visible in the viewport. 
        Returns true if the fit was successful.
        """
        return _core.Viewport_fit(self)

    def modelToViewSpace(self, modelCoordinate: "Point3D") -> "adsk::core::Ptr< adsk::core::Point2D >":
        r"""
        A specified point in model space returns the equivalent point in view space. 
        modelCoordinate : A coordinate in model space. 
        Returns the equivalent point in view space.
        """
        return _core.Viewport_modelToViewSpace(self, modelCoordinate)

    def viewToModelSpace(self, viewCoordinate: "Point2D") -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""
        A specified point in view space returns the equivalent point in model space.
        Because view space is 2D and model space is 3D, the depth of the point is 
        returned is somewhat arbitrary along the eye to target point direction. 
        viewCoordinate : A coordinate in view space. 
        Returns the equivalent point in model space.
        """
        return _core.Viewport_viewToModelSpace(self, viewCoordinate)

    def screenToView(self, screenCoordinate: "Point2D") -> "adsk::core::Ptr< adsk::core::Point2D >":
        r"""
        Converts a 2D screen point into the equivalent viewport coordinate. 
        screenCoordinate : A 2D coordinate in screen space. 
        (0,0) indicates the upper-left corner of the entire screen. 
        Returns the equivalent point in the viewport. This can return null in the case
        where the input screen point does not lie within the viewport.
        """
        return _core.Viewport_screenToView(self, screenCoordinate)

    def viewToScreen(self, viewCoordinate: "Point2D") -> "adsk::core::Ptr< adsk::core::Point2D >":
        r"""
        Converts a 2D viewPort point into the equivalent screen coordinate. 
        viewCoordinate : A 2D coordinate in the viewport. 
        (0,0) indicates the upper-left corner of the viewport. 
        Returns the equivalent point in the screen. This can return null in the case where
        the input point is outside the bounds of the screen, which also means it's outside
        any viewport.
        """
        return _core.Viewport_viewToScreen(self, viewCoordinate)

    def _get_objectType(self) -> "char const *":
        return _core.Viewport__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Viewport__get_isValid(self)

# Register Viewport in _core:
_core.Viewport_swigregister(Viewport)

def Viewport_classType() -> "char const *":
    return _core.Viewport_classType()


Viewport.camera = property(Viewport._get_camera, Viewport._set_camera, doc="Gets and sets the camera associated with the view.\nThe camera returned is a copy of the current camera\nsettings of the view. Editing the properties of the\ncamera will have no affect on the viewport until the\ncamera is assigned back to the viewport.")


Viewport.height = property(Viewport._get_height, doc="Returns the height of the viewport in pixels.")


Viewport.width = property(Viewport._get_width, doc="Returns the width of the viewport in pixels.")


Viewport.isFullScreen = property(Viewport._get_isFullScreen, Viewport._set_isFullScreen, doc="Gets and sets if the view is in full screen mode.")


Viewport.visualStyle = property(Viewport._get_visualStyle, Viewport._set_visualStyle, doc="Gets and sets the current visual style being used.")


Viewport.cast = lambda arg: arg if isinstance(arg, Viewport) else None

class WebRequestEventHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notify(self, eventArgs: "WebRequestEventArgs") -> "void":
        return _core.WebRequestEventHandler_notify(self, eventArgs)

    def __init__(self):
        if self.__class__ == WebRequestEventHandler:
            _self = None
        else:
            _self = self
        _core.WebRequestEventHandler_swiginit(self, _core.new_WebRequestEventHandler(_self, ))
    __swig_destroy__ = _core.delete_WebRequestEventHandler
    def __disown__(self):
        self.this.disown()
        _core.disown_WebRequestEventHandler(self)
        return weakref.proxy(self)

# Register WebRequestEventHandler in _core:
_core.WebRequestEventHandler_swigregister(WebRequestEventHandler)


WebRequestEventHandler.cast = lambda arg: arg if isinstance(arg, WebRequestEventHandler) else None

class Workspace(Base):
    r"""
    A Workspace provides access to a set of panels, which contain commands that
    are relevant for that particular workspace. The user can switch from one 
    workspace to another in a product (e.g. switch from Model to Sculpt in Fusion 360).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Workspace *":
        return _core.Workspace___deref__(self)

    def __eq__(self, rhs: "Workspace") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Workspace___eq__(self, rhs)


    def __ne__(self, rhs: "Workspace") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Workspace___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Workspace_classType()
    __swig_destroy__ = _core.delete_Workspace

    def _get_id(self) -> "std::string":
        r"""
        Gets the unique Id of the workspace that can be used programmatically
        to find a specific workspace. It is not affected by the current
        language.
        """
        return _core.Workspace__get_id(self)

    def _get_isActive(self) -> "bool":
        r"""Gets if the workspace is currently active - i.e. displayed"""
        return _core.Workspace__get_isActive(self)

    def _get_isNative(self) -> "bool":
        r"""Gets if this workspace is native to Fusion 360 or was created via the API."""
        return _core.Workspace__get_isNative(self)

    def _get_name(self) -> "std::string":
        r"""
        Gets the visible name of the workspace as seen in the user interface.
        This is the localized name.
        """
        return _core.Workspace__get_name(self)

    def _get_toolbarPanels(self) -> "adsk::core::Ptr< adsk::core::ToolbarPanels >":
        r"""
        Gets the collection containing the panels associated with this workspace.
        It's through this collection that you can add new toolbar panels.
        """
        return _core.Workspace__get_toolbarPanels(self)

    def _get_resourceFolder(self) -> "std::string":
        r"""Gets or sets the resource folder."""
        return _core.Workspace__get_resourceFolder(self)

    def _set_resourceFolder(self, value: "std::string const &") -> "bool":
        r"""Gets or sets the resource folder."""
        return _core.Workspace__set_resourceFolder(self, value)

    def activate(self) -> "bool":
        r"""
        Activate the workspace (assuming it is valid to do so - a SIM workspace can't
        be activated if Fusion 360 is the active product). 
        Boolean return that indicates if the activation was successful or not.
        """
        return _core.Workspace_activate(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this workspace. Only a workspace added by the API can be deleted, (IsNative is false). 
        Boolean return that indicates if the deletion was successful or not.
        """
        return _core.Workspace_deleteMe(self)

    def _get_productType(self) -> "std::string":
        r"""Returns the name of the product this workspace is associated with."""
        return _core.Workspace__get_productType(self)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip. 
        the tool clip is the image shown when the user hovers the mouse over the workspace name in the workspace drop-down.
        """
        return _core.Workspace__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip. 
        the tool clip is the image shown when the user hovers the mouse over the workspace name in the workspace drop-down.
        """
        return _core.Workspace__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the tooltip text displayed for the workspace. This is the first line of text shown when the
        user hovers over the workspace name in the Fusion 360 toolbar drop-down. This is typically the name of the
        workspace. This is different from the name in the that the name is a short name shown in the drop-down.
        The tooltip is only shown when the user hovers over the name and box appears providing more information 
        about the workspace. For example, the name of the model workspace is 'Model' and the tooltip is 'Model Workspace'.
        """
        return _core.Workspace__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the tooltip text displayed for the workspace. This is the first line of text shown when the
        user hovers over the workspace name in the Fusion 360 toolbar drop-down. This is typically the name of the
        workspace. This is different from the name in the that the name is a short name shown in the drop-down.
        The tooltip is only shown when the user hovers over the name and box appears providing more information 
        about the workspace. For example, the name of the model workspace is 'Model' and the tooltip is 'Model Workspace'.
        """
        return _core.Workspace__set_tooltip(self, value)

    def _get_tooltipDescription(self) -> "std::string":
        r"""
        Gets or sets the tooltip description displayed for the workspace. The tooltip description is a longer
        description of the workspace and is only displayed when the user hovers over the workspace name in
        the Fusion 360 toolbar drop-down. The pop-up dialog that appears contains the tooltip, the tooltip
        description, and the toolclip which is a picture.
        """
        return _core.Workspace__get_tooltipDescription(self)

    def _set_tooltipDescription(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the tooltip description displayed for the workspace. The tooltip description is a longer
        description of the workspace and is only displayed when the user hovers over the workspace name in
        the Fusion 360 toolbar drop-down. The pop-up dialog that appears contains the tooltip, the tooltip
        description, and the toolclip which is a picture.
        """
        return _core.Workspace__set_tooltipDescription(self, value)

    def _get_toolbarTabs(self) -> "adsk::core::Ptr< adsk::core::ToolbarTabs >":
        r"""Gets the collection containing the tabs associated with this workspace."""
        return _core.Workspace__get_toolbarTabs(self)

    def _get_objectType(self) -> "char const *":
        return _core.Workspace__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Workspace__get_isValid(self)

# Register Workspace in _core:
_core.Workspace_swigregister(Workspace)

def Workspace_classType() -> "char const *":
    return _core.Workspace_classType()


Workspace.id = property(Workspace._get_id, doc="Gets the unique Id of the workspace that can be used programmatically\nto find a specific workspace. It is not affected by the current\nlanguage.")


Workspace.isActive = property(Workspace._get_isActive, doc="Gets if the workspace is currently active - i.e. displayed")


Workspace.isNative = property(Workspace._get_isNative, doc="Gets if this workspace is native to Fusion 360 or was created via the API.")


Workspace.name = property(Workspace._get_name, doc="Gets the visible name of the workspace as seen in the user interface.\nThis is the localized name.")


Workspace.toolbarPanels = property(Workspace._get_toolbarPanels, doc="Gets the collection containing the panels associated with this workspace.\nIt's through this collection that you can add new toolbar panels.")


Workspace.resourceFolder = property(Workspace._get_resourceFolder, Workspace._set_resourceFolder, doc="Gets or sets the resource folder.")


Workspace.productType = property(Workspace._get_productType, doc="Returns the name of the product this workspace is associated with.")


Workspace.toolClipFilename = property(Workspace._get_toolClipFilename, Workspace._set_toolClipFilename, doc="Gets or sets the full filename of the image file (png) used for the tool clip.\nthe tool clip is the image shown when the user hovers the mouse over the workspace name in the workspace drop-down.")


Workspace.tooltip = property(Workspace._get_tooltip, Workspace._set_tooltip, doc="Gets or sets the tooltip text displayed for the workspace. This is the first line of text shown when the\nuser hovers over the workspace name in the Fusion 360 toolbar drop-down. This is typically the name of the\nworkspace. This is different from the name in the that the name is a short name shown in the drop-down.\nThe tooltip is only shown when the user hovers over the name and box appears providing more information\nabout the workspace. For example, the name of the model workspace is 'Model' and the tooltip is 'Model Workspace'.")


Workspace.tooltipDescription = property(Workspace._get_tooltipDescription, Workspace._set_tooltipDescription, doc="Gets or sets the tooltip description displayed for the workspace. The tooltip description is a longer\ndescription of the workspace and is only displayed when the user hovers over the workspace name in\nthe Fusion 360 toolbar drop-down. The pop-up dialog that appears contains the tooltip, the tooltip\ndescription, and the toolclip which is a picture.")


Workspace.toolbarTabs = property(Workspace._get_toolbarTabs, doc="Gets the collection containing the tabs associated with this workspace.")


Workspace.cast = lambda arg: arg if isinstance(arg, Workspace) else None

class WorkspaceEventHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notify(self, eventArgs: "WorkspaceEventArgs") -> "void":
        return _core.WorkspaceEventHandler_notify(self, eventArgs)

    def __init__(self):
        if self.__class__ == WorkspaceEventHandler:
            _self = None
        else:
            _self = self
        _core.WorkspaceEventHandler_swiginit(self, _core.new_WorkspaceEventHandler(_self, ))
    __swig_destroy__ = _core.delete_WorkspaceEventHandler
    def __disown__(self):
        self.this.disown()
        _core.disown_WorkspaceEventHandler(self)
        return weakref.proxy(self)

# Register WorkspaceEventHandler in _core:
_core.WorkspaceEventHandler_swigregister(WorkspaceEventHandler)


WorkspaceEventHandler.cast = lambda arg: arg if isinstance(arg, WorkspaceEventHandler) else None

class WorkspaceList(Base):
    r"""A WorkspaceList is a list of Workspaces - e.g. the Workspaces for a given product."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::WorkspaceList *":
        return _core.WorkspaceList___deref__(self)

    def __eq__(self, rhs: "WorkspaceList") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.WorkspaceList___eq__(self, rhs)


    def __ne__(self, rhs: "WorkspaceList") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.WorkspaceList___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.WorkspaceList___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::Workspace >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.WorkspaceList___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.WorkspaceList_classType()
    __swig_destroy__ = _core.delete_WorkspaceList

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::Workspace >":
        r"""
        Returns the specified work space using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.WorkspaceList_item(self, index)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::Workspace >":
        r"""
        Returns the Workspace of the specified ID. 
        id : The ID of the workspace to get. 
        Returns the specified workspace or null in the case where there isn't a workspace with the specified ID.
        """
        return _core.WorkspaceList_itemById(self, id)

    def _get_count(self) -> "size_t":
        r"""Gets the number of workspaces in the collection."""
        return _core.WorkspaceList__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _core.WorkspaceList__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.WorkspaceList__get_isValid(self)

# Register WorkspaceList in _core:
_core.WorkspaceList_swigregister(WorkspaceList)

def WorkspaceList_classType() -> "char const *":
    return _core.WorkspaceList_classType()


WorkspaceList.count = property(WorkspaceList._get_count, doc="Gets the number of workspaces in the collection.")


WorkspaceList.cast = lambda arg: arg if isinstance(arg, WorkspaceList) else None

class Workspaces(Base):
    r"""Provides access to all of the existing workspaces."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Workspaces *":
        return _core.Workspaces___deref__(self)

    def __eq__(self, rhs: "Workspaces") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Workspaces___eq__(self, rhs)


    def __ne__(self, rhs: "Workspaces") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Workspaces___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _core.Workspaces___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::Workspace >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _core.Workspaces___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _core.Workspaces_classType()
    __swig_destroy__ = _core.delete_Workspaces

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::Workspace >":
        r"""
        Returns the specified work space using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.Workspaces_item(self, index)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::core::Workspace >":
        r"""
        Returns the Workspace of the specified ID. 
        id : The ID of the workspace to get. 
        Returns the specified workspace or null in the case where there isn't a workspace with the specified ID.
        """
        return _core.Workspaces_itemById(self, id)

    def _get_count(self) -> "size_t":
        r"""Gets the number of workspaces in the collection."""
        return _core.Workspaces__get_count(self)

    def add(self, productType: "std::string const &", id: "std::string const &", name: "std::string const &", resourceFolder: "std::string const &") -> "adsk::core::Ptr< adsk::core::Workspace >":
        r"""
        Creates a new workspace for a specific product. 
        productType : The name of the product this workspace will be displayed with. You can obtain a list of the available
        products by using the supportedProductTypes property of the Application object. 
        id : The unique ID for this workspace. It must be unique with respect to all other workspaces. 
        name : The displayed name of this workspace. 
        resourceFolder : The resource folder should contain two files; 49X31.png and 98x62.png. The larger is used for the Apple Retina display. 
        Returns the created workspace or null if the creation failed.
        """
        return _core.Workspaces_add(self, productType, id, name, resourceFolder)

    def _get_objectType(self) -> "char const *":
        return _core.Workspaces__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Workspaces__get_isValid(self)

# Register Workspaces in _core:
_core.Workspaces_swigregister(Workspaces)

def Workspaces_classType() -> "char const *":
    return _core.Workspaces_classType()


Workspaces.count = property(Workspaces._get_count, doc="Gets the number of workspaces in the collection.")


Workspaces.cast = lambda arg: arg if isinstance(arg, Workspaces) else None

class ActiveSelectionEvent(Event):
    r"""
    This event fires whenever the contents of the active selection changes. This occurs as the user
    selects or unselects entities while using the Fusion 360 Select command. The Select command
    is the default command that is always running if no other command is active. Pressing Escape 
    terminates the currently active command and starts the Select command. If the Select command is
    running and you press Escape, it terminates the current Select command and starts a new one.
    This event is only associated with the selection associated with the Select command and does not
    fire when any other command is running. The event fires when there is any change to the active
    selection, including when the selection is cleared when the Select command is terminated. It is
    also fired when the user clicks in an open area of the canvas to clear the current selection.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ActiveSelectionEvent *":
        return _core.ActiveSelectionEvent___deref__(self)

    def __eq__(self, rhs: "ActiveSelectionEvent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ActiveSelectionEvent___eq__(self, rhs)


    def __ne__(self, rhs: "ActiveSelectionEvent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ActiveSelectionEvent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ActiveSelectionEvent_classType()
    __swig_destroy__ = _core.delete_ActiveSelectionEvent

    def add(self, handler: "ActiveSelectionEventHandler") -> "bool":
        r"""
        Add a handler to be notified when the event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _core.ActiveSelectionEvent_add(self, handler)

    def remove(self, handler: "ActiveSelectionEventHandler") -> "bool":
        r"""
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _core.ActiveSelectionEvent_remove(self, handler)

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _core.ActiveSelectionEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.ActiveSelectionEvent__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _core.ActiveSelectionEvent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ActiveSelectionEvent__get_isValid(self)

# Register ActiveSelectionEvent in _core:
_core.ActiveSelectionEvent_swigregister(ActiveSelectionEvent)

def ActiveSelectionEvent_classType() -> "char const *":
    return _core.ActiveSelectionEvent_classType()


ActiveSelectionEvent.cast = lambda arg: arg if isinstance(arg, ActiveSelectionEvent) else None

class ActiveSelectionEventArgs(EventArgs):
    r"""
    The ActiveSelectionEventArgs provides information associated with the active selection changing. 
    The event fires whenever the contents of the active selection changes. This occurs as the user
    selects or unselects entities while using the Fusion 360 Select command. The Select command
    is the default command that is always running if no other command is active. Pressing Escape 
    terminates the currently active command and starts the Select command. If the Select command is
    running and you press Escape, it terminates the current Select command and starts a new one.
    An array or list of all the currently selected entities is returned. This is the same set of
    entities accessed through the UserInterface.activeSelection object. An empty array can be returned
    in the case where the selection has been cleared which can occur by the user unselecting and entity,
    terminating the select command pressing Escape or running another command or clicking the mouse in
    an open area of the canvas.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ActiveSelectionEventArgs *":
        return _core.ActiveSelectionEventArgs___deref__(self)

    def __eq__(self, rhs: "ActiveSelectionEventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ActiveSelectionEventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "ActiveSelectionEventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ActiveSelectionEventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ActiveSelectionEventArgs_classType()
    __swig_destroy__ = _core.delete_ActiveSelectionEventArgs

    def _get_currentSelection(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection >,std::allocator< adsk::core::Ptr< adsk::core::Selection > > >":
        r"""
        The list of all of the current selections. This is the same set of selections accessed through
        the UserInterface.activeSelection object. An empty array can be returned
        in the case where the selection has been cleared which can occur by the user unselecting and entity,
        terminating the select command pressing Escape or running another command or clicking the mouse in
        an open area of the canvas.
        """
        return _core.ActiveSelectionEventArgs__get_currentSelection(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _core.ActiveSelectionEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _core.ActiveSelectionEventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ActiveSelectionEventArgs__get_isValid(self)

# Register ActiveSelectionEventArgs in _core:
_core.ActiveSelectionEventArgs_swigregister(ActiveSelectionEventArgs)

def ActiveSelectionEventArgs_classType() -> "char const *":
    return _core.ActiveSelectionEventArgs_classType()


ActiveSelectionEventArgs.currentSelection = property(ActiveSelectionEventArgs._get_currentSelection, doc="The list of all of the current selections. This is the same set of selections accessed through\nthe UserInterface.activeSelection object. An empty array can be returned\nin the case where the selection has been cleared which can occur by the user unselecting and entity,\nterminating the select command pressing Escape or running another command or clicking the mouse in\nan open area of the canvas.")


ActiveSelectionEventArgs.cast = lambda arg: arg if isinstance(arg, ActiveSelectionEventArgs) else None

class AngleValueCommandInput(CommandInput):
    r"""
    Represents a command input that gets an angle from the user. This displays
    an entry in the command dialog where the user can enter a value and also displays
    a manipulator in the graphics window to allow them to graphically set the value.
    The input box is displayed in the dialog when the isVisible property of the command
    input is true. The manipulator is displayed in the graphics when both the isVisible
    and isEnabled properties are true.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::AngleValueCommandInput *":
        return _core.AngleValueCommandInput___deref__(self)

    def __eq__(self, rhs: "AngleValueCommandInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.AngleValueCommandInput___eq__(self, rhs)


    def __ne__(self, rhs: "AngleValueCommandInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.AngleValueCommandInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.AngleValueCommandInput_classType()
    __swig_destroy__ = _core.delete_AngleValueCommandInput

    def _get_value(self) -> "double":
        r"""
        Gets and sets the current value of the command input. The value is in radians
        but will be displayed to the user in degrees. Setting this value can fail if the input value is 
        not within the minimum and maximum value range.
        The isValidExpression property should be checked before using the value within the command 
        because if the expression can't be evaluated there isn't a valid value. Fusion 360 won't allow 
        the execution of a command that contains ValueCommandInput object with invalid expressions 
        so you can dependably use the value in the execute event of the command.
        """
        return _core.AngleValueCommandInput__get_value(self)

    def _set_value(self, value: "double") -> "bool":
        r"""
        Gets and sets the current value of the command input. The value is in radians
        but will be displayed to the user in degrees. Setting this value can fail if the input value is 
        not within the minimum and maximum value range.
        The isValidExpression property should be checked before using the value within the command 
        because if the expression can't be evaluated there isn't a valid value. Fusion 360 won't allow 
        the execution of a command that contains ValueCommandInput object with invalid expressions 
        so you can dependably use the value in the execute event of the command.
        """
        return _core.AngleValueCommandInput__set_value(self, value)

    def _get_expression(self) -> "std::string":
        r"""
        Gets or sets the expression displayed in the input field. This can contain equations and
        references to parameters but must result in a valid angle expression. If units are not
        specified as part of the expression, the default user units of degrees are used.
        """
        return _core.AngleValueCommandInput__get_expression(self)

    def _set_expression(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the expression displayed in the input field. This can contain equations and
        references to parameters but must result in a valid angle expression. If units are not
        specified as part of the expression, the default user units of degrees are used.
        """
        return _core.AngleValueCommandInput__set_expression(self, value)

    def _get_minimumValue(self) -> "double":
        r"""
        Gets and sets minimum value, if any, that the value can be. The value is in radians. When getting this
        property you should first check the hasMinimumValue property to see if this property
        applies. Also, the isMinimumValueInclusive indicates if the minimum includes this
        value or will be up to this value.
        Setting this value will change the isMinimumValueInclusive to True and the hasMinimumValue 
        property to True if hasMinimumValue is currently False, otherwise it will just update the value.
        """
        return _core.AngleValueCommandInput__get_minimumValue(self)

    def _set_minimumValue(self, value: "double") -> "bool":
        r"""
        Gets and sets minimum value, if any, that the value can be. The value is in radians. When getting this
        property you should first check the hasMinimumValue property to see if this property
        applies. Also, the isMinimumValueInclusive indicates if the minimum includes this
        value or will be up to this value.
        Setting this value will change the isMinimumValueInclusive to True and the hasMinimumValue 
        property to True if hasMinimumValue is currently False, otherwise it will just update the value.
        """
        return _core.AngleValueCommandInput__set_minimumValue(self, value)

    def _get_hasMinimumValue(self) -> "bool":
        r"""
        Gets and sets if there is a minimum value for this command input. When setting this property, it is only valid
        to set it to False to remove the minimum value. Setting the minimumValue property will result in this property
        being set to True.
        """
        return _core.AngleValueCommandInput__get_hasMinimumValue(self)

    def _set_hasMinimumValue(self, value: "bool") -> "bool":
        r"""
        Gets and sets if there is a minimum value for this command input. When setting this property, it is only valid
        to set it to False to remove the minimum value. Setting the minimumValue property will result in this property
        being set to True.
        """
        return _core.AngleValueCommandInput__set_hasMinimumValue(self, value)

    def _get_isMinimumValueInclusive(self) -> "bool":
        r"""
        Gets and sets if the value of the input includes the minimum value or is up to the minimum value. For example,
        if the minimum value is zero and this property is True, the minimum value can be zero. If this is False, the 
        minimum value must be greater than zero. When the minimum value is first defined using the minimumValue property,
        this property is set to True. The value returned by this property is only meaningful when the hasMinimumValue property
        returns True.
        """
        return _core.AngleValueCommandInput__get_isMinimumValueInclusive(self)

    def _set_isMinimumValueInclusive(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the value of the input includes the minimum value or is up to the minimum value. For example,
        if the minimum value is zero and this property is True, the minimum value can be zero. If this is False, the 
        minimum value must be greater than zero. When the minimum value is first defined using the minimumValue property,
        this property is set to True. The value returned by this property is only meaningful when the hasMinimumValue property
        returns True.
        """
        return _core.AngleValueCommandInput__set_isMinimumValueInclusive(self, value)

    def _get_maximumValue(self) -> "double":
        r"""
        Gets and sets maximum value, if any, that the value can be. The value is in radians. When getting this
        property you should first check the hasMaximumValue property to see if this property applies. Also, the
        isMaximumValueInclusive indicates if the minimum includes this value or will be up to this value.
        Setting this value will change the isMaximumValueInclusive to True and the hasMaximumValue 
        property to True if hasMaximumValue is currently False, otherwise it will just update the value.
        """
        return _core.AngleValueCommandInput__get_maximumValue(self)

    def _set_maximumValue(self, value: "double") -> "bool":
        r"""
        Gets and sets maximum value, if any, that the value can be. The value is in radians. When getting this
        property you should first check the hasMaximumValue property to see if this property applies. Also, the
        isMaximumValueInclusive indicates if the minimum includes this value or will be up to this value.
        Setting this value will change the isMaximumValueInclusive to True and the hasMaximumValue 
        property to True if hasMaximumValue is currently False, otherwise it will just update the value.
        """
        return _core.AngleValueCommandInput__set_maximumValue(self, value)

    def _get_hasMaximumValue(self) -> "bool":
        r"""
        Gets and sets if there is a maximum value for this command input. When setting this property, it is only valid
        to set it to False to remove the maximum value. Setting the maximumValue property will result in this property
        being set to True.
        """
        return _core.AngleValueCommandInput__get_hasMaximumValue(self)

    def _set_hasMaximumValue(self, value: "bool") -> "bool":
        r"""
        Gets and sets if there is a maximum value for this command input. When setting this property, it is only valid
        to set it to False to remove the maximum value. Setting the maximumValue property will result in this property
        being set to True.
        """
        return _core.AngleValueCommandInput__set_hasMaximumValue(self, value)

    def _get_isMaximumValueInclusive(self) -> "bool":
        r"""
        Gets and sets if the value of the input includes the maximum value or is up to the maximum value. For example,
        if the maximum value is the value of pi (180 degrees) and this property is True, the maximum value can be pi. 
        If this is False, the minimum value must be less than pi. When the maximum value is first defined using the 
        maximumValue property, this property is set to True. The value returned by this property is only meaninful 
        when the hasMaximumValue property returns True.
        """
        return _core.AngleValueCommandInput__get_isMaximumValueInclusive(self)

    def _set_isMaximumValueInclusive(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the value of the input includes the maximum value or is up to the maximum value. For example,
        if the maximum value is the value of pi (180 degrees) and this property is True, the maximum value can be pi. 
        If this is False, the minimum value must be less than pi. When the maximum value is first defined using the 
        maximumValue property, this property is set to True. The value returned by this property is only meaninful 
        when the hasMaximumValue property returns True.
        """
        return _core.AngleValueCommandInput__set_isMaximumValueInclusive(self, value)

    def setManipulator(self, origin: "Point3D", xDirection: "Vector3D", yDirection: "Vector3D") -> "bool":
        r"""
        Defines the position and orientation of the manipulator. The manipulator is only visible
        when both the isVisible and isEnabled properties are true. If those properties are
        true and the setManipulator has not been called, the manipulator will be displayed in
        a default location (0,0,0) using default directions; x direction (1,0,0) and y direction (0,1,0). 
        Because of that the input is typically set to be invisible and/or disabled and then enabled once 
        enough input has been specified that you can display the manipulator in the desired location. 
        origin : Defines the center position of the manipulator in root component space. 
        xDirection : Defines the X direction of the manipulator in root component space. The X direction is the 0 angle direction. This
        direction, along with the Y direction vector define the plane that the manipulator is displayed on. 
        yDirection : Defines the Y direction of the manipulator in root component space. The X and Y direction vectors define the plane
        the manipulator is displayed one. When the manipulator is rotated from the xDirection vector towards the yDirection
        vector that is the positive direction. 
        Returns true if successful.
        """
        return _core.AngleValueCommandInput_setManipulator(self, origin, xDirection, yDirection)

    def _get_manipulatorOrigin(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""
        Gets the origin point of the manipulator in the model space of the root component.
        To set the origin use the setManipulator method.
        """
        return _core.AngleValueCommandInput__get_manipulatorOrigin(self)

    def _get_manipulatorXDirection(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Gets the X direction of the manipulator in the model space of the root component. The X direction is
        the 0 angle direction. This direction, along with the Y direction vector define the plane that the 
        manipulator is displayed on.
        To set the direction use the setManipulator method.
        """
        return _core.AngleValueCommandInput__get_manipulatorXDirection(self)

    def _get_manipulatorYDirection(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Gets the Y direction of the manipulator in the model space of the root component. The X and Y direction 
        vectors define the plane that the manipulator is displayed on.
        To set the direction use the setManipulator method.
        """
        return _core.AngleValueCommandInput__get_manipulatorYDirection(self)

    def _get_isValidExpression(self) -> "bool":
        r"""
        Returns true if the current expression is valid and can be evaluated. If this
        is false, the value returned should be ignored because there currently is
        not a valid value.
        """
        return _core.AngleValueCommandInput__get_isValidExpression(self)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.AngleValueCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string":
        r"""Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.AngleValueCommandInput__get_id(self)

    def _get_name(self) -> "std::string":
        r"""Gets the user visible name of this input."""
        return _core.AngleValueCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.AngleValueCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.AngleValueCommandInput__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.AngleValueCommandInput__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.AngleValueCommandInput__set_isVisible(self, value)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the parent Command."""
        return _core.AngleValueCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.AngleValueCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.AngleValueCommandInput__set_isFullWidth(self, value)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.AngleValueCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.AngleValueCommandInput__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.AngleValueCommandInput__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.AngleValueCommandInput__set_tooltip(self, value)

    def _get_tooltipDescription(self) -> "std::string":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.AngleValueCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.AngleValueCommandInput__set_tooltipDescription(self, value)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.AngleValueCommandInput__get_parentCommandInput(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this Command input. 
        Returns true if the delete was successful.
        """
        return _core.AngleValueCommandInput_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.AngleValueCommandInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.AngleValueCommandInput__get_isValid(self)

# Register AngleValueCommandInput in _core:
_core.AngleValueCommandInput_swigregister(AngleValueCommandInput)

def AngleValueCommandInput_classType() -> "char const *":
    return _core.AngleValueCommandInput_classType()


AngleValueCommandInput.value = property(AngleValueCommandInput._get_value, AngleValueCommandInput._set_value, doc="Gets and sets the current value of the command input. The value is in radians\nbut will be displayed to the user in degrees. Setting this value can fail if the input value is\nnot within the minimum and maximum value range.\nThe isValidExpression property should be checked before using the value within the command\nbecause if the expression can't be evaluated there isn't a valid value. Fusion 360 won't allow\nthe execution of a command that contains ValueCommandInput object with invalid expressions\nso you can dependably use the value in the execute event of the command.")


AngleValueCommandInput.expression = property(AngleValueCommandInput._get_expression, AngleValueCommandInput._set_expression, doc="Gets or sets the expression displayed in the input field. This can contain equations and\nreferences to parameters but must result in a valid angle expression. If units are not\nspecified as part of the expression, the default user units of degrees are used.")


AngleValueCommandInput.minimumValue = property(AngleValueCommandInput._get_minimumValue, AngleValueCommandInput._set_minimumValue, doc="Gets and sets minimum value, if any, that the value can be. The value is in radians. When getting this\nproperty you should first check the hasMinimumValue property to see if this property\napplies. Also, the isMinimumValueInclusive indicates if the minimum includes this\nvalue or will be up to this value.\nSetting this value will change the isMinimumValueInclusive to True and the hasMinimumValue\nproperty to True if hasMinimumValue is currently False, otherwise it will just update the value.")


AngleValueCommandInput.hasMinimumValue = property(AngleValueCommandInput._get_hasMinimumValue, AngleValueCommandInput._set_hasMinimumValue, doc="Gets and sets if there is a minimum value for this command input. When setting this property, it is only valid\nto set it to False to remove the minimum value. Setting the minimumValue property will result in this property\nbeing set to True.")


AngleValueCommandInput.isMinimumValueInclusive = property(AngleValueCommandInput._get_isMinimumValueInclusive, AngleValueCommandInput._set_isMinimumValueInclusive, doc="Gets and sets if the value of the input includes the minimum value or is up to the minimum value. For example,\nif the minimum value is zero and this property is True, the minimum value can be zero. If this is False, the\nminimum value must be greater than zero. When the minimum value is first defined using the minimumValue property,\nthis property is set to True. The value returned by this property is only meaningful when the hasMinimumValue property\nreturns True.")


AngleValueCommandInput.maximumValue = property(AngleValueCommandInput._get_maximumValue, AngleValueCommandInput._set_maximumValue, doc="Gets and sets maximum value, if any, that the value can be. The value is in radians. When getting this\nproperty you should first check the hasMaximumValue property to see if this property applies. Also, the\nisMaximumValueInclusive indicates if the minimum includes this value or will be up to this value.\nSetting this value will change the isMaximumValueInclusive to True and the hasMaximumValue\nproperty to True if hasMaximumValue is currently False, otherwise it will just update the value.")


AngleValueCommandInput.hasMaximumValue = property(AngleValueCommandInput._get_hasMaximumValue, AngleValueCommandInput._set_hasMaximumValue, doc="Gets and sets if there is a maximum value for this command input. When setting this property, it is only valid\nto set it to False to remove the maximum value. Setting the maximumValue property will result in this property\nbeing set to True.")


AngleValueCommandInput.isMaximumValueInclusive = property(AngleValueCommandInput._get_isMaximumValueInclusive, AngleValueCommandInput._set_isMaximumValueInclusive, doc="Gets and sets if the value of the input includes the maximum value or is up to the maximum value. For example,\nif the maximum value is the value of pi (180 degrees) and this property is True, the maximum value can be pi.\nIf this is False, the minimum value must be less than pi. When the maximum value is first defined using the\nmaximumValue property, this property is set to True. The value returned by this property is only meaninful\nwhen the hasMaximumValue property returns True.")


AngleValueCommandInput.manipulatorOrigin = property(AngleValueCommandInput._get_manipulatorOrigin, doc="Gets the origin point of the manipulator in the model space of the root component.\nTo set the origin use the setManipulator method.")


AngleValueCommandInput.manipulatorXDirection = property(AngleValueCommandInput._get_manipulatorXDirection, doc="Gets the X direction of the manipulator in the model space of the root component. The X direction is\nthe 0 angle direction. This direction, along with the Y direction vector define the plane that the\nmanipulator is displayed on.\nTo set the direction use the setManipulator method.")


AngleValueCommandInput.manipulatorYDirection = property(AngleValueCommandInput._get_manipulatorYDirection, doc="Gets the Y direction of the manipulator in the model space of the root component. The X and Y direction\nvectors define the plane that the manipulator is displayed on.\nTo set the direction use the setManipulator method.")


AngleValueCommandInput.isValidExpression = property(AngleValueCommandInput._get_isValidExpression, doc="Returns true if the current expression is valid and can be evaluated. If this\nis false, the value returned should be ignored because there currently is\nnot a valid value.")


AngleValueCommandInput.cast = lambda arg: arg if isinstance(arg, AngleValueCommandInput) else None

class AppearanceTextureProperty(Property):
    r"""A texture value property associated with a material or appearance."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::AppearanceTextureProperty *":
        return _core.AppearanceTextureProperty___deref__(self)

    def __eq__(self, rhs: "AppearanceTextureProperty") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.AppearanceTextureProperty___eq__(self, rhs)


    def __ne__(self, rhs: "AppearanceTextureProperty") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.AppearanceTextureProperty___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.AppearanceTextureProperty_classType()
    __swig_destroy__ = _core.delete_AppearanceTextureProperty

    def _get_value(self) -> "adsk::core::Ptr< adsk::core::AppearanceTexture >":
        r"""Gets and sets this property value."""
        return _core.AppearanceTextureProperty__get_value(self)

    def _set_value(self, value: "AppearanceTexture") -> "bool":
        r"""Gets and sets this property value."""
        return _core.AppearanceTextureProperty__set_value(self, value)

    def _get_isUsed(self) -> "bool":
        r"""
        Specifies if this AppearanceTexture is being used. This is the equivalent of the 
        check box in the Appearance dialog to enable the use of a text for an appearance or not.
        if this is False, then the value property should not be used because there isn't an associated.
        AppearanceTexture.
        """
        return _core.AppearanceTextureProperty__get_isUsed(self)

    def _get_name(self) -> "std::string":
        r"""
        Returns the name of this property as seen in the user interface. This name is localized
        and can change based on the current language
        """
        return _core.AppearanceTextureProperty__get_name(self)

    def _get_isReadOnly(self) -> "bool":
        r"""Indicates if this property is read-only. If True any attempted edits will fail."""
        return _core.AppearanceTextureProperty__get_isReadOnly(self)

    def _get_id(self) -> "std::string":
        r"""Returns the unique ID of this property."""
        return _core.AppearanceTextureProperty__get_id(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the parent of this property."""
        return _core.AppearanceTextureProperty__get_parent(self)

    def _get_objectType(self) -> "char const *":
        return _core.AppearanceTextureProperty__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.AppearanceTextureProperty__get_isValid(self)

# Register AppearanceTextureProperty in _core:
_core.AppearanceTextureProperty_swigregister(AppearanceTextureProperty)

def AppearanceTextureProperty_classType() -> "char const *":
    return _core.AppearanceTextureProperty_classType()


AppearanceTextureProperty.value = property(AppearanceTextureProperty._get_value, AppearanceTextureProperty._set_value, doc="Gets and sets this property value.")


AppearanceTextureProperty.isUsed = property(AppearanceTextureProperty._get_isUsed, doc="Specifies if this AppearanceTexture is being used. This is the equivalent of the\ncheck box in the Appearance dialog to enable the use of a text for an appearance or not.\nif this is False, then the value property should not be used because there isn't an associated.\nAppearanceTexture.")


AppearanceTextureProperty.cast = lambda arg: arg if isinstance(arg, AppearanceTextureProperty) else None

class ApplicationCommandEvent(Event):
    r"""An event endpoint that supports the connection to ApplicationCommandEventHandlers."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ApplicationCommandEvent *":
        return _core.ApplicationCommandEvent___deref__(self)

    def __eq__(self, rhs: "ApplicationCommandEvent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ApplicationCommandEvent___eq__(self, rhs)


    def __ne__(self, rhs: "ApplicationCommandEvent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ApplicationCommandEvent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ApplicationCommandEvent_classType()
    __swig_destroy__ = _core.delete_ApplicationCommandEvent

    def add(self, handler: "ApplicationCommandEventHandler") -> "bool":
        r"""
        Adds an event handler object to this event endpoint. 
        handler : The ApplicationCommandEventHandler to be called when this event is triggered. 
        Returns true if the handler was successfully added to the set of event handlers.
        """
        return _core.ApplicationCommandEvent_add(self, handler)

    def remove(self, handler: "ApplicationCommandEventHandler") -> "bool":
        r"""
        Removes a handler from this event endpoint. 
        handler : An ApplicationCommandEventHandler that was previously added to this event with the add method. 
        Returns true if the handler was found and removed from the set of event handlers.
        """
        return _core.ApplicationCommandEvent_remove(self, handler)

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _core.ApplicationCommandEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.ApplicationCommandEvent__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _core.ApplicationCommandEvent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ApplicationCommandEvent__get_isValid(self)

# Register ApplicationCommandEvent in _core:
_core.ApplicationCommandEvent_swigregister(ApplicationCommandEvent)

def ApplicationCommandEvent_classType() -> "char const *":
    return _core.ApplicationCommandEvent_classType()


ApplicationCommandEvent.cast = lambda arg: arg if isinstance(arg, ApplicationCommandEvent) else None

class ApplicationCommandEventArgs(EventArgs):
    r"""
    Provides a set of arguments from a firing ApplicationCommandEvent to an ApplicationCommandEventHandler's 
    notify callback method.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ApplicationCommandEventArgs *":
        return _core.ApplicationCommandEventArgs___deref__(self)

    def __eq__(self, rhs: "ApplicationCommandEventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ApplicationCommandEventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "ApplicationCommandEventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ApplicationCommandEventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ApplicationCommandEventArgs_classType()
    __swig_destroy__ = _core.delete_ApplicationCommandEventArgs

    def _get_commandDefinition(self) -> "adsk::core::Ptr< adsk::core::CommandDefinition >":
        r"""Returns the CommandDefinition object for the command the event is being fired for."""
        return _core.ApplicationCommandEventArgs__get_commandDefinition(self)

    def _get_commandId(self) -> "std::string":
        r"""Returns the unique id of the command the event if being fired for."""
        return _core.ApplicationCommandEventArgs__get_commandId(self)

    def _get_isCanceled(self) -> "bool":
        r"""
        Used during the commandStarting event to get or set if the command should
        be allowed to continue executing or be canceled. This defaults to false,
        which will allow the command to execute. Setting this to true will cancel
        the command and not begin the execution.
        This property should be ignored for all events besides the commandStarting event.
        """
        return _core.ApplicationCommandEventArgs__get_isCanceled(self)

    def _set_isCanceled(self, value: "bool") -> "bool":
        r"""
        Used during the commandStarting event to get or set if the command should
        be allowed to continue executing or be canceled. This defaults to false,
        which will allow the command to execute. Setting this to true will cancel
        the command and not begin the execution.
        This property should be ignored for all events besides the commandStarting event.
        """
        return _core.ApplicationCommandEventArgs__set_isCanceled(self, value)

    def _get_terminationReason(self) -> "adsk::core::CommandTerminationReason":
        r"""
        Returns the reason the command is being terminated.
        This property should be ignored for all events besides the commandTerminated event.
        """
        return _core.ApplicationCommandEventArgs__get_terminationReason(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _core.ApplicationCommandEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _core.ApplicationCommandEventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ApplicationCommandEventArgs__get_isValid(self)

# Register ApplicationCommandEventArgs in _core:
_core.ApplicationCommandEventArgs_swigregister(ApplicationCommandEventArgs)

def ApplicationCommandEventArgs_classType() -> "char const *":
    return _core.ApplicationCommandEventArgs_classType()


ApplicationCommandEventArgs.commandDefinition = property(ApplicationCommandEventArgs._get_commandDefinition, doc="Returns the CommandDefinition object for the command the event is being fired for.")


ApplicationCommandEventArgs.commandId = property(ApplicationCommandEventArgs._get_commandId, doc="Returns the unique id of the command the event if being fired for.")


ApplicationCommandEventArgs.isCanceled = property(ApplicationCommandEventArgs._get_isCanceled, ApplicationCommandEventArgs._set_isCanceled, doc="Used during the commandStarting event to get or set if the command should\nbe allowed to continue executing or be canceled. This defaults to false,\nwhich will allow the command to execute. Setting this to true will cancel\nthe command and not begin the execution.\nThis property should be ignored for all events besides the commandStarting event.")


ApplicationCommandEventArgs.terminationReason = property(ApplicationCommandEventArgs._get_terminationReason, doc="Returns the reason the command is being terminated.\nThis property should be ignored for all events besides the commandTerminated event.")


ApplicationCommandEventArgs.cast = lambda arg: arg if isinstance(arg, ApplicationCommandEventArgs) else None

class ApplicationEvent(Event):
    r"""An ApplicationEvent represents a Fusion 360 application related event. For example, startupCompleted or OnlineStatusChanged"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ApplicationEvent *":
        return _core.ApplicationEvent___deref__(self)

    def __eq__(self, rhs: "ApplicationEvent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ApplicationEvent___eq__(self, rhs)


    def __ne__(self, rhs: "ApplicationEvent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ApplicationEvent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ApplicationEvent_classType()
    __swig_destroy__ = _core.delete_ApplicationEvent

    def add(self, handler: "ApplicationEventHandler") -> "bool":
        r"""
        Add a handler to be notified when the event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _core.ApplicationEvent_add(self, handler)

    def remove(self, handler: "ApplicationEventHandler") -> "bool":
        r"""
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _core.ApplicationEvent_remove(self, handler)

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _core.ApplicationEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.ApplicationEvent__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _core.ApplicationEvent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ApplicationEvent__get_isValid(self)

# Register ApplicationEvent in _core:
_core.ApplicationEvent_swigregister(ApplicationEvent)

def ApplicationEvent_classType() -> "char const *":
    return _core.ApplicationEvent_classType()


ApplicationEvent.cast = lambda arg: arg if isinstance(arg, ApplicationEvent) else None

class ApplicationEventArgs(EventArgs):
    r"""
    The ApplicationEventArgs provides information associated with an application event. 
    Note that some properties are not available on every event
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ApplicationEventArgs *":
        return _core.ApplicationEventArgs___deref__(self)

    def __eq__(self, rhs: "ApplicationEventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ApplicationEventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "ApplicationEventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ApplicationEventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ApplicationEventArgs_classType()
    __swig_destroy__ = _core.delete_ApplicationEventArgs

    def _get_isOffLine(self) -> "bool":
        r"""Gets and sets if Fusion 360 is offline or not."""
        return _core.ApplicationEventArgs__get_isOffLine(self)

    def _set_isOffLine(self, value: "bool") -> "bool":
        r"""Gets and sets if Fusion 360 is offline or not."""
        return _core.ApplicationEventArgs__set_isOffLine(self, value)

    def _get_hasInternetAccess(self) -> "bool":
        r"""Gets if the client computer has access to the internet."""
        return _core.ApplicationEventArgs__get_hasInternetAccess(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _core.ApplicationEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _core.ApplicationEventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ApplicationEventArgs__get_isValid(self)

# Register ApplicationEventArgs in _core:
_core.ApplicationEventArgs_swigregister(ApplicationEventArgs)

def ApplicationEventArgs_classType() -> "char const *":
    return _core.ApplicationEventArgs_classType()


ApplicationEventArgs.isOffLine = property(ApplicationEventArgs._get_isOffLine, ApplicationEventArgs._set_isOffLine, doc="Gets and sets if Fusion 360 is offline or not.")


ApplicationEventArgs.hasInternetAccess = property(ApplicationEventArgs._get_hasInternetAccess, doc="Gets if the client computer has access to the internet.")


ApplicationEventArgs.cast = lambda arg: arg if isinstance(arg, ApplicationEventArgs) else None

class Arc2D(Curve2D):
    r"""
    Transient 2D arc. A transient arc is not displayed or saved in a document. 
    Transient arcs are used as a wrapper to work with raw 2D arc information. They
    are created statically using one of the create methods supported by the Arc2D class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Arc2D *":
        return _core.Arc2D___deref__(self)

    def __eq__(self, rhs: "Arc2D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Arc2D___eq__(self, rhs)


    def __ne__(self, rhs: "Arc2D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Arc2D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Arc2D_classType()

    @staticmethod
    def createByCenter(center: "Point2D", radius: "double", startAngle: "double", endAngle: "double", isClockwise: "bool"=False) -> "adsk::core::Ptr< adsk::core::Point2D > const &":
        return _core.Arc2D_createByCenter(center, radius, startAngle, endAngle, isClockwise)

    @staticmethod
    def createByThreePoints(startPoint: "Point2D", point: "Point2D", endPoint: "Point2D") -> "adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Point2D > const &":
        return _core.Arc2D_createByThreePoints(startPoint, point, endPoint)
    __swig_destroy__ = _core.delete_Arc2D

    def _get_center(self) -> "adsk::core::Ptr< adsk::core::Point2D >":
        r"""Gets and sets the center position of the arc."""
        return _core.Arc2D__get_center(self)

    def _set_center(self, value: "Point2D") -> "bool":
        r"""Gets and sets the center position of the arc."""
        return _core.Arc2D__set_center(self, value)

    def _get_radius(self) -> "double":
        r"""Gets and sets the radius of the arc."""
        return _core.Arc2D__get_radius(self)

    def _set_radius(self, value: "double") -> "bool":
        r"""Gets and sets the radius of the arc."""
        return _core.Arc2D__set_radius(self, value)

    def _get_startAngle(self) -> "double":
        r"""Gets and sets the start angle of the arc in radians, where 0 is along the x axis."""
        return _core.Arc2D__get_startAngle(self)

    def _set_startAngle(self, value: "double") -> "bool":
        r"""Gets and sets the start angle of the arc in radians, where 0 is along the x axis."""
        return _core.Arc2D__set_startAngle(self, value)

    def _get_endAngle(self) -> "double":
        r"""Gets and sets the end angle of the arc in radians, where 0 is along the x axis."""
        return _core.Arc2D__get_endAngle(self)

    def _set_endAngle(self, value: "double") -> "bool":
        r"""Gets and sets the end angle of the arc in radians, where 0 is along the x axis."""
        return _core.Arc2D__set_endAngle(self, value)

    def _get_isClockwise(self) -> "bool":
        r"""Specifies if the sweep direction of the arc is clockwise or counterclockwise."""
        return _core.Arc2D__get_isClockwise(self)

    def _get_startPoint(self) -> "adsk::core::Ptr< adsk::core::Point2D >":
        r"""Gets the position of the start point of the arc."""
        return _core.Arc2D__get_startPoint(self)

    def _get_endPoint(self) -> "adsk::core::Ptr< adsk::core::Point2D >":
        r"""Gets the position of the end point of the arc."""
        return _core.Arc2D__get_endPoint(self)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Arc2D >":
        r"""
        Creates and returns an independent copy of this Arc2D object. 
        Returns a new Arc2D object that is a copy of this Arc2D object.
        """
        return _core.Arc2D_copy(self)

    def getData(self) -> "bool":
        r"""
        Gets all of the data defining the arc. 
        center : The output center point of the arc. 
        radius : The output radius of the arc. 
        startAngle : The output start angle of the arc in radians, where 0 is along the x axis. 
        endAngle : The output end angle of the arc in radians, where 0 is along the x axis. 
        isClockwise : The output value that indicates if the sweep direction is clockwise or counterclockwise. 
        Returns true if successful
        """
        return _core.Arc2D_getData(self)

    def set(self, center: "Point2D", radius: "double", startAngle: "double", endAngle: "double", isClockwise: "bool") -> "bool":
        r"""
        Sets all of the data defining the arc. 
        center : A Point2D object defining the center position of the arc. 
        radius : The radius of the arc. 
        startAngle : The start angle of the arc in radians, where 0 is along the x axis. 
        endAngle : The end angle of the arc in radians, where 0 is along the x axis. 
        isClockwise : Indicates if the sweep direction is clockwise or counterclockwise. 
        Returns true if redefining the arc is successful
        """
        return _core.Arc2D_set(self, center, radius, startAngle, endAngle, isClockwise)

    def _get_asNurbsCurve(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve2D >":
        r"""Returns a NURBS curve that is geometrically identical to the arc."""
        return _core.Arc2D__get_asNurbsCurve(self)

    def _get_curveType(self) -> "adsk::core::Curve2DTypes":
        r"""Returns the type of geometry this curve represents."""
        return _core.Arc2D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator2D >":
        r"""Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.Arc2D__get_evaluator(self)

    def transformBy(self, matrix: "Matrix2D") -> "bool":
        r"""
        Transforms this curve in 2D space. 
        matrix : A 2D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.Arc2D_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.Arc2D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Arc2D__get_isValid(self)

# Register Arc2D in _core:
_core.Arc2D_swigregister(Arc2D)

def Arc2D_classType() -> "char const *":
    return _core.Arc2D_classType()

def Arc2D_createByCenter(center: "Point2D", radius: "double", startAngle: "double", endAngle: "double", isClockwise: "bool"=False) -> "adsk::core::Ptr< adsk::core::Point2D > const &":
    return _core.Arc2D_createByCenter(center, radius, startAngle, endAngle, isClockwise)

def Arc2D_createByThreePoints(startPoint: "Point2D", point: "Point2D", endPoint: "Point2D") -> "adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Point2D > const &":
    return _core.Arc2D_createByThreePoints(startPoint, point, endPoint)


Arc2D.center = property(Arc2D._get_center, Arc2D._set_center, doc="Gets and sets the center position of the arc.")


Arc2D.radius = property(Arc2D._get_radius, Arc2D._set_radius, doc="Gets and sets the radius of the arc.")


Arc2D.startAngle = property(Arc2D._get_startAngle, Arc2D._set_startAngle, doc="Gets and sets the start angle of the arc in radians, where 0 is along the x axis.")


Arc2D.endAngle = property(Arc2D._get_endAngle, Arc2D._set_endAngle, doc="Gets and sets the end angle of the arc in radians, where 0 is along the x axis.")


Arc2D.isClockwise = property(Arc2D._get_isClockwise, doc="Specifies if the sweep direction of the arc is clockwise or counterclockwise.")


Arc2D.startPoint = property(Arc2D._get_startPoint, doc="Gets the position of the start point of the arc.")


Arc2D.endPoint = property(Arc2D._get_endPoint, doc="Gets the position of the end point of the arc.")


Arc2D.asNurbsCurve = property(Arc2D._get_asNurbsCurve, doc="Returns a NURBS curve that is geometrically identical to the arc.")


Arc2D.cast = lambda arg: arg if isinstance(arg, Arc2D) else None

class Arc3D(Curve3D):
    r"""
    Transient 3D arc. A transient arc is not displayed or saved in a document.
    Transient 3D arcs are used as a wrapper to work with raw 3D arc information.
    They are created statically using one of the create methods of the Arc3D class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Arc3D *":
        return _core.Arc3D___deref__(self)

    def __eq__(self, rhs: "Arc3D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Arc3D___eq__(self, rhs)


    def __ne__(self, rhs: "Arc3D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Arc3D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Arc3D_classType()

    @staticmethod
    def createByCenter(center: "Point3D", normal: "Vector3D", referenceVector: "Vector3D", radius: "double", startAngle: "double", endAngle: "double") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
        return _core.Arc3D_createByCenter(center, normal, referenceVector, radius, startAngle, endAngle)

    @staticmethod
    def createByThreePoints(pointOne: "Point3D", pointTwo: "Point3D", pointThree: "Point3D") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Point3D > const &":
        return _core.Arc3D_createByThreePoints(pointOne, pointTwo, pointThree)
    __swig_destroy__ = _core.delete_Arc3D

    def _get_center(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets the center position of the arc."""
        return _core.Arc3D__get_center(self)

    def _set_center(self, value: "Point3D") -> "bool":
        r"""Gets and sets the center position of the arc."""
        return _core.Arc3D__set_center(self, value)

    def _get_normal(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Gets and sets the normal of the arc."""
        return _core.Arc3D__get_normal(self)

    def _get_referenceVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Gets and sets the reference vector of the arc."""
        return _core.Arc3D__get_referenceVector(self)

    def setAxes(self, normal: "Vector3D", referenceVector: "Vector3D") -> "bool":
        r"""
        Sets the normal and reference vectors of the arc. 
        normal : The new normal vector. 
        referenceVector : The new reference vector from which the start and end angles are measured from.
        The reference vector must be perpendicular to the normal vector. 
        Returns true if successful
        """
        return _core.Arc3D_setAxes(self, normal, referenceVector)

    def _get_radius(self) -> "double":
        r"""Gets and sets the radius of the arc."""
        return _core.Arc3D__get_radius(self)

    def _set_radius(self, value: "double") -> "bool":
        r"""Gets and sets the radius of the arc."""
        return _core.Arc3D__set_radius(self, value)

    def _get_startAngle(self) -> "double":
        r"""
        Gets and sets the start angle of the arc in radians.
        This angle is measured from the reference vector using the right hand rule around the normal vector.
        """
        return _core.Arc3D__get_startAngle(self)

    def _set_startAngle(self, value: "double") -> "bool":
        r"""
        Gets and sets the start angle of the arc in radians.
        This angle is measured from the reference vector using the right hand rule around the normal vector.
        """
        return _core.Arc3D__set_startAngle(self, value)

    def _get_endAngle(self) -> "double":
        r"""
        Gets and sets the end angle of the arc in radians.
        This angle is measured from the reference vector using the right hand rule around the normal vector.
        """
        return _core.Arc3D__get_endAngle(self)

    def _set_endAngle(self, value: "double") -> "bool":
        r"""
        Gets and sets the end angle of the arc in radians.
        This angle is measured from the reference vector using the right hand rule around the normal vector.
        """
        return _core.Arc3D__set_endAngle(self, value)

    def _get_startPoint(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets the start point of the arc."""
        return _core.Arc3D__get_startPoint(self)

    def _get_endPoint(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets the end point of the arc."""
        return _core.Arc3D__get_endPoint(self)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Arc3D >":
        r"""
        Creates and returns an independent copy of this Arc3D object. 
        Returns a new Arc3D object that is a copy of this Arc3D object.
        """
        return _core.Arc3D_copy(self)

    def getData(self) -> "bool":
        r"""
        Gets all of the data defining the arc. 
        center : The output center point of the arc. 
        normal : The output normal vector. 
        referenceVector : The output reference vector. 
        radius : The output radius of the arc. 
        startAngle : The output start angle in radians.
        This angle is measured from the reference vector using the right hand rule around the normal vector. 
        endAngle : The output end angle in radians.
        This angle is measured from the reference vector using the right hand rule around the normal vector. 
        Returns true if successful
        """
        return _core.Arc3D_getData(self)

    def set(self, center: "Point3D", normal: "Vector3D", referenceVector: "Vector3D", radius: "double", startAngle: "double", endAngle: "double") -> "bool":
        r"""
        Sets all of the data defining the arc. 
        center : The center point of the arc. 
        normal : The normal vector of the arc.
        The plane perpendicular to this normal at the center point is the plane of the arc. 
        referenceVector : A reference vector from which the start and end angles are measured from.
        This vector must be perpendicular to the normal vector. 
        radius : The radius of the arc. 
        startAngle : The start angle in radians.
        This angle is measured from the reference vector using the right hand rule around the normal vector. 
        endAngle : The end angle in radians.
        This angle is measured from the reference vector using the right hand rule around the normal vector. 
        Returns true if successful
        """
        return _core.Arc3D_set(self, center, normal, referenceVector, radius, startAngle, endAngle)

    def _get_asNurbsCurve(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >":
        r"""Returns a NURBS curve that is geometrically identical to the arc."""
        return _core.Arc3D__get_asNurbsCurve(self)

    def _get_curveType(self) -> "adsk::core::Curve3DTypes":
        r"""Returns the type of geometry this curve represents."""
        return _core.Arc3D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator3D >":
        r"""Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.Arc3D__get_evaluator(self)

    def transformBy(self, matrix: "Matrix3D") -> "bool":
        r"""
        Transforms this curve in 3D space. 
        matrix : A 3D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.Arc3D_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.Arc3D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Arc3D__get_isValid(self)

# Register Arc3D in _core:
_core.Arc3D_swigregister(Arc3D)

def Arc3D_classType() -> "char const *":
    return _core.Arc3D_classType()

def Arc3D_createByCenter(center: "Point3D", normal: "Vector3D", referenceVector: "Vector3D", radius: "double", startAngle: "double", endAngle: "double") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
    return _core.Arc3D_createByCenter(center, normal, referenceVector, radius, startAngle, endAngle)

def Arc3D_createByThreePoints(pointOne: "Point3D", pointTwo: "Point3D", pointThree: "Point3D") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Point3D > const &":
    return _core.Arc3D_createByThreePoints(pointOne, pointTwo, pointThree)


Arc3D.center = property(Arc3D._get_center, Arc3D._set_center, doc="Gets and sets the center position of the arc.")


Arc3D.normal = property(Arc3D._get_normal, doc="Gets and sets the normal of the arc.")


Arc3D.referenceVector = property(Arc3D._get_referenceVector, doc="Gets and sets the reference vector of the arc.")


Arc3D.radius = property(Arc3D._get_radius, Arc3D._set_radius, doc="Gets and sets the radius of the arc.")


Arc3D.startAngle = property(Arc3D._get_startAngle, Arc3D._set_startAngle, doc="Gets and sets the start angle of the arc in radians.\nThis angle is measured from the reference vector using the right hand rule around the normal vector.")


Arc3D.endAngle = property(Arc3D._get_endAngle, Arc3D._set_endAngle, doc="Gets and sets the end angle of the arc in radians.\nThis angle is measured from the reference vector using the right hand rule around the normal vector.")


Arc3D.startPoint = property(Arc3D._get_startPoint, doc="Gets the start point of the arc.")


Arc3D.endPoint = property(Arc3D._get_endPoint, doc="Gets the end point of the arc.")


Arc3D.asNurbsCurve = property(Arc3D._get_asNurbsCurve, doc="Returns a NURBS curve that is geometrically identical to the arc.")


Arc3D.cast = lambda arg: arg if isinstance(arg, Arc3D) else None

class BooleanProperty(Property):
    r"""A material or appearance property that is a Boolean value."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::BooleanProperty *":
        return _core.BooleanProperty___deref__(self)

    def __eq__(self, rhs: "BooleanProperty") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.BooleanProperty___eq__(self, rhs)


    def __ne__(self, rhs: "BooleanProperty") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.BooleanProperty___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.BooleanProperty_classType()
    __swig_destroy__ = _core.delete_BooleanProperty

    def _get_value(self) -> "bool":
        r"""Gets and sets the value of this property."""
        return _core.BooleanProperty__get_value(self)

    def _set_value(self, value: "bool") -> "bool":
        r"""Gets and sets the value of this property."""
        return _core.BooleanProperty__set_value(self, value)

    def _get_name(self) -> "std::string":
        r"""
        Returns the name of this property as seen in the user interface. This name is localized
        and can change based on the current language
        """
        return _core.BooleanProperty__get_name(self)

    def _get_isReadOnly(self) -> "bool":
        r"""Indicates if this property is read-only. If True any attempted edits will fail."""
        return _core.BooleanProperty__get_isReadOnly(self)

    def _get_id(self) -> "std::string":
        r"""Returns the unique ID of this property."""
        return _core.BooleanProperty__get_id(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the parent of this property."""
        return _core.BooleanProperty__get_parent(self)

    def _get_objectType(self) -> "char const *":
        return _core.BooleanProperty__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.BooleanProperty__get_isValid(self)

# Register BooleanProperty in _core:
_core.BooleanProperty_swigregister(BooleanProperty)

def BooleanProperty_classType() -> "char const *":
    return _core.BooleanProperty_classType()


BooleanProperty.value = property(BooleanProperty._get_value, BooleanProperty._set_value, doc="Gets and sets the value of this property.")


BooleanProperty.cast = lambda arg: arg if isinstance(arg, BooleanProperty) else None

class BoolValueCommandInput(CommandInput):
    r"""
    Provides a command input to get a boolean value from the user. This is represented
    in the user inteface as either a button or a check box.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::BoolValueCommandInput *":
        return _core.BoolValueCommandInput___deref__(self)

    def __eq__(self, rhs: "BoolValueCommandInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.BoolValueCommandInput___eq__(self, rhs)


    def __ne__(self, rhs: "BoolValueCommandInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.BoolValueCommandInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.BoolValueCommandInput_classType()
    __swig_destroy__ = _core.delete_BoolValueCommandInput

    def _get_value(self) -> "bool":
        r"""
        Gets or sets the state of this input. If it's being displayed as a checkbox a value of true indicates the input is checked.
        If it's being displayed as a button, a value of true indicates the button is currently depressed.
        """
        return _core.BoolValueCommandInput__get_value(self)

    def _set_value(self, value: "bool") -> "bool":
        r"""
        Gets or sets the state of this input. If it's being displayed as a checkbox a value of true indicates the input is checked.
        If it's being displayed as a button, a value of true indicates the button is currently depressed.
        """
        return _core.BoolValueCommandInput__set_value(self, value)

    def _get_resourceFolder(self) -> "std::string":
        r"""
        Gets and sets the folder that contains the image to display on the button. Text
        can also be displayed, which is specified using the text property.
        """
        return _core.BoolValueCommandInput__get_resourceFolder(self)

    def _set_resourceFolder(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the folder that contains the image to display on the button. Text
        can also be displayed, which is specified using the text property.
        """
        return _core.BoolValueCommandInput__set_resourceFolder(self, value)

    def _get_isCheckBox(self) -> "bool":
        r"""Indicates if this is being shown as a button or check box."""
        return _core.BoolValueCommandInput__get_isCheckBox(self)

    def _get_text(self) -> "std::string":
        r"""
        Gets and sets text to be displayed on the button. If the resourceFolder
        is not specified then the button will be displayed with only text. If
        text and the resource folder are specified then both the icon and text
        will be displayed.
        """
        return _core.BoolValueCommandInput__get_text(self)

    def _set_text(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets text to be displayed on the button. If the resourceFolder
        is not specified then the button will be displayed with only text. If
        text and the resource folder are specified then both the icon and text
        will be displayed.
        """
        return _core.BoolValueCommandInput__set_text(self, value)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.BoolValueCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string":
        r"""Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.BoolValueCommandInput__get_id(self)

    def _get_name(self) -> "std::string":
        r"""Gets the user visible name of this input."""
        return _core.BoolValueCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.BoolValueCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.BoolValueCommandInput__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.BoolValueCommandInput__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.BoolValueCommandInput__set_isVisible(self, value)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the parent Command."""
        return _core.BoolValueCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.BoolValueCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.BoolValueCommandInput__set_isFullWidth(self, value)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.BoolValueCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.BoolValueCommandInput__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.BoolValueCommandInput__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.BoolValueCommandInput__set_tooltip(self, value)

    def _get_tooltipDescription(self) -> "std::string":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.BoolValueCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.BoolValueCommandInput__set_tooltipDescription(self, value)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.BoolValueCommandInput__get_parentCommandInput(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this Command input. 
        Returns true if the delete was successful.
        """
        return _core.BoolValueCommandInput_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.BoolValueCommandInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.BoolValueCommandInput__get_isValid(self)

# Register BoolValueCommandInput in _core:
_core.BoolValueCommandInput_swigregister(BoolValueCommandInput)

def BoolValueCommandInput_classType() -> "char const *":
    return _core.BoolValueCommandInput_classType()


BoolValueCommandInput.value = property(BoolValueCommandInput._get_value, BoolValueCommandInput._set_value, doc="Gets or sets the state of this input. If it's being displayed as a checkbox a value of true indicates the input is checked.\nIf it's being displayed as a button, a value of true indicates the button is currently depressed.")


BoolValueCommandInput.resourceFolder = property(BoolValueCommandInput._get_resourceFolder, BoolValueCommandInput._set_resourceFolder, doc="Gets and sets the folder that contains the image to display on the button. Text\ncan also be displayed, which is specified using the text property.")


BoolValueCommandInput.isCheckBox = property(BoolValueCommandInput._get_isCheckBox, doc="Indicates if this is being shown as a button or check box.")


BoolValueCommandInput.text = property(BoolValueCommandInput._get_text, BoolValueCommandInput._set_text, doc="Gets and sets text to be displayed on the button. If the resourceFolder\nis not specified then the button will be displayed with only text. If\ntext and the resource folder are specified then both the icon and text\nwill be displayed.")


BoolValueCommandInput.cast = lambda arg: arg if isinstance(arg, BoolValueCommandInput) else None

class ButtonControlDefinition(ControlDefinition):
    r"""
    Represents the information used to define a button. This isn't the visible button control but
    is the information needed to create a button control and fully defines a button except for 
    it's position within the user interface.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ButtonControlDefinition *":
        return _core.ButtonControlDefinition___deref__(self)

    def __eq__(self, rhs: "ButtonControlDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ButtonControlDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ButtonControlDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ButtonControlDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ButtonControlDefinition_classType()
    __swig_destroy__ = _core.delete_ButtonControlDefinition

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this definition is enabled or not. This has the effect of enabling and disabling any associated controls."""
        return _core.ButtonControlDefinition__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this definition is enabled or not. This has the effect of enabling and disabling any associated controls."""
        return _core.ButtonControlDefinition__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this definition is visible or not. This has the effect of making any associated controls visible or invisible in the user interface."""
        return _core.ButtonControlDefinition__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this definition is visible or not. This has the effect of making any associated controls visible or invisible in the user interface."""
        return _core.ButtonControlDefinition__set_isVisible(self, value)

    def _get_name(self) -> "std::string":
        r"""Gets or sets the name for this control. This is the visible name displayed in the user interface."""
        return _core.ButtonControlDefinition__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Gets or sets the name for this control. This is the visible name displayed in the user interface."""
        return _core.ButtonControlDefinition__set_name(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.ButtonControlDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ButtonControlDefinition__get_isValid(self)

# Register ButtonControlDefinition in _core:
_core.ButtonControlDefinition_swigregister(ButtonControlDefinition)

def ButtonControlDefinition_classType() -> "char const *":
    return _core.ButtonControlDefinition_classType()


ButtonControlDefinition.cast = lambda arg: arg if isinstance(arg, ButtonControlDefinition) else None

class ButtonRowCommandInput(CommandInput):
    r"""Provides a command input to get a selection of a single button from a row of buttons."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ButtonRowCommandInput *":
        return _core.ButtonRowCommandInput___deref__(self)

    def __eq__(self, rhs: "ButtonRowCommandInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ButtonRowCommandInput___eq__(self, rhs)


    def __ne__(self, rhs: "ButtonRowCommandInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ButtonRowCommandInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ButtonRowCommandInput_classType()
    __swig_destroy__ = _core.delete_ButtonRowCommandInput

    def _get_isMultiSelectEnabled(self) -> "bool":
        r"""
        Returns if this button row can have multiple items selected at once or not.
        If True, multiple buttons can be selected at once. If False only one button
        can be selected and selecting another button unselects the one currently selected.
        """
        return _core.ButtonRowCommandInput__get_isMultiSelectEnabled(self)

    def _get_listItems(self) -> "adsk::core::Ptr< adsk::core::ListItems >":
        r"""
        Returns the ListItems object associated with this button row. You use this
        object to populate and interact with the buttons in the row.
        """
        return _core.ButtonRowCommandInput__get_listItems(self)

    def _get_selectedItem(self) -> "adsk::core::Ptr< adsk::core::ListItem >":
        r"""
        Gets the button in the row that is currently selected. This can return null in the 
        case where no button in the row has been selected.
        """
        return _core.ButtonRowCommandInput__get_selectedItem(self)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.ButtonRowCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string":
        r"""Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.ButtonRowCommandInput__get_id(self)

    def _get_name(self) -> "std::string":
        r"""Gets the user visible name of this input."""
        return _core.ButtonRowCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.ButtonRowCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.ButtonRowCommandInput__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.ButtonRowCommandInput__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.ButtonRowCommandInput__set_isVisible(self, value)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the parent Command."""
        return _core.ButtonRowCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.ButtonRowCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.ButtonRowCommandInput__set_isFullWidth(self, value)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.ButtonRowCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.ButtonRowCommandInput__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.ButtonRowCommandInput__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.ButtonRowCommandInput__set_tooltip(self, value)

    def _get_tooltipDescription(self) -> "std::string":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.ButtonRowCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.ButtonRowCommandInput__set_tooltipDescription(self, value)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.ButtonRowCommandInput__get_parentCommandInput(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this Command input. 
        Returns true if the delete was successful.
        """
        return _core.ButtonRowCommandInput_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.ButtonRowCommandInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ButtonRowCommandInput__get_isValid(self)

# Register ButtonRowCommandInput in _core:
_core.ButtonRowCommandInput_swigregister(ButtonRowCommandInput)

def ButtonRowCommandInput_classType() -> "char const *":
    return _core.ButtonRowCommandInput_classType()


ButtonRowCommandInput.isMultiSelectEnabled = property(ButtonRowCommandInput._get_isMultiSelectEnabled, doc="Returns if this button row can have multiple items selected at once or not.\nIf True, multiple buttons can be selected at once. If False only one button\ncan be selected and selecting another button unselects the one currently selected.")


ButtonRowCommandInput.listItems = property(ButtonRowCommandInput._get_listItems, doc="Returns the ListItems object associated with this button row. You use this\nobject to populate and interact with the buttons in the row.")


ButtonRowCommandInput.selectedItem = property(ButtonRowCommandInput._get_selectedItem, doc="Gets the button in the row that is currently selected. This can return null in the\ncase where no button in the row has been selected.")


ButtonRowCommandInput.cast = lambda arg: arg if isinstance(arg, ButtonRowCommandInput) else None

class CameraEvent(Event):
    r"""
    A CameraEvent represents an event that occurs in reaction to the user manipulating the view.
    Camera changes happen when user changes the view by rotating, zooming in or out, panning, 
    changing from parallel to perspective, or when the extents of the viewport changes.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::CameraEvent *":
        return _core.CameraEvent___deref__(self)

    def __eq__(self, rhs: "CameraEvent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.CameraEvent___eq__(self, rhs)


    def __ne__(self, rhs: "CameraEvent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.CameraEvent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.CameraEvent_classType()
    __swig_destroy__ = _core.delete_CameraEvent

    def add(self, handler: "CameraEventHandler") -> "bool":
        r"""
        Add a handler to be notified when the event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _core.CameraEvent_add(self, handler)

    def remove(self, handler: "CameraEventHandler") -> "bool":
        r"""
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _core.CameraEvent_remove(self, handler)

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _core.CameraEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.CameraEvent__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _core.CameraEvent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.CameraEvent__get_isValid(self)

# Register CameraEvent in _core:
_core.CameraEvent_swigregister(CameraEvent)

def CameraEvent_classType() -> "char const *":
    return _core.CameraEvent_classType()


CameraEvent.cast = lambda arg: arg if isinstance(arg, CameraEvent) else None

class CameraEventArgs(EventArgs):
    r"""
    The CameraEventArgs provides information associated with a camera change.
    Camera changes happen when user changes the view by rotating, zooming in or out, panning, 
    changing from parallel to perspective, or when the extents of the viewport changes.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::CameraEventArgs *":
        return _core.CameraEventArgs___deref__(self)

    def __eq__(self, rhs: "CameraEventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.CameraEventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "CameraEventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.CameraEventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.CameraEventArgs_classType()
    __swig_destroy__ = _core.delete_CameraEventArgs

    def _get_viewport(self) -> "adsk::core::Ptr< adsk::core::Viewport >":
        r"""Returns the viewport that the modified camera is associated with."""
        return _core.CameraEventArgs__get_viewport(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _core.CameraEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _core.CameraEventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.CameraEventArgs__get_isValid(self)

# Register CameraEventArgs in _core:
_core.CameraEventArgs_swigregister(CameraEventArgs)

def CameraEventArgs_classType() -> "char const *":
    return _core.CameraEventArgs_classType()


CameraEventArgs.viewport = property(CameraEventArgs._get_viewport, doc="Returns the viewport that the modified camera is associated with.")


CameraEventArgs.cast = lambda arg: arg if isinstance(arg, CameraEventArgs) else None

class CheckBoxControlDefinition(ControlDefinition):
    r"""
    Represents the information used to define a check box. This isn't the visible check box control but
    is the information needed to create a check box control and fully defines a check box except for 
    it's position within the user interface.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::CheckBoxControlDefinition *":
        return _core.CheckBoxControlDefinition___deref__(self)

    def __eq__(self, rhs: "CheckBoxControlDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.CheckBoxControlDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "CheckBoxControlDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.CheckBoxControlDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.CheckBoxControlDefinition_classType()
    __swig_destroy__ = _core.delete_CheckBoxControlDefinition

    def _get_isChecked(self) -> "bool":
        r"""
        Gets or sets whether the check box is checked. Changing this will result in changing any 
        associated controls and will execute the associated command.
        """
        return _core.CheckBoxControlDefinition__get_isChecked(self)

    def _set_isChecked(self, value: "bool") -> "bool":
        r"""
        Gets or sets whether the check box is checked. Changing this will result in changing any 
        associated controls and will execute the associated command.
        """
        return _core.CheckBoxControlDefinition__set_isChecked(self, value)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this definition is enabled or not. This has the effect of enabling and disabling any associated controls."""
        return _core.CheckBoxControlDefinition__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this definition is enabled or not. This has the effect of enabling and disabling any associated controls."""
        return _core.CheckBoxControlDefinition__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this definition is visible or not. This has the effect of making any associated controls visible or invisible in the user interface."""
        return _core.CheckBoxControlDefinition__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this definition is visible or not. This has the effect of making any associated controls visible or invisible in the user interface."""
        return _core.CheckBoxControlDefinition__set_isVisible(self, value)

    def _get_name(self) -> "std::string":
        r"""Gets or sets the name for this control. This is the visible name displayed in the user interface."""
        return _core.CheckBoxControlDefinition__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Gets or sets the name for this control. This is the visible name displayed in the user interface."""
        return _core.CheckBoxControlDefinition__set_name(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.CheckBoxControlDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.CheckBoxControlDefinition__get_isValid(self)

# Register CheckBoxControlDefinition in _core:
_core.CheckBoxControlDefinition_swigregister(CheckBoxControlDefinition)

def CheckBoxControlDefinition_classType() -> "char const *":
    return _core.CheckBoxControlDefinition_classType()


CheckBoxControlDefinition.isChecked = property(CheckBoxControlDefinition._get_isChecked, CheckBoxControlDefinition._set_isChecked, doc="Gets or sets whether the check box is checked. Changing this will result in changing any\nassociated controls and will execute the associated command.")


CheckBoxControlDefinition.cast = lambda arg: arg if isinstance(arg, CheckBoxControlDefinition) else None

class ChoiceProperty(Property):
    r"""A material or appearance property that is a pre-defined list of choices."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ChoiceProperty *":
        return _core.ChoiceProperty___deref__(self)

    def __eq__(self, rhs: "ChoiceProperty") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ChoiceProperty___eq__(self, rhs)


    def __ne__(self, rhs: "ChoiceProperty") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ChoiceProperty___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ChoiceProperty_classType()
    __swig_destroy__ = _core.delete_ChoiceProperty

    def getChoices(self) -> "bool":
        r"""
        Method that returns the list of available choices. 
        names : An array of the names of the choices. These coincide with the array of choices returned by the choices argument. 
        choices : An array of the choices. These coincide with the array of names returned by the names argument. 
        Returns true if the call was successful.
        """
        return _core.ChoiceProperty_getChoices(self)

    def _get_value(self) -> "std::string":
        r"""
        Gets and sets the which choice is selected from the set of choices.
        The value is a string that matches one of the pre-defined choices.
        The names of the available choices can be obtained using GetChoices method.
        """
        return _core.ChoiceProperty__get_value(self)

    def _set_value(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the which choice is selected from the set of choices.
        The value is a string that matches one of the pre-defined choices.
        The names of the available choices can be obtained using GetChoices method.
        """
        return _core.ChoiceProperty__set_value(self, value)

    def _get_name(self) -> "std::string":
        r"""
        Returns the name of this property as seen in the user interface. This name is localized
        and can change based on the current language
        """
        return _core.ChoiceProperty__get_name(self)

    def _get_isReadOnly(self) -> "bool":
        r"""Indicates if this property is read-only. If True any attempted edits will fail."""
        return _core.ChoiceProperty__get_isReadOnly(self)

    def _get_id(self) -> "std::string":
        r"""Returns the unique ID of this property."""
        return _core.ChoiceProperty__get_id(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the parent of this property."""
        return _core.ChoiceProperty__get_parent(self)

    def _get_objectType(self) -> "char const *":
        return _core.ChoiceProperty__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ChoiceProperty__get_isValid(self)

# Register ChoiceProperty in _core:
_core.ChoiceProperty_swigregister(ChoiceProperty)

def ChoiceProperty_classType() -> "char const *":
    return _core.ChoiceProperty_classType()


ChoiceProperty.value = property(ChoiceProperty._get_value, ChoiceProperty._set_value, doc="Gets and sets the which choice is selected from the set of choices.\nThe value is a string that matches one of the pre-defined choices.\nThe names of the available choices can be obtained using GetChoices method.")


ChoiceProperty.cast = lambda arg: arg if isinstance(arg, ChoiceProperty) else None

class Circle2D(Curve2D):
    r"""
    Transient 2D circle. A transient circle is not displayed or saved in a document.
    Transient circles are used as a wrapper to work with raw 2D arc information. They
    are created statically using one of the create methods of the Circle2D class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Circle2D *":
        return _core.Circle2D___deref__(self)

    def __eq__(self, rhs: "Circle2D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Circle2D___eq__(self, rhs)


    def __ne__(self, rhs: "Circle2D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Circle2D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Circle2D_classType()

    @staticmethod
    def createByCenter(center: "Point2D", radius: "double") -> "adsk::core::Ptr< adsk::core::Point2D > const &":
        return _core.Circle2D_createByCenter(center, radius)

    @staticmethod
    def createByThreePoints(pointOne: "Point2D", pointTwo: "Point2D", pointThree: "Point2D") -> "adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Point2D > const &":
        return _core.Circle2D_createByThreePoints(pointOne, pointTwo, pointThree)
    __swig_destroy__ = _core.delete_Circle2D

    def _get_center(self) -> "adsk::core::Ptr< adsk::core::Point2D >":
        r"""Gets and sets the center position of the circle."""
        return _core.Circle2D__get_center(self)

    def _set_center(self, value: "Point2D") -> "bool":
        r"""Gets and sets the center position of the circle."""
        return _core.Circle2D__set_center(self, value)

    def _get_radius(self) -> "double":
        r"""Gets and sets the radius of the circle."""
        return _core.Circle2D__get_radius(self)

    def _set_radius(self, value: "double") -> "bool":
        r"""Gets and sets the radius of the circle."""
        return _core.Circle2D__set_radius(self, value)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Circle2D >":
        r"""
        Creates and returns an independent copy of this Circle2D object. 
        Returns an independent copy of this Circle2D object.
        """
        return _core.Circle2D_copy(self)

    def getData(self) -> "bool":
        r"""
        Gets all of the data defining the circle. 
        center : The output point defining the center position of the circle. 
        radius : The output radius of the circle. 
        Returns true if successful.
        """
        return _core.Circle2D_getData(self)

    def set(self, center: "Point2D", radius: "double") -> "bool":
        r"""
        Sets all of the data defining the circle. 
        center : A point that defines the center position of the circle. 
        radius : The radius of the circle. 
        Returns true if redefining the circle is successful
        """
        return _core.Circle2D_set(self, center, radius)

    def _get_asNurbsCurve(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve2D >":
        r"""Returns a NURBS curve that is geometrically identical to the circle."""
        return _core.Circle2D__get_asNurbsCurve(self)

    def _get_curveType(self) -> "adsk::core::Curve2DTypes":
        r"""Returns the type of geometry this curve represents."""
        return _core.Circle2D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator2D >":
        r"""Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.Circle2D__get_evaluator(self)

    def transformBy(self, matrix: "Matrix2D") -> "bool":
        r"""
        Transforms this curve in 2D space. 
        matrix : A 2D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.Circle2D_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.Circle2D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Circle2D__get_isValid(self)

# Register Circle2D in _core:
_core.Circle2D_swigregister(Circle2D)

def Circle2D_classType() -> "char const *":
    return _core.Circle2D_classType()

def Circle2D_createByCenter(center: "Point2D", radius: "double") -> "adsk::core::Ptr< adsk::core::Point2D > const &":
    return _core.Circle2D_createByCenter(center, radius)

def Circle2D_createByThreePoints(pointOne: "Point2D", pointTwo: "Point2D", pointThree: "Point2D") -> "adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Point2D > const &":
    return _core.Circle2D_createByThreePoints(pointOne, pointTwo, pointThree)


Circle2D.center = property(Circle2D._get_center, Circle2D._set_center, doc="Gets and sets the center position of the circle.")


Circle2D.radius = property(Circle2D._get_radius, Circle2D._set_radius, doc="Gets and sets the radius of the circle.")


Circle2D.asNurbsCurve = property(Circle2D._get_asNurbsCurve, doc="Returns a NURBS curve that is geometrically identical to the circle.")


Circle2D.cast = lambda arg: arg if isinstance(arg, Circle2D) else None

class Circle3D(Curve3D):
    r"""
    Transient 3D circle. A transient circle is not displayed or saved in a document.
    Transient 3D circles are used as a wrapper to work with raw 3D circle information.
    They are created statically using one of the create methods of the Circle3D class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Circle3D *":
        return _core.Circle3D___deref__(self)

    def __eq__(self, rhs: "Circle3D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Circle3D___eq__(self, rhs)


    def __ne__(self, rhs: "Circle3D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Circle3D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Circle3D_classType()

    @staticmethod
    def createByCenter(center: "Point3D", normal: "Vector3D", radius: "double") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
        return _core.Circle3D_createByCenter(center, normal, radius)

    @staticmethod
    def createByThreePoints(pointOne: "Point3D", pointTwo: "Point3D", pointThree: "Point3D") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Point3D > const &":
        return _core.Circle3D_createByThreePoints(pointOne, pointTwo, pointThree)
    __swig_destroy__ = _core.delete_Circle3D

    def _get_center(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets the center position of the circle."""
        return _core.Circle3D__get_center(self)

    def _set_center(self, value: "Point3D") -> "bool":
        r"""Gets and sets the center position of the circle."""
        return _core.Circle3D__set_center(self, value)

    def _get_normal(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Gets and sets the normal of the circle."""
        return _core.Circle3D__get_normal(self)

    def _set_normal(self, value: "Vector3D") -> "bool":
        r"""Gets and sets the normal of the circle."""
        return _core.Circle3D__set_normal(self, value)

    def _get_radius(self) -> "double":
        r"""Gets and sets the radius of the circle."""
        return _core.Circle3D__get_radius(self)

    def _set_radius(self, value: "double") -> "bool":
        r"""Gets and sets the radius of the circle."""
        return _core.Circle3D__set_radius(self, value)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Circle3D >":
        r"""
        Creates and returns an independent copy of this Circle3D object. 
        Returns an independent copy of this Circle3D object.
        """
        return _core.Circle3D_copy(self)

    def getData(self) -> "bool":
        r"""
        Gets all of the data defining the circle. 
        center : The output center point of the circle. 
        normal : The output normal vector. 
        radius : The output radius of the circle. 
        Returns true if successful
        """
        return _core.Circle3D_getData(self)

    def set(self, center: "Point3D", normal: "Vector3D", radius: "double") -> "bool":
        r"""
        Sets all of the data defining the circle. 
        center : The center point of the circle. 
        normal : The normal vector of the circle.
        The plane through the center point and perpendicular to the normal vector defines the plane of the circle. 
        radius : The radius of the circle. 
        Returns true if successful
        """
        return _core.Circle3D_set(self, center, normal, radius)

    def _get_asNurbsCurve(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >":
        r"""Returns a NURBS curve that is geometrically identical to the circle."""
        return _core.Circle3D__get_asNurbsCurve(self)

    def _get_curveType(self) -> "adsk::core::Curve3DTypes":
        r"""Returns the type of geometry this curve represents."""
        return _core.Circle3D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator3D >":
        r"""Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.Circle3D__get_evaluator(self)

    def transformBy(self, matrix: "Matrix3D") -> "bool":
        r"""
        Transforms this curve in 3D space. 
        matrix : A 3D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.Circle3D_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.Circle3D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Circle3D__get_isValid(self)

# Register Circle3D in _core:
_core.Circle3D_swigregister(Circle3D)

def Circle3D_classType() -> "char const *":
    return _core.Circle3D_classType()

def Circle3D_createByCenter(center: "Point3D", normal: "Vector3D", radius: "double") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
    return _core.Circle3D_createByCenter(center, normal, radius)

def Circle3D_createByThreePoints(pointOne: "Point3D", pointTwo: "Point3D", pointThree: "Point3D") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Point3D > const &":
    return _core.Circle3D_createByThreePoints(pointOne, pointTwo, pointThree)


Circle3D.center = property(Circle3D._get_center, Circle3D._set_center, doc="Gets and sets the center position of the circle.")


Circle3D.normal = property(Circle3D._get_normal, Circle3D._set_normal, doc="Gets and sets the normal of the circle.")


Circle3D.radius = property(Circle3D._get_radius, Circle3D._set_radius, doc="Gets and sets the radius of the circle.")


Circle3D.asNurbsCurve = property(Circle3D._get_asNurbsCurve, doc="Returns a NURBS curve that is geometrically identical to the circle.")


Circle3D.cast = lambda arg: arg if isinstance(arg, Circle3D) else None

class ColorProperty(Property):
    r"""A color property associated with an appearance."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ColorProperty *":
        return _core.ColorProperty___deref__(self)

    def __eq__(self, rhs: "ColorProperty") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ColorProperty___eq__(self, rhs)


    def __ne__(self, rhs: "ColorProperty") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ColorProperty___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ColorProperty_classType()
    __swig_destroy__ = _core.delete_ColorProperty

    def _get_connectedTexture(self) -> "adsk::core::Ptr< adsk::core::AppearanceTexture >":
        r"""
        Gets the associated texture, if one exists. The HasConnectedTexture property controls 
        if there is an associated texture or not. If the parent is writable you can edit the 
        texture. If no texture exists, this property will return null.
        """
        return _core.ColorProperty__get_connectedTexture(self)

    def _get_hasConnectedTexture(self) -> "bool":
        r"""
        Specifies if this color is specified using a simple color or a texture. If this returns true 
        the color is defined using a texture. If the parent is writable, this property can be set to 
        true to change the definition from a simple color to a texture. You can then use the ConnectedTexture
        property to get the associated texture and modify it.
        """
        return _core.ColorProperty__get_hasConnectedTexture(self)

    def _set_hasConnectedTexture(self, value: "bool") -> "bool":
        r"""
        Specifies if this color is specified using a simple color or a texture. If this returns true 
        the color is defined using a texture. If the parent is writable, this property can be set to 
        true to change the definition from a simple color to a texture. You can then use the ConnectedTexture
        property to get the associated texture and modify it.
        """
        return _core.ColorProperty__set_hasConnectedTexture(self, value)

    def _get_hasMultipleValues(self) -> "bool":
        r"""Indicates if this property has multiple values or not."""
        return _core.ColorProperty__get_hasMultipleValues(self)

    def _get_value(self) -> "adsk::core::Ptr< adsk::core::Color >":
        r"""
        Gets and sets this property value if there is a color and not a texture defining
        this color . If a texture is used, this property returns null. Setting this property
        when a texture is used removes the texture and changes the color definition to a simple color.
        """
        return _core.ColorProperty__get_value(self)

    def _set_value(self, value: "Color") -> "bool":
        r"""
        Gets and sets this property value if there is a color and not a texture defining
        this color . If a texture is used, this property returns null. Setting this property
        when a texture is used removes the texture and changes the color definition to a simple color.
        """
        return _core.ColorProperty__set_value(self, value)

    def _get_values(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color >,std::allocator< adsk::core::Ptr< adsk::core::Color > > >":
        r"""
        Gets and sets the values associated with this property. The HasMultipleValues property 
        indicates if this property will be returning more than one value.
        """
        return _core.ColorProperty__get_values(self)

    def _set_values(self, value: "ColorVector") -> "bool":
        r"""
        Gets and sets the values associated with this property. The HasMultipleValues property 
        indicates if this property will be returning more than one value.
        """
        return _core.ColorProperty__set_values(self, value)

    def _get_name(self) -> "std::string":
        r"""
        Returns the name of this property as seen in the user interface. This name is localized
        and can change based on the current language
        """
        return _core.ColorProperty__get_name(self)

    def _get_isReadOnly(self) -> "bool":
        r"""Indicates if this property is read-only. If True any attempted edits will fail."""
        return _core.ColorProperty__get_isReadOnly(self)

    def _get_id(self) -> "std::string":
        r"""Returns the unique ID of this property."""
        return _core.ColorProperty__get_id(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the parent of this property."""
        return _core.ColorProperty__get_parent(self)

    def _get_objectType(self) -> "char const *":
        return _core.ColorProperty__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ColorProperty__get_isValid(self)

# Register ColorProperty in _core:
_core.ColorProperty_swigregister(ColorProperty)

def ColorProperty_classType() -> "char const *":
    return _core.ColorProperty_classType()


ColorProperty.connectedTexture = property(ColorProperty._get_connectedTexture, doc="Gets the associated texture, if one exists. The HasConnectedTexture property controls\nif there is an associated texture or not. If the parent is writable you can edit the\ntexture. If no texture exists, this property will return null.")


ColorProperty.hasConnectedTexture = property(ColorProperty._get_hasConnectedTexture, ColorProperty._set_hasConnectedTexture, doc="Specifies if this color is specified using a simple color or a texture. If this returns true\nthe color is defined using a texture. If the parent is writable, this property can be set to\ntrue to change the definition from a simple color to a texture. You can then use the ConnectedTexture\nproperty to get the associated texture and modify it.")


ColorProperty.hasMultipleValues = property(ColorProperty._get_hasMultipleValues, doc="Indicates if this property has multiple values or not.")


ColorProperty.value = property(ColorProperty._get_value, ColorProperty._set_value, doc="Gets and sets this property value if there is a color and not a texture defining\nthis color . If a texture is used, this property returns null. Setting this property\nwhen a texture is used removes the texture and changes the color definition to a simple color.")


ColorProperty.values = property(ColorProperty._get_values, ColorProperty._set_values, doc="Gets and sets the values associated with this property. The HasMultipleValues property\nindicates if this property will be returning more than one value.")


ColorProperty.cast = lambda arg: arg if isinstance(arg, ColorProperty) else None

class CommandControl(ToolbarControl):
    r"""Represents a button, check box, or radio control list in a panel, toolbar, or drop-down."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::CommandControl *":
        return _core.CommandControl___deref__(self)

    def __eq__(self, rhs: "CommandControl") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.CommandControl___eq__(self, rhs)


    def __ne__(self, rhs: "CommandControl") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.CommandControl___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.CommandControl_classType()
    __swig_destroy__ = _core.delete_CommandControl

    def _get_commandDefinition(self) -> "adsk::core::Ptr< adsk::core::CommandDefinition >":
        r"""
        Gets the command definition associated with this button. The command definition defines
        all of the resource information used to display this button and receives the event when the button is clicked.
        """
        return _core.CommandControl__get_commandDefinition(self)

    def _get_isPromoted(self) -> "bool":
        r"""
        Gets or sets if this command has been promoted to the parent panel.
        This property is ignored in the case where this control isn't in a panel.
        """
        return _core.CommandControl__get_isPromoted(self)

    def _set_isPromoted(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this command has been promoted to the parent panel.
        This property is ignored in the case where this control isn't in a panel.
        """
        return _core.CommandControl__set_isPromoted(self, value)

    def _get_isPromotedByDefault(self) -> "bool":
        r"""
        Gets or sets if this command is a default command in the panel.
        This defines the default state of the panel if the UI is reset.
        This property is ignored in the case where this control isn't in a panel.
        """
        return _core.CommandControl__get_isPromotedByDefault(self)

    def _set_isPromotedByDefault(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this command is a default command in the panel.
        This defines the default state of the panel if the UI is reset.
        This property is ignored in the case where this control isn't in a panel.
        """
        return _core.CommandControl__set_isPromotedByDefault(self, value)

    def _get_id(self) -> "std::string":
        r"""
        Gets the unique ID of this control. The ID is unique with respect to the other
        controls within the same panel, toolbar, or drop-down control.
        """
        return _core.CommandControl__get_id(self)

    def _get_index(self) -> "size_t":
        r"""Gets the position of this control within the list of controls within the panel, toolbar, or drop-down control."""
        return _core.CommandControl__get_index(self)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this control is currently visible."""
        return _core.CommandControl__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this control is currently visible."""
        return _core.CommandControl__set_isVisible(self, value)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets the Parent object. When associated with a toolbar (right or left QAT or the Nav Bar) this
        returns the parent Toolbar object. When associated with a panel it returns the parent ToolbarPanel object.
        When associated with a control (DropDownControl) it returns the parent control.
        """
        return _core.CommandControl__get_parent(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the ToolbarControl 
        Returns a boolean indicating if the deletion was successful.
        """
        return _core.CommandControl_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.CommandControl__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.CommandControl__get_isValid(self)

# Register CommandControl in _core:
_core.CommandControl_swigregister(CommandControl)

def CommandControl_classType() -> "char const *":
    return _core.CommandControl_classType()


CommandControl.commandDefinition = property(CommandControl._get_commandDefinition, doc="Gets the command definition associated with this button. The command definition defines\nall of the resource information used to display this button and receives the event when the button is clicked.")


CommandControl.isPromoted = property(CommandControl._get_isPromoted, CommandControl._set_isPromoted, doc="Gets or sets if this command has been promoted to the parent panel.\nThis property is ignored in the case where this control isn't in a panel.")


CommandControl.isPromotedByDefault = property(CommandControl._get_isPromotedByDefault, CommandControl._set_isPromotedByDefault, doc="Gets or sets if this command is a default command in the panel.\nThis defines the default state of the panel if the UI is reset.\nThis property is ignored in the case where this control isn't in a panel.")


CommandControl.cast = lambda arg: arg if isinstance(arg, CommandControl) else None

class CommandCreatedEvent(Event):
    r"""Class that needs to be implemented in order to respond to the CommandCreatedEvent event."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::CommandCreatedEvent *":
        return _core.CommandCreatedEvent___deref__(self)

    def __eq__(self, rhs: "CommandCreatedEvent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.CommandCreatedEvent___eq__(self, rhs)


    def __ne__(self, rhs: "CommandCreatedEvent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.CommandCreatedEvent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.CommandCreatedEvent_classType()
    __swig_destroy__ = _core.delete_CommandCreatedEvent

    def add(self, handler: "CommandCreatedEventHandler") -> "bool":
        r"""
        Adds an event handler object to this event endpoint. 
        handler : The client implemented CommandCreatedEventHandler to be called when this event is triggered. 
        Returns true if the handler was successfully added to the set of event handlers.
        """
        return _core.CommandCreatedEvent_add(self, handler)

    def remove(self, handler: "CommandCreatedEventHandler") -> "bool":
        r"""
        Removes a handler from this event endpoint. 
        handler : A CommandCreatedEventHandler that was previously added to this event with the add method. 
        Returns true if the handler was found and removed from the set of event handlers.
        """
        return _core.CommandCreatedEvent_remove(self, handler)

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _core.CommandCreatedEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.CommandCreatedEvent__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _core.CommandCreatedEvent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.CommandCreatedEvent__get_isValid(self)

# Register CommandCreatedEvent in _core:
_core.CommandCreatedEvent_swigregister(CommandCreatedEvent)

def CommandCreatedEvent_classType() -> "char const *":
    return _core.CommandCreatedEvent_classType()


CommandCreatedEvent.cast = lambda arg: arg if isinstance(arg, CommandCreatedEvent) else None

class CommandCreatedEventArgs(EventArgs):
    r"""Provides data for the CommandCreated event."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::CommandCreatedEventArgs *":
        return _core.CommandCreatedEventArgs___deref__(self)

    def __eq__(self, rhs: "CommandCreatedEventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.CommandCreatedEventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "CommandCreatedEventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.CommandCreatedEventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.CommandCreatedEventArgs_classType()
    __swig_destroy__ = _core.delete_CommandCreatedEventArgs

    def _get_command(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the newly created Command object that allows you to perform an action in response to the control being clicked."""
        return _core.CommandCreatedEventArgs__get_command(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _core.CommandCreatedEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _core.CommandCreatedEventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.CommandCreatedEventArgs__get_isValid(self)

# Register CommandCreatedEventArgs in _core:
_core.CommandCreatedEventArgs_swigregister(CommandCreatedEventArgs)

def CommandCreatedEventArgs_classType() -> "char const *":
    return _core.CommandCreatedEventArgs_classType()


CommandCreatedEventArgs.command = property(CommandCreatedEventArgs._get_command, doc="Gets the newly created Command object that allows you to perform an action in response to the control being clicked.")


CommandCreatedEventArgs.cast = lambda arg: arg if isinstance(arg, CommandCreatedEventArgs) else None

class CommandEvent(Event):
    r"""An event endpoint that supports the connection to client implemented CommandEventHandlers."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::CommandEvent *":
        return _core.CommandEvent___deref__(self)

    def __eq__(self, rhs: "CommandEvent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.CommandEvent___eq__(self, rhs)


    def __ne__(self, rhs: "CommandEvent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.CommandEvent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.CommandEvent_classType()
    __swig_destroy__ = _core.delete_CommandEvent

    def add(self, handler: "CommandEventHandler") -> "bool":
        r"""
        Adds an event handler object to this event endpoint. 
        handler : The client implemented CommandEventHandler to be called when this event is triggered. 
        Returns true if the handler was successfully added to the set of event handlers.
        """
        return _core.CommandEvent_add(self, handler)

    def remove(self, handler: "CommandEventHandler") -> "bool":
        r"""
        Removes a handler from this event endpoint. 
        handler : A CommandEventHandler that was previously added to this event with the add method. 
        Returns true if the handler was found and removed from the set of event handlers.
        """
        return _core.CommandEvent_remove(self, handler)

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _core.CommandEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.CommandEvent__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _core.CommandEvent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.CommandEvent__get_isValid(self)

# Register CommandEvent in _core:
_core.CommandEvent_swigregister(CommandEvent)

def CommandEvent_classType() -> "char const *":
    return _core.CommandEvent_classType()


CommandEvent.cast = lambda arg: arg if isinstance(arg, CommandEvent) else None

class CommandEventArgs(EventArgs):
    r"""Provides a set of arguments from a firing CommandEvent to a CommandEventHandler's notify callback method."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::CommandEventArgs *":
        return _core.CommandEventArgs___deref__(self)

    def __eq__(self, rhs: "CommandEventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.CommandEventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "CommandEventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.CommandEventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.CommandEventArgs_classType()
    __swig_destroy__ = _core.delete_CommandEventArgs

    def _get_command(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the Command object."""
        return _core.CommandEventArgs__get_command(self)

    def _get_executeFailed(self) -> "bool":
        r"""
        Used during the execute event to get or set that the execute operations failed
        and the commands transaction should be aborted.
        This property should be ignored for all events besides the Execute event.
        """
        return _core.CommandEventArgs__get_executeFailed(self)

    def _set_executeFailed(self, value: "bool") -> "bool":
        r"""
        Used during the execute event to get or set that the execute operations failed
        and the commands transaction should be aborted.
        This property should be ignored for all events besides the Execute event.
        """
        return _core.CommandEventArgs__set_executeFailed(self, value)

    def _get_executeFailedMessage(self) -> "std::string":
        r"""
        Used during the execute event to get or set a description of an execute failure.
        This property should be ignored for all events besides the Execute event.
        """
        return _core.CommandEventArgs__get_executeFailedMessage(self)

    def _set_executeFailedMessage(self, value: "std::string const &") -> "bool":
        r"""
        Used during the execute event to get or set a description of an execute failure.
        This property should be ignored for all events besides the Execute event.
        """
        return _core.CommandEventArgs__set_executeFailedMessage(self, value)

    def _get_isValidResult(self) -> "bool":
        r"""
        Used during the commandStarting event to get or set that the result of preview is valid
        and the command can reuse the result when Ok is hit.
        This property should be ignored for all events besides the executePreview event.
        """
        return _core.CommandEventArgs__get_isValidResult(self)

    def _set_isValidResult(self, value: "bool") -> "bool":
        r"""
        Used during the commandStarting event to get or set that the result of preview is valid
        and the command can reuse the result when Ok is hit.
        This property should be ignored for all events besides the executePreview event.
        """
        return _core.CommandEventArgs__set_isValidResult(self, value)

    def _get_terminationReason(self) -> "adsk::core::CommandTerminationReason":
        r"""Gets the termination reason of the command. It's only valid on the destroy event."""
        return _core.CommandEventArgs__get_terminationReason(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _core.CommandEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _core.CommandEventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.CommandEventArgs__get_isValid(self)

# Register CommandEventArgs in _core:
_core.CommandEventArgs_swigregister(CommandEventArgs)

def CommandEventArgs_classType() -> "char const *":
    return _core.CommandEventArgs_classType()


CommandEventArgs.command = property(CommandEventArgs._get_command, doc="Gets the Command object.")


CommandEventArgs.executeFailed = property(CommandEventArgs._get_executeFailed, CommandEventArgs._set_executeFailed, doc="Used during the execute event to get or set that the execute operations failed\nand the commands transaction should be aborted.\nThis property should be ignored for all events besides the Execute event.")


CommandEventArgs.executeFailedMessage = property(CommandEventArgs._get_executeFailedMessage, CommandEventArgs._set_executeFailedMessage, doc="Used during the execute event to get or set a description of an execute failure.\nThis property should be ignored for all events besides the Execute event.")


CommandEventArgs.isValidResult = property(CommandEventArgs._get_isValidResult, CommandEventArgs._set_isValidResult, doc="Used during the commandStarting event to get or set that the result of preview is valid\nand the command can reuse the result when Ok is hit.\nThis property should be ignored for all events besides the executePreview event.")


CommandEventArgs.terminationReason = property(CommandEventArgs._get_terminationReason, doc="Gets the termination reason of the command. It's only valid on the destroy event.")


CommandEventArgs.cast = lambda arg: arg if isinstance(arg, CommandEventArgs) else None

class Cone(Surface):
    r"""
    Transient cone. A transient cone is not displayed or saved in a document.
    A transient cone is used as a wrapper to work with raw cone information. 
    A transient cone has no boundaries.
    The cone always goes to a point in its narrowing direction, and is infinite in its 
    widening direction.
    They are created statically using the create method of the Cone class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Cone *":
        return _core.Cone___deref__(self)

    def __eq__(self, rhs: "Cone") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Cone___eq__(self, rhs)


    def __ne__(self, rhs: "Cone") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Cone___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Cone_classType()

    @staticmethod
    def create(origin: "Point3D", axis: "Vector3D", radius: "double", halfAngle: "double") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
        return _core.Cone_create(origin, axis, radius, halfAngle)
    __swig_destroy__ = _core.delete_Cone

    def _get_origin(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets the origin point (center) of the base of the cone."""
        return _core.Cone__get_origin(self)

    def _set_origin(self, value: "Point3D") -> "bool":
        r"""Gets and sets the origin point (center) of the base of the cone."""
        return _core.Cone__set_origin(self, value)

    def _get_axis(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Gets and sets the center axis (along the length) of the cone that defines its 
        normal direction.
        """
        return _core.Cone__get_axis(self)

    def _set_axis(self, value: "Vector3D") -> "bool":
        r"""
        Gets and sets the center axis (along the length) of the cone that defines its 
        normal direction.
        """
        return _core.Cone__set_axis(self, value)

    def _get_radius(self) -> "double":
        r"""Gets and sets the radius of the cone."""
        return _core.Cone__get_radius(self)

    def _set_radius(self, value: "double") -> "bool":
        r"""Gets and sets the radius of the cone."""
        return _core.Cone__set_radius(self, value)

    def _get_halfAngle(self) -> "double":
        r"""
        Gets and sets the taper half-angle of the cone in radians.
        A negative value indicates that the cone is narrowing in the direction of the 
        axis vector, whereas a positive value indicates that it is expanding in the direction of
        the axis vector.
        """
        return _core.Cone__get_halfAngle(self)

    def _set_halfAngle(self, value: "double") -> "bool":
        r"""
        Gets and sets the taper half-angle of the cone in radians.
        A negative value indicates that the cone is narrowing in the direction of the 
        axis vector, whereas a positive value indicates that it is expanding in the direction of
        the axis vector.
        """
        return _core.Cone__set_halfAngle(self, value)

    def getData(self) -> "bool":
        r"""
        Gets the data that defines the cone. 
        origin : The output origin point (center) of the base of the cone. 
        axis : The output center axis (along the length) of the cone that defines its normal direction. 
        radius : The output radius of the cone. 
        halfAngle : The output taper half-angle of the cone. 
        Returns true if successful.
        """
        return _core.Cone_getData(self)

    def set(self, origin: "Point3D", axis: "Vector3D", radius: "double", halfAngle: "double") -> "bool":
        r"""
        Sets the data that defines the cone. 
        origin : The origin point (center) of the base of the cone. 
        axis : The center axis (along the length) of the cone that defines its normal direction. 
        radius : The radius of the cone. 
        halfAngle : The taper half-angle of the cone. 
        Returns true if successful.
        """
        return _core.Cone_set(self, origin, axis, radius, halfAngle)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Cone >":
        r"""
        Creates and returns an independent copy of this Cone object. 
        Returns a new Cone object that is a copy of this Cone object.
        """
        return _core.Cone_copy(self)

    def _get_surfaceType(self) -> "adsk::core::SurfaceTypes":
        r"""Returns the surface type."""
        return _core.Cone__get_surfaceType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::SurfaceEvaluator >":
        r"""Returns the surface evaluator."""
        return _core.Cone__get_evaluator(self)

    def transformBy(self, matrix: "Matrix3D") -> "bool":
        r"""
        Updates this surface by transforming it with a given input matrix. 
        matrix : A 3D matrix that defines the transform to apply to the surface. 
        Returns true if the transform was successful.
        """
        return _core.Cone_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.Cone__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Cone__get_isValid(self)

# Register Cone in _core:
_core.Cone_swigregister(Cone)

def Cone_classType() -> "char const *":
    return _core.Cone_classType()

def Cone_create(origin: "Point3D", axis: "Vector3D", radius: "double", halfAngle: "double") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
    return _core.Cone_create(origin, axis, radius, halfAngle)


Cone.origin = property(Cone._get_origin, Cone._set_origin, doc="Gets and sets the origin point (center) of the base of the cone.")


Cone.axis = property(Cone._get_axis, Cone._set_axis, doc="Gets and sets the center axis (along the length) of the cone that defines its\nnormal direction.")


Cone.radius = property(Cone._get_radius, Cone._set_radius, doc="Gets and sets the radius of the cone.")


Cone.halfAngle = property(Cone._get_halfAngle, Cone._set_halfAngle, doc="Gets and sets the taper half-angle of the cone in radians.\nA negative value indicates that the cone is narrowing in the direction of the\naxis vector, whereas a positive value indicates that it is expanding in the direction of\nthe axis vector.")


Cone.cast = lambda arg: arg if isinstance(arg, Cone) else None

class CustomEvent(Event):
    r"""
    A CustomEvent is primarily used to send an event from a worker thread you've created back
    to your add-in, which is running in the primary thread. It's also possible for add-ins to
    cooperate and another add-in can trigger this event in your add-in by knowing the custom
    event id.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::CustomEvent *":
        return _core.CustomEvent___deref__(self)

    def __eq__(self, rhs: "CustomEvent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.CustomEvent___eq__(self, rhs)


    def __ne__(self, rhs: "CustomEvent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.CustomEvent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.CustomEvent_classType()
    __swig_destroy__ = _core.delete_CustomEvent

    def add(self, handler: "CustomEventHandler") -> "bool":
        r"""
        Add a handler to be notified when the event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _core.CustomEvent_add(self, handler)

    def remove(self, handler: "CustomEventHandler") -> "bool":
        r"""
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _core.CustomEvent_remove(self, handler)

    def _get_eventId(self) -> "std::string":
        r"""
        Returns the id that was assigned to this event when it was registered. Each
        custom event has it's own unique id.
        """
        return _core.CustomEvent__get_eventId(self)

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _core.CustomEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.CustomEvent__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _core.CustomEvent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.CustomEvent__get_isValid(self)

# Register CustomEvent in _core:
_core.CustomEvent_swigregister(CustomEvent)

def CustomEvent_classType() -> "char const *":
    return _core.CustomEvent_classType()


CustomEvent.eventId = property(CustomEvent._get_eventId, doc="Returns the id that was assigned to this event when it was registered. Each\ncustom event has it's own unique id.")


CustomEvent.cast = lambda arg: arg if isinstance(arg, CustomEvent) else None

class CustomEventArgs(EventArgs):
    r"""
    The ApplicationEventArgs provides information associated with an application event. 
    Note that some properties are not available on every event
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::CustomEventArgs *":
        return _core.CustomEventArgs___deref__(self)

    def __eq__(self, rhs: "CustomEventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.CustomEventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "CustomEventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.CustomEventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.CustomEventArgs_classType()
    __swig_destroy__ = _core.delete_CustomEventArgs

    def _get_additionalInfo(self) -> "std::string":
        r"""
        Information being passed to the add-in in the primary thread from the worker thread
        or other add-in.
        """
        return _core.CustomEventArgs__get_additionalInfo(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _core.CustomEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _core.CustomEventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.CustomEventArgs__get_isValid(self)

# Register CustomEventArgs in _core:
_core.CustomEventArgs_swigregister(CustomEventArgs)

def CustomEventArgs_classType() -> "char const *":
    return _core.CustomEventArgs_classType()


CustomEventArgs.additionalInfo = property(CustomEventArgs._get_additionalInfo, doc="Information being passed to the add-in in the primary thread from the worker thread\nor other add-in.")


CustomEventArgs.cast = lambda arg: arg if isinstance(arg, CustomEventArgs) else None

class Cylinder(Surface):
    r"""
    Transient cylinder. A transient cylinder is not displayed or saved in a document.
    A transient cylinder is but is used as a wrapper to work with raw cylinder information. 
    A transient cylinder has no boundaries and is infinite in length. 
    They are created statically using the create method of the Cylinder class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Cylinder *":
        return _core.Cylinder___deref__(self)

    def __eq__(self, rhs: "Cylinder") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Cylinder___eq__(self, rhs)


    def __ne__(self, rhs: "Cylinder") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Cylinder___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Cylinder_classType()

    @staticmethod
    def create(origin: "Point3D", axis: "Vector3D", radius: "double") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
        return _core.Cylinder_create(origin, axis, radius)
    __swig_destroy__ = _core.delete_Cylinder

    def _get_origin(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""The origin point (center) of the base of the cylinder."""
        return _core.Cylinder__get_origin(self)

    def _set_origin(self, value: "Point3D") -> "bool":
        r"""The origin point (center) of the base of the cylinder."""
        return _core.Cylinder__set_origin(self, value)

    def _get_axis(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""The center axis (along the length) of the cylinder that defines its normal direction."""
        return _core.Cylinder__get_axis(self)

    def _set_axis(self, value: "Vector3D") -> "bool":
        r"""The center axis (along the length) of the cylinder that defines its normal direction."""
        return _core.Cylinder__set_axis(self, value)

    def _get_radius(self) -> "double":
        r"""The radius of the cylinder."""
        return _core.Cylinder__get_radius(self)

    def _set_radius(self, value: "double") -> "bool":
        r"""The radius of the cylinder."""
        return _core.Cylinder__set_radius(self, value)

    def getData(self) -> "bool":
        r"""
        Gets the data that defines the cylinder. 
        origin : The output origin point (center) of the base of the cylinder. 
        axis : The output center axis (along the length) of the cylinder that defines its normal direction. 
        radius : The output radius of the cylinder. 
        Returns true if successful.
        """
        return _core.Cylinder_getData(self)

    def set(self, origin: "Point3D", axis: "Vector3D", radius: "double") -> "bool":
        r"""
        Sets the data that defines the cylinder. 
        origin : The origin point (center) of the base of the cylinder. 
        axis : The center axis (along the length) of the cylinder that defines its normal direction. 
        radius : The radius of the cylinder. 
        Returns true if successful.
        """
        return _core.Cylinder_set(self, origin, axis, radius)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Cylinder >":
        r"""
        Creates and returns an independent copy of this Cylinder object. 
        Returns a new Cylinder object that is a copy of this Cylinder object.
        """
        return _core.Cylinder_copy(self)

    def _get_surfaceType(self) -> "adsk::core::SurfaceTypes":
        r"""Returns the surface type."""
        return _core.Cylinder__get_surfaceType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::SurfaceEvaluator >":
        r"""Returns the surface evaluator."""
        return _core.Cylinder__get_evaluator(self)

    def transformBy(self, matrix: "Matrix3D") -> "bool":
        r"""
        Updates this surface by transforming it with a given input matrix. 
        matrix : A 3D matrix that defines the transform to apply to the surface. 
        Returns true if the transform was successful.
        """
        return _core.Cylinder_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.Cylinder__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Cylinder__get_isValid(self)

# Register Cylinder in _core:
_core.Cylinder_swigregister(Cylinder)

def Cylinder_classType() -> "char const *":
    return _core.Cylinder_classType()

def Cylinder_create(origin: "Point3D", axis: "Vector3D", radius: "double") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
    return _core.Cylinder_create(origin, axis, radius)


Cylinder.origin = property(Cylinder._get_origin, Cylinder._set_origin, doc="The origin point (center) of the base of the cylinder.")


Cylinder.axis = property(Cylinder._get_axis, Cylinder._set_axis, doc="The center axis (along the length) of the cylinder that defines its normal direction.")


Cylinder.radius = property(Cylinder._get_radius, Cylinder._set_radius, doc="The radius of the cylinder.")


Cylinder.cast = lambda arg: arg if isinstance(arg, Cylinder) else None

class DirectionCommandInput(CommandInput):
    r"""
    Represents a command input that gets a direction from the user. This displays
    a button or a checkbox in the command dialog where the user can flip the direction if desired and also displays
    a manipulator in the graphics window to allow flipping the direction by clicking and dragging on the manipulator.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::DirectionCommandInput *":
        return _core.DirectionCommandInput___deref__(self)

    def __eq__(self, rhs: "DirectionCommandInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.DirectionCommandInput___eq__(self, rhs)


    def __ne__(self, rhs: "DirectionCommandInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.DirectionCommandInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.DirectionCommandInput_classType()
    __swig_destroy__ = _core.delete_DirectionCommandInput

    def setManipulator(self, origin: "Point3D", direction: "Vector3D") -> "bool":
        r"""
        Defines a direction manipulator arrow in the graphics viewport whose direction can be flipped by the 
        toggling the checkbox, clicking the button or by the user clicking and dragging on the manipulator arrow. 
        origin : The origin point of the direction manipulator (arrow) in the model space of the root component. 
        direction : The direction of the manipulator (arrow) in the model space of the root component. 
        Returns true if successful
        """
        return _core.DirectionCommandInput_setManipulator(self, origin, direction)

    def _get_manipulatorOrigin(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""
        Gets the origin point of the direction manipulator (arrow) in the model space of the root component.
        To set the origin use the setManipulator method.
        """
        return _core.DirectionCommandInput__get_manipulatorOrigin(self)

    def _get_manipulatorDirection(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Gets the direction of the manipulator (arrow) in the model space of the root component.
        To set the direction use the setManipulator method.
        """
        return _core.DirectionCommandInput__get_manipulatorDirection(self)

    def _get_isDirectionFlipped(self) -> "bool":
        r"""
        Gets and sets if the direction manipulator displayed is flipped (reversed 180 degrees as compared to the 
        direction defined by the manipulatorDirection property). This is false for a newly created DirectionCommandInput.
        """
        return _core.DirectionCommandInput__get_isDirectionFlipped(self)

    def _set_isDirectionFlipped(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the direction manipulator displayed is flipped (reversed 180 degrees as compared to the 
        direction defined by the manipulatorDirection property). This is false for a newly created DirectionCommandInput.
        """
        return _core.DirectionCommandInput__set_isDirectionFlipped(self, value)

    def _get_resourceFolder(self) -> "std::string":
        r"""
        Gets and sets the folder that contains the image to display on the button.
        The input is shown as a check box if set resource folder to empty.
        """
        return _core.DirectionCommandInput__get_resourceFolder(self)

    def _set_resourceFolder(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the folder that contains the image to display on the button.
        The input is shown as a check box if set resource folder to empty.
        """
        return _core.DirectionCommandInput__set_resourceFolder(self, value)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.DirectionCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string":
        r"""Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.DirectionCommandInput__get_id(self)

    def _get_name(self) -> "std::string":
        r"""Gets the user visible name of this input."""
        return _core.DirectionCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.DirectionCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.DirectionCommandInput__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.DirectionCommandInput__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.DirectionCommandInput__set_isVisible(self, value)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the parent Command."""
        return _core.DirectionCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.DirectionCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.DirectionCommandInput__set_isFullWidth(self, value)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.DirectionCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.DirectionCommandInput__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.DirectionCommandInput__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.DirectionCommandInput__set_tooltip(self, value)

    def _get_tooltipDescription(self) -> "std::string":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.DirectionCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.DirectionCommandInput__set_tooltipDescription(self, value)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.DirectionCommandInput__get_parentCommandInput(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this Command input. 
        Returns true if the delete was successful.
        """
        return _core.DirectionCommandInput_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.DirectionCommandInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.DirectionCommandInput__get_isValid(self)

# Register DirectionCommandInput in _core:
_core.DirectionCommandInput_swigregister(DirectionCommandInput)

def DirectionCommandInput_classType() -> "char const *":
    return _core.DirectionCommandInput_classType()


DirectionCommandInput.manipulatorOrigin = property(DirectionCommandInput._get_manipulatorOrigin, doc="Gets the origin point of the direction manipulator (arrow) in the model space of the root component.\nTo set the origin use the setManipulator method.")


DirectionCommandInput.manipulatorDirection = property(DirectionCommandInput._get_manipulatorDirection, doc="Gets the direction of the manipulator (arrow) in the model space of the root component.\nTo set the direction use the setManipulator method.")


DirectionCommandInput.isDirectionFlipped = property(DirectionCommandInput._get_isDirectionFlipped, DirectionCommandInput._set_isDirectionFlipped, doc="Gets and sets if the direction manipulator displayed is flipped (reversed 180 degrees as compared to the\ndirection defined by the manipulatorDirection property). This is false for a newly created DirectionCommandInput.")


DirectionCommandInput.resourceFolder = property(DirectionCommandInput._get_resourceFolder, DirectionCommandInput._set_resourceFolder, doc="Gets and sets the folder that contains the image to display on the button.\nThe input is shown as a check box if set resource folder to empty.")


DirectionCommandInput.cast = lambda arg: arg if isinstance(arg, DirectionCommandInput) else None

class DistanceValueCommandInput(CommandInput):
    r"""
    Represents a command input that gets a distance from the user. This displays
    an entry in the command dialog where the user can enter a value and also displays
    a manipulator in the graphics window to allow them to graphically set the value.
    The input box is displayed in the dialog when the isVisible property of the command
    input is true. The manipulator is displayed in the graphics when both the isVisible
    and isEnabled properties are true.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::DistanceValueCommandInput *":
        return _core.DistanceValueCommandInput___deref__(self)

    def __eq__(self, rhs: "DistanceValueCommandInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.DistanceValueCommandInput___eq__(self, rhs)


    def __ne__(self, rhs: "DistanceValueCommandInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.DistanceValueCommandInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.DistanceValueCommandInput_classType()
    __swig_destroy__ = _core.delete_DistanceValueCommandInput

    def _get_value(self) -> "double":
        r"""
        Gets and sets the current value of the command input. The value is
        in centimeters but will be displayed to the user in the current default
        document units. Setting this value can fail if the input value is 
        not within the minimum and maximum value range.
        The isValidExpression property should be checked before using this
        value within the command because if the expression can't be evaluated
        there isn't a valid value. Fusion 360 won't allow the execution of a command
        that contains ValueCommandInput object with invalid expressions so you can
        dependably use the value in the execute event of the command.
        """
        return _core.DistanceValueCommandInput__get_value(self)

    def _set_value(self, value: "double") -> "bool":
        r"""
        Gets and sets the current value of the command input. The value is
        in centimeters but will be displayed to the user in the current default
        document units. Setting this value can fail if the input value is 
        not within the minimum and maximum value range.
        The isValidExpression property should be checked before using this
        value within the command because if the expression can't be evaluated
        there isn't a valid value. Fusion 360 won't allow the execution of a command
        that contains ValueCommandInput object with invalid expressions so you can
        dependably use the value in the execute event of the command.
        """
        return _core.DistanceValueCommandInput__set_value(self, value)

    def _get_expression(self) -> "std::string":
        r"""
        Gets or sets the expression displayed in the input field. This can contain equations and
        references to parameters but must result in a valid length expression. If units are not
        specified as part of the expression, the default units for the design are used.
        """
        return _core.DistanceValueCommandInput__get_expression(self)

    def _set_expression(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the expression displayed in the input field. This can contain equations and
        references to parameters but must result in a valid length expression. If units are not
        specified as part of the expression, the default units for the design are used.
        """
        return _core.DistanceValueCommandInput__set_expression(self, value)

    def _get_minimumValue(self) -> "double":
        r"""
        Gets and sets minimum value, if any, that the value can be. When getting this
        property you should first check the hasMinimumValue property to see if this property
        applies. Also, the isMinimumValueInclusive indicates if the minimum includes this
        value or will be up to this value.
        Setting this value will change the isMinimumValueInclusive to True and the hasMinimumValue property to True if hasMinimumValue is currently
        False, otherwise it will just update the value.
        """
        return _core.DistanceValueCommandInput__get_minimumValue(self)

    def _set_minimumValue(self, value: "double") -> "bool":
        r"""
        Gets and sets minimum value, if any, that the value can be. When getting this
        property you should first check the hasMinimumValue property to see if this property
        applies. Also, the isMinimumValueInclusive indicates if the minimum includes this
        value or will be up to this value.
        Setting this value will change the isMinimumValueInclusive to True and the hasMinimumValue property to True if hasMinimumValue is currently
        False, otherwise it will just update the value.
        """
        return _core.DistanceValueCommandInput__set_minimumValue(self, value)

    def _get_hasMinimumValue(self) -> "bool":
        r"""
        Gets and sets if there is a minimum value for this command input. When setting this property, it is only valid
        to set it to False to remove the minimum value. Setting the minimumValue property will result in this property
        being set to True.
        """
        return _core.DistanceValueCommandInput__get_hasMinimumValue(self)

    def _set_hasMinimumValue(self, value: "bool") -> "bool":
        r"""
        Gets and sets if there is a minimum value for this command input. When setting this property, it is only valid
        to set it to False to remove the minimum value. Setting the minimumValue property will result in this property
        being set to True.
        """
        return _core.DistanceValueCommandInput__set_hasMinimumValue(self, value)

    def _get_isMinimumValueInclusive(self) -> "bool":
        r"""
        Gets and sets if the value of the input includes the minimum value or is up to the minimum value. For example,
        if the minimum value is zero and this property is True, the minimum value can be zero. If this is False, the 
        minimum value must be greater than zero. When the minimum value is first defined using the minimumValue property,
        this property is set to True. The value returned by this property is only meaningful when the hasMinimumValue property
        returns True.
        """
        return _core.DistanceValueCommandInput__get_isMinimumValueInclusive(self)

    def _set_isMinimumValueInclusive(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the value of the input includes the minimum value or is up to the minimum value. For example,
        if the minimum value is zero and this property is True, the minimum value can be zero. If this is False, the 
        minimum value must be greater than zero. When the minimum value is first defined using the minimumValue property,
        this property is set to True. The value returned by this property is only meaningful when the hasMinimumValue property
        returns True.
        """
        return _core.DistanceValueCommandInput__set_isMinimumValueInclusive(self, value)

    def _get_maximumValue(self) -> "double":
        r"""
        Gets and sets maximum value, if any, that the value can be. When getting this
        property you should first check the hasMaximumValue property to see if this property
        applies. Also, the isMaximumValueInclusive indicates if the maximum includes this
        value or will be up to this value.
        """
        return _core.DistanceValueCommandInput__get_maximumValue(self)

    def _set_maximumValue(self, value: "double") -> "bool":
        r"""
        Gets and sets maximum value, if any, that the value can be. When getting this
        property you should first check the hasMaximumValue property to see if this property
        applies. Also, the isMaximumValueInclusive indicates if the maximum includes this
        value or will be up to this value.
        """
        return _core.DistanceValueCommandInput__set_maximumValue(self, value)

    def _get_hasMaximumValue(self) -> "bool":
        r"""
        Gets and sets if there is a maximum value for this command input. When setting this property, it is only valid
        to set it to False to remove the maximum value. Setting the maximumValue property will result in this property
        being set to True.
        """
        return _core.DistanceValueCommandInput__get_hasMaximumValue(self)

    def _set_hasMaximumValue(self, value: "bool") -> "bool":
        r"""
        Gets and sets if there is a maximum value for this command input. When setting this property, it is only valid
        to set it to False to remove the maximum value. Setting the maximumValue property will result in this property
        being set to True.
        """
        return _core.DistanceValueCommandInput__set_hasMaximumValue(self, value)

    def _get_isMaximumValueInclusive(self) -> "bool":
        r"""
        Gets and sets if the value of the input includes the maximum value or is up to the maximum value. For example,
        if the maximum value is 100 and this property is True, the maximum value can be 100. If this is False, the 
        minimum value must be less than 100. When the maximum value is first defined using the maximumValue property,
        this property is set to True. The value returned by this property is only meaninful when the hasMaximumValue property
        returns True.
        """
        return _core.DistanceValueCommandInput__get_isMaximumValueInclusive(self)

    def _set_isMaximumValueInclusive(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the value of the input includes the maximum value or is up to the maximum value. For example,
        if the maximum value is 100 and this property is True, the maximum value can be 100. If this is False, the 
        minimum value must be less than 100. When the maximum value is first defined using the maximumValue property,
        this property is set to True. The value returned by this property is only meaninful when the hasMaximumValue property
        returns True.
        """
        return _core.DistanceValueCommandInput__set_isMaximumValueInclusive(self, value)

    def setManipulator(self, origin: "Point3D", direction: "Vector3D") -> "bool":
        r"""
        Defines the position and orientation of the manipulator. The manipulator is only visible
        when both the isVisible and isEnabled properties are true. If those properties are
        true and the setManipulator has not been called, the manipulator will be displayed in
        a default location (0,0,0) and direction (1,0,0). Because of that the input is typically
        set to be invisible and/or disabled and then enabled once enough input has been specified
        that you can display the manipulator in the desired location. 
        origin : Defines the position of the manipulator in root component space. 
        direction : Defines the direction of the manipulator in root component space. 
        Returns true if successful.
        """
        return _core.DistanceValueCommandInput_setManipulator(self, origin, direction)

    def _get_manipulatorOrigin(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""
        Gets the origin point of the manipulator in the model space of the root component.
        To set the origin use the setManipulator method.
        """
        return _core.DistanceValueCommandInput__get_manipulatorOrigin(self)

    def _get_manipulatorDirection(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Gets the positive direction of the manipulator in the model space or the root component.
        To set the direction use the setManipulator method.
        """
        return _core.DistanceValueCommandInput__get_manipulatorDirection(self)

    def _get_isValidExpression(self) -> "bool":
        r"""
        Returns true if the current expression is valid and can be evaluated. If this
        is false, the value returned should be ignored because there currently is
        not a valid value.
        """
        return _core.DistanceValueCommandInput__get_isValidExpression(self)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.DistanceValueCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string":
        r"""Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.DistanceValueCommandInput__get_id(self)

    def _get_name(self) -> "std::string":
        r"""Gets the user visible name of this input."""
        return _core.DistanceValueCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.DistanceValueCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.DistanceValueCommandInput__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.DistanceValueCommandInput__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.DistanceValueCommandInput__set_isVisible(self, value)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the parent Command."""
        return _core.DistanceValueCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.DistanceValueCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.DistanceValueCommandInput__set_isFullWidth(self, value)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.DistanceValueCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.DistanceValueCommandInput__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.DistanceValueCommandInput__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.DistanceValueCommandInput__set_tooltip(self, value)

    def _get_tooltipDescription(self) -> "std::string":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.DistanceValueCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.DistanceValueCommandInput__set_tooltipDescription(self, value)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.DistanceValueCommandInput__get_parentCommandInput(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this Command input. 
        Returns true if the delete was successful.
        """
        return _core.DistanceValueCommandInput_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.DistanceValueCommandInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.DistanceValueCommandInput__get_isValid(self)

# Register DistanceValueCommandInput in _core:
_core.DistanceValueCommandInput_swigregister(DistanceValueCommandInput)

def DistanceValueCommandInput_classType() -> "char const *":
    return _core.DistanceValueCommandInput_classType()


DistanceValueCommandInput.value = property(DistanceValueCommandInput._get_value, DistanceValueCommandInput._set_value, doc="Gets and sets the current value of the command input. The value is\nin centimeters but will be displayed to the user in the current default\ndocument units. Setting this value can fail if the input value is\nnot within the minimum and maximum value range.\nThe isValidExpression property should be checked before using this\nvalue within the command because if the expression can't be evaluated\nthere isn't a valid value. Fusion 360 won't allow the execution of a command\nthat contains ValueCommandInput object with invalid expressions so you can\ndependably use the value in the execute event of the command.")


DistanceValueCommandInput.expression = property(DistanceValueCommandInput._get_expression, DistanceValueCommandInput._set_expression, doc="Gets or sets the expression displayed in the input field. This can contain equations and\nreferences to parameters but must result in a valid length expression. If units are not\nspecified as part of the expression, the default units for the design are used.")


DistanceValueCommandInput.minimumValue = property(DistanceValueCommandInput._get_minimumValue, DistanceValueCommandInput._set_minimumValue, doc="Gets and sets minimum value, if any, that the value can be. When getting this\nproperty you should first check the hasMinimumValue property to see if this property\napplies. Also, the isMinimumValueInclusive indicates if the minimum includes this\nvalue or will be up to this value.\nSetting this value will change the isMinimumValueInclusive to True and the hasMinimumValue property to True if hasMinimumValue is currently\nFalse, otherwise it will just update the value.")


DistanceValueCommandInput.hasMinimumValue = property(DistanceValueCommandInput._get_hasMinimumValue, DistanceValueCommandInput._set_hasMinimumValue, doc="Gets and sets if there is a minimum value for this command input. When setting this property, it is only valid\nto set it to False to remove the minimum value. Setting the minimumValue property will result in this property\nbeing set to True.")


DistanceValueCommandInput.isMinimumValueInclusive = property(DistanceValueCommandInput._get_isMinimumValueInclusive, DistanceValueCommandInput._set_isMinimumValueInclusive, doc="Gets and sets if the value of the input includes the minimum value or is up to the minimum value. For example,\nif the minimum value is zero and this property is True, the minimum value can be zero. If this is False, the\nminimum value must be greater than zero. When the minimum value is first defined using the minimumValue property,\nthis property is set to True. The value returned by this property is only meaningful when the hasMinimumValue property\nreturns True.")


DistanceValueCommandInput.maximumValue = property(DistanceValueCommandInput._get_maximumValue, DistanceValueCommandInput._set_maximumValue, doc="Gets and sets maximum value, if any, that the value can be. When getting this\nproperty you should first check the hasMaximumValue property to see if this property\napplies. Also, the isMaximumValueInclusive indicates if the maximum includes this\nvalue or will be up to this value.")


DistanceValueCommandInput.hasMaximumValue = property(DistanceValueCommandInput._get_hasMaximumValue, DistanceValueCommandInput._set_hasMaximumValue, doc="Gets and sets if there is a maximum value for this command input. When setting this property, it is only valid\nto set it to False to remove the maximum value. Setting the maximumValue property will result in this property\nbeing set to True.")


DistanceValueCommandInput.isMaximumValueInclusive = property(DistanceValueCommandInput._get_isMaximumValueInclusive, DistanceValueCommandInput._set_isMaximumValueInclusive, doc="Gets and sets if the value of the input includes the maximum value or is up to the maximum value. For example,\nif the maximum value is 100 and this property is True, the maximum value can be 100. If this is False, the\nminimum value must be less than 100. When the maximum value is first defined using the maximumValue property,\nthis property is set to True. The value returned by this property is only meaninful when the hasMaximumValue property\nreturns True.")


DistanceValueCommandInput.manipulatorOrigin = property(DistanceValueCommandInput._get_manipulatorOrigin, doc="Gets the origin point of the manipulator in the model space of the root component.\nTo set the origin use the setManipulator method.")


DistanceValueCommandInput.manipulatorDirection = property(DistanceValueCommandInput._get_manipulatorDirection, doc="Gets the positive direction of the manipulator in the model space or the root component.\nTo set the direction use the setManipulator method.")


DistanceValueCommandInput.isValidExpression = property(DistanceValueCommandInput._get_isValidExpression, doc="Returns true if the current expression is valid and can be evaluated. If this\nis false, the value returned should be ignored because there currently is\nnot a valid value.")


DistanceValueCommandInput.cast = lambda arg: arg if isinstance(arg, DistanceValueCommandInput) else None

class DocumentEvent(Event):
    r"""A DocumentEvent represents a document related event. For example, DocumentOpening or DocumentOpened."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::DocumentEvent *":
        return _core.DocumentEvent___deref__(self)

    def __eq__(self, rhs: "DocumentEvent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.DocumentEvent___eq__(self, rhs)


    def __ne__(self, rhs: "DocumentEvent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.DocumentEvent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.DocumentEvent_classType()
    __swig_destroy__ = _core.delete_DocumentEvent

    def add(self, handler: "DocumentEventHandler") -> "bool":
        r"""
        Add a handler to be notified when the file event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _core.DocumentEvent_add(self, handler)

    def remove(self, handler: "DocumentEventHandler") -> "bool":
        r"""
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _core.DocumentEvent_remove(self, handler)

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _core.DocumentEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.DocumentEvent__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _core.DocumentEvent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.DocumentEvent__get_isValid(self)

# Register DocumentEvent in _core:
_core.DocumentEvent_swigregister(DocumentEvent)

def DocumentEvent_classType() -> "char const *":
    return _core.DocumentEvent_classType()


DocumentEvent.cast = lambda arg: arg if isinstance(arg, DocumentEvent) else None

class DocumentEventArgs(EventArgs):
    r"""
    The DocumentEventArgs provides information associated with a document event. 
    Note that some properties are not available on every event 
    - for example, the Document is not available on the DocumentOpening event because 
    the Document is not yet available.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::DocumentEventArgs *":
        return _core.DocumentEventArgs___deref__(self)

    def __eq__(self, rhs: "DocumentEventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.DocumentEventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "DocumentEventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.DocumentEventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.DocumentEventArgs_classType()
    __swig_destroy__ = _core.delete_DocumentEventArgs

    def _get_document(self) -> "adsk::core::Ptr< adsk::core::Document >":
        r"""
        Provides access to the document that is open. Can be null in the case
        where the event is fired before the document has been opened or after it has been closed.
        """
        return _core.DocumentEventArgs__get_document(self)

    def _get_fullPath(self) -> "std::string":
        r"""The full path to the file."""
        return _core.DocumentEventArgs__get_fullPath(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _core.DocumentEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _core.DocumentEventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.DocumentEventArgs__get_isValid(self)

# Register DocumentEventArgs in _core:
_core.DocumentEventArgs_swigregister(DocumentEventArgs)

def DocumentEventArgs_classType() -> "char const *":
    return _core.DocumentEventArgs_classType()


DocumentEventArgs.document = property(DocumentEventArgs._get_document, doc="Provides access to the document that is open. Can be null in the case\nwhere the event is fired before the document has been opened or after it has been closed.")


DocumentEventArgs.fullPath = property(DocumentEventArgs._get_fullPath, doc="The full path to the file.")


DocumentEventArgs.cast = lambda arg: arg if isinstance(arg, DocumentEventArgs) else None

class DropDownCommandInput(CommandInput):
    r"""Provides a command input to get the choice in a dropdown list from the user."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::DropDownCommandInput *":
        return _core.DropDownCommandInput___deref__(self)

    def __eq__(self, rhs: "DropDownCommandInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.DropDownCommandInput___eq__(self, rhs)


    def __ne__(self, rhs: "DropDownCommandInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.DropDownCommandInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.DropDownCommandInput_classType()
    __swig_destroy__ = _core.delete_DropDownCommandInput

    def _get_dropDownStyle(self) -> "adsk::core::DropDownStyles":
        r"""Returns the style of drop down this was created as."""
        return _core.DropDownCommandInput__get_dropDownStyle(self)

    def _get_listItems(self) -> "adsk::core::Ptr< adsk::core::ListItems >":
        r"""
        Returns the ListItems object associated with this drop-down. You use this
        object to populate and interact with the items in the drop-down.
        """
        return _core.DropDownCommandInput__get_listItems(self)

    def _get_selectedItem(self) -> "adsk::core::Ptr< adsk::core::ListItem >":
        r"""
        Gets the item in the list that is currently selected. This can return null in the 
        case where no item in the list has been selected. This should be ignored
        for CheckBoxDropDownStyle style drop-downs because multiple items can be selected
        and each LiteItem should be checked individually.
        """
        return _core.DropDownCommandInput__get_selectedItem(self)

    def _get_maxVisibleItems(self) -> "int":
        r"""Gets or sets the maximum allowed size on screen of the drop down list, measured in items."""
        return _core.DropDownCommandInput__get_maxVisibleItems(self)

    def _set_maxVisibleItems(self, value: "int") -> "bool":
        r"""Gets or sets the maximum allowed size on screen of the drop down list, measured in items."""
        return _core.DropDownCommandInput__set_maxVisibleItems(self, value)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.DropDownCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string":
        r"""Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.DropDownCommandInput__get_id(self)

    def _get_name(self) -> "std::string":
        r"""Gets the user visible name of this input."""
        return _core.DropDownCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.DropDownCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.DropDownCommandInput__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.DropDownCommandInput__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.DropDownCommandInput__set_isVisible(self, value)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the parent Command."""
        return _core.DropDownCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.DropDownCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.DropDownCommandInput__set_isFullWidth(self, value)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.DropDownCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.DropDownCommandInput__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.DropDownCommandInput__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.DropDownCommandInput__set_tooltip(self, value)

    def _get_tooltipDescription(self) -> "std::string":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.DropDownCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.DropDownCommandInput__set_tooltipDescription(self, value)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.DropDownCommandInput__get_parentCommandInput(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this Command input. 
        Returns true if the delete was successful.
        """
        return _core.DropDownCommandInput_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.DropDownCommandInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.DropDownCommandInput__get_isValid(self)

# Register DropDownCommandInput in _core:
_core.DropDownCommandInput_swigregister(DropDownCommandInput)

def DropDownCommandInput_classType() -> "char const *":
    return _core.DropDownCommandInput_classType()


DropDownCommandInput.dropDownStyle = property(DropDownCommandInput._get_dropDownStyle, doc="Returns the style of drop down this was created as.")


DropDownCommandInput.listItems = property(DropDownCommandInput._get_listItems, doc="Returns the ListItems object associated with this drop-down. You use this\nobject to populate and interact with the items in the drop-down.")


DropDownCommandInput.selectedItem = property(DropDownCommandInput._get_selectedItem, doc="Gets the item in the list that is currently selected. This can return null in the\ncase where no item in the list has been selected. This should be ignored\nfor CheckBoxDropDownStyle style drop-downs because multiple items can be selected\nand each LiteItem should be checked individually.")


DropDownCommandInput.maxVisibleItems = property(DropDownCommandInput._get_maxVisibleItems, DropDownCommandInput._set_maxVisibleItems, doc="Gets or sets the maximum allowed size on screen of the drop down list, measured in items.")


DropDownCommandInput.cast = lambda arg: arg if isinstance(arg, DropDownCommandInput) else None

class DropDownControl(ToolbarControl):
    r"""Represents a drop-down control."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::DropDownControl *":
        return _core.DropDownControl___deref__(self)

    def __eq__(self, rhs: "DropDownControl") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.DropDownControl___eq__(self, rhs)


    def __ne__(self, rhs: "DropDownControl") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.DropDownControl___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.DropDownControl_classType()
    __swig_destroy__ = _core.delete_DropDownControl

    def _get_controls(self) -> "adsk::core::Ptr< adsk::core::ToolbarControls >":
        r"""Gets the associated ToolbarControls collection. Through this you can add additional controls to the drop-down."""
        return _core.DropDownControl__get_controls(self)

    def _get_resourceFolder(self) -> "std::string":
        r"""Gets or sets the resource folder containing the image used for the icon when the drop-down is in a toolbar."""
        return _core.DropDownControl__get_resourceFolder(self)

    def _set_resourceFolder(self, value: "std::string const &") -> "bool":
        r"""Gets or sets the resource folder containing the image used for the icon when the drop-down is in a toolbar."""
        return _core.DropDownControl__set_resourceFolder(self, value)

    def _get_name(self) -> "std::string":
        r"""Gets or sets the Name displayed for this drop down. This isn't used when the drop-down is in a toolbar because an icon is used in that case."""
        return _core.DropDownControl__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Gets or sets the Name displayed for this drop down. This isn't used when the drop-down is in a toolbar because an icon is used in that case."""
        return _core.DropDownControl__set_name(self, value)

    def _get_id(self) -> "std::string":
        r"""
        Gets the unique ID of this control. The ID is unique with respect to the other
        controls within the same panel, toolbar, or drop-down control.
        """
        return _core.DropDownControl__get_id(self)

    def _get_index(self) -> "size_t":
        r"""Gets the position of this control within the list of controls within the panel, toolbar, or drop-down control."""
        return _core.DropDownControl__get_index(self)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this control is currently visible."""
        return _core.DropDownControl__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this control is currently visible."""
        return _core.DropDownControl__set_isVisible(self, value)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets the Parent object. When associated with a toolbar (right or left QAT or the Nav Bar) this
        returns the parent Toolbar object. When associated with a panel it returns the parent ToolbarPanel object.
        When associated with a control (DropDownControl) it returns the parent control.
        """
        return _core.DropDownControl__get_parent(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the ToolbarControl 
        Returns a boolean indicating if the deletion was successful.
        """
        return _core.DropDownControl_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.DropDownControl__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.DropDownControl__get_isValid(self)

# Register DropDownControl in _core:
_core.DropDownControl_swigregister(DropDownControl)

def DropDownControl_classType() -> "char const *":
    return _core.DropDownControl_classType()


DropDownControl.controls = property(DropDownControl._get_controls, doc="Gets the associated ToolbarControls collection. Through this you can add additional controls to the drop-down.")


DropDownControl.resourceFolder = property(DropDownControl._get_resourceFolder, DropDownControl._set_resourceFolder, doc="Gets or sets the resource folder containing the image used for the icon when the drop-down is in a toolbar.")


DropDownControl.name = property(DropDownControl._get_name, DropDownControl._set_name, doc="Gets or sets the Name displayed for this drop down. This isn't used when the drop-down is in a toolbar because an icon is used in that case.")


DropDownControl.cast = lambda arg: arg if isinstance(arg, DropDownControl) else None

class DXF2DImportOptions(ImportOptions):
    r"""
    Defines that a 2D DXF Import to create sketches (based on layers in the DXF file) is to be performed and 
    specifies the various options.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::DXF2DImportOptions *":
        return _core.DXF2DImportOptions___deref__(self)

    def __eq__(self, rhs: "DXF2DImportOptions") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.DXF2DImportOptions___eq__(self, rhs)


    def __ne__(self, rhs: "DXF2DImportOptions") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.DXF2DImportOptions___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.DXF2DImportOptions_classType()
    __swig_destroy__ = _core.delete_DXF2DImportOptions

    def _get_planarEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the construction plane or planar face that defines the plane that the resulting sketches will
        be created on.
        """
        return _core.DXF2DImportOptions__get_planarEntity(self)

    def _set_planarEntity(self, value: "Base") -> "bool":
        r"""
        Gets and sets the construction plane or planar face that defines the plane that the resulting sketches will
        be created on.
        """
        return _core.DXF2DImportOptions__set_planarEntity(self, value)

    def _get_position(self) -> "adsk::core::Ptr< adsk::core::Point2D >":
        r"""
        Gets and sets the X,Y offset position for the origin of the imported DXF data relative to the sketch origin.
        This defaults to (0,0) in a newly created DXF2DImportOptions object.
        """
        return _core.DXF2DImportOptions__get_position(self)

    def _set_position(self, value: "Point2D") -> "bool":
        r"""
        Gets and sets the X,Y offset position for the origin of the imported DXF data relative to the sketch origin.
        This defaults to (0,0) in a newly created DXF2DImportOptions object.
        """
        return _core.DXF2DImportOptions__set_position(self, value)

    def _get_results(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Returns a collection of Sketch objects. A sketch is created for each layer in the dxf file 
        that contains 2D geometry. Any 3D geometry contained in the DXF file is ignored.
        The names of the resulting sketches correspond to the layer names in the DXF file.
        Currently, the only way to get a single sketch as a result is to supply a DXF file that only has 2D geometry
        on a single layer.
        """
        return _core.DXF2DImportOptions__get_results(self)

    def _get_isSingleSketchResult(self) -> "bool":
        r"""
        Gets and sets if importing the DXF file should create a new sketch for each layer or
        if the entire contents of the DXF file should be merged into a single layer. If true
        a single sketch will be created. If false a new sketch for each layer will be created
        where the sketch name will be the name of the layer. The default value for this
        property is false, resulting in a sketch for each layer.
        """
        return _core.DXF2DImportOptions__get_isSingleSketchResult(self)

    def _set_isSingleSketchResult(self, value: "bool") -> "bool":
        r"""
        Gets and sets if importing the DXF file should create a new sketch for each layer or
        if the entire contents of the DXF file should be merged into a single layer. If true
        a single sketch will be created. If false a new sketch for each layer will be created
        where the sketch name will be the name of the layer. The default value for this
        property is false, resulting in a sketch for each layer.
        """
        return _core.DXF2DImportOptions__set_isSingleSketchResult(self, value)

    def _get_filename(self) -> "std::string":
        r"""Gets and sets the filename or url of the file to be imported."""
        return _core.DXF2DImportOptions__get_filename(self)

    def _set_filename(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the filename or url of the file to be imported."""
        return _core.DXF2DImportOptions__set_filename(self, value)

    def _get_isViewFit(self) -> "bool":
        r"""
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.DXF2DImportOptions__get_isViewFit(self)

    def _set_isViewFit(self, value: "bool") -> "bool":
        r"""
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.DXF2DImportOptions__set_isViewFit(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.DXF2DImportOptions__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.DXF2DImportOptions__get_isValid(self)

# Register DXF2DImportOptions in _core:
_core.DXF2DImportOptions_swigregister(DXF2DImportOptions)

def DXF2DImportOptions_classType() -> "char const *":
    return _core.DXF2DImportOptions_classType()


DXF2DImportOptions.planarEntity = property(DXF2DImportOptions._get_planarEntity, DXF2DImportOptions._set_planarEntity, doc="Gets and sets the construction plane or planar face that defines the plane that the resulting sketches will\nbe created on.")


DXF2DImportOptions.position = property(DXF2DImportOptions._get_position, DXF2DImportOptions._set_position, doc="Gets and sets the X,Y offset position for the origin of the imported DXF data relative to the sketch origin.\nThis defaults to (0,0) in a newly created DXF2DImportOptions object.")


DXF2DImportOptions.results = property(DXF2DImportOptions._get_results, doc="Returns a collection of Sketch objects. A sketch is created for each layer in the dxf file\nthat contains 2D geometry. Any 3D geometry contained in the DXF file is ignored.\nThe names of the resulting sketches correspond to the layer names in the DXF file.\nCurrently, the only way to get a single sketch as a result is to supply a DXF file that only has 2D geometry\non a single layer.")


DXF2DImportOptions.isSingleSketchResult = property(DXF2DImportOptions._get_isSingleSketchResult, DXF2DImportOptions._set_isSingleSketchResult, doc="Gets and sets if importing the DXF file should create a new sketch for each layer or\nif the entire contents of the DXF file should be merged into a single layer. If true\na single sketch will be created. If false a new sketch for each layer will be created\nwhere the sketch name will be the name of the layer. The default value for this\nproperty is false, resulting in a sketch for each layer.")


DXF2DImportOptions.cast = lambda arg: arg if isinstance(arg, DXF2DImportOptions) else None

class Ellipse2D(Curve2D):
    r"""
    Transient 2D ellipse. A transient ellipse is not displayed or saved in a document.
    Transient 2D ellipses are used as a wrapper to work with raw 2D ellipse information.
    They are created statically using the create method of the Ellipse2D class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Ellipse2D *":
        return _core.Ellipse2D___deref__(self)

    def __eq__(self, rhs: "Ellipse2D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Ellipse2D___eq__(self, rhs)


    def __ne__(self, rhs: "Ellipse2D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Ellipse2D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Ellipse2D_classType()

    @staticmethod
    def create(center: "Point2D", majorAxis: "Vector2D", majorRadius: "double", minorRadius: "double") -> "adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Vector2D > const &":
        return _core.Ellipse2D_create(center, majorAxis, majorRadius, minorRadius)
    __swig_destroy__ = _core.delete_Ellipse2D

    def _get_center(self) -> "adsk::core::Ptr< adsk::core::Point2D >":
        r"""Gets and sets the center position of the ellipse."""
        return _core.Ellipse2D__get_center(self)

    def _set_center(self, value: "Point2D") -> "bool":
        r"""Gets and sets the center position of the ellipse."""
        return _core.Ellipse2D__set_center(self, value)

    def _get_majorAxis(self) -> "adsk::core::Ptr< adsk::core::Vector2D >":
        r"""Gets and sets the major axis of the ellipse."""
        return _core.Ellipse2D__get_majorAxis(self)

    def _set_majorAxis(self, value: "Vector2D") -> "bool":
        r"""Gets and sets the major axis of the ellipse."""
        return _core.Ellipse2D__set_majorAxis(self, value)

    def _get_majorRadius(self) -> "double":
        r"""Gets and sets the major radius of the ellipse."""
        return _core.Ellipse2D__get_majorRadius(self)

    def _set_majorRadius(self, value: "double") -> "bool":
        r"""Gets and sets the major radius of the ellipse."""
        return _core.Ellipse2D__set_majorRadius(self, value)

    def _get_minorRadius(self) -> "double":
        r"""Gets and sets the minor radius of the ellipse."""
        return _core.Ellipse2D__get_minorRadius(self)

    def _set_minorRadius(self, value: "double") -> "bool":
        r"""Gets and sets the minor radius of the ellipse."""
        return _core.Ellipse2D__set_minorRadius(self, value)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Ellipse2D >":
        r"""
        Creates and returns a copy of this Ellipse2D object. 
        Returns a new Ellipse2D object that is a copy of this Ellipse2D object.
        """
        return _core.Ellipse2D_copy(self)

    def getData(self) -> "bool":
        r"""
        Gets all of the data defining the ellipse. 
        center : The output center point of the ellipse. 
        majorAxis : The output major axis of the ellipse. 
        majorRadius : The output major radius of the of the ellipse. 
        minorRadius : The output minor radius of the of the ellipse. 
        Returns true if successful.
        """
        return _core.Ellipse2D_getData(self)

    def set(self, center: "Point2D", majorAxis: "Vector2D", majorRadius: "double", minorRadius: "double") -> "bool":
        r"""
        Sets all of the data defining the ellipse. 
        center : A Point2D object that defines the center of the ellipse. 
        majorAxis : The major axis of the ellipse. 
        majorRadius : The major radius of the of the ellipse. 
        minorRadius : The minor radius of the of the ellipse. 
        Returns true if redefining the ellipse is successful.
        """
        return _core.Ellipse2D_set(self, center, majorAxis, majorRadius, minorRadius)

    def _get_asNurbsCurve(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve2D >":
        r"""Returns a NURBS curve that is geometrically identical to the ellipse."""
        return _core.Ellipse2D__get_asNurbsCurve(self)

    def _get_curveType(self) -> "adsk::core::Curve2DTypes":
        r"""Returns the type of geometry this curve represents."""
        return _core.Ellipse2D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator2D >":
        r"""Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.Ellipse2D__get_evaluator(self)

    def transformBy(self, matrix: "Matrix2D") -> "bool":
        r"""
        Transforms this curve in 2D space. 
        matrix : A 2D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.Ellipse2D_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.Ellipse2D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Ellipse2D__get_isValid(self)

# Register Ellipse2D in _core:
_core.Ellipse2D_swigregister(Ellipse2D)

def Ellipse2D_classType() -> "char const *":
    return _core.Ellipse2D_classType()

def Ellipse2D_create(center: "Point2D", majorAxis: "Vector2D", majorRadius: "double", minorRadius: "double") -> "adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Vector2D > const &":
    return _core.Ellipse2D_create(center, majorAxis, majorRadius, minorRadius)


Ellipse2D.center = property(Ellipse2D._get_center, Ellipse2D._set_center, doc="Gets and sets the center position of the ellipse.")


Ellipse2D.majorAxis = property(Ellipse2D._get_majorAxis, Ellipse2D._set_majorAxis, doc="Gets and sets the major axis of the ellipse.")


Ellipse2D.majorRadius = property(Ellipse2D._get_majorRadius, Ellipse2D._set_majorRadius, doc="Gets and sets the major radius of the ellipse.")


Ellipse2D.minorRadius = property(Ellipse2D._get_minorRadius, Ellipse2D._set_minorRadius, doc="Gets and sets the minor radius of the ellipse.")


Ellipse2D.asNurbsCurve = property(Ellipse2D._get_asNurbsCurve, doc="Returns a NURBS curve that is geometrically identical to the ellipse.")


Ellipse2D.cast = lambda arg: arg if isinstance(arg, Ellipse2D) else None

class Ellipse3D(Curve3D):
    r"""
    Transient 3D ellipse. A transient ellipse is n0t displayed or saved in a document.
    Transient 3D ellipses are used as a wrapper to work with raw 3D ellipse information.
    They are created statically using the create method of the Ellipse3D class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Ellipse3D *":
        return _core.Ellipse3D___deref__(self)

    def __eq__(self, rhs: "Ellipse3D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Ellipse3D___eq__(self, rhs)


    def __ne__(self, rhs: "Ellipse3D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Ellipse3D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Ellipse3D_classType()

    @staticmethod
    def create(center: "Point3D", normal: "Vector3D", majorAxis: "Vector3D", majorRadius: "double", minorRadius: "double") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
        return _core.Ellipse3D_create(center, normal, majorAxis, majorRadius, minorRadius)
    __swig_destroy__ = _core.delete_Ellipse3D

    def _get_center(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets the center position of the ellipse."""
        return _core.Ellipse3D__get_center(self)

    def _set_center(self, value: "Point3D") -> "bool":
        r"""Gets and sets the center position of the ellipse."""
        return _core.Ellipse3D__set_center(self, value)

    def _get_normal(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Gets and sets the normal of the ellipse."""
        return _core.Ellipse3D__get_normal(self)

    def _get_majorAxis(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Gets and sets the major axis of the ellipse."""
        return _core.Ellipse3D__get_majorAxis(self)

    def _set_majorAxis(self, value: "Vector3D") -> "bool":
        r"""Gets and sets the major axis of the ellipse."""
        return _core.Ellipse3D__set_majorAxis(self, value)

    def _get_majorRadius(self) -> "double":
        r"""Gets and sets the major radius of the ellipse."""
        return _core.Ellipse3D__get_majorRadius(self)

    def _set_majorRadius(self, value: "double") -> "bool":
        r"""Gets and sets the major radius of the ellipse."""
        return _core.Ellipse3D__set_majorRadius(self, value)

    def _get_minorRadius(self) -> "double":
        r"""Gets and sets the minor radius of the ellipse."""
        return _core.Ellipse3D__get_minorRadius(self)

    def _set_minorRadius(self, value: "double") -> "bool":
        r"""Gets and sets the minor radius of the ellipse."""
        return _core.Ellipse3D__set_minorRadius(self, value)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Ellipse3D >":
        r"""
        Creates a copy of this Ellipse3D object. 
        Returns the independent copy of the ellipse.
        """
        return _core.Ellipse3D_copy(self)

    def getData(self) -> "bool":
        r"""
        Gets all of the data defining the ellipse. 
        center : The output center point of the ellipse. 
        normal : The output normal vector of the ellipse. 
        majorAxis : The output major axis of the ellipse 
        majorRadius : The output major radius of the of the ellipse. 
        minorRadius : The output minor radius of the of the ellipse. 
        Returns true if successful.
        """
        return _core.Ellipse3D_getData(self)

    def set(self, center: "Point3D", normal: "Vector3D", majorAxis: "Vector3D", majorRadius: "double", minorRadius: "double") -> "bool":
        r"""
        Sets all of the data defining the ellipse. 
        center : The center point of the ellipse. 
        normal : The normal vector of the ellipse.
        The plane through the center point and perpendicular to the normal vector defines the plane of the ellipse. 
        majorAxis : The major axis of the ellipse. 
        majorRadius : The major radius of the of the ellipse. 
        minorRadius : The minor radius of the of the ellipse. 
        Returns true if successful.
        """
        return _core.Ellipse3D_set(self, center, normal, majorAxis, majorRadius, minorRadius)

    def _get_asNurbsCurve(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >":
        r"""Returns a NURBS curve that is geometrically identical to the ellipse."""
        return _core.Ellipse3D__get_asNurbsCurve(self)

    def _get_curveType(self) -> "adsk::core::Curve3DTypes":
        r"""Returns the type of geometry this curve represents."""
        return _core.Ellipse3D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator3D >":
        r"""Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.Ellipse3D__get_evaluator(self)

    def transformBy(self, matrix: "Matrix3D") -> "bool":
        r"""
        Transforms this curve in 3D space. 
        matrix : A 3D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.Ellipse3D_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.Ellipse3D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Ellipse3D__get_isValid(self)

# Register Ellipse3D in _core:
_core.Ellipse3D_swigregister(Ellipse3D)

def Ellipse3D_classType() -> "char const *":
    return _core.Ellipse3D_classType()

def Ellipse3D_create(center: "Point3D", normal: "Vector3D", majorAxis: "Vector3D", majorRadius: "double", minorRadius: "double") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
    return _core.Ellipse3D_create(center, normal, majorAxis, majorRadius, minorRadius)


Ellipse3D.center = property(Ellipse3D._get_center, Ellipse3D._set_center, doc="Gets and sets the center position of the ellipse.")


Ellipse3D.normal = property(Ellipse3D._get_normal, doc="Gets and sets the normal of the ellipse.")


Ellipse3D.majorAxis = property(Ellipse3D._get_majorAxis, Ellipse3D._set_majorAxis, doc="Gets and sets the major axis of the ellipse.")


Ellipse3D.majorRadius = property(Ellipse3D._get_majorRadius, Ellipse3D._set_majorRadius, doc="Gets and sets the major radius of the ellipse.")


Ellipse3D.minorRadius = property(Ellipse3D._get_minorRadius, Ellipse3D._set_minorRadius, doc="Gets and sets the minor radius of the ellipse.")


Ellipse3D.asNurbsCurve = property(Ellipse3D._get_asNurbsCurve, doc="Returns a NURBS curve that is geometrically identical to the ellipse.")


Ellipse3D.cast = lambda arg: arg if isinstance(arg, Ellipse3D) else None

class EllipticalArc2D(Curve2D):
    r"""
    Transient 2D elliptical arc. A transient elliptical arc is not displayed or saved in a document.
    Transient 2D elliptical arcs are used as a wrapper to work with raw 2D elliptical arc information.
    They are created statically using the create method of the EllipticalArc2D class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::EllipticalArc2D *":
        return _core.EllipticalArc2D___deref__(self)

    def __eq__(self, rhs: "EllipticalArc2D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.EllipticalArc2D___eq__(self, rhs)


    def __ne__(self, rhs: "EllipticalArc2D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.EllipticalArc2D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.EllipticalArc2D_classType()

    @staticmethod
    def create(center: "Point2D", majorAxis: "Vector2D", majorRadius: "double", minorRadius: "double", startAngle: "double", endAngle: "double") -> "adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Vector2D > const &":
        return _core.EllipticalArc2D_create(center, majorAxis, majorRadius, minorRadius, startAngle, endAngle)
    __swig_destroy__ = _core.delete_EllipticalArc2D

    def _get_center(self) -> "adsk::core::Ptr< adsk::core::Point2D >":
        r"""Gets and sets the center position of the elliptical arc."""
        return _core.EllipticalArc2D__get_center(self)

    def _set_center(self, value: "Point2D") -> "bool":
        r"""Gets and sets the center position of the elliptical arc."""
        return _core.EllipticalArc2D__set_center(self, value)

    def _get_majorAxis(self) -> "adsk::core::Ptr< adsk::core::Vector2D >":
        r"""Gets and sets the major axis of the elliptical arc."""
        return _core.EllipticalArc2D__get_majorAxis(self)

    def _set_majorAxis(self, value: "Vector2D") -> "bool":
        r"""Gets and sets the major axis of the elliptical arc."""
        return _core.EllipticalArc2D__set_majorAxis(self, value)

    def _get_majorRadius(self) -> "double":
        r"""Gets and sets the major radius of the elliptical arc."""
        return _core.EllipticalArc2D__get_majorRadius(self)

    def _set_majorRadius(self, value: "double") -> "bool":
        r"""Gets and sets the major radius of the elliptical arc."""
        return _core.EllipticalArc2D__set_majorRadius(self, value)

    def _get_minorRadius(self) -> "double":
        r"""Gets and sets the minor radius of the elliptical arc."""
        return _core.EllipticalArc2D__get_minorRadius(self)

    def _set_minorRadius(self, value: "double") -> "bool":
        r"""Gets and sets the minor radius of the elliptical arc."""
        return _core.EllipticalArc2D__set_minorRadius(self, value)

    def _get_startAngle(self) -> "double":
        r"""Gets and sets the start angle of the elliptical arc in radians, where 0 is along the major axis."""
        return _core.EllipticalArc2D__get_startAngle(self)

    def _set_startAngle(self, value: "double") -> "bool":
        r"""Gets and sets the start angle of the elliptical arc in radians, where 0 is along the major axis."""
        return _core.EllipticalArc2D__set_startAngle(self, value)

    def _get_endAngle(self) -> "double":
        r"""Gets and sets the end angle of the elliptical arc in radians, where 0 is along the major axis."""
        return _core.EllipticalArc2D__get_endAngle(self)

    def _set_endAngle(self, value: "double") -> "bool":
        r"""Gets and sets the end angle of the elliptical arc in radians, where 0 is along the major axis."""
        return _core.EllipticalArc2D__set_endAngle(self, value)

    def _get_isClockwise(self) -> "bool":
        r"""Indicates if the sweep direction of the elliptical arc is clockwise or counterclockwise."""
        return _core.EllipticalArc2D__get_isClockwise(self)

    def _get_isCircular(self) -> "bool":
        r"""Indicates if the elliptical arc is the geometric equivalent of a circular arc"""
        return _core.EllipticalArc2D__get_isCircular(self)

    def _get_startPoint(self) -> "adsk::core::Ptr< adsk::core::Point2D >":
        r"""Gets the position of the start point of the elliptical arc."""
        return _core.EllipticalArc2D__get_startPoint(self)

    def _get_endPoint(self) -> "adsk::core::Ptr< adsk::core::Point2D >":
        r"""Gets the position of the end point of the elliptical arc."""
        return _core.EllipticalArc2D__get_endPoint(self)

    def copy(self) -> "adsk::core::Ptr< adsk::core::EllipticalArc2D >":
        r"""
        Creates and returns a copy of this EllipticalArc2D object. 
        Returns a new EllipticalArc2D object that is a copy of this Arc2D object.
        """
        return _core.EllipticalArc2D_copy(self)

    def getData(self) -> "bool":
        r"""
        Gets all of the data defining the elliptical arc. 
        center : The output center point of the elliptical arc. 
        majorAxis : The output major axis of the elliptical arc. 
        majorRadius : The output major radius of the of the elliptical arc. 
        minorRadius : The output minor radius of the of the elliptical arc. 
        startAngle : The output start angle of the elliptical arc in radians, where 0 is along the major axis. 
        endAngle : The output end angle of the elliptical arc in radians, where 0 is along the major axis. 
        Returns true if successful
        """
        return _core.EllipticalArc2D_getData(self)

    def set(self, center: "Point2D", majorAxis: "Vector2D", majorRadius: "double", minorRadius: "double", startAngle: "double", endAngle: "double") -> "bool":
        r"""
        center : A Point2D object that defines the center of the elliptical arc. 
        majorAxis : The major axis of the elliptical arc. 
        majorRadius : The major radius of the of the elliptical arc. 
        minorRadius : The minor radius of the of the elliptical arc. 
        startAngle : The start angle of the elliptical arc in radians, where 0 is along the major axis. 
        endAngle : The end angle of the elliptical arc in radians, where 0 is along the major axis. 
        Returns true if redefining the elliptical arc is successful
        """
        return _core.EllipticalArc2D_set(self, center, majorAxis, majorRadius, minorRadius, startAngle, endAngle)

    def _get_asNurbsCurve(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve2D >":
        r"""Returns a NURBS curve that is geometrically identical to the elliptical arc."""
        return _core.EllipticalArc2D__get_asNurbsCurve(self)

    def _get_curveType(self) -> "adsk::core::Curve2DTypes":
        r"""Returns the type of geometry this curve represents."""
        return _core.EllipticalArc2D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator2D >":
        r"""Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.EllipticalArc2D__get_evaluator(self)

    def transformBy(self, matrix: "Matrix2D") -> "bool":
        r"""
        Transforms this curve in 2D space. 
        matrix : A 2D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.EllipticalArc2D_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.EllipticalArc2D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.EllipticalArc2D__get_isValid(self)

# Register EllipticalArc2D in _core:
_core.EllipticalArc2D_swigregister(EllipticalArc2D)

def EllipticalArc2D_classType() -> "char const *":
    return _core.EllipticalArc2D_classType()

def EllipticalArc2D_create(center: "Point2D", majorAxis: "Vector2D", majorRadius: "double", minorRadius: "double", startAngle: "double", endAngle: "double") -> "adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Vector2D > const &":
    return _core.EllipticalArc2D_create(center, majorAxis, majorRadius, minorRadius, startAngle, endAngle)


EllipticalArc2D.center = property(EllipticalArc2D._get_center, EllipticalArc2D._set_center, doc="Gets and sets the center position of the elliptical arc.")


EllipticalArc2D.majorAxis = property(EllipticalArc2D._get_majorAxis, EllipticalArc2D._set_majorAxis, doc="Gets and sets the major axis of the elliptical arc.")


EllipticalArc2D.majorRadius = property(EllipticalArc2D._get_majorRadius, EllipticalArc2D._set_majorRadius, doc="Gets and sets the major radius of the elliptical arc.")


EllipticalArc2D.minorRadius = property(EllipticalArc2D._get_minorRadius, EllipticalArc2D._set_minorRadius, doc="Gets and sets the minor radius of the elliptical arc.")


EllipticalArc2D.startAngle = property(EllipticalArc2D._get_startAngle, EllipticalArc2D._set_startAngle, doc="Gets and sets the start angle of the elliptical arc in radians, where 0 is along the major axis.")


EllipticalArc2D.endAngle = property(EllipticalArc2D._get_endAngle, EllipticalArc2D._set_endAngle, doc="Gets and sets the end angle of the elliptical arc in radians, where 0 is along the major axis.")


EllipticalArc2D.isClockwise = property(EllipticalArc2D._get_isClockwise, doc="Indicates if the sweep direction of the elliptical arc is clockwise or counterclockwise.")


EllipticalArc2D.isCircular = property(EllipticalArc2D._get_isCircular, doc="Indicates if the elliptical arc is the geometric equivalent of a circular arc")


EllipticalArc2D.startPoint = property(EllipticalArc2D._get_startPoint, doc="Gets the position of the start point of the elliptical arc.")


EllipticalArc2D.endPoint = property(EllipticalArc2D._get_endPoint, doc="Gets the position of the end point of the elliptical arc.")


EllipticalArc2D.asNurbsCurve = property(EllipticalArc2D._get_asNurbsCurve, doc="Returns a NURBS curve that is geometrically identical to the elliptical arc.")


EllipticalArc2D.cast = lambda arg: arg if isinstance(arg, EllipticalArc2D) else None

class EllipticalArc3D(Curve3D):
    r"""
    Transient 3D elliptical arc. A transient elliptical arc is not displayed or saved in a document.
    Transient 3D elliptical arcs are used as a wrapper to work with raw 3D elliptical arc information.
    They are created statically using the create method of the EllipticalArc3D class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::EllipticalArc3D *":
        return _core.EllipticalArc3D___deref__(self)

    def __eq__(self, rhs: "EllipticalArc3D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.EllipticalArc3D___eq__(self, rhs)


    def __ne__(self, rhs: "EllipticalArc3D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.EllipticalArc3D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.EllipticalArc3D_classType()

    @staticmethod
    def create(center: "Point3D", normal: "Vector3D", majorAxis: "Vector3D", majorRadius: "double", minorRadius: "double", startAngle: "double", endAngle: "double") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
        return _core.EllipticalArc3D_create(center, normal, majorAxis, majorRadius, minorRadius, startAngle, endAngle)
    __swig_destroy__ = _core.delete_EllipticalArc3D

    def _get_center(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets the center point of the elliptical arc."""
        return _core.EllipticalArc3D__get_center(self)

    def _set_center(self, value: "Point3D") -> "bool":
        r"""Gets and sets the center point of the elliptical arc."""
        return _core.EllipticalArc3D__set_center(self, value)

    def _get_normal(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Gets and sets the normal of the elliptical arc."""
        return _core.EllipticalArc3D__get_normal(self)

    def _get_majorAxis(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Gets and sets the major axis of the elliptical arc."""
        return _core.EllipticalArc3D__get_majorAxis(self)

    def _set_majorAxis(self, value: "Vector3D") -> "bool":
        r"""Gets and sets the major axis of the elliptical arc."""
        return _core.EllipticalArc3D__set_majorAxis(self, value)

    def _get_majorRadius(self) -> "double":
        r"""Gets and sets the major radius of the elliptical arc."""
        return _core.EllipticalArc3D__get_majorRadius(self)

    def _set_majorRadius(self, value: "double") -> "bool":
        r"""Gets and sets the major radius of the elliptical arc."""
        return _core.EllipticalArc3D__set_majorRadius(self, value)

    def _get_minorRadius(self) -> "double":
        r"""Gets and sets the minor radius of the elliptical arc."""
        return _core.EllipticalArc3D__get_minorRadius(self)

    def _set_minorRadius(self, value: "double") -> "bool":
        r"""Gets and sets the minor radius of the elliptical arc."""
        return _core.EllipticalArc3D__set_minorRadius(self, value)

    def _get_startAngle(self) -> "double":
        r"""Gets and sets the start angle of the elliptical arc."""
        return _core.EllipticalArc3D__get_startAngle(self)

    def _set_startAngle(self, value: "double") -> "bool":
        r"""Gets and sets the start angle of the elliptical arc."""
        return _core.EllipticalArc3D__set_startAngle(self, value)

    def _get_endAngle(self) -> "double":
        r"""Gets and sets the end angle of the elliptical arc."""
        return _core.EllipticalArc3D__get_endAngle(self)

    def _set_endAngle(self, value: "double") -> "bool":
        r"""Gets and sets the end angle of the elliptical arc."""
        return _core.EllipticalArc3D__set_endAngle(self, value)

    def copy(self) -> "adsk::core::Ptr< adsk::core::EllipticalArc3D >":
        r"""
        Creates and returns a copy of this EllipticalArc3D object. 
        Returns a new EllipticalArc3D object that is a copy of this Arc3D object.
        """
        return _core.EllipticalArc3D_copy(self)

    def getData(self) -> "bool":
        r"""
        Gets all of the data defining the elliptical arc. 
        center : The output center point of the elliptical arc. 
        normal : The output normal vector of the elliptical arc. 
        majorAxis : The output major axis of the elliptical arc. 
        majorRadius : The output major radius of the of the elliptical arc. 
        minorRadius : The output minor radius of the of the elliptical arc. 
        startAngle : The output start angle of the elliptical arc in radians, where 0 is along the major axis. 
        endAngle : The output end angle of the elliptical arc in radians, where 0 is along the major axis. 
        Returns true if successful.
        """
        return _core.EllipticalArc3D_getData(self)

    def set(self, center: "Point3D", normal: "Vector3D", majorAxis: "Vector3D", majorRadius: "double", minorRadius: "double", startAngle: "double", endAngle: "double") -> "bool":
        r"""
        Sets all of the data defining the elliptical arc. 
        center : The center point of the elliptical arc. 
        normal : The normal vector of the elliptical arc. 
        majorAxis : The major axis of the elliptical arc. 
        majorRadius : The major radius of the of the elliptical arc. 
        minorRadius : The minor radius of the of the elliptical arc. 
        startAngle : The start angle of the elliptical arc in radians, where 0 is along the major axis. 
        endAngle : The end angle of the elliptical arc in radians, where 0 is along the major axis. 
        Returns true if successful.
        """
        return _core.EllipticalArc3D_set(self, center, normal, majorAxis, majorRadius, minorRadius, startAngle, endAngle)

    def _get_asNurbsCurve(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >":
        r"""Returns a NURBS curve that is geometrically identical to the elliptical arc."""
        return _core.EllipticalArc3D__get_asNurbsCurve(self)

    def _get_curveType(self) -> "adsk::core::Curve3DTypes":
        r"""Returns the type of geometry this curve represents."""
        return _core.EllipticalArc3D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator3D >":
        r"""Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.EllipticalArc3D__get_evaluator(self)

    def transformBy(self, matrix: "Matrix3D") -> "bool":
        r"""
        Transforms this curve in 3D space. 
        matrix : A 3D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.EllipticalArc3D_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.EllipticalArc3D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.EllipticalArc3D__get_isValid(self)

# Register EllipticalArc3D in _core:
_core.EllipticalArc3D_swigregister(EllipticalArc3D)

def EllipticalArc3D_classType() -> "char const *":
    return _core.EllipticalArc3D_classType()

def EllipticalArc3D_create(center: "Point3D", normal: "Vector3D", majorAxis: "Vector3D", majorRadius: "double", minorRadius: "double", startAngle: "double", endAngle: "double") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
    return _core.EllipticalArc3D_create(center, normal, majorAxis, majorRadius, minorRadius, startAngle, endAngle)


EllipticalArc3D.center = property(EllipticalArc3D._get_center, EllipticalArc3D._set_center, doc="Gets and sets the center point of the elliptical arc.")


EllipticalArc3D.normal = property(EllipticalArc3D._get_normal, doc="Gets and sets the normal of the elliptical arc.")


EllipticalArc3D.majorAxis = property(EllipticalArc3D._get_majorAxis, EllipticalArc3D._set_majorAxis, doc="Gets and sets the major axis of the elliptical arc.")


EllipticalArc3D.majorRadius = property(EllipticalArc3D._get_majorRadius, EllipticalArc3D._set_majorRadius, doc="Gets and sets the major radius of the elliptical arc.")


EllipticalArc3D.minorRadius = property(EllipticalArc3D._get_minorRadius, EllipticalArc3D._set_minorRadius, doc="Gets and sets the minor radius of the elliptical arc.")


EllipticalArc3D.startAngle = property(EllipticalArc3D._get_startAngle, EllipticalArc3D._set_startAngle, doc="Gets and sets the start angle of the elliptical arc.")


EllipticalArc3D.endAngle = property(EllipticalArc3D._get_endAngle, EllipticalArc3D._set_endAngle, doc="Gets and sets the end angle of the elliptical arc.")


EllipticalArc3D.asNurbsCurve = property(EllipticalArc3D._get_asNurbsCurve, doc="Returns a NURBS curve that is geometrically identical to the elliptical arc.")


EllipticalArc3D.cast = lambda arg: arg if isinstance(arg, EllipticalArc3D) else None

class EllipticalCone(Surface):
    r"""
    Transient elliptical cone. A transient elliptical cone is not displayed or saved in a document.
    A transient elliptical cone is used as a wrapper to work with raw elliptical cone information. 
    A transient elliptical cone has no boundaries.
    The cone always goes to a point in its narrowing direction, and is infinite in its
    widening direction.
    They are created statically using the create method of the EllipticalCone class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::EllipticalCone *":
        return _core.EllipticalCone___deref__(self)

    def __eq__(self, rhs: "EllipticalCone") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.EllipticalCone___eq__(self, rhs)


    def __ne__(self, rhs: "EllipticalCone") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.EllipticalCone___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.EllipticalCone_classType()

    @staticmethod
    def create(origin: "Point3D", axis: "Vector3D", majorAxisDirection: "Vector3D", majorRadius: "double", minorRadius: "double", halfAngle: "double") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
        return _core.EllipticalCone_create(origin, axis, majorAxisDirection, majorRadius, minorRadius, halfAngle)
    __swig_destroy__ = _core.delete_EllipticalCone

    def _get_origin(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets the origin point (center) of the base of the cone."""
        return _core.EllipticalCone__get_origin(self)

    def _set_origin(self, value: "Point3D") -> "bool":
        r"""Gets and sets the origin point (center) of the base of the cone."""
        return _core.EllipticalCone__set_origin(self, value)

    def getAxes(self) -> "void":
        r"""
        Gets the center axis of the cone that defines its normal direction and the major axis 
        direction of the ellipse that defines it. 
        axis : The output center axis (along the length) of the cone that defines its normal direction. 
        majorAxisDirection : The output direction of the major axis of the ellipse that defines the cone.
        """
        return _core.EllipticalCone_getAxes(self)

    def setAxes(self, axis: "Vector3D", majorAxisDirection: "Vector3D") -> "bool":
        r"""
        Sets the center axis of the cone and the major axis direction of the ellipse that defines it. 
        axis : The center axis (along the length) of the cone that defines its normal direction. 
        majorAxisDirection : The direction of the major axis of the ellipse that defines the cone. 
        Returns true if successful.
        """
        return _core.EllipticalCone_setAxes(self, axis, majorAxisDirection)

    def _get_majorRadius(self) -> "double":
        r"""Gets and sets the major radius of the ellipse that defines the cone."""
        return _core.EllipticalCone__get_majorRadius(self)

    def _set_majorRadius(self, value: "double") -> "bool":
        r"""Gets and sets the major radius of the ellipse that defines the cone."""
        return _core.EllipticalCone__set_majorRadius(self, value)

    def _get_minorRadius(self) -> "double":
        r"""Gets and sets the minor radius of the ellipse that defines the cone."""
        return _core.EllipticalCone__get_minorRadius(self)

    def _set_minorRadius(self, value: "double") -> "bool":
        r"""Gets and sets the minor radius of the ellipse that defines the cone."""
        return _core.EllipticalCone__set_minorRadius(self, value)

    def _get_halfAngle(self) -> "double":
        r"""
        Gets and sets the taper half-angle of the elliptical cone. 
        A negative value indicates that the cone is narrowing in the direction of the axis vector, 
        whereas a positive values indicates that it is expanding in the direction of the axis vector.
        """
        return _core.EllipticalCone__get_halfAngle(self)

    def _set_halfAngle(self, value: "double") -> "bool":
        r"""
        Gets and sets the taper half-angle of the elliptical cone. 
        A negative value indicates that the cone is narrowing in the direction of the axis vector, 
        whereas a positive values indicates that it is expanding in the direction of the axis vector.
        """
        return _core.EllipticalCone__set_halfAngle(self, value)

    def getData(self) -> "bool":
        r"""
        Gets the data that defines the Elliptical Cone. 
        origin : The output origin point (center) of the base of the cone. 
        axis : The output center axis (along the length) of the cone that defines its normal direction. 
        majorAxisDirection : The output direction of the major axis of the ellipse that defines the cone. 
        majorRadius : The output major radius of the ellipse that defines the cone. 
        minorRadius : The output minor radius of the ellipse that defines the cone. 
        halfAngle : The output taper half-angle of the cone. 
        Returns true if successful.
        """
        return _core.EllipticalCone_getData(self)

    def set(self, origin: "Point3D", axis: "Vector3D", majorAxisDirection: "Vector3D", majorRadius: "double", minorRadius: "double", halfAngle: "double") -> "bool":
        r"""
        Sets the data that defines the Elliptical Cone. 
        origin : The origin point (center) of the base of the cone. 
        axis : The center axis (along the length) of the cone that defines its normal direction. 
        majorAxisDirection : The direction of the major axis of the ellipse that defines the cone. 
        majorRadius : The major radius of the ellipse that defines the cone. 
        minorRadius : The minor radius of the ellipse that defines the cone. 
        halfAngle : The taper half-angle of the cone. 
        Returns true if successful.
        """
        return _core.EllipticalCone_set(self, origin, axis, majorAxisDirection, majorRadius, minorRadius, halfAngle)

    def copy(self) -> "adsk::core::Ptr< adsk::core::EllipticalCone >":
        r"""
        Creates and returns an independent copy of this EllipticalCone object. 
        Returns a new EllipticalCone object that is a copy of this EllipticalCone object.
        """
        return _core.EllipticalCone_copy(self)

    def _get_surfaceType(self) -> "adsk::core::SurfaceTypes":
        r"""Returns the surface type."""
        return _core.EllipticalCone__get_surfaceType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::SurfaceEvaluator >":
        r"""Returns the surface evaluator."""
        return _core.EllipticalCone__get_evaluator(self)

    def transformBy(self, matrix: "Matrix3D") -> "bool":
        r"""
        Updates this surface by transforming it with a given input matrix. 
        matrix : A 3D matrix that defines the transform to apply to the surface. 
        Returns true if the transform was successful.
        """
        return _core.EllipticalCone_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.EllipticalCone__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.EllipticalCone__get_isValid(self)

# Register EllipticalCone in _core:
_core.EllipticalCone_swigregister(EllipticalCone)

def EllipticalCone_classType() -> "char const *":
    return _core.EllipticalCone_classType()

def EllipticalCone_create(origin: "Point3D", axis: "Vector3D", majorAxisDirection: "Vector3D", majorRadius: "double", minorRadius: "double", halfAngle: "double") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
    return _core.EllipticalCone_create(origin, axis, majorAxisDirection, majorRadius, minorRadius, halfAngle)


EllipticalCone.origin = property(EllipticalCone._get_origin, EllipticalCone._set_origin, doc="Gets and sets the origin point (center) of the base of the cone.")


EllipticalCone.majorRadius = property(EllipticalCone._get_majorRadius, EllipticalCone._set_majorRadius, doc="Gets and sets the major radius of the ellipse that defines the cone.")


EllipticalCone.minorRadius = property(EllipticalCone._get_minorRadius, EllipticalCone._set_minorRadius, doc="Gets and sets the minor radius of the ellipse that defines the cone.")


EllipticalCone.halfAngle = property(EllipticalCone._get_halfAngle, EllipticalCone._set_halfAngle, doc="Gets and sets the taper half-angle of the elliptical cone.\nA negative value indicates that the cone is narrowing in the direction of the axis vector,\nwhereas a positive values indicates that it is expanding in the direction of the axis vector.")


EllipticalCone.cast = lambda arg: arg if isinstance(arg, EllipticalCone) else None

class EllipticalCylinder(Surface):
    r"""
    Transient elliptical cylinder. A transient elliptical cylinder is not displayed or saved 
    in a document.
    A transient elliptical cylinder is used as a wrapper to work with raw elliptical cylinder 
    information. 
    A transient elliptical cylinder has no boundaries and is infinite in length. 
    They are created statically using the create method of the EllipticalCylinder class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::EllipticalCylinder *":
        return _core.EllipticalCylinder___deref__(self)

    def __eq__(self, rhs: "EllipticalCylinder") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.EllipticalCylinder___eq__(self, rhs)


    def __ne__(self, rhs: "EllipticalCylinder") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.EllipticalCylinder___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.EllipticalCylinder_classType()

    @staticmethod
    def create(origin: "Point3D", axis: "Vector3D", majorAxis: "Vector3D", majorRadius: "double", minorRadius: "double") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
        return _core.EllipticalCylinder_create(origin, axis, majorAxis, majorRadius, minorRadius)
    __swig_destroy__ = _core.delete_EllipticalCylinder

    def _get_origin(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets the origin point (center) of the base of the cylinder."""
        return _core.EllipticalCylinder__get_origin(self)

    def _set_origin(self, value: "Point3D") -> "bool":
        r"""Gets and sets the origin point (center) of the base of the cylinder."""
        return _core.EllipticalCylinder__set_origin(self, value)

    def _get_axis(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Gets and set the center axis (along the length) of the cylinder that defines 
        its normal direction.
        """
        return _core.EllipticalCylinder__get_axis(self)

    def _set_axis(self, value: "Vector3D") -> "bool":
        r"""
        Gets and set the center axis (along the length) of the cylinder that defines 
        its normal direction.
        """
        return _core.EllipticalCylinder__set_axis(self, value)

    def _get_majorAxis(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Gets and sets the direction of the major axis of the ellipse that defines the cylinder."""
        return _core.EllipticalCylinder__get_majorAxis(self)

    def _set_majorAxis(self, value: "Vector3D") -> "bool":
        r"""Gets and sets the direction of the major axis of the ellipse that defines the cylinder."""
        return _core.EllipticalCylinder__set_majorAxis(self, value)

    def _get_majorRadius(self) -> "double":
        r"""Gets and sets the major radius of the ellipse that defines the cylinder."""
        return _core.EllipticalCylinder__get_majorRadius(self)

    def _set_majorRadius(self, value: "double") -> "bool":
        r"""Gets and sets the major radius of the ellipse that defines the cylinder."""
        return _core.EllipticalCylinder__set_majorRadius(self, value)

    def _get_minorRadius(self) -> "double":
        r"""Gets and sets the minor radius of the ellipse that defines the cylinder."""
        return _core.EllipticalCylinder__get_minorRadius(self)

    def _set_minorRadius(self, value: "double") -> "bool":
        r"""Gets and sets the minor radius of the ellipse that defines the cylinder."""
        return _core.EllipticalCylinder__set_minorRadius(self, value)

    def getData(self) -> "bool":
        r"""
        Gets the data defining the elliptical cylinder. 
        origin : The output origin point (center) of the base of the cylinder. 
        axis : The output center axis (along the length) of the cylinder that defines its normal direction. 
        majorAxis : The output direction of the major axis of the ellipse that defines the cylinder. 
        majorRadius : The output major radius of the ellipse that defines the cylinder. 
        minorRadius : The output minor radius of the ellipse that defines the cylinder. 
        Returns true if successful.
        """
        return _core.EllipticalCylinder_getData(self)

    def set(self, origin: "Point3D", axis: "Vector3D", majorAxis: "Vector3D", majorRadius: "double", minorRadius: "double") -> "bool":
        r"""
        Sets the data defining the elliptical cylinder. 
        origin : The origin point (center) of the base of the cylinder. 
        axis : The center axis (along the length) of the cylinder that defines its normal direction. 
        majorAxis : The direction of the major axis of the ellipse that defines the cylinder. 
        majorRadius : The major radius of the ellipse that defines the cylinder. 
        minorRadius : The minor radius of the ellipse that defines the cylinder. 
        Returns true if successful.
        """
        return _core.EllipticalCylinder_set(self, origin, axis, majorAxis, majorRadius, minorRadius)

    def copy(self) -> "adsk::core::Ptr< adsk::core::EllipticalCylinder >":
        r"""
        Creates and returns an independent copy of this EllipticalCylinder object. 
        Returns a new EllipticalCylinder object that is a copy of this EllipticalCylinder object.
        """
        return _core.EllipticalCylinder_copy(self)

    def _get_surfaceType(self) -> "adsk::core::SurfaceTypes":
        r"""Returns the surface type."""
        return _core.EllipticalCylinder__get_surfaceType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::SurfaceEvaluator >":
        r"""Returns the surface evaluator."""
        return _core.EllipticalCylinder__get_evaluator(self)

    def transformBy(self, matrix: "Matrix3D") -> "bool":
        r"""
        Updates this surface by transforming it with a given input matrix. 
        matrix : A 3D matrix that defines the transform to apply to the surface. 
        Returns true if the transform was successful.
        """
        return _core.EllipticalCylinder_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.EllipticalCylinder__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.EllipticalCylinder__get_isValid(self)

# Register EllipticalCylinder in _core:
_core.EllipticalCylinder_swigregister(EllipticalCylinder)

def EllipticalCylinder_classType() -> "char const *":
    return _core.EllipticalCylinder_classType()

def EllipticalCylinder_create(origin: "Point3D", axis: "Vector3D", majorAxis: "Vector3D", majorRadius: "double", minorRadius: "double") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
    return _core.EllipticalCylinder_create(origin, axis, majorAxis, majorRadius, minorRadius)


EllipticalCylinder.origin = property(EllipticalCylinder._get_origin, EllipticalCylinder._set_origin, doc="Gets and sets the origin point (center) of the base of the cylinder.")


EllipticalCylinder.axis = property(EllipticalCylinder._get_axis, EllipticalCylinder._set_axis, doc="Gets and set the center axis (along the length) of the cylinder that defines\nits normal direction.")


EllipticalCylinder.majorAxis = property(EllipticalCylinder._get_majorAxis, EllipticalCylinder._set_majorAxis, doc="Gets and sets the direction of the major axis of the ellipse that defines the cylinder.")


EllipticalCylinder.majorRadius = property(EllipticalCylinder._get_majorRadius, EllipticalCylinder._set_majorRadius, doc="Gets and sets the major radius of the ellipse that defines the cylinder.")


EllipticalCylinder.minorRadius = property(EllipticalCylinder._get_minorRadius, EllipticalCylinder._set_minorRadius, doc="Gets and sets the minor radius of the ellipse that defines the cylinder.")


EllipticalCylinder.cast = lambda arg: arg if isinstance(arg, EllipticalCylinder) else None

class FilenameProperty(Property):
    r"""A file name property associated with an appearance."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::FilenameProperty *":
        return _core.FilenameProperty___deref__(self)

    def __eq__(self, rhs: "FilenameProperty") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.FilenameProperty___eq__(self, rhs)


    def __ne__(self, rhs: "FilenameProperty") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.FilenameProperty___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.FilenameProperty_classType()
    __swig_destroy__ = _core.delete_FilenameProperty

    def _get_hasMultipleValues(self) -> "bool":
        r"""Gets the boolean flag that indicates if this property has multiple values or not."""
        return _core.FilenameProperty__get_hasMultipleValues(self)

    def _get_value(self) -> "std::string":
        r"""Gets and sets the value of this property."""
        return _core.FilenameProperty__get_value(self)

    def _set_value(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the value of this property."""
        return _core.FilenameProperty__set_value(self, value)

    def _get_values(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Gets and sets the values associated with this property. HasMultipleValues 
        property indicates if this property will be returning more than one value.
        """
        return _core.FilenameProperty__get_values(self)

    def _set_values(self, value: "StringVector") -> "bool":
        r"""
        Gets and sets the values associated with this property. HasMultipleValues 
        property indicates if this property will be returning more than one value.
        """
        return _core.FilenameProperty__set_values(self, value)

    def _get_name(self) -> "std::string":
        r"""
        Returns the name of this property as seen in the user interface. This name is localized
        and can change based on the current language
        """
        return _core.FilenameProperty__get_name(self)

    def _get_isReadOnly(self) -> "bool":
        r"""Indicates if this property is read-only. If True any attempted edits will fail."""
        return _core.FilenameProperty__get_isReadOnly(self)

    def _get_id(self) -> "std::string":
        r"""Returns the unique ID of this property."""
        return _core.FilenameProperty__get_id(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the parent of this property."""
        return _core.FilenameProperty__get_parent(self)

    def _get_objectType(self) -> "char const *":
        return _core.FilenameProperty__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.FilenameProperty__get_isValid(self)

# Register FilenameProperty in _core:
_core.FilenameProperty_swigregister(FilenameProperty)

def FilenameProperty_classType() -> "char const *":
    return _core.FilenameProperty_classType()


FilenameProperty.hasMultipleValues = property(FilenameProperty._get_hasMultipleValues, doc="Gets the boolean flag that indicates if this property has multiple values or not.")


FilenameProperty.value = property(FilenameProperty._get_value, FilenameProperty._set_value, doc="Gets and sets the value of this property.")


FilenameProperty.values = property(FilenameProperty._get_values, FilenameProperty._set_values, doc="Gets and sets the values associated with this property. HasMultipleValues\nproperty indicates if this property will be returning more than one value.")


FilenameProperty.cast = lambda arg: arg if isinstance(arg, FilenameProperty) else None

class FloatProperty(Property):
    r"""A float or real value property associated with a material or appearance."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::FloatProperty *":
        return _core.FloatProperty___deref__(self)

    def __eq__(self, rhs: "FloatProperty") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.FloatProperty___eq__(self, rhs)


    def __ne__(self, rhs: "FloatProperty") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.FloatProperty___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.FloatProperty_classType()
    __swig_destroy__ = _core.delete_FloatProperty

    def _get_hasConnectedTexture(self) -> "bool":
        r"""
        Gets and sets the boolean flag that indicates if the float value has been overridden 
        using a texture. Setting this property to False will remove the texture so that a float 
        value is used. Setting this property to True will connect a texture to this float value.
        """
        return _core.FloatProperty__get_hasConnectedTexture(self)

    def _set_hasConnectedTexture(self, value: "bool") -> "bool":
        r"""
        Gets and sets the boolean flag that indicates if the float value has been overridden 
        using a texture. Setting this property to False will remove the texture so that a float 
        value is used. Setting this property to True will connect a texture to this float value.
        """
        return _core.FloatProperty__set_hasConnectedTexture(self, value)

    def _get_connectedTexture(self) -> "adsk::core::Ptr< adsk::core::AppearanceTexture >":
        r"""
        Gets the associated texture, if one exists. The HasConnectedTexture property controls 
        if there is an associated texture or not. If it's parent writable you can edit the 
        texture. If no texture exists, this property will return Nothing.
        """
        return _core.FloatProperty__get_connectedTexture(self)

    def getLimits(self) -> "bool":
        r"""
        Method that returns any limits for the value of this property. The HasLimits property can
        be used to see if there are any limits or not. 
        hasLowLimit : Output Boolean that indicates if there is a low limit or not. 
        lowLimit : If the hasLowLimit argument is true, this argument returns the low limit. 
        hasHighLimit : Output Boolean that indicates if there is a high limit or not. 
        highLimit : If the hasHighLimit argument is true, this argument returns the high limit. 
        Returns true if the method call was successful.
        """
        return _core.FloatProperty_getLimits(self)

    def _get_hasLimits(self) -> "bool":
        r"""
        Gets the boolean flag that indicates if the value of this property has any limits it must be within to 
        be valid. If True, use the GetLimits method to get the limit values.
        """
        return _core.FloatProperty__get_hasLimits(self)

    def _get_hasMultipleValues(self) -> "bool":
        r"""Gets the boolean flag that indicates if this property has multiple values or not."""
        return _core.FloatProperty__get_hasMultipleValues(self)

    def _get_isPercentage(self) -> "bool":
        r"""
        Gets the boolean flag that indicates that this property represents a percentage value so 
        the valid values must be in the range of 0.0 to 1.0 unless theyre further limited by 
        additional limits which can be determined with the HasLimits property.
        """
        return _core.FloatProperty__get_isPercentage(self)

    def _get_units(self) -> "std::string":
        r"""
        Gets the units that the value of this property is returned in. The String returned is a 
        valid Fusion 360 unit string.
        """
        return _core.FloatProperty__get_units(self)

    def _get_value(self) -> "double":
        r"""
        Gets and sets this property value. The value of this property should be ignored 
        if the HasConnectedTexture property is true. Setting this will remove any 
        associated texture, if there is one.
        """
        return _core.FloatProperty__get_value(self)

    def _set_value(self, value: "double") -> "bool":
        r"""
        Gets and sets this property value. The value of this property should be ignored 
        if the HasConnectedTexture property is true. Setting this will remove any 
        associated texture, if there is one.
        """
        return _core.FloatProperty__set_value(self, value)

    def _get_values(self) -> "std::vector< double,std::allocator< double > >":
        r"""
        Gets and sets the values associated with this property. HasMultipleValues property 
        indicates if this property will be returning more than one value.
        """
        return _core.FloatProperty__get_values(self)

    def _set_values(self, value: "DoubleVector") -> "bool":
        r"""
        Gets and sets the values associated with this property. HasMultipleValues property 
        indicates if this property will be returning more than one value.
        """
        return _core.FloatProperty__set_values(self, value)

    def _get_name(self) -> "std::string":
        r"""
        Returns the name of this property as seen in the user interface. This name is localized
        and can change based on the current language
        """
        return _core.FloatProperty__get_name(self)

    def _get_isReadOnly(self) -> "bool":
        r"""Indicates if this property is read-only. If True any attempted edits will fail."""
        return _core.FloatProperty__get_isReadOnly(self)

    def _get_id(self) -> "std::string":
        r"""Returns the unique ID of this property."""
        return _core.FloatProperty__get_id(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the parent of this property."""
        return _core.FloatProperty__get_parent(self)

    def _get_objectType(self) -> "char const *":
        return _core.FloatProperty__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.FloatProperty__get_isValid(self)

# Register FloatProperty in _core:
_core.FloatProperty_swigregister(FloatProperty)

def FloatProperty_classType() -> "char const *":
    return _core.FloatProperty_classType()


FloatProperty.hasConnectedTexture = property(FloatProperty._get_hasConnectedTexture, FloatProperty._set_hasConnectedTexture, doc="Gets and sets the boolean flag that indicates if the float value has been overridden\nusing a texture. Setting this property to False will remove the texture so that a float\nvalue is used. Setting this property to True will connect a texture to this float value.")


FloatProperty.connectedTexture = property(FloatProperty._get_connectedTexture, doc="Gets the associated texture, if one exists. The HasConnectedTexture property controls\nif there is an associated texture or not. If it's parent writable you can edit the\ntexture. If no texture exists, this property will return Nothing.")


FloatProperty.hasLimits = property(FloatProperty._get_hasLimits, doc="Gets the boolean flag that indicates if the value of this property has any limits it must be within to\nbe valid. If True, use the GetLimits method to get the limit values.")


FloatProperty.hasMultipleValues = property(FloatProperty._get_hasMultipleValues, doc="Gets the boolean flag that indicates if this property has multiple values or not.")


FloatProperty.isPercentage = property(FloatProperty._get_isPercentage, doc="Gets the boolean flag that indicates that this property represents a percentage value so\nthe valid values must be in the range of 0.0 to 1.0 unless theyre further limited by\nadditional limits which can be determined with the HasLimits property.")


FloatProperty.units = property(FloatProperty._get_units, doc="Gets the units that the value of this property is returned in. The String returned is a\nvalid Fusion 360 unit string.")


FloatProperty.value = property(FloatProperty._get_value, FloatProperty._set_value, doc="Gets and sets this property value. The value of this property should be ignored\nif the HasConnectedTexture property is true. Setting this will remove any\nassociated texture, if there is one.")


FloatProperty.values = property(FloatProperty._get_values, FloatProperty._set_values, doc="Gets and sets the values associated with this property. HasMultipleValues property\nindicates if this property will be returning more than one value.")


FloatProperty.cast = lambda arg: arg if isinstance(arg, FloatProperty) else None

class FloatSpinnerCommandInput(CommandInput):
    r"""Provides a command input to get the value of a spinner from the user, the value type is float."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::FloatSpinnerCommandInput *":
        return _core.FloatSpinnerCommandInput___deref__(self)

    def __eq__(self, rhs: "FloatSpinnerCommandInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.FloatSpinnerCommandInput___eq__(self, rhs)


    def __ne__(self, rhs: "FloatSpinnerCommandInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.FloatSpinnerCommandInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.FloatSpinnerCommandInput_classType()
    __swig_destroy__ = _core.delete_FloatSpinnerCommandInput

    def _get_value(self) -> "double":
        r"""
        Gets and sets the value associated with this input. The value is always in
        the database units of the unit type specified. For example, if the unit type is 'inch'
        this value is in centimeters since centimeters are the database length unit. When setting the
        value it is converted into a string using the unit type and displayed in the input box.
        The isValidExpression property should be checked before using this
        value within the command because if the expression can't be evaluated
        there isn't a valid value. Fusion 360 won't allow the execution of a command
        that contains ValueCommandInput object with invalid expressions so you can
        dependably use the value in the execute event of the command.
        """
        return _core.FloatSpinnerCommandInput__get_value(self)

    def _set_value(self, value: "double") -> "bool":
        r"""
        Gets and sets the value associated with this input. The value is always in
        the database units of the unit type specified. For example, if the unit type is 'inch'
        this value is in centimeters since centimeters are the database length unit. When setting the
        value it is converted into a string using the unit type and displayed in the input box.
        The isValidExpression property should be checked before using this
        value within the command because if the expression can't be evaluated
        there isn't a valid value. Fusion 360 won't allow the execution of a command
        that contains ValueCommandInput object with invalid expressions so you can
        dependably use the value in the execute event of the command.
        """
        return _core.FloatSpinnerCommandInput__set_value(self, value)

    def _get_unitType(self) -> "std::string":
        r"""Gets the unit type that is used when evaluating the user's input."""
        return _core.FloatSpinnerCommandInput__get_unitType(self)

    def _get_minimumValue(self) -> "double":
        r"""Gets the minimum allowed value of the spinner in database units."""
        return _core.FloatSpinnerCommandInput__get_minimumValue(self)

    def _get_maximumValue(self) -> "double":
        r"""Gets the maximum allowed value of the spinner in database units."""
        return _core.FloatSpinnerCommandInput__get_maximumValue(self)

    def _get_spinStep(self) -> "double":
        r"""
        Gets the spin step value in the unit type set by the unitType argument. 
        The value should be more than zero. This is the amount the spinner will advance
        when the user clicks the spin button beside the value.
        """
        return _core.FloatSpinnerCommandInput__get_spinStep(self)

    def _get_expression(self) -> "std::string":
        r"""
        Gets or sets the expression displayed in the input field. This can contain equations and
        references to parameters. It is evaluated using the specified unit type.
        """
        return _core.FloatSpinnerCommandInput__get_expression(self)

    def _set_expression(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the expression displayed in the input field. This can contain equations and
        references to parameters. It is evaluated using the specified unit type.
        """
        return _core.FloatSpinnerCommandInput__set_expression(self, value)

    def _get_isValidExpression(self) -> "bool":
        r"""
        Returns true if the current expression is valid and can be evaluated. If this
        is false, the value returned should be ignored because there currently is
        not a valid value.
        """
        return _core.FloatSpinnerCommandInput__get_isValidExpression(self)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.FloatSpinnerCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string":
        r"""Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.FloatSpinnerCommandInput__get_id(self)

    def _get_name(self) -> "std::string":
        r"""Gets the user visible name of this input."""
        return _core.FloatSpinnerCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.FloatSpinnerCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.FloatSpinnerCommandInput__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.FloatSpinnerCommandInput__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.FloatSpinnerCommandInput__set_isVisible(self, value)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the parent Command."""
        return _core.FloatSpinnerCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.FloatSpinnerCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.FloatSpinnerCommandInput__set_isFullWidth(self, value)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.FloatSpinnerCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.FloatSpinnerCommandInput__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.FloatSpinnerCommandInput__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.FloatSpinnerCommandInput__set_tooltip(self, value)

    def _get_tooltipDescription(self) -> "std::string":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.FloatSpinnerCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.FloatSpinnerCommandInput__set_tooltipDescription(self, value)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.FloatSpinnerCommandInput__get_parentCommandInput(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this Command input. 
        Returns true if the delete was successful.
        """
        return _core.FloatSpinnerCommandInput_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.FloatSpinnerCommandInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.FloatSpinnerCommandInput__get_isValid(self)

# Register FloatSpinnerCommandInput in _core:
_core.FloatSpinnerCommandInput_swigregister(FloatSpinnerCommandInput)

def FloatSpinnerCommandInput_classType() -> "char const *":
    return _core.FloatSpinnerCommandInput_classType()


FloatSpinnerCommandInput.value = property(FloatSpinnerCommandInput._get_value, FloatSpinnerCommandInput._set_value, doc="Gets and sets the value associated with this input. The value is always in\nthe database units of the unit type specified. For example, if the unit type is 'inch'\nthis value is in centimeters since centimeters are the database length unit. When setting the\nvalue it is converted into a string using the unit type and displayed in the input box.\nThe isValidExpression property should be checked before using this\nvalue within the command because if the expression can't be evaluated\nthere isn't a valid value. Fusion 360 won't allow the execution of a command\nthat contains ValueCommandInput object with invalid expressions so you can\ndependably use the value in the execute event of the command.")


FloatSpinnerCommandInput.unitType = property(FloatSpinnerCommandInput._get_unitType, doc="Gets the unit type that is used when evaluating the user's input.")


FloatSpinnerCommandInput.minimumValue = property(FloatSpinnerCommandInput._get_minimumValue, doc="Gets the minimum allowed value of the spinner in database units.")


FloatSpinnerCommandInput.maximumValue = property(FloatSpinnerCommandInput._get_maximumValue, doc="Gets the maximum allowed value of the spinner in database units.")


FloatSpinnerCommandInput.spinStep = property(FloatSpinnerCommandInput._get_spinStep, doc="Gets the spin step value in the unit type set by the unitType argument.\nThe value should be more than zero. This is the amount the spinner will advance\nwhen the user clicks the spin button beside the value.")


FloatSpinnerCommandInput.expression = property(FloatSpinnerCommandInput._get_expression, FloatSpinnerCommandInput._set_expression, doc="Gets or sets the expression displayed in the input field. This can contain equations and\nreferences to parameters. It is evaluated using the specified unit type.")


FloatSpinnerCommandInput.isValidExpression = property(FloatSpinnerCommandInput._get_isValidExpression, doc="Returns true if the current expression is valid and can be evaluated. If this\nis false, the value returned should be ignored because there currently is\nnot a valid value.")


FloatSpinnerCommandInput.cast = lambda arg: arg if isinstance(arg, FloatSpinnerCommandInput) else None

class FusionArchiveImportOptions(ImportOptions):
    r"""Defines that a Fusion 360 Archive import is to be done and specifies the various options."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::FusionArchiveImportOptions *":
        return _core.FusionArchiveImportOptions___deref__(self)

    def __eq__(self, rhs: "FusionArchiveImportOptions") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.FusionArchiveImportOptions___eq__(self, rhs)


    def __ne__(self, rhs: "FusionArchiveImportOptions") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.FusionArchiveImportOptions___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.FusionArchiveImportOptions_classType()
    __swig_destroy__ = _core.delete_FusionArchiveImportOptions

    def _get_filename(self) -> "std::string":
        r"""Gets and sets the filename or url of the file to be imported."""
        return _core.FusionArchiveImportOptions__get_filename(self)

    def _set_filename(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the filename or url of the file to be imported."""
        return _core.FusionArchiveImportOptions__set_filename(self, value)

    def _get_isViewFit(self) -> "bool":
        r"""
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.FusionArchiveImportOptions__get_isViewFit(self)

    def _set_isViewFit(self, value: "bool") -> "bool":
        r"""
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.FusionArchiveImportOptions__set_isViewFit(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.FusionArchiveImportOptions__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.FusionArchiveImportOptions__get_isValid(self)

# Register FusionArchiveImportOptions in _core:
_core.FusionArchiveImportOptions_swigregister(FusionArchiveImportOptions)

def FusionArchiveImportOptions_classType() -> "char const *":
    return _core.FusionArchiveImportOptions_classType()


FusionArchiveImportOptions.cast = lambda arg: arg if isinstance(arg, FusionArchiveImportOptions) else None

class GroupCommandInput(CommandInput):
    r"""
    Group Command inputs organize a set of command inputs into a collapsible 
    list within a command dialog
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::GroupCommandInput *":
        return _core.GroupCommandInput___deref__(self)

    def __eq__(self, rhs: "GroupCommandInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.GroupCommandInput___eq__(self, rhs)


    def __ne__(self, rhs: "GroupCommandInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.GroupCommandInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.GroupCommandInput_classType()
    __swig_destroy__ = _core.delete_GroupCommandInput

    def _get_children(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""
        Gets the CommandInputs collection for this GroupCommandInput. 
        Use the add methods on this collection to add child CommandInputs to this Group in the desired order.
        """
        return _core.GroupCommandInput__get_children(self)

    def _get_isExpanded(self) -> "bool":
        r"""
        Gets or sets if this group is expanded.
        If this is a sub-group of another group and the isEnabledCheckBoxDisplayed property is set to false 
        then the isExpanded property must be set to true.
        """
        return _core.GroupCommandInput__get_isExpanded(self)

    def _set_isExpanded(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this group is expanded.
        If this is a sub-group of another group and the isEnabledCheckBoxDisplayed property is set to false 
        then the isExpanded property must be set to true.
        """
        return _core.GroupCommandInput__set_isExpanded(self, value)

    def _get_isEnabledCheckBoxDisplayed(self) -> "bool":
        r"""
        Gets or sets if this group has a checkbox for enabling/disabling the group.
        If this is a sub-group of another group and the isEnabledCheckBoxDisplayed property is set to false 
        then the isExpanded property must be set to true.
        """
        return _core.GroupCommandInput__get_isEnabledCheckBoxDisplayed(self)

    def _set_isEnabledCheckBoxDisplayed(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this group has a checkbox for enabling/disabling the group.
        If this is a sub-group of another group and the isEnabledCheckBoxDisplayed property is set to false 
        then the isExpanded property must be set to true.
        """
        return _core.GroupCommandInput__set_isEnabledCheckBoxDisplayed(self, value)

    def _get_isEnabledCheckBoxChecked(self) -> "bool":
        r"""
        Gets or sets if the enabled check box is checked or not. This is only
        valid when the isEnabledCheckBoxDisplayed property is true.
        """
        return _core.GroupCommandInput__get_isEnabledCheckBoxChecked(self)

    def _set_isEnabledCheckBoxChecked(self, value: "bool") -> "bool":
        r"""
        Gets or sets if the enabled check box is checked or not. This is only
        valid when the isEnabledCheckBoxDisplayed property is true.
        """
        return _core.GroupCommandInput__set_isEnabledCheckBoxChecked(self, value)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.GroupCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string":
        r"""Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.GroupCommandInput__get_id(self)

    def _get_name(self) -> "std::string":
        r"""Gets the user visible name of this input."""
        return _core.GroupCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.GroupCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.GroupCommandInput__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.GroupCommandInput__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.GroupCommandInput__set_isVisible(self, value)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the parent Command."""
        return _core.GroupCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.GroupCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.GroupCommandInput__set_isFullWidth(self, value)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.GroupCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.GroupCommandInput__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.GroupCommandInput__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.GroupCommandInput__set_tooltip(self, value)

    def _get_tooltipDescription(self) -> "std::string":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.GroupCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.GroupCommandInput__set_tooltipDescription(self, value)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.GroupCommandInput__get_parentCommandInput(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this Command input. 
        Returns true if the delete was successful.
        """
        return _core.GroupCommandInput_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.GroupCommandInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.GroupCommandInput__get_isValid(self)

# Register GroupCommandInput in _core:
_core.GroupCommandInput_swigregister(GroupCommandInput)

def GroupCommandInput_classType() -> "char const *":
    return _core.GroupCommandInput_classType()


GroupCommandInput.children = property(GroupCommandInput._get_children, doc="Gets the CommandInputs collection for this GroupCommandInput.\nUse the add methods on this collection to add child CommandInputs to this Group in the desired order.")


GroupCommandInput.isExpanded = property(GroupCommandInput._get_isExpanded, GroupCommandInput._set_isExpanded, doc="Gets or sets if this group is expanded.\nIf this is a sub-group of another group and the isEnabledCheckBoxDisplayed property is set to false\nthen the isExpanded property must be set to true.")


GroupCommandInput.isEnabledCheckBoxDisplayed = property(GroupCommandInput._get_isEnabledCheckBoxDisplayed, GroupCommandInput._set_isEnabledCheckBoxDisplayed, doc="Gets or sets if this group has a checkbox for enabling/disabling the group.\nIf this is a sub-group of another group and the isEnabledCheckBoxDisplayed property is set to false\nthen the isExpanded property must be set to true.")


GroupCommandInput.isEnabledCheckBoxChecked = property(GroupCommandInput._get_isEnabledCheckBoxChecked, GroupCommandInput._set_isEnabledCheckBoxChecked, doc="Gets or sets if the enabled check box is checked or not. This is only\nvalid when the isEnabledCheckBoxDisplayed property is true.")


GroupCommandInput.cast = lambda arg: arg if isinstance(arg, GroupCommandInput) else None

class HTMLEvent(Event):
    r"""
    A HTMLEvent is fired when triggered from JavaScript code associated with HTML used
    in a palette.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::HTMLEvent *":
        return _core.HTMLEvent___deref__(self)

    def __eq__(self, rhs: "HTMLEvent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.HTMLEvent___eq__(self, rhs)


    def __ne__(self, rhs: "HTMLEvent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.HTMLEvent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.HTMLEvent_classType()
    __swig_destroy__ = _core.delete_HTMLEvent

    def add(self, handler: "HTMLEventHandler") -> "bool":
        r"""
        Add a handler to be notified when the event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _core.HTMLEvent_add(self, handler)

    def remove(self, handler: "HTMLEventHandler") -> "bool":
        r"""
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _core.HTMLEvent_remove(self, handler)

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _core.HTMLEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.HTMLEvent__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _core.HTMLEvent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.HTMLEvent__get_isValid(self)

# Register HTMLEvent in _core:
_core.HTMLEvent_swigregister(HTMLEvent)

def HTMLEvent_classType() -> "char const *":
    return _core.HTMLEvent_classType()


HTMLEvent.cast = lambda arg: arg if isinstance(arg, HTMLEvent) else None

class HTMLEventArgs(EventArgs):
    r"""
    The HTMLEventArgs provides access to the information sent from the JavaScript
    that's associated with HTML being displayed within a palette.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::HTMLEventArgs *":
        return _core.HTMLEventArgs___deref__(self)

    def __eq__(self, rhs: "HTMLEventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.HTMLEventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "HTMLEventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.HTMLEventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.HTMLEventArgs_classType()
    __swig_destroy__ = _core.delete_HTMLEventArgs

    def _get_action(self) -> "std::string":
        r"""
        The action string sent from the JavaScript associated with HTML displayed 
        in the palette. The string can represent any type of data in any format but 
        JSON is commonly used to pass more complex data.
        """
        return _core.HTMLEventArgs__get_action(self)

    def _get_data(self) -> "std::string":
        r"""
        The data string sent from the JavaScript associated with HTML displayed 
        in the palette. The string can represent any type of data in any format but 
        JSON is commonly used to pass more complex data.
        """
        return _core.HTMLEventArgs__get_data(self)

    def _get_returnData(self) -> "std::string":
        r"""Set this property to return data back to the JavaScript that's associated with the HTML."""
        return _core.HTMLEventArgs__get_returnData(self)

    def _set_returnData(self, value: "std::string const &") -> "bool":
        r"""Set this property to return data back to the JavaScript that's associated with the HTML."""
        return _core.HTMLEventArgs__set_returnData(self, value)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _core.HTMLEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _core.HTMLEventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.HTMLEventArgs__get_isValid(self)

# Register HTMLEventArgs in _core:
_core.HTMLEventArgs_swigregister(HTMLEventArgs)

def HTMLEventArgs_classType() -> "char const *":
    return _core.HTMLEventArgs_classType()


HTMLEventArgs.action = property(HTMLEventArgs._get_action, doc="The action string sent from the JavaScript associated with HTML displayed\nin the palette. The string can represent any type of data in any format but\nJSON is commonly used to pass more complex data.")


HTMLEventArgs.data = property(HTMLEventArgs._get_data, doc="The data string sent from the JavaScript associated with HTML displayed\nin the palette. The string can represent any type of data in any format but\nJSON is commonly used to pass more complex data.")


HTMLEventArgs.returnData = property(HTMLEventArgs._get_returnData, HTMLEventArgs._set_returnData, doc="Set this property to return data back to the JavaScript that's associated with the HTML.")


HTMLEventArgs.cast = lambda arg: arg if isinstance(arg, HTMLEventArgs) else None

class IGESImportOptions(ImportOptions):
    r"""Defines that an IGES import is to be done and specifies the various options."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::IGESImportOptions *":
        return _core.IGESImportOptions___deref__(self)

    def __eq__(self, rhs: "IGESImportOptions") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.IGESImportOptions___eq__(self, rhs)


    def __ne__(self, rhs: "IGESImportOptions") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.IGESImportOptions___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.IGESImportOptions_classType()
    __swig_destroy__ = _core.delete_IGESImportOptions

    def _get_filename(self) -> "std::string":
        r"""Gets and sets the filename or url of the file to be imported."""
        return _core.IGESImportOptions__get_filename(self)

    def _set_filename(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the filename or url of the file to be imported."""
        return _core.IGESImportOptions__set_filename(self, value)

    def _get_isViewFit(self) -> "bool":
        r"""
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.IGESImportOptions__get_isViewFit(self)

    def _set_isViewFit(self, value: "bool") -> "bool":
        r"""
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.IGESImportOptions__set_isViewFit(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.IGESImportOptions__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.IGESImportOptions__get_isValid(self)

# Register IGESImportOptions in _core:
_core.IGESImportOptions_swigregister(IGESImportOptions)

def IGESImportOptions_classType() -> "char const *":
    return _core.IGESImportOptions_classType()


IGESImportOptions.cast = lambda arg: arg if isinstance(arg, IGESImportOptions) else None

class ImageCommandInput(CommandInput):
    r"""Provides an image command input for including an image in a command dialog."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ImageCommandInput *":
        return _core.ImageCommandInput___deref__(self)

    def __eq__(self, rhs: "ImageCommandInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ImageCommandInput___eq__(self, rhs)


    def __ne__(self, rhs: "ImageCommandInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ImageCommandInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ImageCommandInput_classType()
    __swig_destroy__ = _core.delete_ImageCommandInput

    def _get_imageFile(self) -> "std::string":
        r"""
        Gets and sets the full path and file name of the image file.
        Supported image format is .png
        Images are displayed in the command dialog using their actual size.
        """
        return _core.ImageCommandInput__get_imageFile(self)

    def _set_imageFile(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the full path and file name of the image file.
        Supported image format is .png
        Images are displayed in the command dialog using their actual size.
        """
        return _core.ImageCommandInput__set_imageFile(self, value)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.ImageCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string":
        r"""Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.ImageCommandInput__get_id(self)

    def _get_name(self) -> "std::string":
        r"""Gets the user visible name of this input."""
        return _core.ImageCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.ImageCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.ImageCommandInput__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.ImageCommandInput__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.ImageCommandInput__set_isVisible(self, value)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the parent Command."""
        return _core.ImageCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.ImageCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.ImageCommandInput__set_isFullWidth(self, value)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.ImageCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.ImageCommandInput__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.ImageCommandInput__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.ImageCommandInput__set_tooltip(self, value)

    def _get_tooltipDescription(self) -> "std::string":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.ImageCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.ImageCommandInput__set_tooltipDescription(self, value)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.ImageCommandInput__get_parentCommandInput(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this Command input. 
        Returns true if the delete was successful.
        """
        return _core.ImageCommandInput_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.ImageCommandInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ImageCommandInput__get_isValid(self)

# Register ImageCommandInput in _core:
_core.ImageCommandInput_swigregister(ImageCommandInput)

def ImageCommandInput_classType() -> "char const *":
    return _core.ImageCommandInput_classType()


ImageCommandInput.imageFile = property(ImageCommandInput._get_imageFile, ImageCommandInput._set_imageFile, doc="Gets and sets the full path and file name of the image file.\nSupported image format is .png\nImages are displayed in the command dialog using their actual size.")


ImageCommandInput.cast = lambda arg: arg if isinstance(arg, ImageCommandInput) else None

class InfiniteLine3D(Curve3D):
    r"""
    Transient 3D infinite line. An infinite line is defined by a position and direction in space 
    and has no start or end points.
    They are created statically using the create method of the InfiniteLine3D class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::InfiniteLine3D *":
        return _core.InfiniteLine3D___deref__(self)

    def __eq__(self, rhs: "InfiniteLine3D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.InfiniteLine3D___eq__(self, rhs)


    def __ne__(self, rhs: "InfiniteLine3D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.InfiniteLine3D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.InfiniteLine3D_classType()

    @staticmethod
    def create(origin: "Point3D", direction: "Vector3D") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
        return _core.InfiniteLine3D_create(origin, direction)
    __swig_destroy__ = _core.delete_InfiniteLine3D

    def _get_origin(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets the origin point of the line."""
        return _core.InfiniteLine3D__get_origin(self)

    def _set_origin(self, value: "Point3D") -> "bool":
        r"""Gets and sets the origin point of the line."""
        return _core.InfiniteLine3D__set_origin(self, value)

    def _get_direction(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Gets and sets the direction of the line."""
        return _core.InfiniteLine3D__get_direction(self)

    def _set_direction(self, value: "Vector3D") -> "bool":
        r"""Gets and sets the direction of the line."""
        return _core.InfiniteLine3D__set_direction(self, value)

    def isColinearTo(self, line: "InfiniteLine3D") -> "bool":
        r"""
        Compare this line with another to check for collinearity. 
        line : The line to compare with for collinearity. 
        Returns true if the two lines are collinear.
        """
        return _core.InfiniteLine3D_isColinearTo(self, line)

    def copy(self) -> "adsk::core::Ptr< adsk::core::InfiniteLine3D >":
        r"""
        Creates and returns a copy of this line object. 
        Returns an independent copy of this line object.
        """
        return _core.InfiniteLine3D_copy(self)

    def intersectWithCurve(self, curve: "Curve3D") -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Intersect this line with a curve to get the intersection point(s). 
        curve : The intersecting curve.
        The curve can be a Line3D, InfininteLine3D, Circle3D, Arc3D, EllipticalArc3D, Ellipse3D, 
        or NurbsCurve3D. 
        Returns a collection of the intersection points.
        """
        return _core.InfiniteLine3D_intersectWithCurve(self, curve)

    def intersectWithSurface(self, surface: "Surface") -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Intersect this line with a surface to get the intersection point(s). 
        surface : The intersecting surface.
        The surface can be a Plane, Cone, Cylinder, EllipticalCone, EllipticalCylinder, Sphere, 
        Torus, or a NurbsSurface. 
        Returns a collection of the intersection points.
        """
        return _core.InfiniteLine3D_intersectWithSurface(self, surface)

    def getData(self) -> "bool":
        r"""
        Gets all of the data defining the infinite line. 
        origin : The output origin point of the line. 
        direction : The output direction of the line. 
        Returns true if successful.
        """
        return _core.InfiniteLine3D_getData(self)

    def set(self, origin: "Point3D", direction: "Vector3D") -> "bool":
        r"""
        Sets all of the data defining the infinite line. 
        origin : The origin point of the line. 
        direction : The direction of the line. 
        Returns true if successful.
        """
        return _core.InfiniteLine3D_set(self, origin, direction)

    def _get_curveType(self) -> "adsk::core::Curve3DTypes":
        r"""Returns the type of geometry this curve represents."""
        return _core.InfiniteLine3D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator3D >":
        r"""Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.InfiniteLine3D__get_evaluator(self)

    def transformBy(self, matrix: "Matrix3D") -> "bool":
        r"""
        Transforms this curve in 3D space. 
        matrix : A 3D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.InfiniteLine3D_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.InfiniteLine3D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.InfiniteLine3D__get_isValid(self)

# Register InfiniteLine3D in _core:
_core.InfiniteLine3D_swigregister(InfiniteLine3D)

def InfiniteLine3D_classType() -> "char const *":
    return _core.InfiniteLine3D_classType()

def InfiniteLine3D_create(origin: "Point3D", direction: "Vector3D") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
    return _core.InfiniteLine3D_create(origin, direction)


InfiniteLine3D.origin = property(InfiniteLine3D._get_origin, InfiniteLine3D._set_origin, doc="Gets and sets the origin point of the line.")


InfiniteLine3D.direction = property(InfiniteLine3D._get_direction, InfiniteLine3D._set_direction, doc="Gets and sets the direction of the line.")


InfiniteLine3D.cast = lambda arg: arg if isinstance(arg, InfiniteLine3D) else None

class InputChangedEvent(Event):
    r"""An event endpoint that supports the connection to client implemented InputChangedEventHandlers."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::InputChangedEvent *":
        return _core.InputChangedEvent___deref__(self)

    def __eq__(self, rhs: "InputChangedEvent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.InputChangedEvent___eq__(self, rhs)


    def __ne__(self, rhs: "InputChangedEvent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.InputChangedEvent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.InputChangedEvent_classType()
    __swig_destroy__ = _core.delete_InputChangedEvent

    def add(self, handler: "InputChangedEventHandler") -> "bool":
        r"""
        Adds an event handler to this event endpoint. 
        handler : The client implemented InputChangedEventHandler to be called when this event is triggered. 
        Returns true if the handler was successfully added to the set of event handlers.
        """
        return _core.InputChangedEvent_add(self, handler)

    def remove(self, handler: "InputChangedEventHandler") -> "bool":
        r"""
        Removes a handler from this event endpoint. 
        handler : A InputChangedEventHandler that was previously added to this event with the add method. 
        Returns true if the handler was found and removed from the set of event handlers.
        """
        return _core.InputChangedEvent_remove(self, handler)

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _core.InputChangedEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.InputChangedEvent__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _core.InputChangedEvent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.InputChangedEvent__get_isValid(self)

# Register InputChangedEvent in _core:
_core.InputChangedEvent_swigregister(InputChangedEvent)

def InputChangedEvent_classType() -> "char const *":
    return _core.InputChangedEvent_classType()


InputChangedEvent.cast = lambda arg: arg if isinstance(arg, InputChangedEvent) else None

class InputChangedEventArgs(EventArgs):
    r"""Provides a set of arguments from a firing InputChangedEvent to a InputEventChangedEventHandler's notify callback method."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::InputChangedEventArgs *":
        return _core.InputChangedEventArgs___deref__(self)

    def __eq__(self, rhs: "InputChangedEventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.InputChangedEventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "InputChangedEventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.InputChangedEventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.InputChangedEventArgs_classType()
    __swig_destroy__ = _core.delete_InputChangedEventArgs

    def _get_input(self) -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""Returns the command input that has just changed."""
        return _core.InputChangedEventArgs__get_input(self)

    def _get_inputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Returns the collection of command inputs that are associated with the command this event is being fired for."""
        return _core.InputChangedEventArgs__get_inputs(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _core.InputChangedEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _core.InputChangedEventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.InputChangedEventArgs__get_isValid(self)

# Register InputChangedEventArgs in _core:
_core.InputChangedEventArgs_swigregister(InputChangedEventArgs)

def InputChangedEventArgs_classType() -> "char const *":
    return _core.InputChangedEventArgs_classType()


InputChangedEventArgs.input = property(InputChangedEventArgs._get_input, doc="Returns the command input that has just changed.")


InputChangedEventArgs.inputs = property(InputChangedEventArgs._get_inputs, doc="Returns the collection of command inputs that are associated with the command this event is being fired for.")


InputChangedEventArgs.cast = lambda arg: arg if isinstance(arg, InputChangedEventArgs) else None

class IntegerProperty(Property):
    r"""An integer value property associated with a material or appearance."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::IntegerProperty *":
        return _core.IntegerProperty___deref__(self)

    def __eq__(self, rhs: "IntegerProperty") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.IntegerProperty___eq__(self, rhs)


    def __ne__(self, rhs: "IntegerProperty") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.IntegerProperty___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.IntegerProperty_classType()
    __swig_destroy__ = _core.delete_IntegerProperty

    def getLimits(self) -> "bool":
        r"""
        Method that returns any limits for the value of this property. The HasLimits property can
        be used to see if there are any limits or not. 
        hasLowLimit : Output Boolean that indicates if there is a low limit or not. 
        lowLimit : If the hasLowLimit argument is true, this argument returns the low limit. 
        hasHighLimit : Output Boolean that indicates if there is a high limit or not. 
        highLimit : If the hasHighLimit argument is true, this argument returns the high limit. 
        Returns true if the method call was successful.
        """
        return _core.IntegerProperty_getLimits(self)

    def _get_hasLimits(self) -> "bool":
        r"""
        Gets the boolean flag that indicates if the value of this property has any limits it must 
        be within to be valid. If True, use the GetLimits method to get the limit values.
        """
        return _core.IntegerProperty__get_hasLimits(self)

    def _get_hasMultipleValues(self) -> "bool":
        r"""Gets the boolean flag that indicates if this property has multiple values or not."""
        return _core.IntegerProperty__get_hasMultipleValues(self)

    def _get_value(self) -> "int":
        r"""
        Gets and sets this property value. The value of this property should be ignored 
        if the HasConnectedTexture property is true. Setting this will remove any 
        associated texture, if there is one.
        """
        return _core.IntegerProperty__get_value(self)

    def _set_value(self, value: "int") -> "bool":
        r"""
        Gets and sets this property value. The value of this property should be ignored 
        if the HasConnectedTexture property is true. Setting this will remove any 
        associated texture, if there is one.
        """
        return _core.IntegerProperty__set_value(self, value)

    def _get_values(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        Gets and sets the values associated with this property. HasMultipleValues property 
        indicates if this property will be returning more than one value.
        """
        return _core.IntegerProperty__get_values(self)

    def _set_values(self, value: "IntVector") -> "bool":
        r"""
        Gets and sets the values associated with this property. HasMultipleValues property 
        indicates if this property will be returning more than one value.
        """
        return _core.IntegerProperty__set_values(self, value)

    def _get_name(self) -> "std::string":
        r"""
        Returns the name of this property as seen in the user interface. This name is localized
        and can change based on the current language
        """
        return _core.IntegerProperty__get_name(self)

    def _get_isReadOnly(self) -> "bool":
        r"""Indicates if this property is read-only. If True any attempted edits will fail."""
        return _core.IntegerProperty__get_isReadOnly(self)

    def _get_id(self) -> "std::string":
        r"""Returns the unique ID of this property."""
        return _core.IntegerProperty__get_id(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the parent of this property."""
        return _core.IntegerProperty__get_parent(self)

    def _get_objectType(self) -> "char const *":
        return _core.IntegerProperty__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.IntegerProperty__get_isValid(self)

# Register IntegerProperty in _core:
_core.IntegerProperty_swigregister(IntegerProperty)

def IntegerProperty_classType() -> "char const *":
    return _core.IntegerProperty_classType()


IntegerProperty.hasLimits = property(IntegerProperty._get_hasLimits, doc="Gets the boolean flag that indicates if the value of this property has any limits it must\nbe within to be valid. If True, use the GetLimits method to get the limit values.")


IntegerProperty.hasMultipleValues = property(IntegerProperty._get_hasMultipleValues, doc="Gets the boolean flag that indicates if this property has multiple values or not.")


IntegerProperty.value = property(IntegerProperty._get_value, IntegerProperty._set_value, doc="Gets and sets this property value. The value of this property should be ignored\nif the HasConnectedTexture property is true. Setting this will remove any\nassociated texture, if there is one.")


IntegerProperty.values = property(IntegerProperty._get_values, IntegerProperty._set_values, doc="Gets and sets the values associated with this property. HasMultipleValues property\nindicates if this property will be returning more than one value.")


IntegerProperty.cast = lambda arg: arg if isinstance(arg, IntegerProperty) else None

class IntegerSpinnerCommandInput(CommandInput):
    r"""Provides a command input to get the value of a spinner from the user, the value type is integer."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::IntegerSpinnerCommandInput *":
        return _core.IntegerSpinnerCommandInput___deref__(self)

    def __eq__(self, rhs: "IntegerSpinnerCommandInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.IntegerSpinnerCommandInput___eq__(self, rhs)


    def __ne__(self, rhs: "IntegerSpinnerCommandInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.IntegerSpinnerCommandInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.IntegerSpinnerCommandInput_classType()
    __swig_destroy__ = _core.delete_IntegerSpinnerCommandInput

    def _get_value(self) -> "int":
        r"""Gets and sets the value associated with this input."""
        return _core.IntegerSpinnerCommandInput__get_value(self)

    def _set_value(self, value: "int") -> "bool":
        r"""Gets and sets the value associated with this input."""
        return _core.IntegerSpinnerCommandInput__set_value(self, value)

    def _get_minimumValue(self) -> "int":
        r"""Gets the minimum allowed value of the spinner."""
        return _core.IntegerSpinnerCommandInput__get_minimumValue(self)

    def _get_maximumValue(self) -> "int":
        r"""Gets the maximum allowed value of the spinner."""
        return _core.IntegerSpinnerCommandInput__get_maximumValue(self)

    def _get_spinStep(self) -> "size_t":
        r"""
        Gets the spin step. The value should be more than zero. This is the amount the spinner will advance
        when the user clicks the spin button beside the value.
        """
        return _core.IntegerSpinnerCommandInput__get_spinStep(self)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.IntegerSpinnerCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string":
        r"""Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.IntegerSpinnerCommandInput__get_id(self)

    def _get_name(self) -> "std::string":
        r"""Gets the user visible name of this input."""
        return _core.IntegerSpinnerCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.IntegerSpinnerCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.IntegerSpinnerCommandInput__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.IntegerSpinnerCommandInput__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.IntegerSpinnerCommandInput__set_isVisible(self, value)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the parent Command."""
        return _core.IntegerSpinnerCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.IntegerSpinnerCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.IntegerSpinnerCommandInput__set_isFullWidth(self, value)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.IntegerSpinnerCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.IntegerSpinnerCommandInput__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.IntegerSpinnerCommandInput__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.IntegerSpinnerCommandInput__set_tooltip(self, value)

    def _get_tooltipDescription(self) -> "std::string":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.IntegerSpinnerCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.IntegerSpinnerCommandInput__set_tooltipDescription(self, value)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.IntegerSpinnerCommandInput__get_parentCommandInput(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this Command input. 
        Returns true if the delete was successful.
        """
        return _core.IntegerSpinnerCommandInput_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.IntegerSpinnerCommandInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.IntegerSpinnerCommandInput__get_isValid(self)

# Register IntegerSpinnerCommandInput in _core:
_core.IntegerSpinnerCommandInput_swigregister(IntegerSpinnerCommandInput)

def IntegerSpinnerCommandInput_classType() -> "char const *":
    return _core.IntegerSpinnerCommandInput_classType()


IntegerSpinnerCommandInput.value = property(IntegerSpinnerCommandInput._get_value, IntegerSpinnerCommandInput._set_value, doc="Gets and sets the value associated with this input.")


IntegerSpinnerCommandInput.minimumValue = property(IntegerSpinnerCommandInput._get_minimumValue, doc="Gets the minimum allowed value of the spinner.")


IntegerSpinnerCommandInput.maximumValue = property(IntegerSpinnerCommandInput._get_maximumValue, doc="Gets the maximum allowed value of the spinner.")


IntegerSpinnerCommandInput.spinStep = property(IntegerSpinnerCommandInput._get_spinStep, doc="Gets the spin step. The value should be more than zero. This is the amount the spinner will advance\nwhen the user clicks the spin button beside the value.")


IntegerSpinnerCommandInput.cast = lambda arg: arg if isinstance(arg, IntegerSpinnerCommandInput) else None

class KeyboardEvent(Event):
    r"""An event endpoint that supports the connection to client implemented KeyboardEventHandlers."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::KeyboardEvent *":
        return _core.KeyboardEvent___deref__(self)

    def __eq__(self, rhs: "KeyboardEvent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.KeyboardEvent___eq__(self, rhs)


    def __ne__(self, rhs: "KeyboardEvent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.KeyboardEvent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.KeyboardEvent_classType()
    __swig_destroy__ = _core.delete_KeyboardEvent

    def add(self, handler: "KeyboardEventHandler") -> "bool":
        r"""
        Adds an event handler to this event endpoint. 
        handler : The client implemented KeyboardEventHandler to be called when this event is triggered. 
        Returns true if the handler was successfully added to the set of event handlers.
        """
        return _core.KeyboardEvent_add(self, handler)

    def remove(self, handler: "KeyboardEventHandler") -> "bool":
        r"""
        Removes a handler from this event endpoint. 
        handler : A KeyboardEventHandler that was previously added to this event with the add method. 
        Returns true if the handler was found and removed from the set of event handlers.
        """
        return _core.KeyboardEvent_remove(self, handler)

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _core.KeyboardEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.KeyboardEvent__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _core.KeyboardEvent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.KeyboardEvent__get_isValid(self)

# Register KeyboardEvent in _core:
_core.KeyboardEvent_swigregister(KeyboardEvent)

def KeyboardEvent_classType() -> "char const *":
    return _core.KeyboardEvent_classType()


KeyboardEvent.cast = lambda arg: arg if isinstance(arg, KeyboardEvent) else None

class KeyboardEventArgs(EventArgs):
    r"""Provides a set of arguments from a firing KeyboardEvent to a KeyboardEventHandler's notify callback method."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::KeyboardEventArgs *":
        return _core.KeyboardEventArgs___deref__(self)

    def __eq__(self, rhs: "KeyboardEventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.KeyboardEventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "KeyboardEventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.KeyboardEventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.KeyboardEventArgs_classType()
    __swig_destroy__ = _core.delete_KeyboardEventArgs

    def _get_modifierMask(self) -> "int":
        r"""
        Gets the set of keyboard modifiers that were active. The value is the Boolean
        combination of KeyboardModifiers values.
        """
        return _core.KeyboardEventArgs__get_modifierMask(self)

    def _get_keyCode(self) -> "adsk::core::KeyCodes":
        r"""Gets the keyboard key."""
        return _core.KeyboardEventArgs__get_keyCode(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _core.KeyboardEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _core.KeyboardEventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.KeyboardEventArgs__get_isValid(self)

# Register KeyboardEventArgs in _core:
_core.KeyboardEventArgs_swigregister(KeyboardEventArgs)

def KeyboardEventArgs_classType() -> "char const *":
    return _core.KeyboardEventArgs_classType()


KeyboardEventArgs.modifierMask = property(KeyboardEventArgs._get_modifierMask, doc="Gets the set of keyboard modifiers that were active. The value is the Boolean\ncombination of KeyboardModifiers values.")


KeyboardEventArgs.keyCode = property(KeyboardEventArgs._get_keyCode, doc="Gets the keyboard key.")


KeyboardEventArgs.cast = lambda arg: arg if isinstance(arg, KeyboardEventArgs) else None

class Line2D(Curve2D):
    r"""
    Transient 2D line. A transient line is not displayed or saved in a document.
    Transient 2D lines are used as a wrapper to work with raw 2D line information.
    They are created statically using the create method of the Line2D class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Line2D *":
        return _core.Line2D___deref__(self)

    def __eq__(self, rhs: "Line2D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Line2D___eq__(self, rhs)


    def __ne__(self, rhs: "Line2D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Line2D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Line2D_classType()

    @staticmethod
    def create(startPoint: "Point2D", endPoint: "Point2D") -> "adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Point2D > const &":
        return _core.Line2D_create(startPoint, endPoint)
    __swig_destroy__ = _core.delete_Line2D

    def _get_startPoint(self) -> "adsk::core::Ptr< adsk::core::Point2D >":
        r"""Gets and sets the start point of the line."""
        return _core.Line2D__get_startPoint(self)

    def _set_startPoint(self, value: "Point2D") -> "bool":
        r"""Gets and sets the start point of the line."""
        return _core.Line2D__set_startPoint(self, value)

    def _get_endPoint(self) -> "adsk::core::Ptr< adsk::core::Point2D >":
        r"""Gets and sets the end point of the line."""
        return _core.Line2D__get_endPoint(self)

    def _set_endPoint(self, value: "Point2D") -> "bool":
        r"""Gets and sets the end point of the line."""
        return _core.Line2D__set_endPoint(self, value)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Line2D >":
        r"""
        Creates and returns a copy of this line object. 
        Returns an independent copy of this line object.
        """
        return _core.Line2D_copy(self)

    def getData(self) -> "bool":
        r"""
        Gets all of the data defining the line segment. 
        startPoint : The output start point of the line. 
        endPoint : The output end point of the line. 
        Returns true if successful.
        """
        return _core.Line2D_getData(self)

    def set(self, startPoint: "Point2D", endPoint: "Point2D") -> "bool":
        r"""
        Sets all of the data defining the line segment. 
        startPoint : The start point of the line 
        endPoint : The end point of the line 
        Returns true if redefining the line is successful
        """
        return _core.Line2D_set(self, startPoint, endPoint)

    def _get_asNurbsCurve(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve2D >":
        r"""Returns a NURBS curve that is geometrically identical to the line."""
        return _core.Line2D__get_asNurbsCurve(self)

    def _get_curveType(self) -> "adsk::core::Curve2DTypes":
        r"""Returns the type of geometry this curve represents."""
        return _core.Line2D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator2D >":
        r"""Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.Line2D__get_evaluator(self)

    def transformBy(self, matrix: "Matrix2D") -> "bool":
        r"""
        Transforms this curve in 2D space. 
        matrix : A 2D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.Line2D_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.Line2D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Line2D__get_isValid(self)

# Register Line2D in _core:
_core.Line2D_swigregister(Line2D)

def Line2D_classType() -> "char const *":
    return _core.Line2D_classType()

def Line2D_create(startPoint: "Point2D", endPoint: "Point2D") -> "adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Point2D > const &":
    return _core.Line2D_create(startPoint, endPoint)


Line2D.startPoint = property(Line2D._get_startPoint, Line2D._set_startPoint, doc="Gets and sets the start point of the line.")


Line2D.endPoint = property(Line2D._get_endPoint, Line2D._set_endPoint, doc="Gets and sets the end point of the line.")


Line2D.asNurbsCurve = property(Line2D._get_asNurbsCurve, doc="Returns a NURBS curve that is geometrically identical to the line.")


Line2D.cast = lambda arg: arg if isinstance(arg, Line2D) else None

class Line3D(Curve3D):
    r"""
    Transient 3D line. A transient line is not displayed or saved in a document.
    Transient 3D lines are used as a wrapper to work with raw 3D line information.
    They are created statically using the create method of the Line3D class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Line3D *":
        return _core.Line3D___deref__(self)

    def __eq__(self, rhs: "Line3D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Line3D___eq__(self, rhs)


    def __ne__(self, rhs: "Line3D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Line3D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Line3D_classType()

    @staticmethod
    def create(startPoint: "Point3D", endPoint: "Point3D") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Point3D > const &":
        return _core.Line3D_create(startPoint, endPoint)
    __swig_destroy__ = _core.delete_Line3D

    def _get_startPoint(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets the start point of the line."""
        return _core.Line3D__get_startPoint(self)

    def _set_startPoint(self, value: "Point3D") -> "bool":
        r"""Gets and sets the start point of the line."""
        return _core.Line3D__set_startPoint(self, value)

    def _get_endPoint(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets the end point of the line."""
        return _core.Line3D__get_endPoint(self)

    def _set_endPoint(self, value: "Point3D") -> "bool":
        r"""Gets and sets the end point of the line."""
        return _core.Line3D__set_endPoint(self, value)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Line3D >":
        r"""
        Creates and returns a copy of this line object. 
        Returns an independent copy of this line object.
        """
        return _core.Line3D_copy(self)

    def asInfiniteLine(self) -> "adsk::core::Ptr< adsk::core::InfiniteLine3D >":
        r"""
        Creates an equivalent InfiniteLine3D. 
        Returns an equivalent InfiniteLine3D
        """
        return _core.Line3D_asInfiniteLine(self)

    def isColinearTo(self, line: "Line3D") -> "bool":
        r"""
        Compare this line with another to check for collinearity 
        line : The line to compare with for collinearity 
        Returns true if the two lines are collinear
        """
        return _core.Line3D_isColinearTo(self, line)

    def intersectWithCurve(self, curve: "Curve3D") -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Intersect this line with a curve to get the intersection point(s). 
        curve : The intersecting curve.
        The curve can be a Line3D, InfininteLine3D, Circle3D, Arc3D, EllipticalArc3D, Ellipse3D, 
        or NurbsCurve3D. 
        Returns a collection of the intersection points
        """
        return _core.Line3D_intersectWithCurve(self, curve)

    def intersectWithSurface(self, surface: "Surface") -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Intersect this line with a surface to get the intersection point(s). 
        surface : The intersecting surface.
        The surface can be a Plane, Cone, Cylinder, EllipticalCone, EllipticalCylinder, Sphere, 
        Torus or a NurbsSurface. 
        Returns a collection of the intersection points.
        """
        return _core.Line3D_intersectWithSurface(self, surface)

    def getData(self) -> "bool":
        r"""
        Gets all of the data defining the line segment. 
        startPoint : The output start point of the line. 
        endPoint : The output end point of the line. 
        Returns true if successful.
        """
        return _core.Line3D_getData(self)

    def set(self, startPoint: "Point3D", endPoint: "Point3D") -> "bool":
        r"""
        Sets all of the data defining the line segment. 
        startPoint : The start point of the line. 
        endPoint : The end point of the line. 
        Returns true if successful.
        """
        return _core.Line3D_set(self, startPoint, endPoint)

    def _get_asNurbsCurve(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >":
        r"""Returns a NURBS curve that is geometrically identical to the line."""
        return _core.Line3D__get_asNurbsCurve(self)

    def _get_curveType(self) -> "adsk::core::Curve3DTypes":
        r"""Returns the type of geometry this curve represents."""
        return _core.Line3D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator3D >":
        r"""Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.Line3D__get_evaluator(self)

    def transformBy(self, matrix: "Matrix3D") -> "bool":
        r"""
        Transforms this curve in 3D space. 
        matrix : A 3D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.Line3D_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.Line3D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Line3D__get_isValid(self)

# Register Line3D in _core:
_core.Line3D_swigregister(Line3D)

def Line3D_classType() -> "char const *":
    return _core.Line3D_classType()

def Line3D_create(startPoint: "Point3D", endPoint: "Point3D") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Point3D > const &":
    return _core.Line3D_create(startPoint, endPoint)


Line3D.startPoint = property(Line3D._get_startPoint, Line3D._set_startPoint, doc="Gets and sets the start point of the line.")


Line3D.endPoint = property(Line3D._get_endPoint, Line3D._set_endPoint, doc="Gets and sets the end point of the line.")


Line3D.asNurbsCurve = property(Line3D._get_asNurbsCurve, doc="Returns a NURBS curve that is geometrically identical to the line.")


Line3D.cast = lambda arg: arg if isinstance(arg, Line3D) else None

class ListControlDefinition(ControlDefinition):
    r"""
    Represents the information used to define a list of check boxes, radio buttons, or text with icons. This class
    isn't the visible list control but is the information needed to create a list control and fully defines a list except for 
    it's position within the user interface.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ListControlDefinition *":
        return _core.ListControlDefinition___deref__(self)

    def __eq__(self, rhs: "ListControlDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ListControlDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ListControlDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ListControlDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ListControlDefinition_classType()
    __swig_destroy__ = _core.delete_ListControlDefinition

    def _get_listItems(self) -> "adsk::core::Ptr< adsk::core::ListItems >":
        r"""Gets the associated ListControlItems collection through which you can add and modify items in the list."""
        return _core.ListControlDefinition__get_listItems(self)

    def _get_listControlDisplayType(self) -> "adsk::core::ListControlDisplayTypes":
        r"""Gets how this list control will be displayed; as a standard list, a list of check boxes, or a list of radio buttons."""
        return _core.ListControlDefinition__get_listControlDisplayType(self)

    def _get_lastSelected(self) -> "adsk::core::Ptr< adsk::core::ListItem >":
        r"""
        Gets the item in the list that was last selected. This can return null
        in the case where this control is displayed as a list of check boxes and there hasn't 
        been any interaction by the end-user. In the case of a list of check boxes, this returns
        the item that was last clicked by the user, whether it was to check or uncheck the item.
        In the case of a list of radio buttons, this always returns the item that is currently selected.
        """
        return _core.ListControlDefinition__get_lastSelected(self)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this definition is enabled or not. This has the effect of enabling and disabling any associated controls."""
        return _core.ListControlDefinition__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this definition is enabled or not. This has the effect of enabling and disabling any associated controls."""
        return _core.ListControlDefinition__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this definition is visible or not. This has the effect of making any associated controls visible or invisible in the user interface."""
        return _core.ListControlDefinition__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this definition is visible or not. This has the effect of making any associated controls visible or invisible in the user interface."""
        return _core.ListControlDefinition__set_isVisible(self, value)

    def _get_name(self) -> "std::string":
        r"""Gets or sets the name for this control. This is the visible name displayed in the user interface."""
        return _core.ListControlDefinition__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Gets or sets the name for this control. This is the visible name displayed in the user interface."""
        return _core.ListControlDefinition__set_name(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.ListControlDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ListControlDefinition__get_isValid(self)

# Register ListControlDefinition in _core:
_core.ListControlDefinition_swigregister(ListControlDefinition)

def ListControlDefinition_classType() -> "char const *":
    return _core.ListControlDefinition_classType()


ListControlDefinition.listItems = property(ListControlDefinition._get_listItems, doc="Gets the associated ListControlItems collection through which you can add and modify items in the list.")


ListControlDefinition.listControlDisplayType = property(ListControlDefinition._get_listControlDisplayType, doc="Gets how this list control will be displayed; as a standard list, a list of check boxes, or a list of radio buttons.")


ListControlDefinition.lastSelected = property(ListControlDefinition._get_lastSelected, doc="Gets the item in the list that was last selected. This can return null\nin the case where this control is displayed as a list of check boxes and there hasn't\nbeen any interaction by the end-user. In the case of a list of check boxes, this returns\nthe item that was last clicked by the user, whether it was to check or uncheck the item.\nIn the case of a list of radio buttons, this always returns the item that is currently selected.")


ListControlDefinition.cast = lambda arg: arg if isinstance(arg, ListControlDefinition) else None

class MarkingMenuEvent(Event):
    r"""
    A MarkingMenuEvent is fired when the marking menu and context menu are displayed. For example, in response to the
    markingMenuDisplaying event.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::MarkingMenuEvent *":
        return _core.MarkingMenuEvent___deref__(self)

    def __eq__(self, rhs: "MarkingMenuEvent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.MarkingMenuEvent___eq__(self, rhs)


    def __ne__(self, rhs: "MarkingMenuEvent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.MarkingMenuEvent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.MarkingMenuEvent_classType()
    __swig_destroy__ = _core.delete_MarkingMenuEvent

    def add(self, handler: "MarkingMenuEventHandler") -> "bool":
        r"""
        Add a handler to be notified when the event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _core.MarkingMenuEvent_add(self, handler)

    def remove(self, handler: "MarkingMenuEventHandler") -> "bool":
        r"""
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _core.MarkingMenuEvent_remove(self, handler)

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _core.MarkingMenuEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.MarkingMenuEvent__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _core.MarkingMenuEvent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.MarkingMenuEvent__get_isValid(self)

# Register MarkingMenuEvent in _core:
_core.MarkingMenuEvent_swigregister(MarkingMenuEvent)

def MarkingMenuEvent_classType() -> "char const *":
    return _core.MarkingMenuEvent_classType()


MarkingMenuEvent.cast = lambda arg: arg if isinstance(arg, MarkingMenuEvent) else None

class MarkingMenuEventArgs(EventArgs):
    r"""
    The MarkingMenuEventArgs provides information associated with the marking and context
    menu being displayed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::MarkingMenuEventArgs *":
        return _core.MarkingMenuEventArgs___deref__(self)

    def __eq__(self, rhs: "MarkingMenuEventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.MarkingMenuEventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "MarkingMenuEventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.MarkingMenuEventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.MarkingMenuEventArgs_classType()
    __swig_destroy__ = _core.delete_MarkingMenuEventArgs

    def _get_radialMarkingMenu(self) -> "adsk::core::Ptr< adsk::core::RadialMarkingMenu >":
        r"""Provides access to the radial marking menu."""
        return _core.MarkingMenuEventArgs__get_radialMarkingMenu(self)

    def _get_linearMarkingMenu(self) -> "adsk::core::Ptr< adsk::core::LinearMarkingMenu >":
        r"""Provides access to the linear marking menu."""
        return _core.MarkingMenuEventArgs__get_linearMarkingMenu(self)

    def _get_selectedEntities(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base >,std::allocator< adsk::core::Ptr< adsk::core::Base > > >":
        r"""
        Returns the currently selected entities that the user left-clicked over.
        These provide the 'context' of what should be displayed in the menu. This
        can be an empty array in the case where they clicked in a open area within 
        the graphics window.
        """
        return _core.MarkingMenuEventArgs__get_selectedEntities(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _core.MarkingMenuEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _core.MarkingMenuEventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.MarkingMenuEventArgs__get_isValid(self)

# Register MarkingMenuEventArgs in _core:
_core.MarkingMenuEventArgs_swigregister(MarkingMenuEventArgs)

def MarkingMenuEventArgs_classType() -> "char const *":
    return _core.MarkingMenuEventArgs_classType()


MarkingMenuEventArgs.radialMarkingMenu = property(MarkingMenuEventArgs._get_radialMarkingMenu, doc="Provides access to the radial marking menu.")


MarkingMenuEventArgs.linearMarkingMenu = property(MarkingMenuEventArgs._get_linearMarkingMenu, doc="Provides access to the linear marking menu.")


MarkingMenuEventArgs.selectedEntities = property(MarkingMenuEventArgs._get_selectedEntities, doc="Returns the currently selected entities that the user left-clicked over.\nThese provide the 'context' of what should be displayed in the menu. This\ncan be an empty array in the case where they clicked in a open area within\nthe graphics window.")


MarkingMenuEventArgs.cast = lambda arg: arg if isinstance(arg, MarkingMenuEventArgs) else None

class MouseEvent(Event):
    r"""An event endpoint that supports the connection to client implemented MouseEventHandlers."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::MouseEvent *":
        return _core.MouseEvent___deref__(self)

    def __eq__(self, rhs: "MouseEvent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.MouseEvent___eq__(self, rhs)


    def __ne__(self, rhs: "MouseEvent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.MouseEvent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.MouseEvent_classType()
    __swig_destroy__ = _core.delete_MouseEvent

    def add(self, handler: "MouseEventHandler") -> "bool":
        r"""
        Adds an event handler to this event endpoint. 
        handler : The client implemented MouseEventHandler to be called when this event is triggered. 
        Returns true if the handler was successfully added to the set of event handlers.
        """
        return _core.MouseEvent_add(self, handler)

    def remove(self, handler: "MouseEventHandler") -> "bool":
        r"""
        Removes a handler from this event endpoint. 
        handler : A MouseEventhandler that was previously added to this event with the add method. 
        Returns true if the handler was found and removed from the set of event handlers.
        """
        return _core.MouseEvent_remove(self, handler)

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _core.MouseEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.MouseEvent__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _core.MouseEvent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.MouseEvent__get_isValid(self)

# Register MouseEvent in _core:
_core.MouseEvent_swigregister(MouseEvent)

def MouseEvent_classType() -> "char const *":
    return _core.MouseEvent_classType()


MouseEvent.cast = lambda arg: arg if isinstance(arg, MouseEvent) else None

class MouseEventArgs(EventArgs):
    r"""Provides a set of arguments from a firing MouseEvent to a MouseEventHandler's notify callback method."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::MouseEventArgs *":
        return _core.MouseEventArgs___deref__(self)

    def __eq__(self, rhs: "MouseEventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.MouseEventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "MouseEventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.MouseEventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.MouseEventArgs_classType()
    __swig_destroy__ = _core.delete_MouseEventArgs

    def _get_button(self) -> "adsk::core::MouseButtons":
        r"""
        Gets which mouse button(s) are pressed. The returned value
        is bitwise and can indicate that more than one button is pressed.
        """
        return _core.MouseEventArgs__get_button(self)

    def _get_clicks(self) -> "size_t":
        r"""Gets the number of times the button was pressed and released."""
        return _core.MouseEventArgs__get_clicks(self)

    def _get_wheelDelta(self) -> "int":
        r"""Gets a signed count of the number of detents the mouse wheel has rotated."""
        return _core.MouseEventArgs__get_wheelDelta(self)

    def _get_keyboardModifiers(self) -> "adsk::core::KeyboardModifiers":
        r"""
        Gets which modifier keys are currently pressed. The returned value
        is bitwise and can indicate that more than one button is pressed.
        """
        return _core.MouseEventArgs__get_keyboardModifiers(self)

    def _get_position(self) -> "adsk::core::Ptr< adsk::core::Point2D >":
        r"""Gets the coordinate of the mouse in screen space."""
        return _core.MouseEventArgs__get_position(self)

    def _get_viewportPosition(self) -> "adsk::core::Ptr< adsk::core::Point2D >":
        r"""
        Gets the coordinate of the mouse in viewport space, if the mouse is
        within a viewport. If the mouse is not over a viewport this property will return null.
        """
        return _core.MouseEventArgs__get_viewportPosition(self)

    def _get_viewport(self) -> "adsk::core::Ptr< adsk::core::Viewport >":
        r"""
        Returns the viewport where the mouse event occurred, if it was within a viewport.
        If the mouse is not over a viewport this property will return null.
        """
        return _core.MouseEventArgs__get_viewport(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _core.MouseEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _core.MouseEventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.MouseEventArgs__get_isValid(self)

# Register MouseEventArgs in _core:
_core.MouseEventArgs_swigregister(MouseEventArgs)

def MouseEventArgs_classType() -> "char const *":
    return _core.MouseEventArgs_classType()


MouseEventArgs.button = property(MouseEventArgs._get_button, doc="Gets which mouse button(s) are pressed. The returned value\nis bitwise and can indicate that more than one button is pressed.")


MouseEventArgs.clicks = property(MouseEventArgs._get_clicks, doc="Gets the number of times the button was pressed and released.")


MouseEventArgs.wheelDelta = property(MouseEventArgs._get_wheelDelta, doc="Gets a signed count of the number of detents the mouse wheel has rotated.")


MouseEventArgs.keyboardModifiers = property(MouseEventArgs._get_keyboardModifiers, doc="Gets which modifier keys are currently pressed. The returned value\nis bitwise and can indicate that more than one button is pressed.")


MouseEventArgs.position = property(MouseEventArgs._get_position, doc="Gets the coordinate of the mouse in screen space.")


MouseEventArgs.viewportPosition = property(MouseEventArgs._get_viewportPosition, doc="Gets the coordinate of the mouse in viewport space, if the mouse is\nwithin a viewport. If the mouse is not over a viewport this property will return null.")


MouseEventArgs.viewport = property(MouseEventArgs._get_viewport, doc="Returns the viewport where the mouse event occurred, if it was within a viewport.\nIf the mouse is not over a viewport this property will return null.")


MouseEventArgs.cast = lambda arg: arg if isinstance(arg, MouseEventArgs) else None

class NavigationEvent(Event):
    r"""A NavigationEvent is fired when a link is navigated on the page in a palette."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::NavigationEvent *":
        return _core.NavigationEvent___deref__(self)

    def __eq__(self, rhs: "NavigationEvent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.NavigationEvent___eq__(self, rhs)


    def __ne__(self, rhs: "NavigationEvent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.NavigationEvent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.NavigationEvent_classType()
    __swig_destroy__ = _core.delete_NavigationEvent

    def add(self, handler: "NavigationEventHandler") -> "bool":
        r"""
        Add a handler to be notified when the event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _core.NavigationEvent_add(self, handler)

    def remove(self, handler: "NavigationEventHandler") -> "bool":
        r"""
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _core.NavigationEvent_remove(self, handler)

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _core.NavigationEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.NavigationEvent__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _core.NavigationEvent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.NavigationEvent__get_isValid(self)

# Register NavigationEvent in _core:
_core.NavigationEvent_swigregister(NavigationEvent)

def NavigationEvent_classType() -> "char const *":
    return _core.NavigationEvent_classType()


NavigationEvent.cast = lambda arg: arg if isinstance(arg, NavigationEvent) else None

class NavigationEventArgs(EventArgs):
    r"""
    The NavigationEventArgs provides access to the information sent from the browser
    within a palette on a navigation event.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::NavigationEventArgs *":
        return _core.NavigationEventArgs___deref__(self)

    def __eq__(self, rhs: "NavigationEventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.NavigationEventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "NavigationEventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.NavigationEventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.NavigationEventArgs_classType()
    __swig_destroy__ = _core.delete_NavigationEventArgs

    def _get_navigationURL(self) -> "std::string":
        r"""The URL that is being navigated to."""
        return _core.NavigationEventArgs__get_navigationURL(self)

    def _set_navigationURL(self, value: "std::string const &") -> "bool":
        r"""The URL that is being navigated to."""
        return _core.NavigationEventArgs__set_navigationURL(self, value)

    def _get_launchExternally(self) -> "bool":
        r"""
        If True, the URL will be navigated to in an external browser by the operating system.
        If False, the default value, the URL will be navigated to in the palette's browser.
        """
        return _core.NavigationEventArgs__get_launchExternally(self)

    def _set_launchExternally(self, value: "bool") -> "bool":
        r"""
        If True, the URL will be navigated to in an external browser by the operating system.
        If False, the default value, the URL will be navigated to in the palette's browser.
        """
        return _core.NavigationEventArgs__set_launchExternally(self, value)

    def _get_preventDefault(self) -> "bool":
        r"""
        If True, the default handling of this navigation event will not continue.
        If False, the default value, the default handling of this navigation event will continue.
        """
        return _core.NavigationEventArgs__get_preventDefault(self)

    def _set_preventDefault(self, value: "bool") -> "bool":
        r"""
        If True, the default handling of this navigation event will not continue.
        If False, the default value, the default handling of this navigation event will continue.
        """
        return _core.NavigationEventArgs__set_preventDefault(self, value)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _core.NavigationEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _core.NavigationEventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.NavigationEventArgs__get_isValid(self)

# Register NavigationEventArgs in _core:
_core.NavigationEventArgs_swigregister(NavigationEventArgs)

def NavigationEventArgs_classType() -> "char const *":
    return _core.NavigationEventArgs_classType()


NavigationEventArgs.navigationURL = property(NavigationEventArgs._get_navigationURL, NavigationEventArgs._set_navigationURL, doc="The URL that is being navigated to.")


NavigationEventArgs.launchExternally = property(NavigationEventArgs._get_launchExternally, NavigationEventArgs._set_launchExternally, doc="If True, the URL will be navigated to in an external browser by the operating system.\nIf False, the default value, the URL will be navigated to in the palette's browser.")


NavigationEventArgs.preventDefault = property(NavigationEventArgs._get_preventDefault, NavigationEventArgs._set_preventDefault, doc="If True, the default handling of this navigation event will not continue.\nIf False, the default value, the default handling of this navigation event will continue.")


NavigationEventArgs.cast = lambda arg: arg if isinstance(arg, NavigationEventArgs) else None

class NurbsCurve2D(Curve2D):
    r"""
    Transient 2D NURBS curve. A transient NURBS curve is not displayed or saved in a document.
    Transient 2D NURBS curves are used as a wrapper to work with raw 2D NURBS curve information.
    They are created statically using one of the create methods of the NurbsCurve2D class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::NurbsCurve2D *":
        return _core.NurbsCurve2D___deref__(self)

    def __eq__(self, rhs: "NurbsCurve2D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.NurbsCurve2D___eq__(self, rhs)


    def __ne__(self, rhs: "NurbsCurve2D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.NurbsCurve2D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.NurbsCurve2D_classType()

    @staticmethod
    def createNonRational(controlPoints: "Point2DVector", degree: "int", knots: "DoubleVector", isPeriodic: "bool") -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > > const &, std::vector< double > const &":
        return _core.NurbsCurve2D_createNonRational(controlPoints, degree, knots, isPeriodic)

    @staticmethod
    def createRational(controlPoints: "Point2DVector", degree: "int", knots: "DoubleVector", weights: "DoubleVector", isPeriodic: "bool") -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > > const &, std::vector< double > const &, std::vector< double > const &":
        return _core.NurbsCurve2D_createRational(controlPoints, degree, knots, weights, isPeriodic)
    __swig_destroy__ = _core.delete_NurbsCurve2D

    def _get_controlPointCount(self) -> "int":
        r"""Gets the number of control points that define the curve"""
        return _core.NurbsCurve2D__get_controlPointCount(self)

    def copy(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve2D >":
        r"""
        Creates and returns an independent copy of this NurbsCurve2D object. 
        Returns an independent copy of this NurbsCurve2D.
        """
        return _core.NurbsCurve2D_copy(self)

    def _get_degree(self) -> "int":
        r"""Returns the degree of the curve"""
        return _core.NurbsCurve2D__get_degree(self)

    def _get_knotCount(self) -> "int":
        r"""Returns the knot count of the curve"""
        return _core.NurbsCurve2D__get_knotCount(self)

    def _get_isRational(self) -> "bool":
        r"""Indicates if the curve is rational or non-rational type"""
        return _core.NurbsCurve2D__get_isRational(self)

    def _get_isClosed(self) -> "bool":
        r"""Indicates if the curve is closed"""
        return _core.NurbsCurve2D__get_isClosed(self)

    def _get_isPeriodic(self) -> "bool":
        r"""Indicates if the curve is periodic."""
        return _core.NurbsCurve2D__get_isPeriodic(self)

    def _get_controlPoints(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D >,std::allocator< adsk::core::Ptr< adsk::core::Point2D > > >":
        r"""Returns an array of Point2D objects that define the control points of the curve."""
        return _core.NurbsCurve2D__get_controlPoints(self)

    def _get_knots(self) -> "std::vector< double,std::allocator< double > >":
        r"""Returns an array of numbers that define the Knots of the curve."""
        return _core.NurbsCurve2D__get_knots(self)

    def getData(self) -> "bool":
        r"""
        Gets the data that defines a transient 2D NURBS rational b-spline object. 
        controlPoints : The output array of control point that define the path of the spline. 
        degree : The output degree of curvature of the spline. 
        knots : The output array of numbers that define the knots of the spline. 
        isRational : The output value indicating if the spline is rational. A rational spline will have a weight value
        for each control point. 
        weights : The output array of numbers that define the weights for the spline. 
        isPeriodic : The output value indicating if the spline is Periodic. A periodic curve has a start point and
        end point that meet (with curvature continuity) forming a closed loop. 
        Returns true if successful.
        """
        return _core.NurbsCurve2D_getData(self)

    def set(self, controlPoints: "Point2DVector", degree: "int", knots: "DoubleVector", isRational: "bool", weights: "DoubleVector", isPeriodic: "bool") -> "bool":
        r"""
        Sets the data that defines a transient 2D NURBS rational b-spline object. 
        controlPoints : The array of control point that define the path of the spline 
        degree : The degree of curvature of the spline 
        knots : An array of numbers that define the knots of the spline. 
        isRational : A bool indicating if the spline is rational. A rational spline must have a weight value
        for each control point. 
        weights : An array of numbers that define the weights for the spline. 
        isPeriodic : A bool specifying if the spline is to be Periodic. A periodic curve has a start point and
        end point that meet (with curvature continuity) forming a closed loop. 
        Returns true if successful
        """
        return _core.NurbsCurve2D_set(self, controlPoints, degree, knots, isRational, weights, isPeriodic)

    def extract(self, startParam: "double", endParam: "double") -> "adsk::core::Ptr< adsk::core::NurbsCurve2D >":
        r"""
        Defines a new nurbs curve that is the subset of this nurbs curve in the parameter 
        range of [startParam, endParam] 
        startParam : The parameter position of the start of the subset. 
        endParam : The parameter position of the end of the subset. 
        Returns a new NurbsCurve2D object.
        """
        return _core.NurbsCurve2D_extract(self, startParam, endParam)

    def merge(self, nurbsCurve: "NurbsCurve2D") -> "adsk::core::Ptr< adsk::core::NurbsCurve2D >":
        r"""
        Define a new nurbs curve that is the result of combining this nurbs curve with 
        another nurbs curve. 
        nurbsCurve : The nurbs curve to combine with 
        Returns a new NurbsCurve2D object.
        """
        return _core.NurbsCurve2D_merge(self, nurbsCurve)

    def _get_curveType(self) -> "adsk::core::Curve2DTypes":
        r"""Returns the type of geometry this curve represents."""
        return _core.NurbsCurve2D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator2D >":
        r"""Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.NurbsCurve2D__get_evaluator(self)

    def transformBy(self, matrix: "Matrix2D") -> "bool":
        r"""
        Transforms this curve in 2D space. 
        matrix : A 2D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.NurbsCurve2D_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.NurbsCurve2D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.NurbsCurve2D__get_isValid(self)

# Register NurbsCurve2D in _core:
_core.NurbsCurve2D_swigregister(NurbsCurve2D)

def NurbsCurve2D_classType() -> "char const *":
    return _core.NurbsCurve2D_classType()

def NurbsCurve2D_createNonRational(controlPoints: "Point2DVector", degree: "int", knots: "DoubleVector", isPeriodic: "bool") -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > > const &, std::vector< double > const &":
    return _core.NurbsCurve2D_createNonRational(controlPoints, degree, knots, isPeriodic)

def NurbsCurve2D_createRational(controlPoints: "Point2DVector", degree: "int", knots: "DoubleVector", weights: "DoubleVector", isPeriodic: "bool") -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > > const &, std::vector< double > const &, std::vector< double > const &":
    return _core.NurbsCurve2D_createRational(controlPoints, degree, knots, weights, isPeriodic)


NurbsCurve2D.controlPointCount = property(NurbsCurve2D._get_controlPointCount, doc="Gets the number of control points that define the curve")


NurbsCurve2D.degree = property(NurbsCurve2D._get_degree, doc="Returns the degree of the curve")


NurbsCurve2D.knotCount = property(NurbsCurve2D._get_knotCount, doc="Returns the knot count of the curve")


NurbsCurve2D.isRational = property(NurbsCurve2D._get_isRational, doc="Indicates if the curve is rational or non-rational type")


NurbsCurve2D.isClosed = property(NurbsCurve2D._get_isClosed, doc="Indicates if the curve is closed")


NurbsCurve2D.isPeriodic = property(NurbsCurve2D._get_isPeriodic, doc="Indicates if the curve is periodic.")


NurbsCurve2D.controlPoints = property(NurbsCurve2D._get_controlPoints, doc="Returns an array of Point2D objects that define the control points of the curve.")


NurbsCurve2D.knots = property(NurbsCurve2D._get_knots, doc="Returns an array of numbers that define the Knots of the curve.")


NurbsCurve2D.cast = lambda arg: arg if isinstance(arg, NurbsCurve2D) else None

class NurbsCurve3D(Curve3D):
    r"""
    Transient 3D NURBS curve. A transient NURBS curve is not displayed or saved in a document.
    Transient 3D NURBS curves are used as a wrapper to work with raw 3D NURBS curve information.
    They are created statically using one of the create methods of the NurbsCurve3D class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::NurbsCurve3D *":
        return _core.NurbsCurve3D___deref__(self)

    def __eq__(self, rhs: "NurbsCurve3D") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.NurbsCurve3D___eq__(self, rhs)


    def __ne__(self, rhs: "NurbsCurve3D") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.NurbsCurve3D___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.NurbsCurve3D_classType()

    @staticmethod
    def createNonRational(controlPoints: "Point3DVector", degree: "int", knots: "DoubleVector", isPeriodic: "bool") -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > > const &, std::vector< double > const &":
        return _core.NurbsCurve3D_createNonRational(controlPoints, degree, knots, isPeriodic)

    @staticmethod
    def createRational(controlPoints: "Point3DVector", degree: "int", knots: "DoubleVector", weights: "DoubleVector", isPeriodic: "bool") -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > > const &, std::vector< double > const &, std::vector< double > const &":
        return _core.NurbsCurve3D_createRational(controlPoints, degree, knots, weights, isPeriodic)
    __swig_destroy__ = _core.delete_NurbsCurve3D

    def _get_controlPointCount(self) -> "int":
        r"""Gets the number of control points that define the curve."""
        return _core.NurbsCurve3D__get_controlPointCount(self)

    def _get_degree(self) -> "int":
        r"""Returns the degree of the curve."""
        return _core.NurbsCurve3D__get_degree(self)

    def _get_knotCount(self) -> "int":
        r"""Returns the knot count of the curve."""
        return _core.NurbsCurve3D__get_knotCount(self)

    def _get_isRational(self) -> "bool":
        r"""Indicates if the curve is rational or non-rational type."""
        return _core.NurbsCurve3D__get_isRational(self)

    def _get_isClosed(self) -> "bool":
        r"""Indicates if the curve is closed."""
        return _core.NurbsCurve3D__get_isClosed(self)

    def _get_isPeriodic(self) -> "bool":
        r"""Indicates if the curve is periodic."""
        return _core.NurbsCurve3D__get_isPeriodic(self)

    def _get_controlPoints(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D >,std::allocator< adsk::core::Ptr< adsk::core::Point3D > > >":
        r"""Returns an array of Point3D objects that define the control points of the curve."""
        return _core.NurbsCurve3D__get_controlPoints(self)

    def _get_knots(self) -> "std::vector< double,std::allocator< double > >":
        r"""Returns an array of numbers that define the knot vector of the curve."""
        return _core.NurbsCurve3D__get_knots(self)

    def getData(self) -> "bool":
        r"""
        Gets the data that defines a transient 3D NURBS rational b-spline object. 
        controlPoints : The output array of control point that define the path of the spline. 
        degree : The output degree of curvature of the spline. 
        knots : The output array of numbers that define the knot vector of the spline. 
        isRational : The output value indicating if the spline is rational. A rational spline will have a weight value
        for each control point. 
        weights : The output array of numbers that define the weights for the spline. 
        isPeriodic : The output value indicating if the spline is Periodic. A periodic curve has a start point and
        end point that meet (with curvature continuity) forming a closed loop. 
        Returns true if successful.
        """
        return _core.NurbsCurve3D_getData(self)

    def set(self, controlPoints: "Point3DVector", degree: "int", knots: "DoubleVector", isRational: "bool", weights: "DoubleVector", isPeriodic: "bool") -> "bool":
        r"""
        Sets the data that defines a transient 3D NURBS rational b-spline object. 
        controlPoints : The array of control point that define the path of the spline. 
        degree : The degree of curvature of the spline. 
        knots : An array of numbers that define the knot vector of the spline. 
        isRational : A bool value indicating if the spline is rational. A rational spline must have a weight value
        for each control point. 
        weights : An array of numbers that define the weights for the spline. 
        isPeriodic : A bool indicating if the spline is Periodic. A periodic curve has a start point and
        end point that meet (with curvature continuity) forming a closed loop. 
        Returns true if successful.
        """
        return _core.NurbsCurve3D_set(self, controlPoints, degree, knots, isRational, weights, isPeriodic)

    def extract(self, startParam: "double", endParam: "double") -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >":
        r"""
        Defines a new nurbs curve that is the subset of this nurbs curve in the parameter 
        range of [startParam, endParam] 
        startParam : The parameter position that defines the start of the subset. 
        endParam : The parameter position that defines the end of the subset. 
        Returns a new NurbsCurve3D object.
        """
        return _core.NurbsCurve3D_extract(self, startParam, endParam)

    def merge(self, nurbsCurve: "NurbsCurve3D") -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >":
        r"""
        Define a new nurbs curve that is the result of combining this nurbs curve with 
        another nurbs curve. 
        nurbsCurve : The nurbs curve to combine with. 
        Returns a new NurbsCurve3D object.
        """
        return _core.NurbsCurve3D_merge(self, nurbsCurve)

    def copy(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >":
        r"""
        Creates and returns an independent copy of this NurbsCurve3D object. 
        Returns an independent copy of this NurbsCurve3D.
        """
        return _core.NurbsCurve3D_copy(self)

    def _get_curveType(self) -> "adsk::core::Curve3DTypes":
        r"""Returns the type of geometry this curve represents."""
        return _core.NurbsCurve3D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator3D >":
        r"""Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.NurbsCurve3D__get_evaluator(self)

    def transformBy(self, matrix: "Matrix3D") -> "bool":
        r"""
        Transforms this curve in 3D space. 
        matrix : A 3D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.NurbsCurve3D_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.NurbsCurve3D__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.NurbsCurve3D__get_isValid(self)

# Register NurbsCurve3D in _core:
_core.NurbsCurve3D_swigregister(NurbsCurve3D)

def NurbsCurve3D_classType() -> "char const *":
    return _core.NurbsCurve3D_classType()

def NurbsCurve3D_createNonRational(controlPoints: "Point3DVector", degree: "int", knots: "DoubleVector", isPeriodic: "bool") -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > > const &, std::vector< double > const &":
    return _core.NurbsCurve3D_createNonRational(controlPoints, degree, knots, isPeriodic)

def NurbsCurve3D_createRational(controlPoints: "Point3DVector", degree: "int", knots: "DoubleVector", weights: "DoubleVector", isPeriodic: "bool") -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > > const &, std::vector< double > const &, std::vector< double > const &":
    return _core.NurbsCurve3D_createRational(controlPoints, degree, knots, weights, isPeriodic)


NurbsCurve3D.controlPointCount = property(NurbsCurve3D._get_controlPointCount, doc="Gets the number of control points that define the curve.")


NurbsCurve3D.degree = property(NurbsCurve3D._get_degree, doc="Returns the degree of the curve.")


NurbsCurve3D.knotCount = property(NurbsCurve3D._get_knotCount, doc="Returns the knot count of the curve.")


NurbsCurve3D.isRational = property(NurbsCurve3D._get_isRational, doc="Indicates if the curve is rational or non-rational type.")


NurbsCurve3D.isClosed = property(NurbsCurve3D._get_isClosed, doc="Indicates if the curve is closed.")


NurbsCurve3D.isPeriodic = property(NurbsCurve3D._get_isPeriodic, doc="Indicates if the curve is periodic.")


NurbsCurve3D.controlPoints = property(NurbsCurve3D._get_controlPoints, doc="Returns an array of Point3D objects that define the control points of the curve.")


NurbsCurve3D.knots = property(NurbsCurve3D._get_knots, doc="Returns an array of numbers that define the knot vector of the curve.")


NurbsCurve3D.cast = lambda arg: arg if isinstance(arg, NurbsCurve3D) else None

class NurbsSurface(Surface):
    r"""
    Transient NURBS surface. A transient NURBS surface is not displayed or saved in a document.
    A transient NURBS surface is used as a wrapper to work with raw NURBS surface information. 
    A transient NURBS surface is bounded by it's natural boundaries and does not support the 
    definition of arbitrary boundaries. 
    A NURBS surface is typically obtained from a BREPFace object, which does have boundary information.
    They are created statically using the create method of the NurbsSurface class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::NurbsSurface *":
        return _core.NurbsSurface___deref__(self)

    def __eq__(self, rhs: "NurbsSurface") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.NurbsSurface___eq__(self, rhs)


    def __ne__(self, rhs: "NurbsSurface") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.NurbsSurface___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.NurbsSurface_classType()

    @staticmethod
    def create(degreeU: "int", degreeV: "int", controlPointCountU: "int", controlPointCountV: "int", controlPoints: "Point3DVector", knotsU: "DoubleVector", knotsV: "DoubleVector", weights: "DoubleVector", propertiesU: "NurbsSurfaceProperties", propertiesV: "NurbsSurfaceProperties") -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > > const &, std::vector< double > const &, std::vector< double > const &, std::vector< double > const &":
        return _core.NurbsSurface_create(degreeU, degreeV, controlPointCountU, controlPointCountV, controlPoints, knotsU, knotsV, weights, propertiesU, propertiesV)
    __swig_destroy__ = _core.delete_NurbsSurface

    def _get_controlPointCountU(self) -> "int":
        r"""Gets the number of control points in the U direction."""
        return _core.NurbsSurface__get_controlPointCountU(self)

    def _get_controlPointCountV(self) -> "int":
        r"""Gets the number of control points in the V direction."""
        return _core.NurbsSurface__get_controlPointCountV(self)

    def _get_degreeU(self) -> "int":
        r"""Gets the degree in the U direction."""
        return _core.NurbsSurface__get_degreeU(self)

    def _get_degreeV(self) -> "int":
        r"""Gets the degree in the V direction."""
        return _core.NurbsSurface__get_degreeV(self)

    def _get_knotCountU(self) -> "int":
        r"""Gets the knot count in the U direction."""
        return _core.NurbsSurface__get_knotCountU(self)

    def _get_knotCountV(self) -> "int":
        r"""Gets thekKnot count in the V direction."""
        return _core.NurbsSurface__get_knotCountV(self)

    def _get_propertiesU(self) -> "adsk::core::NurbsSurfaceProperties":
        r"""Gets the properties (NurbsSurfaceProperties) of the surface in the U direction."""
        return _core.NurbsSurface__get_propertiesU(self)

    def _get_propertiesV(self) -> "adsk::core::NurbsSurfaceProperties":
        r"""Gets the properties (NurbsSurfaceProperties) of the surface in the V direction."""
        return _core.NurbsSurface__get_propertiesV(self)

    def _get_controlPoints(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D >,std::allocator< adsk::core::Ptr< adsk::core::Point3D > > >":
        r"""Gets an array of control points from the surface."""
        return _core.NurbsSurface__get_controlPoints(self)

    def _get_knotsU(self) -> "std::vector< double,std::allocator< double > >":
        r"""Get the knot vector from the U direction."""
        return _core.NurbsSurface__get_knotsU(self)

    def _get_knotsV(self) -> "std::vector< double,std::allocator< double > >":
        r"""Get the knot vector from the V direction"""
        return _core.NurbsSurface__get_knotsV(self)

    def getData(self) -> "bool":
        r"""
        Gets the data that defines the NURBS surface. 
        degreeU : The output degree in the U direction. 
        degreeV : The output degree in the V direction. 
        controlPointCountU : The output number of control points in the U direction. 
        controlPointCountV : The output number of control points in the V direction. 
        controlPoints : An output array of surface control points. 
        knotsU : The output knot vector for the U direction. 
        knotsV : The output knot vector for the V direction. 
        weights : An output array of weights that corresponds to the control points of the surface. 
        propertiesU : The output properties (NurbsSurfaceProperties) of the surface in the U direction. 
        propertiesV : The output properties (NurbsSurfaceProperties) of the surface in the V direction. 
        Returns true if successful.
        """
        return _core.NurbsSurface_getData(self)

    def set(self, degreeU: "int", degreeV: "int", controlPointCountU: "int", controlPointCountV: "int", controlPoints: "Point3DVector", knotsU: "DoubleVector", knotsV: "DoubleVector", weights: "DoubleVector", propertiesU: "NurbsSurfaceProperties", propertiesV: "NurbsSurfaceProperties") -> "bool":
        r"""
        Sets the data that defines the NURBS surface. 
        degreeU : The degree in the U direction. 
        degreeV : The degree in the V direction. 
        controlPointCountU : The number of control points in the U direction. 
        controlPointCountV : The number of control points in the V direction. 
        controlPoints : An array of surface control points. 
        knotsU : The knot vector for the U direction. 
        knotsV : The knot vector for the V direction. 
        weights : An array of weights that corresponds to the control points of the surface. 
        propertiesU : The properties (NurbsSurfaceProperties) of the surface in the U direction. 
        propertiesV : The properties (NurbsSurfaceProperties) of the surface in the V direction. 
        Returns true if successful
        """
        return _core.NurbsSurface_set(self, degreeU, degreeV, controlPointCountU, controlPointCountV, controlPoints, knotsU, knotsV, weights, propertiesU, propertiesV)

    def copy(self) -> "adsk::core::Ptr< adsk::core::NurbsSurface >":
        r"""
        Creates and returns an independent copy of this NurbsSurface object. 
        Returns a new NurbsSurface object that is a copy of this NurbsSurface object.
        """
        return _core.NurbsSurface_copy(self)

    def _get_surfaceType(self) -> "adsk::core::SurfaceTypes":
        r"""Returns the surface type."""
        return _core.NurbsSurface__get_surfaceType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::SurfaceEvaluator >":
        r"""Returns the surface evaluator."""
        return _core.NurbsSurface__get_evaluator(self)

    def transformBy(self, matrix: "Matrix3D") -> "bool":
        r"""
        Updates this surface by transforming it with a given input matrix. 
        matrix : A 3D matrix that defines the transform to apply to the surface. 
        Returns true if the transform was successful.
        """
        return _core.NurbsSurface_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.NurbsSurface__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.NurbsSurface__get_isValid(self)

# Register NurbsSurface in _core:
_core.NurbsSurface_swigregister(NurbsSurface)

def NurbsSurface_classType() -> "char const *":
    return _core.NurbsSurface_classType()

def NurbsSurface_create(degreeU: "int", degreeV: "int", controlPointCountU: "int", controlPointCountV: "int", controlPoints: "Point3DVector", knotsU: "DoubleVector", knotsV: "DoubleVector", weights: "DoubleVector", propertiesU: "NurbsSurfaceProperties", propertiesV: "NurbsSurfaceProperties") -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > > const &, std::vector< double > const &, std::vector< double > const &, std::vector< double > const &":
    return _core.NurbsSurface_create(degreeU, degreeV, controlPointCountU, controlPointCountV, controlPoints, knotsU, knotsV, weights, propertiesU, propertiesV)


NurbsSurface.controlPointCountU = property(NurbsSurface._get_controlPointCountU, doc="Gets the number of control points in the U direction.")


NurbsSurface.controlPointCountV = property(NurbsSurface._get_controlPointCountV, doc="Gets the number of control points in the V direction.")


NurbsSurface.degreeU = property(NurbsSurface._get_degreeU, doc="Gets the degree in the U direction.")


NurbsSurface.degreeV = property(NurbsSurface._get_degreeV, doc="Gets the degree in the V direction.")


NurbsSurface.knotCountU = property(NurbsSurface._get_knotCountU, doc="Gets the knot count in the U direction.")


NurbsSurface.knotCountV = property(NurbsSurface._get_knotCountV, doc="Gets thekKnot count in the V direction.")


NurbsSurface.propertiesU = property(NurbsSurface._get_propertiesU, doc="Gets the properties (NurbsSurfaceProperties) of the surface in the U direction.")


NurbsSurface.propertiesV = property(NurbsSurface._get_propertiesV, doc="Gets the properties (NurbsSurfaceProperties) of the surface in the V direction.")


NurbsSurface.controlPoints = property(NurbsSurface._get_controlPoints, doc="Gets an array of control points from the surface.")


NurbsSurface.knotsU = property(NurbsSurface._get_knotsU, doc="Get the knot vector from the U direction.")


NurbsSurface.knotsV = property(NurbsSurface._get_knotsV, doc="Get the knot vector from the V direction")


NurbsSurface.cast = lambda arg: arg if isinstance(arg, NurbsSurface) else None

class Plane(Surface):
    r"""
    Transient plane. A transient plane is not displayed or saved in a document.
    Transient planes are used as a wrapper to work with raw plane information. 
    A transient plane has no boundaries or size, but is infinite and is represented 
    by a position, a normal, and an orientation in space.
    They are created statically using the create method of the Plane class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Plane *":
        return _core.Plane___deref__(self)

    def __eq__(self, rhs: "Plane") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Plane___eq__(self, rhs)


    def __ne__(self, rhs: "Plane") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Plane___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Plane_classType()

    @staticmethod
    def create(origin: "Point3D", normal: "Vector3D") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
        return _core.Plane_create(origin, normal)

    @staticmethod
    def createUsingDirections(origin: "Point3D", uDirection: "Vector3D", vDirection: "Vector3D") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
        return _core.Plane_createUsingDirections(origin, uDirection, vDirection)
    __swig_destroy__ = _core.delete_Plane

    def _get_origin(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets the origin point of the plane."""
        return _core.Plane__get_origin(self)

    def _set_origin(self, value: "Point3D") -> "bool":
        r"""Gets and sets the origin point of the plane."""
        return _core.Plane__set_origin(self, value)

    def _get_normal(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Gets and sets the normal of the plane."""
        return _core.Plane__get_normal(self)

    def _set_normal(self, value: "Vector3D") -> "bool":
        r"""Gets and sets the normal of the plane."""
        return _core.Plane__set_normal(self, value)

    def _get_uDirection(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Gets the U Direction of the plane."""
        return _core.Plane__get_uDirection(self)

    def _get_vDirection(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Gets the V Direction of the plane."""
        return _core.Plane__get_vDirection(self)

    def setUVDirections(self, uDirection: "Vector3D", vDirection: "Vector3D") -> "bool":
        r"""
        Sets the U and V directions of the plane. 
        uDirection : The U direction for the plane. 
        vDirection : The V direction for the plane. 
        Returns true if successful.
        """
        return _core.Plane_setUVDirections(self, uDirection, vDirection)

    def isParallelToPlane(self, plane: "Plane") -> "bool":
        r"""
        Checks if this plane is parallel to another plane. 
        plane : The plane to compare with for parallelism. 
        Returns true if the planes are parallel.
        """
        return _core.Plane_isParallelToPlane(self, plane)

    def isParallelToLine(self, line: "Line3D") -> "bool":
        r"""
        Checks if this plane is parallel to a line. 
        line : The line to compare with for parallelism. 
        Returns true if the plane and line are parallel.
        """
        return _core.Plane_isParallelToLine(self, line)

    def isPerpendicularToPlane(self, plane: "Plane") -> "bool":
        r"""
        Checks if this plane is perpendicular to another plane. 
        plane : The plane to compare with for perpendicularity. 
        Returns true if the planes are perpendicular.
        """
        return _core.Plane_isPerpendicularToPlane(self, plane)

    def isPerpendicularToLine(self, line: "Line3D") -> "bool":
        r"""
        Checks if this plane is perpendicular to a line. 
        line : The line to compare with for perpendicularity. 
        Returns true if the plane and line are perpendicular.
        """
        return _core.Plane_isPerpendicularToLine(self, line)

    def isCoPlanarTo(self, plane: "Plane") -> "bool":
        r"""
        Checks if this plane is coplanar with another plane. 
        plane : The plane to compare with for coplanarity. 
        Returns true if the planes are coplanar.
        """
        return _core.Plane_isCoPlanarTo(self, plane)

    def intersectWithPlane(self, plane: "Plane") -> "adsk::core::Ptr< adsk::core::InfiniteLine3D >":
        r"""
        Creates an infinite line at the intersection of this plane with another plane. 
        plane : The plane to intersect with. 
        Returns an InfiniteLine3D object or null if the planes do not intersect (are parallel).
        """
        return _core.Plane_intersectWithPlane(self, plane)

    def intersectWithLine(self, line: "InfiniteLine3D") -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""
        Creates a 3D point at the intersection of this plane and a line. 
        line : The line to intersect with. 
        Returns a Point3D object or null if the plane and line do not intersect (are parallel).
        """
        return _core.Plane_intersectWithLine(self, line)

    def intersectWithCurve(self, curve: "Curve3D") -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Intersect this plane with a curve to get the intersection point(s). 
        curve : The intersecting curve.
        The curve can be a Line3D, InfininteLine3D, Circle3D, Arc3D, EllipticalArc3D, Ellipse3D, 
        or NurbsCurve3D. 
        Returns a collection of the intersection points.
        """
        return _core.Plane_intersectWithCurve(self, curve)

    def intersectWithSurface(self, surface: "Surface") -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Intersect this plane with a surface to get the intersection point(s). 
        surface : The intersecting surface.
        The surface can be a Plane, Cone, Cylinder, EllipticalCone, EllipticalCylinder, Sphere, 
        Torus, or a NurbsSurface. 
        Returns a collection of the intersection points.
        """
        return _core.Plane_intersectWithSurface(self, surface)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Plane >":
        r"""
        Creates and returns an independent copy of this Plane object. 
        Returns a new Plane object that is a copy of this Plane object.
        """
        return _core.Plane_copy(self)

    def _get_surfaceType(self) -> "adsk::core::SurfaceTypes":
        r"""Returns the surface type."""
        return _core.Plane__get_surfaceType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::SurfaceEvaluator >":
        r"""Returns the surface evaluator."""
        return _core.Plane__get_evaluator(self)

    def transformBy(self, matrix: "Matrix3D") -> "bool":
        r"""
        Updates this surface by transforming it with a given input matrix. 
        matrix : A 3D matrix that defines the transform to apply to the surface. 
        Returns true if the transform was successful.
        """
        return _core.Plane_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.Plane__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Plane__get_isValid(self)

# Register Plane in _core:
_core.Plane_swigregister(Plane)

def Plane_classType() -> "char const *":
    return _core.Plane_classType()

def Plane_create(origin: "Point3D", normal: "Vector3D") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
    return _core.Plane_create(origin, normal)

def Plane_createUsingDirections(origin: "Point3D", uDirection: "Vector3D", vDirection: "Vector3D") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
    return _core.Plane_createUsingDirections(origin, uDirection, vDirection)


Plane.origin = property(Plane._get_origin, Plane._set_origin, doc="Gets and sets the origin point of the plane.")


Plane.normal = property(Plane._get_normal, Plane._set_normal, doc="Gets and sets the normal of the plane.")


Plane.uDirection = property(Plane._get_uDirection, doc="Gets the U Direction of the plane.")


Plane.vDirection = property(Plane._get_vDirection, doc="Gets the V Direction of the plane.")


Plane.cast = lambda arg: arg if isinstance(arg, Plane) else None

class RadioButtonGroupCommandInput(CommandInput):
    r"""Provides a command input to get the choice from a radio button group from the user."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::RadioButtonGroupCommandInput *":
        return _core.RadioButtonGroupCommandInput___deref__(self)

    def __eq__(self, rhs: "RadioButtonGroupCommandInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.RadioButtonGroupCommandInput___eq__(self, rhs)


    def __ne__(self, rhs: "RadioButtonGroupCommandInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.RadioButtonGroupCommandInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.RadioButtonGroupCommandInput_classType()
    __swig_destroy__ = _core.delete_RadioButtonGroupCommandInput

    def _get_listItems(self) -> "adsk::core::Ptr< adsk::core::ListItems >":
        r"""
        Returns the ListItems object associated with this radio button group. You use this
        object to populate and interact with the items in the radio button group.
        """
        return _core.RadioButtonGroupCommandInput__get_listItems(self)

    def _get_selectedItem(self) -> "adsk::core::Ptr< adsk::core::ListItem >":
        r"""Gets and sets the item in the radio button list that is currently selected."""
        return _core.RadioButtonGroupCommandInput__get_selectedItem(self)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.RadioButtonGroupCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string":
        r"""Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.RadioButtonGroupCommandInput__get_id(self)

    def _get_name(self) -> "std::string":
        r"""Gets the user visible name of this input."""
        return _core.RadioButtonGroupCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.RadioButtonGroupCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.RadioButtonGroupCommandInput__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.RadioButtonGroupCommandInput__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.RadioButtonGroupCommandInput__set_isVisible(self, value)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the parent Command."""
        return _core.RadioButtonGroupCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.RadioButtonGroupCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.RadioButtonGroupCommandInput__set_isFullWidth(self, value)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.RadioButtonGroupCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.RadioButtonGroupCommandInput__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.RadioButtonGroupCommandInput__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.RadioButtonGroupCommandInput__set_tooltip(self, value)

    def _get_tooltipDescription(self) -> "std::string":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.RadioButtonGroupCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.RadioButtonGroupCommandInput__set_tooltipDescription(self, value)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.RadioButtonGroupCommandInput__get_parentCommandInput(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this Command input. 
        Returns true if the delete was successful.
        """
        return _core.RadioButtonGroupCommandInput_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.RadioButtonGroupCommandInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.RadioButtonGroupCommandInput__get_isValid(self)

# Register RadioButtonGroupCommandInput in _core:
_core.RadioButtonGroupCommandInput_swigregister(RadioButtonGroupCommandInput)

def RadioButtonGroupCommandInput_classType() -> "char const *":
    return _core.RadioButtonGroupCommandInput_classType()


RadioButtonGroupCommandInput.listItems = property(RadioButtonGroupCommandInput._get_listItems, doc="Returns the ListItems object associated with this radio button group. You use this\nobject to populate and interact with the items in the radio button group.")


RadioButtonGroupCommandInput.selectedItem = property(RadioButtonGroupCommandInput._get_selectedItem, doc="Gets and sets the item in the radio button list that is currently selected.")


RadioButtonGroupCommandInput.cast = lambda arg: arg if isinstance(arg, RadioButtonGroupCommandInput) else None

class SATImportOptions(ImportOptions):
    r"""Defines that a SAT import is to be done and specifies the various options."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::SATImportOptions *":
        return _core.SATImportOptions___deref__(self)

    def __eq__(self, rhs: "SATImportOptions") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.SATImportOptions___eq__(self, rhs)


    def __ne__(self, rhs: "SATImportOptions") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.SATImportOptions___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.SATImportOptions_classType()
    __swig_destroy__ = _core.delete_SATImportOptions

    def _get_filename(self) -> "std::string":
        r"""Gets and sets the filename or url of the file to be imported."""
        return _core.SATImportOptions__get_filename(self)

    def _set_filename(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the filename or url of the file to be imported."""
        return _core.SATImportOptions__set_filename(self, value)

    def _get_isViewFit(self) -> "bool":
        r"""
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.SATImportOptions__get_isViewFit(self)

    def _set_isViewFit(self, value: "bool") -> "bool":
        r"""
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.SATImportOptions__set_isViewFit(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.SATImportOptions__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.SATImportOptions__get_isValid(self)

# Register SATImportOptions in _core:
_core.SATImportOptions_swigregister(SATImportOptions)

def SATImportOptions_classType() -> "char const *":
    return _core.SATImportOptions_classType()


SATImportOptions.cast = lambda arg: arg if isinstance(arg, SATImportOptions) else None


def _get_adsk_core_SelectionCommandInput_Bodies() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_Bodies()

def _get_adsk_core_SelectionCommandInput_SolidBodies() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_SolidBodies()

def _get_adsk_core_SelectionCommandInput_SurfaceBodies() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_SurfaceBodies()

def _get_adsk_core_SelectionCommandInput_MeshBodies() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_MeshBodies()

def _get_adsk_core_SelectionCommandInput_Faces() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_Faces()

def _get_adsk_core_SelectionCommandInput_SolidFaces() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_SolidFaces()

def _get_adsk_core_SelectionCommandInput_SurfaceFaces() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_SurfaceFaces()

def _get_adsk_core_SelectionCommandInput_PlanarFaces() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_PlanarFaces()

def _get_adsk_core_SelectionCommandInput_CylindricalFaces() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_CylindricalFaces()

def _get_adsk_core_SelectionCommandInput_ConicalFaces() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_ConicalFaces()

def _get_adsk_core_SelectionCommandInput_SphericalFaces() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_SphericalFaces()

def _get_adsk_core_SelectionCommandInput_ToroidalFaces() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_ToroidalFaces()

def _get_adsk_core_SelectionCommandInput_SplineFaces() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_SplineFaces()

def _get_adsk_core_SelectionCommandInput_Edges() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_Edges()

def _get_adsk_core_SelectionCommandInput_LinearEdges() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_LinearEdges()

def _get_adsk_core_SelectionCommandInput_CircularEdges() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_CircularEdges()

def _get_adsk_core_SelectionCommandInput_EllipticalEdges() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_EllipticalEdges()

def _get_adsk_core_SelectionCommandInput_TangentEdges() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_TangentEdges()

def _get_adsk_core_SelectionCommandInput_NonTangentEdges() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_NonTangentEdges()

def _get_adsk_core_SelectionCommandInput_Vertices() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_Vertices()

def _get_adsk_core_SelectionCommandInput_RootComponents() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_RootComponents()

def _get_adsk_core_SelectionCommandInput_Occurrences() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_Occurrences()

def _get_adsk_core_SelectionCommandInput_Sketches() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_Sketches()

def _get_adsk_core_SelectionCommandInput_SketchCurves() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_SketchCurves()

def _get_adsk_core_SelectionCommandInput_SketchLines() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_SketchLines()

def _get_adsk_core_SelectionCommandInput_SketchCircles() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_SketchCircles()

def _get_adsk_core_SelectionCommandInput_SketchPoints() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_SketchPoints()

def _get_adsk_core_SelectionCommandInput_ConstructionPoints() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_ConstructionPoints()

def _get_adsk_core_SelectionCommandInput_ConstructionLines() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_ConstructionLines()

def _get_adsk_core_SelectionCommandInput_ConstructionPlanes() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_ConstructionPlanes()

def _get_adsk_core_SelectionCommandInput_Features() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_Features()

def _get_adsk_core_SelectionCommandInput_Canvases() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_Canvases()

def _get_adsk_core_SelectionCommandInput_Decals() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_Decals()

def _get_adsk_core_SelectionCommandInput_JointOrigins() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_JointOrigins()

def _get_adsk_core_SelectionCommandInput_Joints() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_Joints()

def _get_adsk_core_SelectionCommandInput_SketchConstraints() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_SketchConstraints()

def _get_adsk_core_SelectionCommandInput_Profiles() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_Profiles()

def _get_adsk_core_SelectionCommandInput_Texts() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_Texts()

def _get_adsk_core_SelectionCommandInput_CustomGraphics() -> "std::string const":
    return _core._get_adsk_core_SelectionCommandInput_CustomGraphics()

class _SelectionCommandInput_Meta_Class(type):
    def __init__(cls, name, bases, nmspc):
        super().__init__(name, bases, nmspc)
    def _get_Bodies(cls): return _get_adsk_core_SelectionCommandInput_Bodies()
    Bodies = property(_get_Bodies)
    def _get_SolidBodies(cls): return _get_adsk_core_SelectionCommandInput_SolidBodies()
    SolidBodies = property(_get_SolidBodies)
    def _get_SurfaceBodies(cls): return _get_adsk_core_SelectionCommandInput_SurfaceBodies()
    SurfaceBodies = property(_get_SurfaceBodies)
    def _get_MeshBodies(cls): return _get_adsk_core_SelectionCommandInput_MeshBodies()
    MeshBodies = property(_get_MeshBodies)
    def _get_Faces(cls): return _get_adsk_core_SelectionCommandInput_Faces()
    Faces = property(_get_Faces)
    def _get_SolidFaces(cls): return _get_adsk_core_SelectionCommandInput_SolidFaces()
    SolidFaces = property(_get_SolidFaces)
    def _get_SurfaceFaces(cls): return _get_adsk_core_SelectionCommandInput_SurfaceFaces()
    SurfaceFaces = property(_get_SurfaceFaces)
    def _get_PlanarFaces(cls): return _get_adsk_core_SelectionCommandInput_PlanarFaces()
    PlanarFaces = property(_get_PlanarFaces)
    def _get_CylindricalFaces(cls): return _get_adsk_core_SelectionCommandInput_CylindricalFaces()
    CylindricalFaces = property(_get_CylindricalFaces)
    def _get_ConicalFaces(cls): return _get_adsk_core_SelectionCommandInput_ConicalFaces()
    ConicalFaces = property(_get_ConicalFaces)
    def _get_SphericalFaces(cls): return _get_adsk_core_SelectionCommandInput_SphericalFaces()
    SphericalFaces = property(_get_SphericalFaces)
    def _get_ToroidalFaces(cls): return _get_adsk_core_SelectionCommandInput_ToroidalFaces()
    ToroidalFaces = property(_get_ToroidalFaces)
    def _get_SplineFaces(cls): return _get_adsk_core_SelectionCommandInput_SplineFaces()
    SplineFaces = property(_get_SplineFaces)
    def _get_Edges(cls): return _get_adsk_core_SelectionCommandInput_Edges()
    Edges = property(_get_Edges)
    def _get_LinearEdges(cls): return _get_adsk_core_SelectionCommandInput_LinearEdges()
    LinearEdges = property(_get_LinearEdges)
    def _get_CircularEdges(cls): return _get_adsk_core_SelectionCommandInput_CircularEdges()
    CircularEdges = property(_get_CircularEdges)
    def _get_EllipticalEdges(cls): return _get_adsk_core_SelectionCommandInput_EllipticalEdges()
    EllipticalEdges = property(_get_EllipticalEdges)
    def _get_TangentEdges(cls): return _get_adsk_core_SelectionCommandInput_TangentEdges()
    TangentEdges = property(_get_TangentEdges)
    def _get_NonTangentEdges(cls): return _get_adsk_core_SelectionCommandInput_NonTangentEdges()
    NonTangentEdges = property(_get_NonTangentEdges)
    def _get_Vertices(cls): return _get_adsk_core_SelectionCommandInput_Vertices()
    Vertices = property(_get_Vertices)
    def _get_RootComponents(cls): return _get_adsk_core_SelectionCommandInput_RootComponents()
    RootComponents = property(_get_RootComponents)
    def _get_Occurrences(cls): return _get_adsk_core_SelectionCommandInput_Occurrences()
    Occurrences = property(_get_Occurrences)
    def _get_Sketches(cls): return _get_adsk_core_SelectionCommandInput_Sketches()
    Sketches = property(_get_Sketches)
    def _get_SketchCurves(cls): return _get_adsk_core_SelectionCommandInput_SketchCurves()
    SketchCurves = property(_get_SketchCurves)
    def _get_SketchLines(cls): return _get_adsk_core_SelectionCommandInput_SketchLines()
    SketchLines = property(_get_SketchLines)
    def _get_SketchCircles(cls): return _get_adsk_core_SelectionCommandInput_SketchCircles()
    SketchCircles = property(_get_SketchCircles)
    def _get_SketchPoints(cls): return _get_adsk_core_SelectionCommandInput_SketchPoints()
    SketchPoints = property(_get_SketchPoints)
    def _get_ConstructionPoints(cls): return _get_adsk_core_SelectionCommandInput_ConstructionPoints()
    ConstructionPoints = property(_get_ConstructionPoints)
    def _get_ConstructionLines(cls): return _get_adsk_core_SelectionCommandInput_ConstructionLines()
    ConstructionLines = property(_get_ConstructionLines)
    def _get_ConstructionPlanes(cls): return _get_adsk_core_SelectionCommandInput_ConstructionPlanes()
    ConstructionPlanes = property(_get_ConstructionPlanes)
    def _get_Features(cls): return _get_adsk_core_SelectionCommandInput_Features()
    Features = property(_get_Features)
    def _get_Canvases(cls): return _get_adsk_core_SelectionCommandInput_Canvases()
    Canvases = property(_get_Canvases)
    def _get_Decals(cls): return _get_adsk_core_SelectionCommandInput_Decals()
    Decals = property(_get_Decals)
    def _get_JointOrigins(cls): return _get_adsk_core_SelectionCommandInput_JointOrigins()
    JointOrigins = property(_get_JointOrigins)
    def _get_Joints(cls): return _get_adsk_core_SelectionCommandInput_Joints()
    Joints = property(_get_Joints)
    def _get_SketchConstraints(cls): return _get_adsk_core_SelectionCommandInput_SketchConstraints()
    SketchConstraints = property(_get_SketchConstraints)
    def _get_Profiles(cls): return _get_adsk_core_SelectionCommandInput_Profiles()
    Profiles = property(_get_Profiles)
    def _get_Texts(cls): return _get_adsk_core_SelectionCommandInput_Texts()
    Texts = property(_get_Texts)
    def _get_CustomGraphics(cls): return _get_adsk_core_SelectionCommandInput_CustomGraphics()
    CustomGraphics = property(_get_CustomGraphics)

class SelectionCommandInput(CommandInput, metaclass=_SelectionCommandInput_Meta_Class):
    r"""Provides a command input to get a selection from the user."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::SelectionCommandInput *":
        return _core.SelectionCommandInput___deref__(self)

    def __eq__(self, rhs: "SelectionCommandInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.SelectionCommandInput___eq__(self, rhs)


    def __ne__(self, rhs: "SelectionCommandInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.SelectionCommandInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.SelectionCommandInput_classType()
    __swig_destroy__ = _core.delete_SelectionCommandInput

    def _get_commandPrompt(self) -> "std::string":
        r"""Gets or sets the tooltip shown next to the cursor."""
        return _core.SelectionCommandInput__get_commandPrompt(self)

    def _set_commandPrompt(self, value: "std::string const &") -> "bool":
        r"""Gets or sets the tooltip shown next to the cursor."""
        return _core.SelectionCommandInput__set_commandPrompt(self, value)

    def addSelectionFilter(self, filter: "std::string const &") -> "bool":
        r"""
        Adds an additional filter to the existing filter list. 
        filter : The name of a selection filter to add. The valid list of selection filters can be found here: <a href='SelectionFilters_UM.htm'>Selection Filters</a>. 
        Returns true if the filter was added successfully.
        """
        return _core.SelectionCommandInput_addSelectionFilter(self, filter)

    def clearSelectionFilter(self) -> "bool":
        r"""
        Clears the list of selection filters. 
        Returns true if successful.
        """
        return _core.SelectionCommandInput_clearSelectionFilter(self)

    def _get_selectionFilters(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""Gets or sets the list of selection filters. The valid list of selection filters can be found here: <a href='SelectionFilters_UM.htm'>Selection Filters</a>."""
        return _core.SelectionCommandInput__get_selectionFilters(self)

    def _set_selectionFilters(self, value: "StringVector") -> "bool":
        r"""Gets or sets the list of selection filters. The valid list of selection filters can be found here: <a href='SelectionFilters_UM.htm'>Selection Filters</a>."""
        return _core.SelectionCommandInput__set_selectionFilters(self, value)

    def _get_selectionCount(self) -> "size_t":
        r"""Gets the current number of selections the user has made for this input."""
        return _core.SelectionCommandInput__get_selectionCount(self)

    def selection(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::Selection >":
        r"""
        Returns the selection at the specified index. 
        index : The index of the selection to return. 
        Returns the Selection at the specified index, or null on error.
        """
        return _core.SelectionCommandInput_selection(self, index)

    def addSelection(self, selection: "Base") -> "bool":
        r"""
        Adds the selection to the list of selections associated with this input. This method is not valid within
        the commandCreated event but must be used later in the command lifetime. If you want to pre-populate the
        selection when the command is starting, you can use this method in the activate method of the Command.
        It's also valid to use in other events once the command is running, such as the validateInputs event. 
        selection : The entity to add a selection of to this input. The addition may fail if the entity
        does not match the selection filter, or adding it would exceed the limits. 
        Returns true if a selection to the entity was added to this input.
        """
        return _core.SelectionCommandInput_addSelection(self, selection)

    def getSelectionLimits(self) -> "bool":
        r"""
        Get the limits currently defined for this input. 
        minimum : The minimum number of selections required. A value of zero means that there is no minimum limit. 
        maximum : The maximum number of selections required. A value of zero means that there is no maximum limit. 
        Returns true if the selection limits were successfully returned.
        """
        return _core.SelectionCommandInput_getSelectionLimits(self)

    def setSelectionLimits(self, minimum: "size_t", maximum: "size_t"=0) -> "bool":
        r"""
        Defines the limits for the number of selections associated with this input.
        A maximum value of 0 indicates that there is no maximum. 
        minimum : The minimum number of selections required. A value of zero means that there is no minimum limit. 
        maximum : The maximum number of selections required. A value of zero means that there is no maximum limit.
        If maximum is equal to minimim, then exactly that number of selections is required. 
        Returns true if the limits were successfully set.
        """
        return _core.SelectionCommandInput_setSelectionLimits(self, minimum, maximum)

    def clearSelection(self) -> "bool":
        r"""
        Clears the current selection so no entities are in the selection. 
        Returns true if successful.
        """
        return _core.SelectionCommandInput_clearSelection(self)

    def _get_hasFocus(self) -> "bool":
        r"""
        Gets and sets if this selection input has focus with respect to other selection inputs on the
        command dialog. Only one selection input on a dialog can have focus at a time so setting hasFocus to true
        will remove the focus from the selection input that previously had focus. When a selection input
        has focus, any user selections will be added to that selection input and the selection rules associated
        with that selection input will apply.
        """
        return _core.SelectionCommandInput__get_hasFocus(self)

    def _set_hasFocus(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this selection input has focus with respect to other selection inputs on the
        command dialog. Only one selection input on a dialog can have focus at a time so setting hasFocus to true
        will remove the focus from the selection input that previously had focus. When a selection input
        has focus, any user selections will be added to that selection input and the selection rules associated
        with that selection input will apply.
        """
        return _core.SelectionCommandInput__set_hasFocus(self, value)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.SelectionCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string":
        r"""Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.SelectionCommandInput__get_id(self)

    def _get_name(self) -> "std::string":
        r"""Gets the user visible name of this input."""
        return _core.SelectionCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.SelectionCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.SelectionCommandInput__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.SelectionCommandInput__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.SelectionCommandInput__set_isVisible(self, value)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the parent Command."""
        return _core.SelectionCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.SelectionCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.SelectionCommandInput__set_isFullWidth(self, value)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.SelectionCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.SelectionCommandInput__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.SelectionCommandInput__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.SelectionCommandInput__set_tooltip(self, value)

    def _get_tooltipDescription(self) -> "std::string":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.SelectionCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.SelectionCommandInput__set_tooltipDescription(self, value)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.SelectionCommandInput__get_parentCommandInput(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this Command input. 
        Returns true if the delete was successful.
        """
        return _core.SelectionCommandInput_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.SelectionCommandInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.SelectionCommandInput__get_isValid(self)

# Register SelectionCommandInput in _core:
_core.SelectionCommandInput_swigregister(SelectionCommandInput)

def SelectionCommandInput_classType() -> "char const *":
    return _core.SelectionCommandInput_classType()


SelectionCommandInput.commandPrompt = property(SelectionCommandInput._get_commandPrompt, SelectionCommandInput._set_commandPrompt, doc="Gets or sets the tooltip shown next to the cursor.")


SelectionCommandInput.selectionFilters = property(SelectionCommandInput._get_selectionFilters, SelectionCommandInput._set_selectionFilters, doc="Gets or sets the list of selection filters. The valid list of selection filters can be found here: <a href='SelectionFilters_UM.htm'>Selection Filters</a>.")


SelectionCommandInput.selectionCount = property(SelectionCommandInput._get_selectionCount, doc="Gets the current number of selections the user has made for this input.")


SelectionCommandInput.hasFocus = property(SelectionCommandInput._get_hasFocus, SelectionCommandInput._set_hasFocus, doc="Gets and sets if this selection input has focus with respect to other selection inputs on the\ncommand dialog. Only one selection input on a dialog can have focus at a time so setting hasFocus to true\nwill remove the focus from the selection input that previously had focus. When a selection input\nhas focus, any user selections will be added to that selection input and the selection rules associated\nwith that selection input will apply.")


SelectionCommandInput.cast = lambda arg: arg if isinstance(arg, SelectionCommandInput) else None

class SelectionEvent(Event):
    r"""An event endpoint that supports the connection to client implemented SelectionEventHandlers."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::SelectionEvent *":
        return _core.SelectionEvent___deref__(self)

    def __eq__(self, rhs: "SelectionEvent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.SelectionEvent___eq__(self, rhs)


    def __ne__(self, rhs: "SelectionEvent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.SelectionEvent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.SelectionEvent_classType()
    __swig_destroy__ = _core.delete_SelectionEvent

    def add(self, handler: "SelectionEventHandler") -> "bool":
        r"""
        Adds an event handler to this event endpoint. 
        handler : The client implemented SelectionEventHandler to be called when this event is triggered. 
        Returns true if the handler was successfully added to the set of event handlers.
        """
        return _core.SelectionEvent_add(self, handler)

    def remove(self, handler: "SelectionEventHandler") -> "bool":
        r"""
        Removes a handler from this event endpoint. 
        handler : A SelectionEventHandler that was previously added to this event with the add method. 
        Returns true if the handler was found and removed from the set of event handlers.
        """
        return _core.SelectionEvent_remove(self, handler)

    def _get_activeInput(self) -> "adsk::core::Ptr< adsk::core::SelectionCommandInput >":
        r"""
        Returns the SelectionCommandInput that is currently active in the command dialog and
        that the user is selecting entities for. This can be used to determine which set of
        rules you want to apply to determine if the current entity is selectable or not.
        """
        return _core.SelectionEvent__get_activeInput(self)

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _core.SelectionEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.SelectionEvent__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _core.SelectionEvent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.SelectionEvent__get_isValid(self)

# Register SelectionEvent in _core:
_core.SelectionEvent_swigregister(SelectionEvent)

def SelectionEvent_classType() -> "char const *":
    return _core.SelectionEvent_classType()


SelectionEvent.activeInput = property(SelectionEvent._get_activeInput, doc="Returns the SelectionCommandInput that is currently active in the command dialog and\nthat the user is selecting entities for. This can be used to determine which set of\nrules you want to apply to determine if the current entity is selectable or not.")


SelectionEvent.cast = lambda arg: arg if isinstance(arg, SelectionEvent) else None

class SelectionEventArgs(EventArgs):
    r"""Provides a set of arguments from a firing SelectionEvent to a SelectionEventHandler's notify callback method."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::SelectionEventArgs *":
        return _core.SelectionEventArgs___deref__(self)

    def __eq__(self, rhs: "SelectionEventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.SelectionEventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "SelectionEventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.SelectionEventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.SelectionEventArgs_classType()
    __swig_destroy__ = _core.delete_SelectionEventArgs

    def _get_selection(self) -> "adsk::core::Ptr< adsk::core::Selection >":
        r"""Gets the entity that is valid for selection."""
        return _core.SelectionEventArgs__get_selection(self)

    def _get_isSelectable(self) -> "bool":
        r"""
        Gets or sets whether this entity should be made available to be selected.
        The value is initialized to true, so doing nothing will result
        in the entity being selectable.
        """
        return _core.SelectionEventArgs__get_isSelectable(self)

    def _set_isSelectable(self, value: "bool") -> "bool":
        r"""
        Gets or sets whether this entity should be made available to be selected.
        The value is initialized to true, so doing nothing will result
        in the entity being selectable.
        """
        return _core.SelectionEventArgs__set_isSelectable(self, value)

    def _get_additionalEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets or sets any additional entities that should be pre-highlighted and selected
        if the entity the mouse is over is selected. If you add an entity that is already 
        selected, it will be unselected. The result of adding additional entitities is the
        same as if they were selected one at a time by the user and the user can unselect each
        entity one at a time by picking it while it's selected.
        An example of how this might be used is that that the user can select a group of
        tangentially connected edges by picking a single edge. You can use the 
        BrepEdge.tangentiallyConnectedEdges to easily find the tangent edges and add them
        to the set of additional entities to be selected. These edges are pre-highlighted 
        and then selected.
        If you are using this property you need to make sure that the selection 
        limits for the SelectionCommandInput have been set appropriately. For example, a 
        newly created SeletionCommandInput is set to only allow the selection of a single
        entity. By adding additional entities you'll need more than one entity because the
        entire set of entities will be added to the selection. Use the setSelectionLimits
        method of the SelectionCommandInput to change the number of allowed selections.
        The additional entities should all be valid based on the current selection filter.
        """
        return _core.SelectionEventArgs__get_additionalEntities(self)

    def _set_additionalEntities(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets or sets any additional entities that should be pre-highlighted and selected
        if the entity the mouse is over is selected. If you add an entity that is already 
        selected, it will be unselected. The result of adding additional entitities is the
        same as if they were selected one at a time by the user and the user can unselect each
        entity one at a time by picking it while it's selected.
        An example of how this might be used is that that the user can select a group of
        tangentially connected edges by picking a single edge. You can use the 
        BrepEdge.tangentiallyConnectedEdges to easily find the tangent edges and add them
        to the set of additional entities to be selected. These edges are pre-highlighted 
        and then selected.
        If you are using this property you need to make sure that the selection 
        limits for the SelectionCommandInput have been set appropriately. For example, a 
        newly created SeletionCommandInput is set to only allow the selection of a single
        entity. By adding additional entities you'll need more than one entity because the
        entire set of entities will be added to the selection. Use the setSelectionLimits
        method of the SelectionCommandInput to change the number of allowed selections.
        The additional entities should all be valid based on the current selection filter.
        """
        return _core.SelectionEventArgs__set_additionalEntities(self, value)

    def _get_activeInput(self) -> "adsk::core::Ptr< adsk::core::SelectionCommandInput >":
        r"""
        Returns the SelectionCommandInput that is currently active in the command dialog and
        that the user is selecting entities for. This can be used to determine which set of
        rules you want to apply to determine if the current entity is selectable or not.
        """
        return _core.SelectionEventArgs__get_activeInput(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _core.SelectionEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _core.SelectionEventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.SelectionEventArgs__get_isValid(self)

# Register SelectionEventArgs in _core:
_core.SelectionEventArgs_swigregister(SelectionEventArgs)

def SelectionEventArgs_classType() -> "char const *":
    return _core.SelectionEventArgs_classType()


SelectionEventArgs.selection = property(SelectionEventArgs._get_selection, doc="Gets the entity that is valid for selection.")


SelectionEventArgs.isSelectable = property(SelectionEventArgs._get_isSelectable, SelectionEventArgs._set_isSelectable, doc="Gets or sets whether this entity should be made available to be selected.\nThe value is initialized to true, so doing nothing will result\nin the entity being selectable.")


SelectionEventArgs.additionalEntities = property(SelectionEventArgs._get_additionalEntities, SelectionEventArgs._set_additionalEntities, doc="Gets or sets any additional entities that should be pre-highlighted and selected\nif the entity the mouse is over is selected. If you add an entity that is already\nselected, it will be unselected. The result of adding additional entitities is the\nsame as if they were selected one at a time by the user and the user can unselect each\nentity one at a time by picking it while it's selected.\nAn example of how this might be used is that that the user can select a group of\ntangentially connected edges by picking a single edge. You can use the\nBrepEdge.tangentiallyConnectedEdges to easily find the tangent edges and add them\nto the set of additional entities to be selected. These edges are pre-highlighted\nand then selected.\nIf you are using this property you need to make sure that the selection\nlimits for the SelectionCommandInput have been set appropriately. For example, a\nnewly created SeletionCommandInput is set to only allow the selection of a single\nentity. By adding additional entities you'll need more than one entity because the\nentire set of entities will be added to the selection. Use the setSelectionLimits\nmethod of the SelectionCommandInput to change the number of allowed selections.\nThe additional entities should all be valid based on the current selection filter.")


SelectionEventArgs.activeInput = property(SelectionEventArgs._get_activeInput, doc="Returns the SelectionCommandInput that is currently active in the command dialog and\nthat the user is selecting entities for. This can be used to determine which set of\nrules you want to apply to determine if the current entity is selectable or not.")


SelectionEventArgs.cast = lambda arg: arg if isinstance(arg, SelectionEventArgs) else None

class SeparatorControl(ToolbarControl):
    r"""Represents a separator within a panel, toolbar, or drop-down control."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::SeparatorControl *":
        return _core.SeparatorControl___deref__(self)

    def __eq__(self, rhs: "SeparatorControl") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.SeparatorControl___eq__(self, rhs)


    def __ne__(self, rhs: "SeparatorControl") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.SeparatorControl___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.SeparatorControl_classType()
    __swig_destroy__ = _core.delete_SeparatorControl

    def _get_id(self) -> "std::string":
        r"""
        Gets the unique ID of this control. The ID is unique with respect to the other
        controls within the same panel, toolbar, or drop-down control.
        """
        return _core.SeparatorControl__get_id(self)

    def _get_index(self) -> "size_t":
        r"""Gets the position of this control within the list of controls within the panel, toolbar, or drop-down control."""
        return _core.SeparatorControl__get_index(self)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this control is currently visible."""
        return _core.SeparatorControl__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this control is currently visible."""
        return _core.SeparatorControl__set_isVisible(self, value)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets the Parent object. When associated with a toolbar (right or left QAT or the Nav Bar) this
        returns the parent Toolbar object. When associated with a panel it returns the parent ToolbarPanel object.
        When associated with a control (DropDownControl) it returns the parent control.
        """
        return _core.SeparatorControl__get_parent(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the ToolbarControl 
        Returns a boolean indicating if the deletion was successful.
        """
        return _core.SeparatorControl_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.SeparatorControl__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.SeparatorControl__get_isValid(self)

# Register SeparatorControl in _core:
_core.SeparatorControl_swigregister(SeparatorControl)

def SeparatorControl_classType() -> "char const *":
    return _core.SeparatorControl_classType()


SeparatorControl.cast = lambda arg: arg if isinstance(arg, SeparatorControl) else None

class SliderCommandInput(CommandInput):
    r"""Provides a command input to get the value of a slider from the user."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::SliderCommandInput *":
        return _core.SliderCommandInput___deref__(self)

    def __eq__(self, rhs: "SliderCommandInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.SliderCommandInput___eq__(self, rhs)


    def __ne__(self, rhs: "SliderCommandInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.SliderCommandInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.SliderCommandInput_classType()
    __swig_destroy__ = _core.delete_SliderCommandInput

    def _get_expressionOne(self) -> "std::string":
        r"""
        Uses an expression to set the value in the first input field. This can contain equations and
        is evaluated using the specified unit type.
        """
        return _core.SliderCommandInput__get_expressionOne(self)

    def _set_expressionOne(self, value: "std::string const &") -> "bool":
        r"""
        Uses an expression to set the value in the first input field. This can contain equations and
        is evaluated using the specified unit type.
        """
        return _core.SliderCommandInput__set_expressionOne(self, value)

    def _get_expressionTwo(self) -> "std::string":
        r"""
        Uses an expression to set the value in the second input field. This can contain equations and
        is evaluated using the specified unit type.
        This property is only available when the hasTwoSliders property returns true.
        """
        return _core.SliderCommandInput__get_expressionTwo(self)

    def _set_expressionTwo(self, value: "std::string const &") -> "bool":
        r"""
        Uses an expression to set the value in the second input field. This can contain equations and
        is evaluated using the specified unit type.
        This property is only available when the hasTwoSliders property returns true.
        """
        return _core.SliderCommandInput__set_expressionTwo(self, value)

    def _get_unitType(self) -> "std::string":
        r"""Gets and sets the unit type that is used when evaluating the user's input."""
        return _core.SliderCommandInput__get_unitType(self)

    def _set_unitType(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the unit type that is used when evaluating the user's input."""
        return _core.SliderCommandInput__set_unitType(self, value)

    def _get_hasTwoSliders(self) -> "bool":
        r"""Gets if the command input has two sliders."""
        return _core.SliderCommandInput__get_hasTwoSliders(self)

    def setText(self, left: "std::string const &", right: "std::string const &") -> "bool":
        r"""
        Sets the text of the slider. Both the left and the right text should be set. 
        left : Indicates the text on the left side of the slider. 
        right : Indicates the text on the right side of the slider. 
        Returns true if successful.
        """
        return _core.SliderCommandInput_setText(self, left, right)

    def getText(self, isLeft: "bool") -> "std::string":
        r"""
        Gets the texts of the slider if text has been defined. 
        isLeft : Indicates to get the left or right text. 
        Returns the left or right text of the slider.
        """
        return _core.SliderCommandInput_getText(self, isLeft)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.SliderCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string":
        r"""Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.SliderCommandInput__get_id(self)

    def _get_name(self) -> "std::string":
        r"""Gets the user visible name of this input."""
        return _core.SliderCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.SliderCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.SliderCommandInput__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.SliderCommandInput__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.SliderCommandInput__set_isVisible(self, value)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the parent Command."""
        return _core.SliderCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.SliderCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.SliderCommandInput__set_isFullWidth(self, value)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.SliderCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.SliderCommandInput__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.SliderCommandInput__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.SliderCommandInput__set_tooltip(self, value)

    def _get_tooltipDescription(self) -> "std::string":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.SliderCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.SliderCommandInput__set_tooltipDescription(self, value)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.SliderCommandInput__get_parentCommandInput(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this Command input. 
        Returns true if the delete was successful.
        """
        return _core.SliderCommandInput_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.SliderCommandInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.SliderCommandInput__get_isValid(self)

# Register SliderCommandInput in _core:
_core.SliderCommandInput_swigregister(SliderCommandInput)

def SliderCommandInput_classType() -> "char const *":
    return _core.SliderCommandInput_classType()


SliderCommandInput.expressionOne = property(SliderCommandInput._get_expressionOne, SliderCommandInput._set_expressionOne, doc="Uses an expression to set the value in the first input field. This can contain equations and\nis evaluated using the specified unit type.")


SliderCommandInput.expressionTwo = property(SliderCommandInput._get_expressionTwo, SliderCommandInput._set_expressionTwo, doc="Uses an expression to set the value in the second input field. This can contain equations and\nis evaluated using the specified unit type.\nThis property is only available when the hasTwoSliders property returns true.")


SliderCommandInput.unitType = property(SliderCommandInput._get_unitType, SliderCommandInput._set_unitType, doc="Gets and sets the unit type that is used when evaluating the user's input.")


SliderCommandInput.hasTwoSliders = property(SliderCommandInput._get_hasTwoSliders, doc="Gets if the command input has two sliders.")


SliderCommandInput.cast = lambda arg: arg if isinstance(arg, SliderCommandInput) else None

class SMTImportOptions(ImportOptions):
    r"""Defines that an SMT import is to be done and specifies the various options."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::SMTImportOptions *":
        return _core.SMTImportOptions___deref__(self)

    def __eq__(self, rhs: "SMTImportOptions") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.SMTImportOptions___eq__(self, rhs)


    def __ne__(self, rhs: "SMTImportOptions") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.SMTImportOptions___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.SMTImportOptions_classType()
    __swig_destroy__ = _core.delete_SMTImportOptions

    def _get_filename(self) -> "std::string":
        r"""Gets and sets the filename or url of the file to be imported."""
        return _core.SMTImportOptions__get_filename(self)

    def _set_filename(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the filename or url of the file to be imported."""
        return _core.SMTImportOptions__set_filename(self, value)

    def _get_isViewFit(self) -> "bool":
        r"""
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.SMTImportOptions__get_isViewFit(self)

    def _set_isViewFit(self, value: "bool") -> "bool":
        r"""
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.SMTImportOptions__set_isViewFit(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.SMTImportOptions__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.SMTImportOptions__get_isValid(self)

# Register SMTImportOptions in _core:
_core.SMTImportOptions_swigregister(SMTImportOptions)

def SMTImportOptions_classType() -> "char const *":
    return _core.SMTImportOptions_classType()


SMTImportOptions.cast = lambda arg: arg if isinstance(arg, SMTImportOptions) else None

class Sphere(Surface):
    r"""
    Transient sphere. A transient sphere is not displayed or saved in a document.
    Transient spheres are used as a wrapper to work with raw sphere information. 
    A transient sphere is a full sphere defined by a point and a radius.
    They are created statically using the create method of the Sphere class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Sphere *":
        return _core.Sphere___deref__(self)

    def __eq__(self, rhs: "Sphere") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Sphere___eq__(self, rhs)


    def __ne__(self, rhs: "Sphere") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Sphere___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Sphere_classType()

    @staticmethod
    def create(origin: "Point3D", radius: "double") -> "adsk::core::Ptr< adsk::core::Point3D > const &":
        return _core.Sphere_create(origin, radius)
    __swig_destroy__ = _core.delete_Sphere

    def _get_origin(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets the origin point (center) of the sphere."""
        return _core.Sphere__get_origin(self)

    def _set_origin(self, value: "Point3D") -> "bool":
        r"""Gets and sets the origin point (center) of the sphere."""
        return _core.Sphere__set_origin(self, value)

    def _get_radius(self) -> "double":
        r"""Gets and sets the radius of the sphere."""
        return _core.Sphere__get_radius(self)

    def _set_radius(self, value: "double") -> "bool":
        r"""Gets and sets the radius of the sphere."""
        return _core.Sphere__set_radius(self, value)

    def getData(self) -> "bool":
        r"""
        Gets all of the data defining the sphere. 
        origin : The output origin point (center) of the sphere. 
        radius : The output radius of the sphere. 
        Returns true if successful.
        """
        return _core.Sphere_getData(self)

    def set(self, origin: "Point3D", radius: "double") -> "bool":
        r"""
        Sets all of the data defining the sphere. 
        origin : The origin point (center) of the sphere. 
        radius : The radius of the sphere. 
        Returns true if successful.
        """
        return _core.Sphere_set(self, origin, radius)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Sphere >":
        r"""
        Creates and returns an independent copy of this Sphere object. 
        Returns a new Sphere object that is a copy of this Sphere object.
        """
        return _core.Sphere_copy(self)

    def _get_surfaceType(self) -> "adsk::core::SurfaceTypes":
        r"""Returns the surface type."""
        return _core.Sphere__get_surfaceType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::SurfaceEvaluator >":
        r"""Returns the surface evaluator."""
        return _core.Sphere__get_evaluator(self)

    def transformBy(self, matrix: "Matrix3D") -> "bool":
        r"""
        Updates this surface by transforming it with a given input matrix. 
        matrix : A 3D matrix that defines the transform to apply to the surface. 
        Returns true if the transform was successful.
        """
        return _core.Sphere_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.Sphere__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Sphere__get_isValid(self)

# Register Sphere in _core:
_core.Sphere_swigregister(Sphere)

def Sphere_classType() -> "char const *":
    return _core.Sphere_classType()

def Sphere_create(origin: "Point3D", radius: "double") -> "adsk::core::Ptr< adsk::core::Point3D > const &":
    return _core.Sphere_create(origin, radius)


Sphere.origin = property(Sphere._get_origin, Sphere._set_origin, doc="Gets and sets the origin point (center) of the sphere.")


Sphere.radius = property(Sphere._get_radius, Sphere._set_radius, doc="Gets and sets the radius of the sphere.")


Sphere.cast = lambda arg: arg if isinstance(arg, Sphere) else None

class SplitButtonControl(ToolbarControl):
    r"""
    A split button has two active areas that the user can click;
    the main button portion and the drop-down arrow. Clicking the main button, executes the displayed command.
    Clicking the drop-down displays the drop-down with additional commands.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::SplitButtonControl *":
        return _core.SplitButtonControl___deref__(self)

    def __eq__(self, rhs: "SplitButtonControl") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.SplitButtonControl___eq__(self, rhs)


    def __ne__(self, rhs: "SplitButtonControl") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.SplitButtonControl___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.SplitButtonControl_classType()
    __swig_destroy__ = _core.delete_SplitButtonControl

    def _get_defaultCommandDefinition(self) -> "adsk::core::Ptr< adsk::core::CommandDefinition >":
        r"""Gets the command definition that is used as the default command on the main portion of the split button."""
        return _core.SplitButtonControl__get_defaultCommandDefinition(self)

    def _get_isLastUsedShown(self) -> "bool":
        r"""Gets if this button behaves where the last executed command becomes the command on the main portion of the split button."""
        return _core.SplitButtonControl__get_isLastUsedShown(self)

    def _get_additionalDefinitions(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition >,std::allocator< adsk::core::Ptr< adsk::core::CommandDefinition > > >":
        r"""Gets or sets the command definitions used to define the buttons associated with the split button."""
        return _core.SplitButtonControl__get_additionalDefinitions(self)

    def _set_additionalDefinitions(self, value: "CommandDefinitionVector") -> "bool":
        r"""Gets or sets the command definitions used to define the buttons associated with the split button."""
        return _core.SplitButtonControl__set_additionalDefinitions(self, value)

    def _get_id(self) -> "std::string":
        r"""
        Gets the unique ID of this control. The ID is unique with respect to the other
        controls within the same panel, toolbar, or drop-down control.
        """
        return _core.SplitButtonControl__get_id(self)

    def _get_index(self) -> "size_t":
        r"""Gets the position of this control within the list of controls within the panel, toolbar, or drop-down control."""
        return _core.SplitButtonControl__get_index(self)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this control is currently visible."""
        return _core.SplitButtonControl__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this control is currently visible."""
        return _core.SplitButtonControl__set_isVisible(self, value)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets the Parent object. When associated with a toolbar (right or left QAT or the Nav Bar) this
        returns the parent Toolbar object. When associated with a panel it returns the parent ToolbarPanel object.
        When associated with a control (DropDownControl) it returns the parent control.
        """
        return _core.SplitButtonControl__get_parent(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the ToolbarControl 
        Returns a boolean indicating if the deletion was successful.
        """
        return _core.SplitButtonControl_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.SplitButtonControl__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.SplitButtonControl__get_isValid(self)

# Register SplitButtonControl in _core:
_core.SplitButtonControl_swigregister(SplitButtonControl)

def SplitButtonControl_classType() -> "char const *":
    return _core.SplitButtonControl_classType()


SplitButtonControl.defaultCommandDefinition = property(SplitButtonControl._get_defaultCommandDefinition, doc="Gets the command definition that is used as the default command on the main portion of the split button.")


SplitButtonControl.isLastUsedShown = property(SplitButtonControl._get_isLastUsedShown, doc="Gets if this button behaves where the last executed command becomes the command on the main portion of the split button.")


SplitButtonControl.additionalDefinitions = property(SplitButtonControl._get_additionalDefinitions, SplitButtonControl._set_additionalDefinitions, doc="Gets or sets the command definitions used to define the buttons associated with the split button.")


SplitButtonControl.cast = lambda arg: arg if isinstance(arg, SplitButtonControl) else None

class STEPImportOptions(ImportOptions):
    r"""Defines that a STEP import is to be done and specifies the various options."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::STEPImportOptions *":
        return _core.STEPImportOptions___deref__(self)

    def __eq__(self, rhs: "STEPImportOptions") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.STEPImportOptions___eq__(self, rhs)


    def __ne__(self, rhs: "STEPImportOptions") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.STEPImportOptions___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.STEPImportOptions_classType()
    __swig_destroy__ = _core.delete_STEPImportOptions

    def _get_filename(self) -> "std::string":
        r"""Gets and sets the filename or url of the file to be imported."""
        return _core.STEPImportOptions__get_filename(self)

    def _set_filename(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the filename or url of the file to be imported."""
        return _core.STEPImportOptions__set_filename(self, value)

    def _get_isViewFit(self) -> "bool":
        r"""
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.STEPImportOptions__get_isViewFit(self)

    def _set_isViewFit(self, value: "bool") -> "bool":
        r"""
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.STEPImportOptions__set_isViewFit(self, value)

    def _get_objectType(self) -> "char const *":
        return _core.STEPImportOptions__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.STEPImportOptions__get_isValid(self)

# Register STEPImportOptions in _core:
_core.STEPImportOptions_swigregister(STEPImportOptions)

def STEPImportOptions_classType() -> "char const *":
    return _core.STEPImportOptions_classType()


STEPImportOptions.cast = lambda arg: arg if isinstance(arg, STEPImportOptions) else None

class StringProperty(Property):
    r"""A string value property associated with a material or appearance."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::StringProperty *":
        return _core.StringProperty___deref__(self)

    def __eq__(self, rhs: "StringProperty") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.StringProperty___eq__(self, rhs)


    def __ne__(self, rhs: "StringProperty") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.StringProperty___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.StringProperty_classType()
    __swig_destroy__ = _core.delete_StringProperty

    def _get_value(self) -> "std::string":
        r"""Gets and sets the property value."""
        return _core.StringProperty__get_value(self)

    def _set_value(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the property value."""
        return _core.StringProperty__set_value(self, value)

    def _get_name(self) -> "std::string":
        r"""
        Returns the name of this property as seen in the user interface. This name is localized
        and can change based on the current language
        """
        return _core.StringProperty__get_name(self)

    def _get_isReadOnly(self) -> "bool":
        r"""Indicates if this property is read-only. If True any attempted edits will fail."""
        return _core.StringProperty__get_isReadOnly(self)

    def _get_id(self) -> "std::string":
        r"""Returns the unique ID of this property."""
        return _core.StringProperty__get_id(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the parent of this property."""
        return _core.StringProperty__get_parent(self)

    def _get_objectType(self) -> "char const *":
        return _core.StringProperty__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.StringProperty__get_isValid(self)

# Register StringProperty in _core:
_core.StringProperty_swigregister(StringProperty)

def StringProperty_classType() -> "char const *":
    return _core.StringProperty_classType()


StringProperty.value = property(StringProperty._get_value, StringProperty._set_value, doc="Gets and sets the property value.")


StringProperty.cast = lambda arg: arg if isinstance(arg, StringProperty) else None

class StringValueCommandInput(CommandInput):
    r"""Provides a command input to get a string value from the user."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::StringValueCommandInput *":
        return _core.StringValueCommandInput___deref__(self)

    def __eq__(self, rhs: "StringValueCommandInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.StringValueCommandInput___eq__(self, rhs)


    def __ne__(self, rhs: "StringValueCommandInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.StringValueCommandInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.StringValueCommandInput_classType()
    __swig_destroy__ = _core.delete_StringValueCommandInput

    def _get_value(self) -> "std::string":
        r"""Gets or sets the value of this input."""
        return _core.StringValueCommandInput__get_value(self)

    def _set_value(self, value: "std::string const &") -> "bool":
        r"""Gets or sets the value of this input."""
        return _core.StringValueCommandInput__set_value(self, value)

    def _get_isPassword(self) -> "bool":
        r"""
        Gets or sets if this string input behaves as a password field.
        This defaults to false for a newly created StringValueCommandInput.
        If true, dots are displayed instead of the actual characters but
        the value property will get and set the actual string.
        """
        return _core.StringValueCommandInput__get_isPassword(self)

    def _set_isPassword(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this string input behaves as a password field.
        This defaults to false for a newly created StringValueCommandInput.
        If true, dots are displayed instead of the actual characters but
        the value property will get and set the actual string.
        """
        return _core.StringValueCommandInput__set_isPassword(self, value)

    def _get_isReadOnly(self) -> "bool":
        r"""
        Gets and sets if the string value is read-only or not. If it is read-only the user
        cannot edit the text. This property is initialized to False for a newly created
        StringValueCommandInput object.
        """
        return _core.StringValueCommandInput__get_isReadOnly(self)

    def _set_isReadOnly(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the string value is read-only or not. If it is read-only the user
        cannot edit the text. This property is initialized to False for a newly created
        StringValueCommandInput object.
        """
        return _core.StringValueCommandInput__set_isReadOnly(self, value)

    def _get_isValueError(self) -> "bool":
        r"""
        Specifies if the current value shown is valid or not. Any string is valid for a 
        StringValueCommandInput, but you many have some criteria that the string needs
        to meet for it to be valid in your application. You you use the command's validateInputs
        event to verify that inputs are valid and control whether the 'OK' button is enabled
        or not, and you can also set this property on specific StringValueCommandInputs objects
        to indicate to the user that a specific value is not correct. When this property is
        true, Fusion 360 will change the color of the text to red to indicate to the user there is
        a problem.
        """
        return _core.StringValueCommandInput__get_isValueError(self)

    def _set_isValueError(self, value: "bool") -> "bool":
        r"""
        Specifies if the current value shown is valid or not. Any string is valid for a 
        StringValueCommandInput, but you many have some criteria that the string needs
        to meet for it to be valid in your application. You you use the command's validateInputs
        event to verify that inputs are valid and control whether the 'OK' button is enabled
        or not, and you can also set this property on specific StringValueCommandInputs objects
        to indicate to the user that a specific value is not correct. When this property is
        true, Fusion 360 will change the color of the text to red to indicate to the user there is
        a problem.
        """
        return _core.StringValueCommandInput__set_isValueError(self, value)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.StringValueCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string":
        r"""Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.StringValueCommandInput__get_id(self)

    def _get_name(self) -> "std::string":
        r"""Gets the user visible name of this input."""
        return _core.StringValueCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.StringValueCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.StringValueCommandInput__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.StringValueCommandInput__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.StringValueCommandInput__set_isVisible(self, value)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the parent Command."""
        return _core.StringValueCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.StringValueCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.StringValueCommandInput__set_isFullWidth(self, value)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.StringValueCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.StringValueCommandInput__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.StringValueCommandInput__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.StringValueCommandInput__set_tooltip(self, value)

    def _get_tooltipDescription(self) -> "std::string":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.StringValueCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.StringValueCommandInput__set_tooltipDescription(self, value)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.StringValueCommandInput__get_parentCommandInput(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this Command input. 
        Returns true if the delete was successful.
        """
        return _core.StringValueCommandInput_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.StringValueCommandInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.StringValueCommandInput__get_isValid(self)

# Register StringValueCommandInput in _core:
_core.StringValueCommandInput_swigregister(StringValueCommandInput)

def StringValueCommandInput_classType() -> "char const *":
    return _core.StringValueCommandInput_classType()


StringValueCommandInput.value = property(StringValueCommandInput._get_value, StringValueCommandInput._set_value, doc="Gets or sets the value of this input.")


StringValueCommandInput.isPassword = property(StringValueCommandInput._get_isPassword, StringValueCommandInput._set_isPassword, doc="Gets or sets if this string input behaves as a password field.\nThis defaults to false for a newly created StringValueCommandInput.\nIf true, dots are displayed instead of the actual characters but\nthe value property will get and set the actual string.")


StringValueCommandInput.isReadOnly = property(StringValueCommandInput._get_isReadOnly, StringValueCommandInput._set_isReadOnly, doc="Gets and sets if the string value is read-only or not. If it is read-only the user\ncannot edit the text. This property is initialized to False for a newly created\nStringValueCommandInput object.")


StringValueCommandInput.isValueError = property(StringValueCommandInput._get_isValueError, StringValueCommandInput._set_isValueError, doc="Specifies if the current value shown is valid or not. Any string is valid for a\nStringValueCommandInput, but you many have some criteria that the string needs\nto meet for it to be valid in your application. You you use the command's validateInputs\nevent to verify that inputs are valid and control whether the 'OK' button is enabled\nor not, and you can also set this property on specific StringValueCommandInputs objects\nto indicate to the user that a specific value is not correct. When this property is\ntrue, Fusion 360 will change the color of the text to red to indicate to the user there is\na problem.")


StringValueCommandInput.cast = lambda arg: arg if isinstance(arg, StringValueCommandInput) else None

class TabCommandInput(CommandInput):
    r"""Tab command inputs contain a set of command inputs and/or group command inputs/"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::TabCommandInput *":
        return _core.TabCommandInput___deref__(self)

    def __eq__(self, rhs: "TabCommandInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.TabCommandInput___eq__(self, rhs)


    def __ne__(self, rhs: "TabCommandInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.TabCommandInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.TabCommandInput_classType()
    __swig_destroy__ = _core.delete_TabCommandInput

    def _get_children(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""
        Gets the CommandInputs collection for this TabCommandInput.
        Use the add methods on this collection to add child CommandInputs to this Tab in the desired order.
        """
        return _core.TabCommandInput__get_children(self)

    def _get_resourceFolder(self) -> "std::string":
        r"""
        Gets the folder that contains the image for the tab. If no name is specified (no text on tab), 
        a resourceFolder containing the image to appear on the tab needs to be provided.
        """
        return _core.TabCommandInput__get_resourceFolder(self)

    def _get_isActive(self) -> "bool":
        r"""Gets if this is the currently activated (selected) tab."""
        return _core.TabCommandInput__get_isActive(self)

    def activate(self) -> "bool":
        r"""Sets this to be the currently activated (selected) tab."""
        return _core.TabCommandInput_activate(self)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.TabCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string":
        r"""Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.TabCommandInput__get_id(self)

    def _get_name(self) -> "std::string":
        r"""Gets the user visible name of this input."""
        return _core.TabCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.TabCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.TabCommandInput__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.TabCommandInput__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.TabCommandInput__set_isVisible(self, value)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the parent Command."""
        return _core.TabCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.TabCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.TabCommandInput__set_isFullWidth(self, value)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.TabCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.TabCommandInput__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.TabCommandInput__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.TabCommandInput__set_tooltip(self, value)

    def _get_tooltipDescription(self) -> "std::string":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.TabCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.TabCommandInput__set_tooltipDescription(self, value)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.TabCommandInput__get_parentCommandInput(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this Command input. 
        Returns true if the delete was successful.
        """
        return _core.TabCommandInput_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.TabCommandInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.TabCommandInput__get_isValid(self)

# Register TabCommandInput in _core:
_core.TabCommandInput_swigregister(TabCommandInput)

def TabCommandInput_classType() -> "char const *":
    return _core.TabCommandInput_classType()


TabCommandInput.children = property(TabCommandInput._get_children, doc="Gets the CommandInputs collection for this TabCommandInput.\nUse the add methods on this collection to add child CommandInputs to this Tab in the desired order.")


TabCommandInput.resourceFolder = property(TabCommandInput._get_resourceFolder, doc="Gets the folder that contains the image for the tab. If no name is specified (no text on tab),\na resourceFolder containing the image to appear on the tab needs to be provided.")


TabCommandInput.isActive = property(TabCommandInput._get_isActive, doc="Gets if this is the currently activated (selected) tab.")


TabCommandInput.cast = lambda arg: arg if isinstance(arg, TabCommandInput) else None

class TableCommandInput(CommandInput):
    r"""
    Represents a table within a command dialog. The table consists of
    rows and columns where each cell can contain another command input. The 
    selection and button row command inputs cannot be used within a table.
    In addition to the rows and columns, each table can optionally have a
    toolbar of seperate command inputs that is shown at the bottom of the table.
    A table command input can conceptually be compared to an Excel table where you
    have an infinite number of rows and columns available but use a small portion.
    As you add inputs to the table, the table will adjust so all used columns are
    visible. The visible number of rows is controlled by you and if you create
    more rows than can be displayed a scroll bar becomes available.
    For an example of this command input, see the loft command which uses it to show
    the selected profiles and rails.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::TableCommandInput *":
        return _core.TableCommandInput___deref__(self)

    def __eq__(self, rhs: "TableCommandInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.TableCommandInput___eq__(self, rhs)


    def __ne__(self, rhs: "TableCommandInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.TableCommandInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.TableCommandInput_classType()
    __swig_destroy__ = _core.delete_TableCommandInput

    def _get_numberOfColumns(self) -> "int":
        r"""
        Returns the current number of visible columns displayed. Setting this property
        has no effect because the number of columns is automatically inferred by
        the command inputs that have been added to the table. The table automatically
        adjusts the number of rows displayed so all inputs can be seen.
        """
        return _core.TableCommandInput__get_numberOfColumns(self)

    def _set_numberOfColumns(self, value: "int") -> "bool":
        r"""
        Returns the current number of visible columns displayed. Setting this property
        has no effect because the number of columns is automatically inferred by
        the command inputs that have been added to the table. The table automatically
        adjusts the number of rows displayed so all inputs can be seen.
        """
        return _core.TableCommandInput__set_numberOfColumns(self, value)

    def _get_columnRatio(self) -> "std::string":
        r"""
        Gets and sets the width ratio of the columns. This is defined using a string
        such as '1:1:1' where this defines that the first three columns are all the same width.
        A value of '2:1' defines that the first column is twice the width of the second.
        If the table has more columns than are defined by this property, they will automatically
        default to a value of 1. If this property defines the width of more columns than are
        displayed, the extra definitions are ignored.
        You can also specify 0 as a column width and this will have the effect of hiding
        that column. Setting a column width to 0 does not delete the column or the command inputs
        but only hides them so they can be turned back on at a later time by resetting the
        column ratio.
        """
        return _core.TableCommandInput__get_columnRatio(self)

    def _set_columnRatio(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the width ratio of the columns. This is defined using a string
        such as '1:1:1' where this defines that the first three columns are all the same width.
        A value of '2:1' defines that the first column is twice the width of the second.
        If the table has more columns than are defined by this property, they will automatically
        default to a value of 1. If this property defines the width of more columns than are
        displayed, the extra definitions are ignored.
        You can also specify 0 as a column width and this will have the effect of hiding
        that column. Setting a column width to 0 does not delete the column or the command inputs
        but only hides them so they can be turned back on at a later time by resetting the
        column ratio.
        """
        return _core.TableCommandInput__set_columnRatio(self, value)

    def _get_hasGrid(self) -> "bool":
        r"""
        Gets and sets whether a grid is displayed for the table. For a newly created
        table, this property defaults to false.
        """
        return _core.TableCommandInput__get_hasGrid(self)

    def _set_hasGrid(self, value: "bool") -> "bool":
        r"""
        Gets and sets whether a grid is displayed for the table. For a newly created
        table, this property defaults to false.
        """
        return _core.TableCommandInput__set_hasGrid(self, value)

    def _get_rowSpacing(self) -> "int":
        r"""
        Gets and sets the spacing between rows. This is defined in pixels. For a newly
        created table, this property defaults to 1.
        """
        return _core.TableCommandInput__get_rowSpacing(self)

    def _set_rowSpacing(self, value: "int") -> "bool":
        r"""
        Gets and sets the spacing between rows. This is defined in pixels. For a newly
        created table, this property defaults to 1.
        """
        return _core.TableCommandInput__set_rowSpacing(self, value)

    def _get_columnSpacing(self) -> "int":
        r"""
        Gets and sets the spacing between columns. This is defined in pixels. For a newly
        created table, this property defaults to 1.
        """
        return _core.TableCommandInput__get_columnSpacing(self)

    def _set_columnSpacing(self, value: "int") -> "bool":
        r"""
        Gets and sets the spacing between columns. This is defined in pixels. For a newly
        created table, this property defaults to 1.
        """
        return _core.TableCommandInput__set_columnSpacing(self, value)

    def _get_minimumVisibleRows(self) -> "int":
        r"""
        Gets and sets the minimum number of rows displayed. This is the minimum amount of
        space taken up on the command dialog, even if the table doesn't yet contain any
        rows. For a newly created table, this property defaults to 2.
        """
        return _core.TableCommandInput__get_minimumVisibleRows(self)

    def _set_minimumVisibleRows(self, value: "int") -> "bool":
        r"""
        Gets and sets the minimum number of rows displayed. This is the minimum amount of
        space taken up on the command dialog, even if the table doesn't yet contain any
        rows. For a newly created table, this property defaults to 2.
        """
        return _core.TableCommandInput__set_minimumVisibleRows(self, value)

    def _get_maximumVisibleRows(self) -> "int":
        r"""
        Gets and sets the maximum number of rows that can be displayed. As rows are added
        the visible size of the table will grow to show all rows until this maximum number
        of rows is reached and then a scroll bar will be displayed to allow the user to
        access all rows. For a new created table, this property defaults to 4.
        """
        return _core.TableCommandInput__get_maximumVisibleRows(self)

    def _set_maximumVisibleRows(self, value: "int") -> "bool":
        r"""
        Gets and sets the maximum number of rows that can be displayed. As rows are added
        the visible size of the table will grow to show all rows until this maximum number
        of rows is reached and then a scroll bar will be displayed to allow the user to
        access all rows. For a new created table, this property defaults to 4.
        """
        return _core.TableCommandInput__set_maximumVisibleRows(self, value)

    def deleteRow(self, row: "int") -> "bool":
        r"""
        Deletes the specified row. The following rows will be shifted up. The row and the 
        command inputs it contains are deleted. To temporarily hide a row you can set the 
        visibility of all of the command inputs it contains to be invisible. If all inputs
        are invisible the row will automatically be hidden. 
        row : The row to delete where valid values are 0 to the number of rows minus 1. A value of
        0 will delete the first row. A value greater than the number of rows will delete the
        last row. 
        Returns true if the delete was successful.
        """
        return _core.TableCommandInput_deleteRow(self, row)

    def _get_tablePresentationStyle(self) -> "adsk::core::TablePresentationStyles":
        r"""Gets and sets the presentation style the table is currently using for its display."""
        return _core.TableCommandInput__get_tablePresentationStyle(self)

    def _set_tablePresentationStyle(self, value: "TablePresentationStyles") -> "bool":
        r"""Gets and sets the presentation style the table is currently using for its display."""
        return _core.TableCommandInput__set_tablePresentationStyle(self, value)

    def addCommandInput(self, input: "CommandInput", row: "int", column: "int", rowSpan: "int"=0, columnSpan: "int"=0) -> "bool":
        r"""
        Adds a command input to a particular cell in the table. Rows are automatically added to the table to
        able to contain the command input. The command input can span multiple columns within a row and spanning
        across multiple rows is not currently supported.
        The command input is created in the standard way but when it's added to the table using this method it 
        will be displayed in the table instead of the main area of the dialog. 
        input : The command input to associate to a cell. The command input is created in the standard way but when it's added to 
        the table using this method it will be displayed in the table instead of the main area of the dialog. 
        row : The row index of the cell where 0 is the first row. 
        column : The column index of the cell where 0 is the first column. 
        rowSpan : The number of additional rows that this input uses. The default value of 0 indicates that no additional
        rows are used. Row spanning is not currently supported so this value must always be 0. 
        columnSpan : The number of additional columns that this input uses. The default value of 0 indicates that no additional
        columns are used. 
        Returns true if the association of the command input to the cell was successful.
        """
        return _core.TableCommandInput_addCommandInput(self, input, row, column, rowSpan, columnSpan)

    def removeInput(self, row: "int", column: "int") -> "bool":
        r"""
        Removes the command input that is at the specified row and column. This doesn't delete the command input from
        the collection of inputs associated with the command but just removes it from being displayed in the table. 
        row : The row where the command input to be removed is located. 
        column : The row where the command input to be removed is located. 
        Returns true if the removal was successful.
        """
        return _core.TableCommandInput_removeInput(self, row, column)

    def getPosition(self, input: "CommandInput") -> "bool":
        r"""
        Gets the position of the specified command input within the table. 
        input : The existing command input you want to find the associated cell for. 
        row : The returned row index of the cell. 
        column : The returned column index of the cell. 
        rowSpan : The returned number of additional rows used by the input. A value of 0
        indicates that no additional rows are used. 
        columnSpan : The returned number of additional columns used by the input. A value of 0
        indicates that no additional columns are used. 
        Returns true if the position was successfully returned.
        """
        return _core.TableCommandInput_getPosition(self, input)

    def _get_rowCount(self) -> "int":
        r"""
        Returns the number of rows in the table. The actual number of rows in the table is defined
        by the number of rows that contain command inputs.
        """
        return _core.TableCommandInput__get_rowCount(self)

    def clear(self) -> "bool":
        r"""
        Removes all rows in the table and the toolbar. 
        Returns true if successful.
        """
        return _core.TableCommandInput_clear(self)

    def _get_selectedRow(self) -> "int":
        r"""
        Gets and sets which row is selected in the user-interface. A value of 0 indicates
        that the first row is selected. A value of -1 indicates that no row is selected.
        """
        return _core.TableCommandInput__get_selectedRow(self)

    def _set_selectedRow(self, value: "int") -> "bool":
        r"""
        Gets and sets which row is selected in the user-interface. A value of 0 indicates
        that the first row is selected. A value of -1 indicates that no row is selected.
        """
        return _core.TableCommandInput__set_selectedRow(self, value)

    def addToolbarCommandInput(self, input: "CommandInput") -> "bool":
        r"""
        Adds a new command input to the toolbar at the bottom of the table. 
        input : Adds a command input to the toolbar at the bottom of the table. The inputs are displayed
        in the same order that they're added.
        The command input is created in the standard way but when it's added to the table using this method it 
        will be displayed in the table instead of the main area of the dialog. 
        Returns true if the command input was successfully added.
        """
        return _core.TableCommandInput_addToolbarCommandInput(self, input)

    def getInputAtPosition(self, row: "int", column: "int") -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Returns the command input that is in the specified row and column. In the case
        where a command input spans multiple columns, the same input can be returned
        from mulitple positions. 
        row : The row index to return the command input from where the first row is 0. 
        column : The row index to return the command input from where the first row is 0. 
        Returns the command input that is in the specified row and column. If there
        isn't a command input in the specified location, null is returned.
        """
        return _core.TableCommandInput_getInputAtPosition(self, row, column)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.TableCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string":
        r"""Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.TableCommandInput__get_id(self)

    def _get_name(self) -> "std::string":
        r"""Gets the user visible name of this input."""
        return _core.TableCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.TableCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.TableCommandInput__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.TableCommandInput__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.TableCommandInput__set_isVisible(self, value)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the parent Command."""
        return _core.TableCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.TableCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.TableCommandInput__set_isFullWidth(self, value)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.TableCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.TableCommandInput__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.TableCommandInput__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.TableCommandInput__set_tooltip(self, value)

    def _get_tooltipDescription(self) -> "std::string":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.TableCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.TableCommandInput__set_tooltipDescription(self, value)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.TableCommandInput__get_parentCommandInput(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this Command input. 
        Returns true if the delete was successful.
        """
        return _core.TableCommandInput_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.TableCommandInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.TableCommandInput__get_isValid(self)

# Register TableCommandInput in _core:
_core.TableCommandInput_swigregister(TableCommandInput)

def TableCommandInput_classType() -> "char const *":
    return _core.TableCommandInput_classType()


TableCommandInput.numberOfColumns = property(TableCommandInput._get_numberOfColumns, TableCommandInput._set_numberOfColumns, doc="Returns the current number of visible columns displayed. Setting this property\nhas no effect because the number of columns is automatically inferred by\nthe command inputs that have been added to the table. The table automatically\nadjusts the number of rows displayed so all inputs can be seen.")


TableCommandInput.columnRatio = property(TableCommandInput._get_columnRatio, TableCommandInput._set_columnRatio, doc="Gets and sets the width ratio of the columns. This is defined using a string\nsuch as '1:1:1' where this defines that the first three columns are all the same width.\nA value of '2:1' defines that the first column is twice the width of the second.\nIf the table has more columns than are defined by this property, they will automatically\ndefault to a value of 1. If this property defines the width of more columns than are\ndisplayed, the extra definitions are ignored.\nYou can also specify 0 as a column width and this will have the effect of hiding\nthat column. Setting a column width to 0 does not delete the column or the command inputs\nbut only hides them so they can be turned back on at a later time by resetting the\ncolumn ratio.")


TableCommandInput.hasGrid = property(TableCommandInput._get_hasGrid, TableCommandInput._set_hasGrid, doc="Gets and sets whether a grid is displayed for the table. For a newly created\ntable, this property defaults to false.")


TableCommandInput.rowSpacing = property(TableCommandInput._get_rowSpacing, TableCommandInput._set_rowSpacing, doc="Gets and sets the spacing between rows. This is defined in pixels. For a newly\ncreated table, this property defaults to 1.")


TableCommandInput.columnSpacing = property(TableCommandInput._get_columnSpacing, TableCommandInput._set_columnSpacing, doc="Gets and sets the spacing between columns. This is defined in pixels. For a newly\ncreated table, this property defaults to 1.")


TableCommandInput.minimumVisibleRows = property(TableCommandInput._get_minimumVisibleRows, TableCommandInput._set_minimumVisibleRows, doc="Gets and sets the minimum number of rows displayed. This is the minimum amount of\nspace taken up on the command dialog, even if the table doesn't yet contain any\nrows. For a newly created table, this property defaults to 2.")


TableCommandInput.maximumVisibleRows = property(TableCommandInput._get_maximumVisibleRows, TableCommandInput._set_maximumVisibleRows, doc="Gets and sets the maximum number of rows that can be displayed. As rows are added\nthe visible size of the table will grow to show all rows until this maximum number\nof rows is reached and then a scroll bar will be displayed to allow the user to\naccess all rows. For a new created table, this property defaults to 4.")


TableCommandInput.tablePresentationStyle = property(TableCommandInput._get_tablePresentationStyle, TableCommandInput._set_tablePresentationStyle, doc="Gets and sets the presentation style the table is currently using for its display.")


TableCommandInput.rowCount = property(TableCommandInput._get_rowCount, doc="Returns the number of rows in the table. The actual number of rows in the table is defined\nby the number of rows that contain command inputs.")


TableCommandInput.selectedRow = property(TableCommandInput._get_selectedRow, TableCommandInput._set_selectedRow, doc="Gets and sets which row is selected in the user-interface. A value of 0 indicates\nthat the first row is selected. A value of -1 indicates that no row is selected.")


TableCommandInput.cast = lambda arg: arg if isinstance(arg, TableCommandInput) else None

class TextBoxCommandInput(CommandInput):
    r"""Provides a command input to interact with a text box."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::TextBoxCommandInput *":
        return _core.TextBoxCommandInput___deref__(self)

    def __eq__(self, rhs: "TextBoxCommandInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.TextBoxCommandInput___eq__(self, rhs)


    def __ne__(self, rhs: "TextBoxCommandInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.TextBoxCommandInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.TextBoxCommandInput_classType()
    __swig_destroy__ = _core.delete_TextBoxCommandInput

    def _get_formattedText(self) -> "std::string":
        r"""
        Gets and sets the formatted text displayed in the dialog. Formatted text includes
        any html formatting that has been defined. For example, you can use basic html formatting such as
        <b>Bold</b>, <i>Italic</i>, and <br /> for a line break.
        """
        return _core.TextBoxCommandInput__get_formattedText(self)

    def _set_formattedText(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the formatted text displayed in the dialog. Formatted text includes
        any html formatting that has been defined. For example, you can use basic html formatting such as
        <b>Bold</b>, <i>Italic</i>, and <br /> for a line break.
        """
        return _core.TextBoxCommandInput__set_formattedText(self, value)

    def _get_text(self) -> "std::string":
        r"""
        Gets and sets the text in the text box. This returns the string
        as seen in the text box with any formatting stripped out.
        """
        return _core.TextBoxCommandInput__get_text(self)

    def _set_text(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the text in the text box. This returns the string
        as seen in the text box with any formatting stripped out.
        """
        return _core.TextBoxCommandInput__set_text(self, value)

    def _get_numRows(self) -> "int":
        r"""
        Gets and sets the height of the text box as defined by the number of rows of
        text that can be displayed. If the text is larger than will fit in the box
        a scroll bar will automatically be displayed.
        """
        return _core.TextBoxCommandInput__get_numRows(self)

    def _set_numRows(self, value: "int") -> "bool":
        r"""
        Gets and sets the height of the text box as defined by the number of rows of
        text that can be displayed. If the text is larger than will fit in the box
        a scroll bar will automatically be displayed.
        """
        return _core.TextBoxCommandInput__set_numRows(self, value)

    def _get_isReadOnly(self) -> "bool":
        r"""
        Gets and sets if the text box is read-only or not. If it is read-only the user
        cannot edit the text.
        """
        return _core.TextBoxCommandInput__get_isReadOnly(self)

    def _set_isReadOnly(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the text box is read-only or not. If it is read-only the user
        cannot edit the text.
        """
        return _core.TextBoxCommandInput__set_isReadOnly(self, value)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.TextBoxCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string":
        r"""Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.TextBoxCommandInput__get_id(self)

    def _get_name(self) -> "std::string":
        r"""Gets the user visible name of this input."""
        return _core.TextBoxCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.TextBoxCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.TextBoxCommandInput__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.TextBoxCommandInput__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.TextBoxCommandInput__set_isVisible(self, value)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the parent Command."""
        return _core.TextBoxCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.TextBoxCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.TextBoxCommandInput__set_isFullWidth(self, value)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.TextBoxCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.TextBoxCommandInput__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.TextBoxCommandInput__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.TextBoxCommandInput__set_tooltip(self, value)

    def _get_tooltipDescription(self) -> "std::string":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.TextBoxCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.TextBoxCommandInput__set_tooltipDescription(self, value)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.TextBoxCommandInput__get_parentCommandInput(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this Command input. 
        Returns true if the delete was successful.
        """
        return _core.TextBoxCommandInput_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.TextBoxCommandInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.TextBoxCommandInput__get_isValid(self)

# Register TextBoxCommandInput in _core:
_core.TextBoxCommandInput_swigregister(TextBoxCommandInput)

def TextBoxCommandInput_classType() -> "char const *":
    return _core.TextBoxCommandInput_classType()


TextBoxCommandInput.formattedText = property(TextBoxCommandInput._get_formattedText, TextBoxCommandInput._set_formattedText, doc="Gets and sets the formatted text displayed in the dialog. Formatted text includes\nany html formatting that has been defined. For example, you can use basic html formatting such as\n<b>Bold</b>, <i>Italic</i>, and <br /> for a line break.")


TextBoxCommandInput.text = property(TextBoxCommandInput._get_text, TextBoxCommandInput._set_text, doc="Gets and sets the text in the text box. This returns the string\nas seen in the text box with any formatting stripped out.")


TextBoxCommandInput.numRows = property(TextBoxCommandInput._get_numRows, TextBoxCommandInput._set_numRows, doc="Gets and sets the height of the text box as defined by the number of rows of\ntext that can be displayed. If the text is larger than will fit in the box\na scroll bar will automatically be displayed.")


TextBoxCommandInput.isReadOnly = property(TextBoxCommandInput._get_isReadOnly, TextBoxCommandInput._set_isReadOnly, doc="Gets and sets if the text box is read-only or not. If it is read-only the user\ncannot edit the text.")


TextBoxCommandInput.cast = lambda arg: arg if isinstance(arg, TextBoxCommandInput) else None

class TextCommandPalette(Palette):
    r"""
    <p class='api'>Represents the palette that is the Text Command window in Fusion 360. You can obtain the Text Command palette by using the itemById method of the Palettes object and using 'TextCommands' as the ID. Below is some sample code that illustrates making sure the palette is visible and writing some text to it.</p>
    <pre class='api-code'><span style = 'color:blue' ># Get the palette that represents the TEXT COMMANDS window.</span>
    textPalette = ui.palettes.itemById('TextCommands')
    <span style = 'color:blue'># Make sure the palette is visible.</span> 
    if not textPalette.isVisible:
    textPalette.isVisible = True
    <span style= 'color:blue' ># Write some text.</span>
    textPalette.writeText('This is a text message.') </pre>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::TextCommandPalette *":
        return _core.TextCommandPalette___deref__(self)

    def __eq__(self, rhs: "TextCommandPalette") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.TextCommandPalette___eq__(self, rhs)


    def __ne__(self, rhs: "TextCommandPalette") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.TextCommandPalette___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.TextCommandPalette_classType()
    __swig_destroy__ = _core.delete_TextCommandPalette

    def writeText(self, text: "std::string const &") -> "bool":
        r"""
        <p class='api'>Write the specified text to the TEXT COMMAND window. Below is some sample code that illustrates making sure the palette is visible and writing some text to it.</p>
        <pre class='api-code'><span style = 'color:blue' ># Get the palette that represents the TEXT COMMANDS window.</span>
        textPalette = ui.palettes.itemById('TextCommands')
        <span style = 'color:blue'># Make sure the palette is visible.</span>
        if not textPalette.isVisible:
        textPalette.isVisible = True
        <span style= 'color:blue' ># Write some text.</span>
        textPalette.writeText('This is a text message.') </pre> 
        text : The text to write to the Text Command window. 
        Returns true if successful.
        """
        return _core.TextCommandPalette_writeText(self, text)

    def _get_id(self) -> "std::string":
        r"""Gets The unique, language independent, ID of this palette."""
        return _core.TextCommandPalette__get_id(self)

    def _get_isVisible(self) -> "bool":
        r"""Gets and sets whether this palette is currently being displayed in the user interface."""
        return _core.TextCommandPalette__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets and sets whether this palette is currently being displayed in the user interface."""
        return _core.TextCommandPalette__set_isVisible(self, value)

    def _get_htmlFileURL(self) -> "std::string":
        r"""Gets and sets the URL to the html file currently being displayed. This can be local or on the web."""
        return _core.TextCommandPalette__get_htmlFileURL(self)

    def _set_htmlFileURL(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the URL to the html file currently being displayed. This can be local or on the web."""
        return _core.TextCommandPalette__set_htmlFileURL(self, value)

    def sendInfoToHTML(self, action: "std::string const &", data: "std::string const &") -> "std::string":
        r"""
        <p>Sends the string to the JavaScript associated with the loaded HTML. A variation of the
        event handler below should be implemented in the JavaScript associated with the HTML to
        receive the data. The event will be triggered by Fusion 360 whenever the sendInfoToHTML method 
        is called.</p>
        <pre class='api-code'>window.fusionJavaScriptHandler = {
        handle: function(actionString, dataString){
        confirm('Action from Fusion: ' + actionString);
        confirm('Data from Fusion: ' + dataString);
        // Build up JSON return string.
        var result = {};
        result.status = 'OK';
        var response = JSON.stringify(result);
        return response;
        }
        };</pre> 
        <p>Your JavaScript code should always return something in response because an empty string
        response is assumed to be a failure.</p> 
        action : The 'action' string to pass to the JavaScript associated with the HTML. This string can be 
        anything but will typically be JSON formatted information. 
        data : The 'data' string to pass to the JavaScript associated with the HTML. This string can be 
        anything but will typically be JSON formatted information. 
        Returns a string that can be anything that your JavaScript code generates. The JavaScript
        should always return some content because an empty string is used to indicate a failure.
        If useNewWebBrowser flag is set to true while creating the palette control this API call
        will be asynchronous and an empty string is returned. Response will come in data field of HTMLEvent with action
        equal to 'response'.
        """
        return _core.TextCommandPalette_sendInfoToHTML(self, action, data)

    def _get_incomingFromHTML(self) -> "adsk::core::Ptr< adsk::core::HTMLEvent >":
        r"""
        This event is fired when the JavaScript associated with the HTML calls the 
        adsk.fusionSendData function. This allows the HTML to communicate with the add-in by
        passing information to the add-in.
        """
        return _core.TextCommandPalette__get_incomingFromHTML(self)

    def _get_closed(self) -> "adsk::core::Ptr< adsk::core::UserInterfaceGeneralEvent >":
        r"""
        This event is fired when the user clicks the 'Close' button on the palette. You can choose
        if the 'Close' button is available or not when you initially create the palette. When a
        palette is closed, it still exists but is change to invisible so you can still interact with it and
        retrieve any needed information and can make it visible again. Use the deleteMe method to
        delete the palette.
        """
        return _core.TextCommandPalette__get_closed(self)

    def _get_name(self) -> "std::string":
        r"""
        Gets and set the name of the palette as seen in the user interface. The name of native palletes
        cannot be set.
        """
        return _core.TextCommandPalette__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""
        Gets and set the name of the palette as seen in the user interface. The name of native palletes
        cannot be set.
        """
        return _core.TextCommandPalette__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this palette. Fusion 360 native palettes cannot be deleted. Use the
        isNative property to determine if this is a native or API created palette. 
        Returns true if the delete was successful.
        """
        return _core.TextCommandPalette_deleteMe(self)

    def _get_isNative(self) -> "bool":
        r"""
        Indicates if this is one of the standard Fusion 360 palettes or a custom palette
        created through the API. If true, it is a standard Fusion 360 palette and will
        have some restrictions on changing its properties and cannot be deleted.
        """
        return _core.TextCommandPalette__get_isNative(self)

    def _get_dockingOption(self) -> "adsk::core::PaletteDockingOptions":
        r"""Defines the docking behavior for this palette. This controls how the user is allowed to dock the palette."""
        return _core.TextCommandPalette__get_dockingOption(self)

    def _set_dockingOption(self, value: "PaletteDockingOptions") -> "bool":
        r"""Defines the docking behavior for this palette. This controls how the user is allowed to dock the palette."""
        return _core.TextCommandPalette__set_dockingOption(self, value)

    def _get_dockingState(self) -> "adsk::core::PaletteDockingStates":
        r"""Gets and sets how the palette is currented docked."""
        return _core.TextCommandPalette__get_dockingState(self)

    def _set_dockingState(self, value: "PaletteDockingStates") -> "bool":
        r"""Gets and sets how the palette is currented docked."""
        return _core.TextCommandPalette__set_dockingState(self, value)

    def _get_width(self) -> "int":
        r"""
        Gets and sets the width of the palette. Setting this property may not always set the width. Depending on
        how the palette is docked or snapped, the width may not be editable.
        """
        return _core.TextCommandPalette__get_width(self)

    def _set_width(self, value: "int") -> "bool":
        r"""
        Gets and sets the width of the palette. Setting this property may not always set the width. Depending on
        how the palette is docked or snapped, the width may not be editable.
        """
        return _core.TextCommandPalette__set_width(self, value)

    def _get_height(self) -> "int":
        r"""
        Gets and sets the height of the palette. Setting this property may not always set the height. Depending on
        how the palette is docked or snapped, the height may not be editable.
        """
        return _core.TextCommandPalette__get_height(self)

    def _set_height(self, value: "int") -> "bool":
        r"""
        Gets and sets the height of the palette. Setting this property may not always set the height. Depending on
        how the palette is docked or snapped, the height may not be editable.
        """
        return _core.TextCommandPalette__set_height(self, value)

    def setPosition(self, left: "int", top: "int") -> "bool":
        r"""
        Sets the position of the palette. If the palette is docked or snapped, this will result in changing it
        to be floating. 
        left : The position of the left side of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the left side of the screen and not the 
        Fusion 360 window. 
        top : The position of the top of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the top of the screen and not the 
        Fusion 360 window. 
        Returns true if setting the position was successful.
        """
        return _core.TextCommandPalette_setPosition(self, left, top)

    def setSize(self, width: "int", height: "int") -> "bool":
        r"""
        Sets the size of the palette. This is best used for a floating palette because either the width or
        height can be locked when a palette is docked. 
        width : Specifies the width of the palette. Depending on how the palette is docked or snapped, the width 
        may not be editable. 
        height : Specifies the height of the palette. Depending on how the palette is docked or snapped, the height 
        may not be editable. 
        Returns true if the sizing was succesful. It is still considered a success even if the width or
        height could not be changed because of how the palette is docked or snapped.
        """
        return _core.TextCommandPalette_setSize(self, width, height)

    def _get_left(self) -> "int":
        r"""
        Gets and sets the left side of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the left side of the screen and not the 
        Fusion 360 window.
        """
        return _core.TextCommandPalette__get_left(self)

    def _set_left(self, value: "int") -> "bool":
        r"""
        Gets and sets the left side of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the left side of the screen and not the 
        Fusion 360 window.
        """
        return _core.TextCommandPalette__set_left(self, value)

    def _get_top(self) -> "int":
        r"""
        Gets and sets the top of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the top of the screen and not the 
        Fusion 360 window.
        """
        return _core.TextCommandPalette__get_top(self)

    def _set_top(self, value: "int") -> "bool":
        r"""
        Gets and sets the top of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the top of the screen and not the 
        Fusion 360 window.
        """
        return _core.TextCommandPalette__set_top(self, value)

    def snapTo(self, palette: "Palette", snapOption: "PaletteSnapOptions") -> "bool":
        r"""
        Snaps this palette to another palette. 
        palette : Specifies the palette to snap to. 
        snapOption : Specifies how this palette should be snapped to the other palette. 
        Returns true if the palette was successfully snapped to the other palette.
        """
        return _core.TextCommandPalette_snapTo(self, palette, snapOption)

    def setMinimumSize(self, width: "int", height: "int") -> "bool":
        r"""
        Sets the minimum size of the palette. The user cannot resize it to be smaller than
        this size. This does not change the current size of the palette unless the palette
        is already smaller than this size.
        Calling this method and setting the width and height to zero, removes the minimum
        size restriction. 
        width : Specifies the minimum width of the palette. 
        height : Specifies the minimum height of the palette. 
        Returns true if setting the minimum size was succesful.
        """
        return _core.TextCommandPalette_setMinimumSize(self, width, height)

    def setMaximumSize(self, width: "int", height: "int") -> "bool":
        r"""
        Sets the maximum size of the palette. The user cannot resize it to be larger than
        this size. This does not change the current size of the palette unless the palette
        is already larger than this size.
        Calling this method and setting the width and height to zero, removes the maximum
        size restriction. 
        width : Specifies the maximum width of the palette. 
        height : Specifies the maximum height of the palette. 
        Returns true if setting the maximum size was succesful.
        """
        return _core.TextCommandPalette_setMaximumSize(self, width, height)

    def _get_navigatingURL(self) -> "adsk::core::Ptr< adsk::core::NavigationEvent >":
        r"""
        This event is fired when a navigation event occurs on the page. This allows the add-in to determine
        how this navigation should be handled by the browser.
        """
        return _core.TextCommandPalette__get_navigatingURL(self)

    def _get_objectType(self) -> "char const *":
        return _core.TextCommandPalette__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.TextCommandPalette__get_isValid(self)

# Register TextCommandPalette in _core:
_core.TextCommandPalette_swigregister(TextCommandPalette)

def TextCommandPalette_classType() -> "char const *":
    return _core.TextCommandPalette_classType()


TextCommandPalette.cast = lambda arg: arg if isinstance(arg, TextCommandPalette) else None

class Torus(Surface):
    r"""
    Transient torus. A transient torus is not displayed or saved in a document. 
    A transient torus is used as a wrapper to work with raw torus information. 
    A transient torus is a full torus with no boundaries.
    They are created statically using the create method of the Torus class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Torus *":
        return _core.Torus___deref__(self)

    def __eq__(self, rhs: "Torus") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.Torus___eq__(self, rhs)


    def __ne__(self, rhs: "Torus") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.Torus___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.Torus_classType()

    @staticmethod
    def create(origin: "Point3D", axis: "Vector3D", majorRadius: "double", minorRadius: "double") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
        return _core.Torus_create(origin, axis, majorRadius, minorRadius)
    __swig_destroy__ = _core.delete_Torus

    def _get_origin(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets the origin point (center) of the torus."""
        return _core.Torus__get_origin(self)

    def _set_origin(self, value: "Point3D") -> "bool":
        r"""Gets and sets the origin point (center) of the torus."""
        return _core.Torus__set_origin(self, value)

    def _get_axis(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Gets and sets the center axis of the torus."""
        return _core.Torus__get_axis(self)

    def _set_axis(self, value: "Vector3D") -> "bool":
        r"""Gets and sets the center axis of the torus."""
        return _core.Torus__set_axis(self, value)

    def _get_majorRadius(self) -> "double":
        r"""Gets and sets the major radius of the torus."""
        return _core.Torus__get_majorRadius(self)

    def _set_majorRadius(self, value: "double") -> "bool":
        r"""Gets and sets the major radius of the torus."""
        return _core.Torus__set_majorRadius(self, value)

    def _get_minorRadius(self) -> "double":
        r"""Gets and sets the minor radius of the torus."""
        return _core.Torus__get_minorRadius(self)

    def _set_minorRadius(self, value: "double") -> "bool":
        r"""Gets and sets the minor radius of the torus."""
        return _core.Torus__set_minorRadius(self, value)

    def getData(self) -> "bool":
        r"""
        Gets all of the data defining the torus. 
        origin : The output origin point (center) of the torus. 
        axis : The output center axis of the torus. 
        majorRadius : The output major radius of the torus. 
        minorRadius : The output minor radius of the torus. 
        Returns true if successful.
        """
        return _core.Torus_getData(self)

    def set(self, origin: "Point3D", axis: "Vector3D", majorRadius: "double", minorRadius: "double") -> "bool":
        r"""
        Sets all of the data defining the torus. 
        origin : The origin point (center) of the torus. 
        axis : The center axis of the torus. 
        majorRadius : The major radius of the torus. 
        minorRadius : The minor radius of the torus. 
        Returns true if successful.
        """
        return _core.Torus_set(self, origin, axis, majorRadius, minorRadius)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Torus >":
        r"""
        Creates and returns an independent copy of this Torus object. 
        Returns a new Torus object that is a copy of this Torus object.
        """
        return _core.Torus_copy(self)

    def _get_surfaceType(self) -> "adsk::core::SurfaceTypes":
        r"""Returns the surface type."""
        return _core.Torus__get_surfaceType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::SurfaceEvaluator >":
        r"""Returns the surface evaluator."""
        return _core.Torus__get_evaluator(self)

    def transformBy(self, matrix: "Matrix3D") -> "bool":
        r"""
        Updates this surface by transforming it with a given input matrix. 
        matrix : A 3D matrix that defines the transform to apply to the surface. 
        Returns true if the transform was successful.
        """
        return _core.Torus_transformBy(self, matrix)

    def _get_objectType(self) -> "char const *":
        return _core.Torus__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.Torus__get_isValid(self)

# Register Torus in _core:
_core.Torus_swigregister(Torus)

def Torus_classType() -> "char const *":
    return _core.Torus_classType()

def Torus_create(origin: "Point3D", axis: "Vector3D", majorRadius: "double", minorRadius: "double") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &":
    return _core.Torus_create(origin, axis, majorRadius, minorRadius)


Torus.origin = property(Torus._get_origin, Torus._set_origin, doc="Gets and sets the origin point (center) of the torus.")


Torus.axis = property(Torus._get_axis, Torus._set_axis, doc="Gets and sets the center axis of the torus.")


Torus.majorRadius = property(Torus._get_majorRadius, Torus._set_majorRadius, doc="Gets and sets the major radius of the torus.")


Torus.minorRadius = property(Torus._get_minorRadius, Torus._set_minorRadius, doc="Gets and sets the minor radius of the torus.")


Torus.cast = lambda arg: arg if isinstance(arg, Torus) else None

class UserInterfaceGeneralEvent(Event):
    r"""
    A UserInterfaceGeneralEvent is used for user-interface related events that don't
    require any additional information beyond getting the event itself.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::UserInterfaceGeneralEvent *":
        return _core.UserInterfaceGeneralEvent___deref__(self)

    def __eq__(self, rhs: "UserInterfaceGeneralEvent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.UserInterfaceGeneralEvent___eq__(self, rhs)


    def __ne__(self, rhs: "UserInterfaceGeneralEvent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.UserInterfaceGeneralEvent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.UserInterfaceGeneralEvent_classType()
    __swig_destroy__ = _core.delete_UserInterfaceGeneralEvent

    def add(self, handler: "UserInterfaceGeneralEventHandler") -> "bool":
        r"""
        Add a handler to be notified when the event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _core.UserInterfaceGeneralEvent_add(self, handler)

    def remove(self, handler: "UserInterfaceGeneralEventHandler") -> "bool":
        r"""
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _core.UserInterfaceGeneralEvent_remove(self, handler)

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _core.UserInterfaceGeneralEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.UserInterfaceGeneralEvent__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _core.UserInterfaceGeneralEvent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.UserInterfaceGeneralEvent__get_isValid(self)

# Register UserInterfaceGeneralEvent in _core:
_core.UserInterfaceGeneralEvent_swigregister(UserInterfaceGeneralEvent)

def UserInterfaceGeneralEvent_classType() -> "char const *":
    return _core.UserInterfaceGeneralEvent_classType()


UserInterfaceGeneralEvent.cast = lambda arg: arg if isinstance(arg, UserInterfaceGeneralEvent) else None

class UserInterfaceGeneralEventArgs(EventArgs):
    r"""The UserInterfaceGeneralEventArgs is passed when a UserInterfaceGeneralEvent is fired."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::UserInterfaceGeneralEventArgs *":
        return _core.UserInterfaceGeneralEventArgs___deref__(self)

    def __eq__(self, rhs: "UserInterfaceGeneralEventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.UserInterfaceGeneralEventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "UserInterfaceGeneralEventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.UserInterfaceGeneralEventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.UserInterfaceGeneralEventArgs_classType()
    __swig_destroy__ = _core.delete_UserInterfaceGeneralEventArgs

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _core.UserInterfaceGeneralEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _core.UserInterfaceGeneralEventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.UserInterfaceGeneralEventArgs__get_isValid(self)

# Register UserInterfaceGeneralEventArgs in _core:
_core.UserInterfaceGeneralEventArgs_swigregister(UserInterfaceGeneralEventArgs)

def UserInterfaceGeneralEventArgs_classType() -> "char const *":
    return _core.UserInterfaceGeneralEventArgs_classType()


UserInterfaceGeneralEventArgs.cast = lambda arg: arg if isinstance(arg, UserInterfaceGeneralEventArgs) else None

class ValidateInputsEvent(Event):
    r"""An event endpoint that supports the connection to client implemented ValidateInputsEventHandlers."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ValidateInputsEvent *":
        return _core.ValidateInputsEvent___deref__(self)

    def __eq__(self, rhs: "ValidateInputsEvent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ValidateInputsEvent___eq__(self, rhs)


    def __ne__(self, rhs: "ValidateInputsEvent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ValidateInputsEvent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ValidateInputsEvent_classType()
    __swig_destroy__ = _core.delete_ValidateInputsEvent

    def add(self, handler: "ValidateInputsEventHandler") -> "bool":
        r"""
        Adds an event handler to this event endpoint. 
        handler : The client implemented ValidateInputsEventHandler to be called when this event is triggered. 
        Returns true if the handler was successfully added to the set of event handlers.
        """
        return _core.ValidateInputsEvent_add(self, handler)

    def remove(self, handler: "ValidateInputsEventHandler") -> "bool":
        r"""
        Removes a handler from this event endpoint. 
        handler : A ValidateInputsEventHandler that was previously added to this event with the add method. 
        Returns true if the handler was found and removed from the set of event handlers.
        """
        return _core.ValidateInputsEvent_remove(self, handler)

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _core.ValidateInputsEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.ValidateInputsEvent__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _core.ValidateInputsEvent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ValidateInputsEvent__get_isValid(self)

# Register ValidateInputsEvent in _core:
_core.ValidateInputsEvent_swigregister(ValidateInputsEvent)

def ValidateInputsEvent_classType() -> "char const *":
    return _core.ValidateInputsEvent_classType()


ValidateInputsEvent.cast = lambda arg: arg if isinstance(arg, ValidateInputsEvent) else None

class ValidateInputsEventArgs(EventArgs):
    r"""Provides a set of arguments from a firing ValidateInputsEvent to a ValidateInputsEventHandler's notify callback method."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ValidateInputsEventArgs *":
        return _core.ValidateInputsEventArgs___deref__(self)

    def __eq__(self, rhs: "ValidateInputsEventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ValidateInputsEventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "ValidateInputsEventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ValidateInputsEventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ValidateInputsEventArgs_classType()
    __swig_destroy__ = _core.delete_ValidateInputsEventArgs

    def _get_areInputsValid(self) -> "bool":
        r"""
        Used during the AreInputsValid event to get or set if all inputs are valid
        and the OK button should be enabled.
        """
        return _core.ValidateInputsEventArgs__get_areInputsValid(self)

    def _set_areInputsValid(self, value: "bool") -> "bool":
        r"""
        Used during the AreInputsValid event to get or set if all inputs are valid
        and the OK button should be enabled.
        """
        return _core.ValidateInputsEventArgs__set_areInputsValid(self, value)

    def _get_inputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Returns the collection of command inputs that are associated with the command this event is being fired for."""
        return _core.ValidateInputsEventArgs__get_inputs(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _core.ValidateInputsEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _core.ValidateInputsEventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ValidateInputsEventArgs__get_isValid(self)

# Register ValidateInputsEventArgs in _core:
_core.ValidateInputsEventArgs_swigregister(ValidateInputsEventArgs)

def ValidateInputsEventArgs_classType() -> "char const *":
    return _core.ValidateInputsEventArgs_classType()


ValidateInputsEventArgs.areInputsValid = property(ValidateInputsEventArgs._get_areInputsValid, ValidateInputsEventArgs._set_areInputsValid, doc="Used during the AreInputsValid event to get or set if all inputs are valid\nand the OK button should be enabled.")


ValidateInputsEventArgs.inputs = property(ValidateInputsEventArgs._get_inputs, doc="Returns the collection of command inputs that are associated with the command this event is being fired for.")


ValidateInputsEventArgs.cast = lambda arg: arg if isinstance(arg, ValidateInputsEventArgs) else None

class ValueCommandInput(CommandInput):
    r"""Provides a command input to get a unit based value from the user."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::ValueCommandInput *":
        return _core.ValueCommandInput___deref__(self)

    def __eq__(self, rhs: "ValueCommandInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.ValueCommandInput___eq__(self, rhs)


    def __ne__(self, rhs: "ValueCommandInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.ValueCommandInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.ValueCommandInput_classType()
    __swig_destroy__ = _core.delete_ValueCommandInput

    def _get_value(self) -> "double":
        r"""
        Gets or sets the value associated with this input. The value is always in
        the database units of the unit type specified. For example, if the unit type is 'inch'
        this value is in centimeters since centimeters are the database length unit. When setting the
        value it is converted into a string using the unit type and displayed in the input box.
        When getting the value, the current expression string is evaluated and the database value
        for the unit type is returned.
        The isValidExpression property should be checked before using this
        value within the command because if the expression can't be evaluated
        there isn't a valid value. Fusion 360 won't allow the execution of a command
        that contains ValueCommandInput object with invalid expressions so you can
        dependably use the value in the execute event of the command.
        """
        return _core.ValueCommandInput__get_value(self)

    def _set_value(self, value: "double") -> "bool":
        r"""
        Gets or sets the value associated with this input. The value is always in
        the database units of the unit type specified. For example, if the unit type is 'inch'
        this value is in centimeters since centimeters are the database length unit. When setting the
        value it is converted into a string using the unit type and displayed in the input box.
        When getting the value, the current expression string is evaluated and the database value
        for the unit type is returned.
        The isValidExpression property should be checked before using this
        value within the command because if the expression can't be evaluated
        there isn't a valid value. Fusion 360 won't allow the execution of a command
        that contains ValueCommandInput object with invalid expressions so you can
        dependably use the value in the execute event of the command.
        """
        return _core.ValueCommandInput__set_value(self, value)

    def _get_expression(self) -> "std::string":
        r"""
        Gets or sets the expression displayed in the input field. This can contain equations and
        references to parameters. It is evaluated using the specified unit type.
        """
        return _core.ValueCommandInput__get_expression(self)

    def _set_expression(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the expression displayed in the input field. This can contain equations and
        references to parameters. It is evaluated using the specified unit type.
        """
        return _core.ValueCommandInput__set_expression(self, value)

    def _get_unitType(self) -> "std::string":
        r"""Gets and sets the unit type that is used when evaluating the user's input."""
        return _core.ValueCommandInput__get_unitType(self)

    def _set_unitType(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the unit type that is used when evaluating the user's input."""
        return _core.ValueCommandInput__set_unitType(self, value)

    def _get_isValidExpression(self) -> "bool":
        r"""
        Returns true if the current expression is valid and can be evaluated. If this
        is false, the value returned should be ignored because there currently is
        not a valid value.
        """
        return _core.ValueCommandInput__get_isValidExpression(self)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.ValueCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string":
        r"""Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.ValueCommandInput__get_id(self)

    def _get_name(self) -> "std::string":
        r"""Gets the user visible name of this input."""
        return _core.ValueCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.ValueCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.ValueCommandInput__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.ValueCommandInput__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.ValueCommandInput__set_isVisible(self, value)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the parent Command."""
        return _core.ValueCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.ValueCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.ValueCommandInput__set_isFullWidth(self, value)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.ValueCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.ValueCommandInput__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.ValueCommandInput__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.ValueCommandInput__set_tooltip(self, value)

    def _get_tooltipDescription(self) -> "std::string":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.ValueCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.ValueCommandInput__set_tooltipDescription(self, value)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.ValueCommandInput__get_parentCommandInput(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this Command input. 
        Returns true if the delete was successful.
        """
        return _core.ValueCommandInput_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.ValueCommandInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.ValueCommandInput__get_isValid(self)

# Register ValueCommandInput in _core:
_core.ValueCommandInput_swigregister(ValueCommandInput)

def ValueCommandInput_classType() -> "char const *":
    return _core.ValueCommandInput_classType()


ValueCommandInput.value = property(ValueCommandInput._get_value, ValueCommandInput._set_value, doc="Gets or sets the value associated with this input. The value is always in\nthe database units of the unit type specified. For example, if the unit type is 'inch'\nthis value is in centimeters since centimeters are the database length unit. When setting the\nvalue it is converted into a string using the unit type and displayed in the input box.\nWhen getting the value, the current expression string is evaluated and the database value\nfor the unit type is returned.\nThe isValidExpression property should be checked before using this\nvalue within the command because if the expression can't be evaluated\nthere isn't a valid value. Fusion 360 won't allow the execution of a command\nthat contains ValueCommandInput object with invalid expressions so you can\ndependably use the value in the execute event of the command.")


ValueCommandInput.expression = property(ValueCommandInput._get_expression, ValueCommandInput._set_expression, doc="Gets or sets the expression displayed in the input field. This can contain equations and\nreferences to parameters. It is evaluated using the specified unit type.")


ValueCommandInput.unitType = property(ValueCommandInput._get_unitType, ValueCommandInput._set_unitType, doc="Gets and sets the unit type that is used when evaluating the user's input.")


ValueCommandInput.isValidExpression = property(ValueCommandInput._get_isValidExpression, doc="Returns true if the current expression is valid and can be evaluated. If this\nis false, the value returned should be ignored because there currently is\nnot a valid value.")


ValueCommandInput.cast = lambda arg: arg if isinstance(arg, ValueCommandInput) else None

class WebRequestEvent(Event):
    r"""
    A WebRequestEvent represents an event that occurs in reaction to a Fusion 360 protocol handler
    in a web page. For example, insertedFromURL and openedFromURL
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::WebRequestEvent *":
        return _core.WebRequestEvent___deref__(self)

    def __eq__(self, rhs: "WebRequestEvent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.WebRequestEvent___eq__(self, rhs)


    def __ne__(self, rhs: "WebRequestEvent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.WebRequestEvent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.WebRequestEvent_classType()
    __swig_destroy__ = _core.delete_WebRequestEvent

    def add(self, handler: "WebRequestEventHandler") -> "bool":
        r"""
        Add a handler to be notified when the event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _core.WebRequestEvent_add(self, handler)

    def remove(self, handler: "WebRequestEventHandler") -> "bool":
        r"""
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _core.WebRequestEvent_remove(self, handler)

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _core.WebRequestEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.WebRequestEvent__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _core.WebRequestEvent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.WebRequestEvent__get_isValid(self)

# Register WebRequestEvent in _core:
_core.WebRequestEvent_swigregister(WebRequestEvent)

def WebRequestEvent_classType() -> "char const *":
    return _core.WebRequestEvent_classType()


WebRequestEvent.cast = lambda arg: arg if isinstance(arg, WebRequestEvent) else None

class WebRequestEventArgs(EventArgs):
    r"""
    The WebRequestEventArgs provides information associated with a web request event. These
    are events fired as a result of a Fusion 360 protocol handler being invoked from a web page.
    Note that some properties are not available on every event.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::WebRequestEventArgs *":
        return _core.WebRequestEventArgs___deref__(self)

    def __eq__(self, rhs: "WebRequestEventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.WebRequestEventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "WebRequestEventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.WebRequestEventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.WebRequestEventArgs_classType()
    __swig_destroy__ = _core.delete_WebRequestEventArgs

    def _get_isCanceled(self) -> "bool":
        r"""
        Used during the insertingFromURL and openingFromURL events to get or set 
        if the insert or open should be allowed to continue. This defaults to false,
        which will allow the operation to continue as normal. 
        This property should be ignored for all events besides the insertingFromURL and
        openingFromURL events.
        """
        return _core.WebRequestEventArgs__get_isCanceled(self)

    def _set_isCanceled(self, value: "bool") -> "bool":
        r"""
        Used during the insertingFromURL and openingFromURL events to get or set 
        if the insert or open should be allowed to continue. This defaults to false,
        which will allow the operation to continue as normal. 
        This property should be ignored for all events besides the insertingFromURL and
        openingFromURL events.
        """
        return _core.WebRequestEventArgs__set_isCanceled(self, value)

    def _get_file(self) -> "std::string":
        r"""Returns the value specified as the 'file' parameter in the URL."""
        return _core.WebRequestEventArgs__get_file(self)

    def _get_properties(self) -> "std::string":
        r"""
        Returns the value specified as the 'properties' parameter in the URL. This
        will be decoded and should be in JSON format if it was properly provided
        by the web page. It can be an empty string if the 'properties' parameter was
        not specified in the URL.
        """
        return _core.WebRequestEventArgs__get_properties(self)

    def _get_id(self) -> "std::string":
        r"""
        Returns the value specified as the 'id' parameter in the URL. This
        will be decoded. It can be an empty string if the 'id' parameter was
        not specified in the URL.
        """
        return _core.WebRequestEventArgs__get_id(self)

    def _get_privateInfo(self) -> "std::string":
        r"""
        Returns the value specified as the 'privateInfo' parameter in the URL. This
        will be decoded and can be an empty string if the 'privateInfo' parameter was
        not specified in the URL.
        """
        return _core.WebRequestEventArgs__get_privateInfo(self)

    def _get_occurrenceOrDocument(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Used during the insertedFromURL or openedFromURL events and returns the Document (openedFromURL)
        or Occurrence (insertedFromURL) that was just created.
        """
        return _core.WebRequestEventArgs__get_occurrenceOrDocument(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _core.WebRequestEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _core.WebRequestEventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.WebRequestEventArgs__get_isValid(self)

# Register WebRequestEventArgs in _core:
_core.WebRequestEventArgs_swigregister(WebRequestEventArgs)

def WebRequestEventArgs_classType() -> "char const *":
    return _core.WebRequestEventArgs_classType()


WebRequestEventArgs.isCanceled = property(WebRequestEventArgs._get_isCanceled, WebRequestEventArgs._set_isCanceled, doc="Used during the insertingFromURL and openingFromURL events to get or set\nif the insert or open should be allowed to continue. This defaults to false,\nwhich will allow the operation to continue as normal.\nThis property should be ignored for all events besides the insertingFromURL and\nopeningFromURL events.")


WebRequestEventArgs.file = property(WebRequestEventArgs._get_file, doc="Returns the value specified as the 'file' parameter in the URL.")


WebRequestEventArgs.properties = property(WebRequestEventArgs._get_properties, doc="Returns the value specified as the 'properties' parameter in the URL. This\nwill be decoded and should be in JSON format if it was properly provided\nby the web page. It can be an empty string if the 'properties' parameter was\nnot specified in the URL.")


WebRequestEventArgs.id = property(WebRequestEventArgs._get_id, doc="Returns the value specified as the 'id' parameter in the URL. This\nwill be decoded. It can be an empty string if the 'id' parameter was\nnot specified in the URL.")


WebRequestEventArgs.privateInfo = property(WebRequestEventArgs._get_privateInfo, doc="Returns the value specified as the 'privateInfo' parameter in the URL. This\nwill be decoded and can be an empty string if the 'privateInfo' parameter was\nnot specified in the URL.")


WebRequestEventArgs.occurrenceOrDocument = property(WebRequestEventArgs._get_occurrenceOrDocument, doc="Used during the insertedFromURL or openedFromURL events and returns the Document (openedFromURL)\nor Occurrence (insertedFromURL) that was just created.")


WebRequestEventArgs.cast = lambda arg: arg if isinstance(arg, WebRequestEventArgs) else None

class WorkspaceEvent(Event):
    r"""A WorkspaceEvent represents a workspace related event. For example, workspaceActivate or workspaceDeactivate."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::WorkspaceEvent *":
        return _core.WorkspaceEvent___deref__(self)

    def __eq__(self, rhs: "WorkspaceEvent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.WorkspaceEvent___eq__(self, rhs)


    def __ne__(self, rhs: "WorkspaceEvent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.WorkspaceEvent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.WorkspaceEvent_classType()
    __swig_destroy__ = _core.delete_WorkspaceEvent

    def add(self, handler: "WorkspaceEventHandler") -> "bool":
        r"""
        Add a handler to be notified when the event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _core.WorkspaceEvent_add(self, handler)

    def remove(self, handler: "WorkspaceEventHandler") -> "bool":
        r"""
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _core.WorkspaceEvent_remove(self, handler)

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _core.WorkspaceEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.WorkspaceEvent__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _core.WorkspaceEvent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.WorkspaceEvent__get_isValid(self)

# Register WorkspaceEvent in _core:
_core.WorkspaceEvent_swigregister(WorkspaceEvent)

def WorkspaceEvent_classType() -> "char const *":
    return _core.WorkspaceEvent_classType()


WorkspaceEvent.cast = lambda arg: arg if isinstance(arg, WorkspaceEvent) else None

class WorkspaceEventArgs(EventArgs):
    r"""The WorkspaceEventArgs provides information associated with a workspace event."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::WorkspaceEventArgs *":
        return _core.WorkspaceEventArgs___deref__(self)

    def __eq__(self, rhs: "WorkspaceEventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.WorkspaceEventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "WorkspaceEventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.WorkspaceEventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.WorkspaceEventArgs_classType()
    __swig_destroy__ = _core.delete_WorkspaceEventArgs

    def _get_workspace(self) -> "adsk::core::Ptr< adsk::core::Workspace >":
        r"""Provides access to the workspace."""
        return _core.WorkspaceEventArgs__get_workspace(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _core.WorkspaceEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _core.WorkspaceEventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.WorkspaceEventArgs__get_isValid(self)

# Register WorkspaceEventArgs in _core:
_core.WorkspaceEventArgs_swigregister(WorkspaceEventArgs)

def WorkspaceEventArgs_classType() -> "char const *":
    return _core.WorkspaceEventArgs_classType()


WorkspaceEventArgs.workspace = property(WorkspaceEventArgs._get_workspace, doc="Provides access to the workspace.")


WorkspaceEventArgs.cast = lambda arg: arg if isinstance(arg, WorkspaceEventArgs) else None

class FloatSliderCommandInput(SliderCommandInput):
    r"""Provides a command input to get the value of a slider from the user, the value type is float."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::FloatSliderCommandInput *":
        return _core.FloatSliderCommandInput___deref__(self)

    def __eq__(self, rhs: "FloatSliderCommandInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.FloatSliderCommandInput___eq__(self, rhs)


    def __ne__(self, rhs: "FloatSliderCommandInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.FloatSliderCommandInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.FloatSliderCommandInput_classType()
    __swig_destroy__ = _core.delete_FloatSliderCommandInput

    def _get_valueOne(self) -> "double":
        r"""
        Gets or sets the first value associated with this input. The value is always in
        the database units of the unit type specified. For example, if the unit type is 'inch'
        this value is in centimeters since centimeters are the database length unit. When setting the
        value it is converted into a string using the unit type and displayed in the input box.
        """
        return _core.FloatSliderCommandInput__get_valueOne(self)

    def _set_valueOne(self, value: "double") -> "bool":
        r"""
        Gets or sets the first value associated with this input. The value is always in
        the database units of the unit type specified. For example, if the unit type is 'inch'
        this value is in centimeters since centimeters are the database length unit. When setting the
        value it is converted into a string using the unit type and displayed in the input box.
        """
        return _core.FloatSliderCommandInput__set_valueOne(self, value)

    def _get_valueTwo(self) -> "double":
        r"""
        Gets or sets the second value associated with this input. The value is always in
        the database units of the unit type specified. For example, if the unit type is 'inch'
        this value is in centimeters since centimeters are the database length unit. When setting the
        value it is converted into a string using the unit type and displayed in the input box.
        This property is only available when the hasTwoSliders property returns true.
        """
        return _core.FloatSliderCommandInput__get_valueTwo(self)

    def _set_valueTwo(self, value: "double") -> "bool":
        r"""
        Gets or sets the second value associated with this input. The value is always in
        the database units of the unit type specified. For example, if the unit type is 'inch'
        this value is in centimeters since centimeters are the database length unit. When setting the
        value it is converted into a string using the unit type and displayed in the input box.
        This property is only available when the hasTwoSliders property returns true.
        """
        return _core.FloatSliderCommandInput__set_valueTwo(self, value)

    def _get_minimumValue(self) -> "double":
        r"""
        Gets and sets minimum value of the slider in database units. 
        Gets a failure when set if the value of this command input was added by value list.
        """
        return _core.FloatSliderCommandInput__get_minimumValue(self)

    def _set_minimumValue(self, value: "double") -> "bool":
        r"""
        Gets and sets minimum value of the slider in database units. 
        Gets a failure when set if the value of this command input was added by value list.
        """
        return _core.FloatSliderCommandInput__set_minimumValue(self, value)

    def _get_maximumValue(self) -> "double":
        r"""
        Gets and sets maximum value of the slider in database units. 
        Gets a failure when set if the value of this command input was added by value list.
        """
        return _core.FloatSliderCommandInput__get_maximumValue(self)

    def _set_maximumValue(self, value: "double") -> "bool":
        r"""
        Gets and sets maximum value of the slider in database units. 
        Gets a failure when set if the value of this command input was added by value list.
        """
        return _core.FloatSliderCommandInput__set_maximumValue(self, value)

    def _get_valueList(self) -> "std::vector< double,std::allocator< double > >":
        r"""
        Gets the value list of the slider. This property is valid when this input represents a list type of slider command input.
        Otherwise an empty list will be returned.
        """
        return _core.FloatSliderCommandInput__get_valueList(self)

    def _get_spinStep(self) -> "double":
        r"""
        Gets and sets the spin step value in the unit type set by the unitType argument. 
        The value should be more than zero. This is the amount the slider will advance
        when the user clicks the spin button beside the value.
        """
        return _core.FloatSliderCommandInput__get_spinStep(self)

    def _set_spinStep(self, value: "double") -> "bool":
        r"""
        Gets and sets the spin step value in the unit type set by the unitType argument. 
        The value should be more than zero. This is the amount the slider will advance
        when the user clicks the spin button beside the value.
        """
        return _core.FloatSliderCommandInput__set_spinStep(self, value)

    def _get_expressionOne(self) -> "std::string":
        r"""
        Uses an expression to set the value in the first input field. This can contain equations and
        is evaluated using the specified unit type.
        """
        return _core.FloatSliderCommandInput__get_expressionOne(self)

    def _set_expressionOne(self, value: "std::string const &") -> "bool":
        r"""
        Uses an expression to set the value in the first input field. This can contain equations and
        is evaluated using the specified unit type.
        """
        return _core.FloatSliderCommandInput__set_expressionOne(self, value)

    def _get_expressionTwo(self) -> "std::string":
        r"""
        Uses an expression to set the value in the second input field. This can contain equations and
        is evaluated using the specified unit type.
        This property is only available when the hasTwoSliders property returns true.
        """
        return _core.FloatSliderCommandInput__get_expressionTwo(self)

    def _set_expressionTwo(self, value: "std::string const &") -> "bool":
        r"""
        Uses an expression to set the value in the second input field. This can contain equations and
        is evaluated using the specified unit type.
        This property is only available when the hasTwoSliders property returns true.
        """
        return _core.FloatSliderCommandInput__set_expressionTwo(self, value)

    def _get_unitType(self) -> "std::string":
        r"""Gets and sets the unit type that is used when evaluating the user's input."""
        return _core.FloatSliderCommandInput__get_unitType(self)

    def _set_unitType(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the unit type that is used when evaluating the user's input."""
        return _core.FloatSliderCommandInput__set_unitType(self, value)

    def _get_hasTwoSliders(self) -> "bool":
        r"""Gets if the command input has two sliders."""
        return _core.FloatSliderCommandInput__get_hasTwoSliders(self)

    def setText(self, left: "std::string const &", right: "std::string const &") -> "bool":
        r"""
        Sets the text of the slider. Both the left and the right text should be set. 
        left : Indicates the text on the left side of the slider. 
        right : Indicates the text on the right side of the slider. 
        Returns true if successful.
        """
        return _core.FloatSliderCommandInput_setText(self, left, right)

    def getText(self, isLeft: "bool") -> "std::string":
        r"""
        Gets the texts of the slider if text has been defined. 
        isLeft : Indicates to get the left or right text. 
        Returns the left or right text of the slider.
        """
        return _core.FloatSliderCommandInput_getText(self, isLeft)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.FloatSliderCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string":
        r"""Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.FloatSliderCommandInput__get_id(self)

    def _get_name(self) -> "std::string":
        r"""Gets the user visible name of this input."""
        return _core.FloatSliderCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.FloatSliderCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.FloatSliderCommandInput__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.FloatSliderCommandInput__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.FloatSliderCommandInput__set_isVisible(self, value)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the parent Command."""
        return _core.FloatSliderCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.FloatSliderCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.FloatSliderCommandInput__set_isFullWidth(self, value)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.FloatSliderCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.FloatSliderCommandInput__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.FloatSliderCommandInput__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.FloatSliderCommandInput__set_tooltip(self, value)

    def _get_tooltipDescription(self) -> "std::string":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.FloatSliderCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.FloatSliderCommandInput__set_tooltipDescription(self, value)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.FloatSliderCommandInput__get_parentCommandInput(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this Command input. 
        Returns true if the delete was successful.
        """
        return _core.FloatSliderCommandInput_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.FloatSliderCommandInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.FloatSliderCommandInput__get_isValid(self)

# Register FloatSliderCommandInput in _core:
_core.FloatSliderCommandInput_swigregister(FloatSliderCommandInput)

def FloatSliderCommandInput_classType() -> "char const *":
    return _core.FloatSliderCommandInput_classType()


FloatSliderCommandInput.valueOne = property(FloatSliderCommandInput._get_valueOne, FloatSliderCommandInput._set_valueOne, doc="Gets or sets the first value associated with this input. The value is always in\nthe database units of the unit type specified. For example, if the unit type is 'inch'\nthis value is in centimeters since centimeters are the database length unit. When setting the\nvalue it is converted into a string using the unit type and displayed in the input box.")


FloatSliderCommandInput.valueTwo = property(FloatSliderCommandInput._get_valueTwo, FloatSliderCommandInput._set_valueTwo, doc="Gets or sets the second value associated with this input. The value is always in\nthe database units of the unit type specified. For example, if the unit type is 'inch'\nthis value is in centimeters since centimeters are the database length unit. When setting the\nvalue it is converted into a string using the unit type and displayed in the input box.\nThis property is only available when the hasTwoSliders property returns true.")


FloatSliderCommandInput.minimumValue = property(FloatSliderCommandInput._get_minimumValue, FloatSliderCommandInput._set_minimumValue, doc="Gets and sets minimum value of the slider in database units.\nGets a failure when set if the value of this command input was added by value list.")


FloatSliderCommandInput.maximumValue = property(FloatSliderCommandInput._get_maximumValue, FloatSliderCommandInput._set_maximumValue, doc="Gets and sets maximum value of the slider in database units.\nGets a failure when set if the value of this command input was added by value list.")


FloatSliderCommandInput.valueList = property(FloatSliderCommandInput._get_valueList, doc="Gets the value list of the slider. This property is valid when this input represents a list type of slider command input.\nOtherwise an empty list will be returned.")


FloatSliderCommandInput.spinStep = property(FloatSliderCommandInput._get_spinStep, FloatSliderCommandInput._set_spinStep, doc="Gets and sets the spin step value in the unit type set by the unitType argument.\nThe value should be more than zero. This is the amount the slider will advance\nwhen the user clicks the spin button beside the value.")


FloatSliderCommandInput.cast = lambda arg: arg if isinstance(arg, FloatSliderCommandInput) else None

class IntegerSliderCommandInput(SliderCommandInput):
    r"""Provides a command input to get the value of a slider from the user, the value type is integer."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::IntegerSliderCommandInput *":
        return _core.IntegerSliderCommandInput___deref__(self)

    def __eq__(self, rhs: "IntegerSliderCommandInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _core.IntegerSliderCommandInput___eq__(self, rhs)


    def __ne__(self, rhs: "IntegerSliderCommandInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _core.IntegerSliderCommandInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _core.IntegerSliderCommandInput_classType()
    __swig_destroy__ = _core.delete_IntegerSliderCommandInput

    def _get_valueOne(self) -> "int":
        r"""Gets or sets the value associated with the first slider."""
        return _core.IntegerSliderCommandInput__get_valueOne(self)

    def _set_valueOne(self, value: "int") -> "bool":
        r"""Gets or sets the value associated with the first slider."""
        return _core.IntegerSliderCommandInput__set_valueOne(self, value)

    def _get_valueTwo(self) -> "int":
        r"""
        If the hasTwoSliders property is true, this returns the value associated with 
        the second slider.
        """
        return _core.IntegerSliderCommandInput__get_valueTwo(self)

    def _set_valueTwo(self, value: "int") -> "bool":
        r"""
        If the hasTwoSliders property is true, this returns the value associated with 
        the second slider.
        """
        return _core.IntegerSliderCommandInput__set_valueTwo(self, value)

    def _get_minimumValue(self) -> "int":
        r"""
        Gets and sets minimum value of the slider. This will fail if there is a value list because the
        minimum and maximum values are defined by the value list.
        """
        return _core.IntegerSliderCommandInput__get_minimumValue(self)

    def _set_minimumValue(self, value: "int") -> "bool":
        r"""
        Gets and sets minimum value of the slider. This will fail if there is a value list because the
        minimum and maximum values are defined by the value list.
        """
        return _core.IntegerSliderCommandInput__set_minimumValue(self, value)

    def _get_maximumValue(self) -> "int":
        r"""
        Gets and sets maximum value of the slider. This will fail if there is a value list because the
        minimum and maximum values are defined by the value list.
        """
        return _core.IntegerSliderCommandInput__get_maximumValue(self)

    def _set_maximumValue(self, value: "int") -> "bool":
        r"""
        Gets and sets maximum value of the slider. This will fail if there is a value list because the
        minimum and maximum values are defined by the value list.
        """
        return _core.IntegerSliderCommandInput__set_maximumValue(self, value)

    def _get_valueList(self) -> "std::vector< int,std::allocator< int > >":
        r"""Gets the value list of the slider. The list is empty if this command input was not added by value list."""
        return _core.IntegerSliderCommandInput__get_valueList(self)

    def _get_spinStep(self) -> "size_t":
        r"""
        Gets and sets the spin step. This defines the amount the slider moves when the user clicks the spin
        button beside the value. The spin step should be more than zero.
        """
        return _core.IntegerSliderCommandInput__get_spinStep(self)

    def _set_spinStep(self, value: "size_t") -> "bool":
        r"""
        Gets and sets the spin step. This defines the amount the slider moves when the user clicks the spin
        button beside the value. The spin step should be more than zero.
        """
        return _core.IntegerSliderCommandInput__set_spinStep(self, value)

    def _get_expressionOne(self) -> "std::string":
        r"""
        Uses an expression to set the value in the first input field. This can contain equations and
        is evaluated using the specified unit type.
        """
        return _core.IntegerSliderCommandInput__get_expressionOne(self)

    def _set_expressionOne(self, value: "std::string const &") -> "bool":
        r"""
        Uses an expression to set the value in the first input field. This can contain equations and
        is evaluated using the specified unit type.
        """
        return _core.IntegerSliderCommandInput__set_expressionOne(self, value)

    def _get_expressionTwo(self) -> "std::string":
        r"""
        Uses an expression to set the value in the second input field. This can contain equations and
        is evaluated using the specified unit type.
        This property is only available when the hasTwoSliders property returns true.
        """
        return _core.IntegerSliderCommandInput__get_expressionTwo(self)

    def _set_expressionTwo(self, value: "std::string const &") -> "bool":
        r"""
        Uses an expression to set the value in the second input field. This can contain equations and
        is evaluated using the specified unit type.
        This property is only available when the hasTwoSliders property returns true.
        """
        return _core.IntegerSliderCommandInput__set_expressionTwo(self, value)

    def _get_unitType(self) -> "std::string":
        r"""Gets and sets the unit type that is used when evaluating the user's input."""
        return _core.IntegerSliderCommandInput__get_unitType(self)

    def _set_unitType(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the unit type that is used when evaluating the user's input."""
        return _core.IntegerSliderCommandInput__set_unitType(self, value)

    def _get_hasTwoSliders(self) -> "bool":
        r"""Gets if the command input has two sliders."""
        return _core.IntegerSliderCommandInput__get_hasTwoSliders(self)

    def setText(self, left: "std::string const &", right: "std::string const &") -> "bool":
        r"""
        Sets the text of the slider. Both the left and the right text should be set. 
        left : Indicates the text on the left side of the slider. 
        right : Indicates the text on the right side of the slider. 
        Returns true if successful.
        """
        return _core.IntegerSliderCommandInput_setText(self, left, right)

    def getText(self, isLeft: "bool") -> "std::string":
        r"""
        Gets the texts of the slider if text has been defined. 
        isLeft : Indicates to get the left or right text. 
        Returns the left or right text of the slider.
        """
        return _core.IntegerSliderCommandInput_getText(self, isLeft)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >":
        r"""Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.IntegerSliderCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string":
        r"""Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.IntegerSliderCommandInput__get_id(self)

    def _get_name(self) -> "std::string":
        r"""Gets the user visible name of this input."""
        return _core.IntegerSliderCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.IntegerSliderCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, value: "bool") -> "bool":
        r"""Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.IntegerSliderCommandInput__set_isEnabled(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.IntegerSliderCommandInput__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""Gets or sets if this input will be visible to the user."""
        return _core.IntegerSliderCommandInput__set_isVisible(self, value)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >":
        r"""Gets the parent Command."""
        return _core.IntegerSliderCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.IntegerSliderCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, value: "bool") -> "bool":
        r"""
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.IntegerSliderCommandInput__set_isFullWidth(self, value)

    def _get_toolClipFilename(self) -> "std::string":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.IntegerSliderCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.IntegerSliderCommandInput__set_toolClipFilename(self, value)

    def _get_tooltip(self) -> "std::string":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.IntegerSliderCommandInput__get_tooltip(self)

    def _set_tooltip(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.IntegerSliderCommandInput__set_tooltip(self, value)

    def _get_tooltipDescription(self) -> "std::string":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.IntegerSliderCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, value: "std::string const &") -> "bool":
        r"""
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.IntegerSliderCommandInput__set_tooltipDescription(self, value)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >":
        r"""
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.IntegerSliderCommandInput__get_parentCommandInput(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this Command input. 
        Returns true if the delete was successful.
        """
        return _core.IntegerSliderCommandInput_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _core.IntegerSliderCommandInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _core.IntegerSliderCommandInput__get_isValid(self)

# Register IntegerSliderCommandInput in _core:
_core.IntegerSliderCommandInput_swigregister(IntegerSliderCommandInput)

def IntegerSliderCommandInput_classType() -> "char const *":
    return _core.IntegerSliderCommandInput_classType()


IntegerSliderCommandInput.valueOne = property(IntegerSliderCommandInput._get_valueOne, IntegerSliderCommandInput._set_valueOne, doc="Gets or sets the value associated with the first slider.")


IntegerSliderCommandInput.valueTwo = property(IntegerSliderCommandInput._get_valueTwo, IntegerSliderCommandInput._set_valueTwo, doc="If the hasTwoSliders property is true, this returns the value associated with\nthe second slider.")


IntegerSliderCommandInput.minimumValue = property(IntegerSliderCommandInput._get_minimumValue, IntegerSliderCommandInput._set_minimumValue, doc="Gets and sets minimum value of the slider. This will fail if there is a value list because the\nminimum and maximum values are defined by the value list.")


IntegerSliderCommandInput.maximumValue = property(IntegerSliderCommandInput._get_maximumValue, IntegerSliderCommandInput._set_maximumValue, doc="Gets and sets maximum value of the slider. This will fail if there is a value list because the\nminimum and maximum values are defined by the value list.")


IntegerSliderCommandInput.valueList = property(IntegerSliderCommandInput._get_valueList, doc="Gets the value list of the slider. The list is empty if this command input was not added by value list.")


IntegerSliderCommandInput.spinStep = property(IntegerSliderCommandInput._get_spinStep, IntegerSliderCommandInput._set_spinStep, doc="Gets and sets the spin step. This defines the amount the slider moves when the user clicks the spin\nbutton beside the value. The spin step should be more than zero.")


IntegerSliderCommandInput.cast = lambda arg: arg if isinstance(arg, IntegerSliderCommandInput) else None



