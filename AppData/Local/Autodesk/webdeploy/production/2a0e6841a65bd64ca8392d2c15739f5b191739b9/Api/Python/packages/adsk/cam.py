# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _cam
else:
    import _cam

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _cam.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _cam.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _cam.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _cam.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _cam.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _cam.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _cam.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _cam.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _cam.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _cam.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _cam.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _cam.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _cam.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _cam.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _cam.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _cam.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _cam.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _cam:
_cam.SwigPyIterator_swigregister(SwigPyIterator)

class Base(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Base *":
        return _cam.Base___deref__(self)

    def __eq__(self, rhs: "Application") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.Base___eq__(self, rhs)


    def __ne__(self, rhs: "Base") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.Base___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.Base_classType()
    __swig_destroy__ = _cam.delete_Base

    def _get_objectType(self) -> "char const *":
        return _cam.Base__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.Base__get_isValid(self)

# Register Base in _cam:
_cam.Base_swigregister(Base)

def Base_classType() -> "char const *":
    return _cam.Base_classType()


Base.objectType = property(Base._get_objectType, doc="Returns a string indicating the type of the object.")
Base.isValid = property(Base._get_isValid, doc="Indicates if this object is still valid, i.e. hasn't been deleted or some other action done to invalidate the reference.")

import adsk.core
class SetupSheetFormats(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    HTMLFormat = _cam.SetupSheetFormats_HTMLFormat
    ExcelFormat = _cam.SetupSheetFormats_ExcelFormat

    def __init__(self):
        _cam.SetupSheetFormats_swiginit(self, _cam.new_SetupSheetFormats())
    __swig_destroy__ = _cam.delete_SetupSheetFormats

# Register SetupSheetFormats in _cam:
_cam.SetupSheetFormats_swigregister(SetupSheetFormats)

class OperationTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    MillingOperation = _cam.OperationTypes_MillingOperation
    TurningOperation = _cam.OperationTypes_TurningOperation
    JetOperation = _cam.OperationTypes_JetOperation
    AdditiveOperation = _cam.OperationTypes_AdditiveOperation

    def __init__(self):
        _cam.OperationTypes_swiginit(self, _cam.new_OperationTypes())
    __swig_destroy__ = _cam.delete_OperationTypes

# Register OperationTypes in _cam:
_cam.OperationTypes_swigregister(OperationTypes)

class LibraryLocation(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Local = _cam.LibraryLocation_Local
    Cloud = _cam.LibraryLocation_Cloud
    Network = _cam.LibraryLocation_Network
    OnlineSamples = _cam.LibraryLocation_OnlineSamples
    External = _cam.LibraryLocation_External

    def __init__(self):
        _cam.LibraryLocation_swiginit(self, _cam.new_LibraryLocation())
    __swig_destroy__ = _cam.delete_LibraryLocation

# Register LibraryLocation in _cam:
_cam.LibraryLocation_swigregister(LibraryLocation)

class PostOutputUnitOptions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DocumentUnitsOutput = _cam.PostOutputUnitOptions_DocumentUnitsOutput
    InchesOutput = _cam.PostOutputUnitOptions_InchesOutput
    MillimetersOutput = _cam.PostOutputUnitOptions_MillimetersOutput

    def __init__(self):
        _cam.PostOutputUnitOptions_swiginit(self, _cam.new_PostOutputUnitOptions())
    __swig_destroy__ = _cam.delete_PostOutputUnitOptions

# Register PostOutputUnitOptions in _cam:
_cam.PostOutputUnitOptions_swigregister(PostOutputUnitOptions)

class SetupChangeEventType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Arbitrary = _cam.SetupChangeEventType_Arbitrary
    PrintSettingSelection = _cam.SetupChangeEventType_PrintSettingSelection

    def __init__(self):
        _cam.SetupChangeEventType_swiginit(self, _cam.new_SetupChangeEventType())
    __swig_destroy__ = _cam.delete_SetupChangeEventType

# Register SetupChangeEventType in _cam:
_cam.SetupChangeEventType_swigregister(SetupChangeEventType)

class MachineTemplate(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    GenericLathe = _cam.MachineTemplate_GenericLathe
    Generic3Axis = _cam.MachineTemplate_Generic3Axis
    Generic4Axis = _cam.MachineTemplate_Generic4Axis
    Generic5AxisHeadHead = _cam.MachineTemplate_Generic5AxisHeadHead
    Generic5AxisHeadTable = _cam.MachineTemplate_Generic5AxisHeadTable
    Generic5AxisTableTable = _cam.MachineTemplate_Generic5AxisTableTable

    def __init__(self):
        _cam.MachineTemplate_swiginit(self, _cam.new_MachineTemplate())
    __swig_destroy__ = _cam.delete_MachineTemplate

# Register MachineTemplate in _cam:
_cam.MachineTemplate_swigregister(MachineTemplate)

class MachinePartTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BasicMachinePartType = _cam.MachinePartTypes_BasicMachinePartType
    AxisMachinePartType = _cam.MachinePartTypes_AxisMachinePartType
    ToolAttachmentMachinePartType = _cam.MachinePartTypes_ToolAttachmentMachinePartType
    FixtureAttachmentMachinePartType = _cam.MachinePartTypes_FixtureAttachmentMachinePartType

    def __init__(self):
        _cam.MachinePartTypes_swiginit(self, _cam.new_MachinePartTypes())
    __swig_destroy__ = _cam.delete_MachinePartTypes

# Register MachinePartTypes in _cam:
_cam.MachinePartTypes_swigregister(MachinePartTypes)

class MachineAxisTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    LinearMachineAxisType = _cam.MachineAxisTypes_LinearMachineAxisType
    RotaryMachineAxisType = _cam.MachineAxisTypes_RotaryMachineAxisType

    def __init__(self):
        _cam.MachineAxisTypes_swiginit(self, _cam.new_MachineAxisTypes())
    __swig_destroy__ = _cam.delete_MachineAxisTypes

# Register MachineAxisTypes in _cam:
_cam.MachineAxisTypes_swigregister(MachineAxisTypes)

class OperationStrategyTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    AdaptiveClearing2D = _cam.OperationStrategyTypes_AdaptiveClearing2D
    Pocket2D = _cam.OperationStrategyTypes_Pocket2D
    Face = _cam.OperationStrategyTypes_Face
    Contour2D = _cam.OperationStrategyTypes_Contour2D
    Slot = _cam.OperationStrategyTypes_Slot
    Trace = _cam.OperationStrategyTypes_Trace
    Thread = _cam.OperationStrategyTypes_Thread
    Bore = _cam.OperationStrategyTypes_Bore
    Circular = _cam.OperationStrategyTypes_Circular
    Engrave = _cam.OperationStrategyTypes_Engrave
    AdaptiveClearing = _cam.OperationStrategyTypes_AdaptiveClearing
    PocketClearing = _cam.OperationStrategyTypes_PocketClearing
    Parallel = _cam.OperationStrategyTypes_Parallel
    Contour = _cam.OperationStrategyTypes_Contour
    Ramp = _cam.OperationStrategyTypes_Ramp
    Horizontal = _cam.OperationStrategyTypes_Horizontal
    Pencil = _cam.OperationStrategyTypes_Pencil
    Scallop = _cam.OperationStrategyTypes_Scallop
    Spiral = _cam.OperationStrategyTypes_Spiral
    Radial = _cam.OperationStrategyTypes_Radial
    MorphedSpiral = _cam.OperationStrategyTypes_MorphedSpiral
    Projection = _cam.OperationStrategyTypes_Projection
    Drilling = _cam.OperationStrategyTypes_Drilling
    Jet2D = _cam.OperationStrategyTypes_Jet2D
    TurningChamfer = _cam.OperationStrategyTypes_TurningChamfer
    TurningFace = _cam.OperationStrategyTypes_TurningFace
    TurningGroove = _cam.OperationStrategyTypes_TurningGroove
    TurningPart = _cam.OperationStrategyTypes_TurningPart
    TurningProfile = _cam.OperationStrategyTypes_TurningProfile
    TurningProfileGroove = _cam.OperationStrategyTypes_TurningProfileGroove
    TurningStockTransfer = _cam.OperationStrategyTypes_TurningStockTransfer
    TurningThread = _cam.OperationStrategyTypes_TurningThread
    SteepAndShallow = _cam.OperationStrategyTypes_SteepAndShallow
    Flow = _cam.OperationStrategyTypes_Flow
    RotaryFinishing = _cam.OperationStrategyTypes_RotaryFinishing
    Chamfer2D = _cam.OperationStrategyTypes_Chamfer2D
    Morph = _cam.OperationStrategyTypes_Morph
    MultiAxisContour = _cam.OperationStrategyTypes_MultiAxisContour
    MultiAxisMorph = _cam.OperationStrategyTypes_MultiAxisMorph
    RestFinishing = _cam.OperationStrategyTypes_RestFinishing
    Swarf = _cam.OperationStrategyTypes_Swarf

    def __init__(self):
        _cam.OperationStrategyTypes_swiginit(self, _cam.new_OperationStrategyTypes())
    __swig_destroy__ = _cam.delete_OperationStrategyTypes

# Register OperationStrategyTypes in _cam:
_cam.OperationStrategyTypes_swigregister(OperationStrategyTypes)

class OperationStates(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    IsValidOperationState = _cam.OperationStates_IsValidOperationState
    IsInvalidOperationState = _cam.OperationStates_IsInvalidOperationState
    SuppressedOperationState = _cam.OperationStates_SuppressedOperationState
    NoToolpathOperationState = _cam.OperationStates_NoToolpathOperationState

    def __init__(self):
        _cam.OperationStates_swiginit(self, _cam.new_OperationStates())
    __swig_destroy__ = _cam.delete_OperationStates

# Register OperationStates in _cam:
_cam.OperationStates_swigregister(OperationStates)

class CAM(adsk.core.Product):
    r"""Object that represents the CAM environment of a Fusion document."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::CAM *":
        return _cam.CAM___deref__(self)

    def __eq__(self, rhs: "CAM") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.CAM___eq__(self, rhs)


    def __ne__(self, rhs: "CAM") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.CAM___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.CAM_classType()
    __swig_destroy__ = _cam.delete_CAM

    def _get_setups(self) -> "adsk::core::Ptr< adsk::cam::Setups >":
        r"""Returns the Setups collection that provides access to existing setups"""
        return _cam.CAM__get_setups(self)

    def export3MFForDefaultAdditiveSetup(self, filepath: "std::string const &", addSimulationInfo: "bool"=False, simPostProcess: "bool"=False, simSplitSurrogates: "bool"=False, simKeepThickeningStructure: "bool"=False) -> "bool":
        r"""
        Exports the default additive setup's models into a 3mf file. The 3mf also contains machine and support information. 
        True on success, false on errors or wrong setup type
        """
        return _cam.CAM_export3MFForDefaultAdditiveSetup(self, filepath, addSimulationInfo, simPostProcess, simSplitSurrogates, simKeepThickeningStructure)

    def generateToolpath(self, operations: "Base") -> "adsk::core::Ptr< adsk::cam::GenerateToolpathFuture >":
        r"""
        Generates/Regenerates all of the toolpaths (including those nested in sub-folders or patterns)
        for the specified objects. 
        operations : An Operation, Setup, Folder or Pattern object for which to generate the toolpath/s for. You can also
        specify a collection of any combination of these object types. 
        Return GenerateToolpathFuture that includes the status of toolpath generation.
        """
        return _cam.CAM_generateToolpath(self, operations)

    def generateAllToolpaths(self, skipValid: "bool") -> "adsk::core::Ptr< adsk::cam::GenerateToolpathFuture >":
        r"""
        Generates/Regenerates all toolpaths (includes those nested in sub-folders or patterns) in the document. 
        skipValid : Option to skip valid toolpaths and only regenerate invalid toolpaths. 
        Return GenerateToolpathFuture that includes the status of toolpath generation.
        """
        return _cam.CAM_generateAllToolpaths(self, skipValid)

    def clearToolpath(self, operations: "Base") -> "bool":
        r"""
        Clears all of the toolpaths (including those nested in sub-folders or patterns) for the specified objects. 
        operations : An Operation, Setup, Folder or Pattern object for which to clear the toolpath/s for. You can also
        specify a collection of any combination of these object types. 
        Return true if successful.
        """
        return _cam.CAM_clearToolpath(self, operations)

    def clearAllToolpaths(self) -> "bool":
        r"""
        Clears all the toolpaths (includes those nested in sub-folders or patterns) in the document 
        Return true if successful.
        """
        return _cam.CAM_clearAllToolpaths(self)

    def checkToolpath(self, operations: "Base") -> "bool":
        r"""
        Checks if toolpath operations (including those nested in sub-folders or patterns) are valid for the specified objects. 
        operations : An Operation, Setup, Folder or Pattern object for which to check the toolpath/s of. You can also
        specify a collection of any combination of these object types. 
        Returns true if the toolpath operations are valid
        """
        return _cam.CAM_checkToolpath(self, operations)

    def checkAllToolpaths(self) -> "bool":
        r"""
        Checks if all the toolpath operations (includes those nested in sub-folders or patterns) in the document are valid 
        Returns true if the all toolpath operations are valid
        """
        return _cam.CAM_checkAllToolpaths(self)

    def postProcess(self, operations: "Base", input: "PostProcessInput") -> "bool":
        r"""
        Post all of the toolpaths (including those nested in sub-folders or patterns) for the specified objects.
        If post processing fails, an error message can be retrieved from the error log explaining the reason for the failure. 
        operations : An Operation, Setup, Folder or Pattern object for which to post the toolpath/s of. You can also
        specify a collection of any combination of these object types. 
        input : The PostProcessInput object that defines the post options and parameters. 
        Returns true if successful
        """
        return _cam.CAM_postProcess(self, operations, input)

    def postProcessAll(self, input: "PostProcessInput") -> "bool":
        r"""
        Post all of the toolpaths (includes those nested in sub-folders or patterns) in the document.
        If post processing fails, an error message can be retrieved from the error log explaining the reason for the failure. 
        input : The PostProcessInput object that defines the post options and parameters. 
        Returns true if successful.
        """
        return _cam.CAM_postProcessAll(self, input)

    def generateSetupSheet(self, operations: "Base", format: "SetupSheetFormats", folder: "std::string const &", openDocument: "bool"=True) -> "bool":
        r"""
        Generate the setup sheets for the specified objects 
        operations : An Operation, Setup, Folder or Pattern object for which to generate the setup sheet/s for. You can also
        specify a collection of any combination of these object types. 
        format : The document format for the setup sheet. Valid options are HTMLFormat and ExcelFormat.
        Limitation: 'ExcelFormat' can be used in windows OS only. 
        folder : The destination folder to locate the setup sheet documents in. 
        openDocument : An option to allow to open the document instantly after the generation. By default, the document is opened. 
        Returns true if successful
        """
        return _cam.CAM_generateSetupSheet(self, operations, format, folder, openDocument)

    def generateAllSetupSheets(self, format: "SetupSheetFormats", folder: "std::string const &", openDocument: "bool"=True) -> "bool":
        r"""
        Generates all of the setup sheets for all of the operations in the document 
        format : The document format for the setup sheet. Valid options are HTMLFormat and ExcelFormat.
        Limitation: 'ExcelFormat' can be used in windows OS only. 
        folder : The destination folder to locate the setup sheet documents in. 
        openDocument : An option to allow to open the document instantly after the generation. By default, the document is opened. 
        Returns true if successful
        """
        return _cam.CAM_generateAllSetupSheets(self, format, folder, openDocument)

    def _get_allOperations(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets a collection containing all of the operations in the document.
        This includes all operations nested in folders and patterns.
        """
        return _cam.CAM__get_allOperations(self)

    def _get_genericPostFolder(self) -> "std::string":
        r"""Gets the installed post folder."""
        return _cam.CAM__get_genericPostFolder(self)

    def _get_personalPostFolder(self) -> "std::string":
        r"""Gets the personal post folder."""
        return _cam.CAM__get_personalPostFolder(self)

    def _get_temporaryFolder(self) -> "std::string":
        r"""Gets the folder for temporary files."""
        return _cam.CAM__get_temporaryFolder(self)

    def getMachiningTime(self, operations: "Base", feedScale: "double", rapidFeed: "double", toolChangeTime: "double") -> "adsk::core::Ptr< adsk::cam::MachiningTime >":
        r"""
        Get the machining time for the specified objects. 
        operations : An Operation, Setup, Folder or Pattern object for which to get the machining time for. You can also
        specify a collection of any combination of these object types. 
        feedScale : The feed scale value (%) to use. 
        rapidFeed : The rapid feed rate in centimeters per second. 
        toolChangeTime : The tool change time in seconds. 
        Returns a MachiningTime object that has properties holding the calculation results.
        """
        return _cam.CAM_getMachiningTime(self, operations, feedScale, rapidFeed, toolChangeTime)

    def _get_customGraphicsGroups(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsGroups >":
        r"""Returns the customGraphicsGroups object associated with the CAM product."""
        return _cam.CAM__get_customGraphicsGroups(self)

    def _get_designRootOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""Returns the occurrence that references the design root component in CAM product."""
        return _cam.CAM__get_designRootOccurrence(self)

    def _get_flatPatternOccurrences(self) -> "adsk::core::Ptr< adsk::fusion::OccurrenceList >":
        r"""Returns a read only list of flat pattern occurrences in CAM product."""
        return _cam.CAM__get_flatPatternOccurrences(self)

    def _get_allMachines(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""Gets a collection containing all of the machines in the document."""
        return _cam.CAM__get_allMachines(self)

    def _get_setupCreated(self) -> "adsk::core::Ptr< adsk::cam::SetupEvent >":
        r"""The SetupCreated event fires when a new setup was created."""
        return _cam.CAM__get_setupCreated(self)

    def _get_setupDestroying(self) -> "adsk::core::Ptr< adsk::cam::SetupEvent >":
        r"""The setupDestroying event fires before a setup will be destroyed."""
        return _cam.CAM__get_setupDestroying(self)

    def _get_setupChanged(self) -> "adsk::core::Ptr< adsk::cam::SetupChangeEvent >":
        r"""The SetupChanged event fires when a setup was modified."""
        return _cam.CAM__get_setupChanged(self)

    def _get_setupActivating(self) -> "adsk::core::Ptr< adsk::cam::SetupEvent >":
        r"""The SetupActivating event fires before a setup will be activated."""
        return _cam.CAM__get_setupActivating(self)

    def _get_setupActivated(self) -> "adsk::core::Ptr< adsk::cam::SetupEvent >":
        r"""The SetupActivated event fires when a setup was activated."""
        return _cam.CAM__get_setupActivated(self)

    def _get_setupDeactivating(self) -> "adsk::core::Ptr< adsk::cam::SetupEvent >":
        r"""The SetupDeactivating event fires before a setup will be deactivated."""
        return _cam.CAM__get_setupDeactivating(self)

    def _get_setupDeactivated(self) -> "adsk::core::Ptr< adsk::cam::SetupEvent >":
        r"""The SetupDeactivated event fires when a setup was deactivated."""
        return _cam.CAM__get_setupDeactivated(self)

    def _get_parentDocument(self) -> "adsk::core::Ptr< adsk::core::Document >":
        r"""Returns the parent Document object."""
        return _cam.CAM__get_parentDocument(self)

    def _get_unitsManager(self) -> "adsk::core::Ptr< adsk::core::UnitsManager >":
        r"""Returns the UnitsManager object associated with this product."""
        return _cam.CAM__get_unitsManager(self)

    def _get_workspaces(self) -> "adsk::core::Ptr< adsk::core::WorkspaceList >":
        r"""Returns the workspaces associated with this product."""
        return _cam.CAM__get_workspaces(self)

    def _get_productType(self) -> "std::string":
        r"""
        Returns the product type name of this product. A list of all of
        the possible product types can be obtained by using the 
        Application.supportedProductTypes property.
        """
        return _cam.CAM__get_productType(self)

    def findAttributes(self, groupName: "std::string const &", attributeName: "std::string const &") -> "std::vector< adsk::core::Ptr< adsk::core::Attribute >,std::allocator< adsk::core::Ptr< adsk::core::Attribute > > >":
        r"""
        Find attributes attached to objects in this product that match the group and or attribute name.
        This does not find attributes attached directly to the Product or Document objects but finds the
        attributes attached to entities within the product.
        The search string for both the groupName and attributeName arguments can be either an absolute 
        name value, or a regular expression. With an absolute name, the search string must match the
        entire groupName or attributeName, including case. An empty string will match everything.
        For example if you have an attribute group named 'MyStuff' that contains the attribute 'Length1', 
        using the search string 'MyStuff' as the group name and 'Length1' as the attribute name will 
        find the attributes with those names. Searching for 'MyStuff' as the group name and '' as the
        attribute name will find all attributes that have 'MyStuff' as the group name.
        Regular expressions provide a more flexible way of searching. To use a regular expression, 
        prefix the input string for the groupName or attributeName arguments with 're:'. The regular
        expression much match the entire group or attribute name. For example if you have a group that
        contains attributes named 'Length1', 'Length2', 'Width1', and 'Width2' and want to find any 
        of the length attributes you can use a regular expression using the string 're:Length.*'. For more
        information on attributes see the Attributes topic in the user manual. 
        groupName : The search string for the group name. See above for more details. 
        attributeName : The search string for the attribute name. See above for more details. 
        An array of Attribute objects that were found. An empty array is returned if no attributes were found.
        """
        return _cam.CAM_findAttributes(self, groupName, attributeName)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this product."""
        return _cam.CAM__get_attributes(self)

    def deleteEntities(self, entities: "ObjectCollection") -> "bool":
        r"""
        Deletes the specified set of entities that are associated with this product. 
        entities : An ObjectCollection containing the list of entities to delete. 
        Returns True if any of the entities provided in the list were deleted. If
        entities were specified that can't be deleted or aren't owned by this product,
        they are ignored.
        """
        return _cam.CAM_deleteEntities(self, entities)

    def _get_objectType(self) -> "char const *":
        return _cam.CAM__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.CAM__get_isValid(self)

# Register CAM in _cam:
_cam.CAM_swigregister(CAM)

def CAM_classType() -> "char const *":
    return _cam.CAM_classType()


CAM.setups = property(CAM._get_setups, doc="Returns the Setups collection that provides access to existing setups")


CAM.allOperations = property(CAM._get_allOperations, doc="Gets a collection containing all of the operations in the document.\nThis includes all operations nested in folders and patterns.")


CAM.genericPostFolder = property(CAM._get_genericPostFolder, doc="Gets the installed post folder.")


CAM.personalPostFolder = property(CAM._get_personalPostFolder, doc="Gets the personal post folder.")


CAM.temporaryFolder = property(CAM._get_temporaryFolder, doc="Gets the folder for temporary files.")


CAM.customGraphicsGroups = property(CAM._get_customGraphicsGroups, doc="Returns the customGraphicsGroups object associated with the CAM product.")


CAM.designRootOccurrence = property(CAM._get_designRootOccurrence, doc="Returns the occurrence that references the design root component in CAM product.")


CAM.flatPatternOccurrences = property(CAM._get_flatPatternOccurrences, doc="Returns a read only list of flat pattern occurrences in CAM product.")


CAM.allMachines = property(CAM._get_allMachines, doc="Gets a collection containing all of the machines in the document.")


CAM.setupCreated = property(CAM._get_setupCreated, doc="The SetupCreated event fires when a new setup was created.")


CAM.setupDestroying = property(CAM._get_setupDestroying, doc="The setupDestroying event fires before a setup will be destroyed.")


CAM.setupChanged = property(CAM._get_setupChanged, doc="The SetupChanged event fires when a setup was modified.")


CAM.setupActivating = property(CAM._get_setupActivating, doc="The SetupActivating event fires before a setup will be activated.")


CAM.setupActivated = property(CAM._get_setupActivated, doc="The SetupActivated event fires when a setup was activated.")


CAM.setupDeactivating = property(CAM._get_setupDeactivating, doc="The SetupDeactivating event fires before a setup will be deactivated.")


CAM.setupDeactivated = property(CAM._get_setupDeactivated, doc="The SetupDeactivated event fires when a setup was deactivated.")


CAM.cast = lambda arg: arg if isinstance(arg, CAM) else None

class CAMFolders(Base):
    r"""Collection that provides access to the folders within an existing setup, folder or pattern."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::CAMFolders *":
        return _cam.CAMFolders___deref__(self)

    def __eq__(self, rhs: "CAMFolders") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.CAMFolders___eq__(self, rhs)


    def __ne__(self, rhs: "CAMFolders") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.CAMFolders___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _cam.CAMFolders___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::cam::CAMFolder >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _cam.CAMFolders___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _cam.CAMFolders_classType()
    __swig_destroy__ = _cam.delete_CAMFolders

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::cam::CAMFolder >":
        r"""
        Function that returns the specified folder using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _cam.CAMFolders_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::cam::CAMFolder >":
        r"""
        Returns the folder with the specified name (as appears in the browser). 
        name : The name (as it appears in the browser) of the folder. 
        Returns the specified folder or null in the case where there is no folder with the specified name.
        """
        return _cam.CAMFolders_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of items in the collection."""
        return _cam.CAMFolders__get_count(self)

    def itemByOperationId(self, id: "int") -> "adsk::core::Ptr< adsk::cam::CAMFolder >":
        r"""
        Returns the folder with the specified operation id. 
        id : The id of the folder. 
        Returns the specified folder or null in the case where there is no folder with the specified operation id.
        """
        return _cam.CAMFolders_itemByOperationId(self, id)

    def _get_objectType(self) -> "char const *":
        return _cam.CAMFolders__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.CAMFolders__get_isValid(self)

# Register CAMFolders in _cam:
_cam.CAMFolders_swigregister(CAMFolders)

def CAMFolders_classType() -> "char const *":
    return _cam.CAMFolders_classType()


CAMFolders.count = property(CAMFolders._get_count, doc="The number of items in the collection.")


CAMFolders.cast = lambda arg: arg if isinstance(arg, CAMFolders) else None

class CAMParameter(Base):
    r"""Base class for representing parameter of an operation."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::CAMParameter *":
        return _cam.CAMParameter___deref__(self)

    def __eq__(self, rhs: "CAMParameter") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.CAMParameter___eq__(self, rhs)


    def __ne__(self, rhs: "CAMParameter") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.CAMParameter___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.CAMParameter_classType()
    __swig_destroy__ = _cam.delete_CAMParameter

    def _get_name(self) -> "std::string":
        r"""Gets the name (internal name) of the parameter."""
        return _cam.CAMParameter__get_name(self)

    def _get_title(self) -> "std::string":
        r"""
        Returns the title of this parameter as seen in the user interface.
        This title is localized and can change based on the current language
        """
        return _cam.CAMParameter__get_title(self)

    def _get_expression(self) -> "std::string":
        r"""Gets and sets the value expression of the parameter."""
        return _cam.CAMParameter__get_expression(self)

    def _set_expression(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the value expression of the parameter."""
        return _cam.CAMParameter__set_expression(self, value)

    def _get_isEnabled(self) -> "bool":
        r"""
        Gets if this parameter is enabled. Some parameters are enabled/disabled depending on the values 
        set for other parameters.
        """
        return _cam.CAMParameter__get_isEnabled(self)

    def _get_error(self) -> "std::string":
        r"""Returns a message corresponding to any active error associated with the value of this parameter."""
        return _cam.CAMParameter__get_error(self)

    def _get_warning(self) -> "std::string":
        r"""Returns a message corresponding to any active warning associated with the value of this parameter."""
        return _cam.CAMParameter__get_warning(self)

    def _get_objectType(self) -> "char const *":
        return _cam.CAMParameter__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.CAMParameter__get_isValid(self)

# Register CAMParameter in _cam:
_cam.CAMParameter_swigregister(CAMParameter)

def CAMParameter_classType() -> "char const *":
    return _cam.CAMParameter_classType()


CAMParameter.name = property(CAMParameter._get_name, doc="Gets the name (internal name) of the parameter.")


CAMParameter.title = property(CAMParameter._get_title, doc="Returns the title of this parameter as seen in the user interface.\nThis title is localized and can change based on the current language")


CAMParameter.expression = property(CAMParameter._get_expression, CAMParameter._set_expression, doc="Gets and sets the value expression of the parameter.")


CAMParameter.isEnabled = property(CAMParameter._get_isEnabled, doc="Gets if this parameter is enabled. Some parameters are enabled/disabled depending on the values\nset for other parameters.")


CAMParameter.error = property(CAMParameter._get_error, doc="Returns a message corresponding to any active error associated with the value of this parameter.")


CAMParameter.warning = property(CAMParameter._get_warning, doc="Returns a message corresponding to any active warning associated with the value of this parameter.")


CAMParameter.cast = lambda arg: arg if isinstance(arg, CAMParameter) else None

class CAMParameters(Base):
    r"""Collection that provides access to the parameters of an existing operation."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::CAMParameters *":
        return _cam.CAMParameters___deref__(self)

    def __eq__(self, rhs: "CAMParameters") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.CAMParameters___eq__(self, rhs)


    def __ne__(self, rhs: "CAMParameters") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.CAMParameters___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _cam.CAMParameters___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::cam::CAMParameter >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _cam.CAMParameters___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _cam.CAMParameters_classType()
    __swig_destroy__ = _cam.delete_CAMParameters

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::cam::CAMParameter >":
        r"""
        Function that returns the specified parameter using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _cam.CAMParameters_item(self, index)

    def itemByName(self, internalName: "std::string const &") -> "adsk::core::Ptr< adsk::cam::CAMParameter >":
        r"""
        Returns the parameter of the specified id (internal name). 
        internalName : The id (internal name) of the parameter. 
        Returns the specified parameter or null in the case where there is no parameter with the specified id.
        """
        return _cam.CAMParameters_itemByName(self, internalName)

    def _get_count(self) -> "size_t":
        r"""The number of items in the collection."""
        return _cam.CAMParameters__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _cam.CAMParameters__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.CAMParameters__get_isValid(self)

# Register CAMParameters in _cam:
_cam.CAMParameters_swigregister(CAMParameters)

def CAMParameters_classType() -> "char const *":
    return _cam.CAMParameters_classType()


CAMParameters.count = property(CAMParameters._get_count, doc="The number of items in the collection.")


CAMParameters.cast = lambda arg: arg if isinstance(arg, CAMParameters) else None

class CAMPatterns(Base):
    r"""Collection that provides access to the patterns within an existing setup, folder or pattern."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::CAMPatterns *":
        return _cam.CAMPatterns___deref__(self)

    def __eq__(self, rhs: "CAMPatterns") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.CAMPatterns___eq__(self, rhs)


    def __ne__(self, rhs: "CAMPatterns") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.CAMPatterns___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _cam.CAMPatterns___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::cam::CAMPattern >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _cam.CAMPatterns___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _cam.CAMPatterns_classType()
    __swig_destroy__ = _cam.delete_CAMPatterns

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::cam::CAMPattern >":
        r"""
        Function that returns the specified pattern using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _cam.CAMPatterns_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::cam::CAMPattern >":
        r"""
        Returns the pattern with the specified name (as appears in the browser). 
        name : The name (as it appears in the browser) of the pattern. 
        Returns the specified pattern or null in the case where there is no pattern with the specified name.
        """
        return _cam.CAMPatterns_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of items in the collection."""
        return _cam.CAMPatterns__get_count(self)

    def itemByOperationId(self, id: "int") -> "adsk::core::Ptr< adsk::cam::CAMPattern >":
        r"""
        Returns the pattern with the specified operation id. 
        id : The id of the pattern. 
        Returns the specified pattern or null in the case where there is no pattern with the specified operation id.
        """
        return _cam.CAMPatterns_itemByOperationId(self, id)

    def _get_objectType(self) -> "char const *":
        return _cam.CAMPatterns__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.CAMPatterns__get_isValid(self)

# Register CAMPatterns in _cam:
_cam.CAMPatterns_swigregister(CAMPatterns)

def CAMPatterns_classType() -> "char const *":
    return _cam.CAMPatterns_classType()


CAMPatterns.count = property(CAMPatterns._get_count, doc="The number of items in the collection.")


CAMPatterns.cast = lambda arg: arg if isinstance(arg, CAMPatterns) else None

class ChildOperationList(Base):
    r"""Provides access to the collection of child operations, folders and patterns of an existing setup."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::ChildOperationList *":
        return _cam.ChildOperationList___deref__(self)

    def __eq__(self, rhs: "ChildOperationList") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.ChildOperationList___eq__(self, rhs)


    def __ne__(self, rhs: "ChildOperationList") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.ChildOperationList___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _cam.ChildOperationList___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::core::Base >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _cam.ChildOperationList___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _cam.ChildOperationList_classType()
    __swig_destroy__ = _cam.delete_ChildOperationList

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the specified item using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _cam.ChildOperationList_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the operation, folder or pattern with the specified name (the name seen in the browser). 
        name : The name of the operation, folder or pattern as seen in the browser. 
        Returns the specified item or null in the case where there is no item with the specified name.
        """
        return _cam.ChildOperationList_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""Gets the number of objects in the collection."""
        return _cam.ChildOperationList__get_count(self)

    def itemByOperationId(self, id: "int") -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the operation, folder or pattern with the specified operation id. 
        id : The id of the operation, folder or pattern. 
        Returns the specified item or null in the case where there is no item with the specified operation id.
        """
        return _cam.ChildOperationList_itemByOperationId(self, id)

    def _get_objectType(self) -> "char const *":
        return _cam.ChildOperationList__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.ChildOperationList__get_isValid(self)

# Register ChildOperationList in _cam:
_cam.ChildOperationList_swigregister(ChildOperationList)

def ChildOperationList_classType() -> "char const *":
    return _cam.ChildOperationList_classType()


ChildOperationList.count = property(ChildOperationList._get_count, doc="Gets the number of objects in the collection.")


ChildOperationList.cast = lambda arg: arg if isinstance(arg, ChildOperationList) else None

class GenerateToolpathFuture(Base):
    r"""Used to check the state and get back the results of toolpath generation."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::GenerateToolpathFuture *":
        return _cam.GenerateToolpathFuture___deref__(self)

    def __eq__(self, rhs: "GenerateToolpathFuture") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.GenerateToolpathFuture___eq__(self, rhs)


    def __ne__(self, rhs: "GenerateToolpathFuture") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.GenerateToolpathFuture___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.GenerateToolpathFuture_classType()
    __swig_destroy__ = _cam.delete_GenerateToolpathFuture

    def _get_numberOfOperations(self) -> "int":
        r"""Returns a number of operations need to be generated."""
        return _cam.GenerateToolpathFuture__get_numberOfOperations(self)

    def _get_numberOfCompleted(self) -> "int":
        r"""Returns a number of operations whose toolpath generation are completed."""
        return _cam.GenerateToolpathFuture__get_numberOfCompleted(self)

    def _get_operations(self) -> "adsk::core::Ptr< adsk::cam::Operations >":
        r"""Returns all operations that need to be generated."""
        return _cam.GenerateToolpathFuture__get_operations(self)

    def _get_isGenerationCompleted(self) -> "bool":
        r"""Returns true if all operations are generated."""
        return _cam.GenerateToolpathFuture__get_isGenerationCompleted(self)

    def _get_objectType(self) -> "char const *":
        return _cam.GenerateToolpathFuture__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.GenerateToolpathFuture__get_isValid(self)

# Register GenerateToolpathFuture in _cam:
_cam.GenerateToolpathFuture_swigregister(GenerateToolpathFuture)

def GenerateToolpathFuture_classType() -> "char const *":
    return _cam.GenerateToolpathFuture_classType()


GenerateToolpathFuture.numberOfOperations = property(GenerateToolpathFuture._get_numberOfOperations, doc="Returns a number of operations need to be generated.")


GenerateToolpathFuture.numberOfCompleted = property(GenerateToolpathFuture._get_numberOfCompleted, doc="Returns a number of operations whose toolpath generation are completed.")


GenerateToolpathFuture.operations = property(GenerateToolpathFuture._get_operations, doc="Returns all operations that need to be generated.")


GenerateToolpathFuture.isGenerationCompleted = property(GenerateToolpathFuture._get_isGenerationCompleted, doc="Returns true if all operations are generated.")


GenerateToolpathFuture.cast = lambda arg: arg if isinstance(arg, GenerateToolpathFuture) else None

class Machine(Base):
    r"""Object that represents a machine."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::Machine *":
        return _cam.Machine___deref__(self)

    def __eq__(self, rhs: "Machine") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.Machine___eq__(self, rhs)


    def __ne__(self, rhs: "Machine") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.Machine___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.Machine_classType()

    @staticmethod
    def createFromTemplate(machineTemplate: "MachineTemplate") -> "adsk::core::Ptr< adsk::cam::Machine >":
        return _cam.Machine_createFromTemplate(machineTemplate)

    @staticmethod
    def createFromFile(location: "LibraryLocation", filePath: "std::string const &") -> "adsk::core::Ptr< adsk::cam::Machine >":
        return _cam.Machine_createFromFile(location, filePath)
    __swig_destroy__ = _cam.delete_Machine

    def _get_vendor(self) -> "std::string":
        r"""Gets and sets the vendor name of the machine."""
        return _cam.Machine__get_vendor(self)

    def _set_vendor(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the vendor name of the machine."""
        return _cam.Machine__set_vendor(self, value)

    def _get_model(self) -> "std::string":
        r"""Gets and sets the model name of the machine."""
        return _cam.Machine__get_model(self)

    def _set_model(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the model name of the machine."""
        return _cam.Machine__set_model(self, value)

    def _get_description(self) -> "std::string":
        r"""Gets and sets the description of the machine."""
        return _cam.Machine__get_description(self)

    def _set_description(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the description of the machine."""
        return _cam.Machine__set_description(self, value)

    def _get_id(self) -> "std::string":
        r"""
        Gets the unique identifier of the machine.
        Can be used for comparing machines within the document.
        """
        return _cam.Machine__get_id(self)

    def _get_capabilities(self) -> "adsk::core::Ptr< adsk::cam::MachineCapabilities >":
        r"""Gets the capabilities of the machine."""
        return _cam.Machine__get_capabilities(self)

    def _get_kinematics(self) -> "adsk::core::Ptr< adsk::cam::MachineKinematics >":
        r"""Gets the kinematics tree of the machine."""
        return _cam.Machine__get_kinematics(self)

    def save(self, location: "LibraryLocation", filePath: "std::string const &") -> "bool":
        r"""
        Save the Machine to a file.
        Any subsequent edits will need to be saved again. 
        location : The location in the machine library to save the machine to. 
        filePath : The path of the file to save the machine as.
        The path is relative to the library location given, unless library location is External,
        then the filePath is expected to be an absolute path.
        .machine will be appended if no extension is given. 
        Returns true if the machine was saved successfully, false otherwise.
        """
        return _cam.Machine_save(self, location, filePath)

    def _get_objectType(self) -> "char const *":
        return _cam.Machine__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.Machine__get_isValid(self)

# Register Machine in _cam:
_cam.Machine_swigregister(Machine)

def Machine_classType() -> "char const *":
    return _cam.Machine_classType()

def Machine_createFromTemplate(machineTemplate: "MachineTemplate") -> "adsk::core::Ptr< adsk::cam::Machine >":
    return _cam.Machine_createFromTemplate(machineTemplate)

def Machine_createFromFile(location: "LibraryLocation", filePath: "std::string const &") -> "adsk::core::Ptr< adsk::cam::Machine >":
    return _cam.Machine_createFromFile(location, filePath)


Machine.vendor = property(Machine._get_vendor, Machine._set_vendor, doc="Gets and sets the vendor name of the machine.")


Machine.model = property(Machine._get_model, Machine._set_model, doc="Gets and sets the model name of the machine.")


Machine.description = property(Machine._get_description, Machine._set_description, doc="Gets and sets the description of the machine.")


Machine.id = property(Machine._get_id, doc="Gets the unique identifier of the machine.\nCan be used for comparing machines within the document.")


Machine.capabilities = property(Machine._get_capabilities, doc="Gets the capabilities of the machine.")


Machine.kinematics = property(Machine._get_kinematics, doc="Gets the kinematics tree of the machine.")


Machine.cast = lambda arg: arg if isinstance(arg, Machine) else None

class MachineAxis(Base):
    r"""Abstract base class representing a single machine axis."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::MachineAxis *":
        return _cam.MachineAxis___deref__(self)

    def __eq__(self, rhs: "MachineAxis") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.MachineAxis___eq__(self, rhs)


    def __ne__(self, rhs: "MachineAxis") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.MachineAxis___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.MachineAxis_classType()
    __swig_destroy__ = _cam.delete_MachineAxis

    def _get_name(self) -> "std::string":
        r"""The name of this axis."""
        return _cam.MachineAxis__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""The name of this axis."""
        return _cam.MachineAxis__set_name(self, value)

    def _get_axisType(self) -> "adsk::cam::MachineAxisTypes":
        r"""The type of axis."""
        return _cam.MachineAxis__get_axisType(self)

    def _get_hasLimits(self) -> "bool":
        r"""Does this axis have a limited range of motion."""
        return _cam.MachineAxis__get_hasLimits(self)

    def _get_physicalMin(self) -> "double":
        r"""
        The minimum possible value for this axis (in mm/deg).
        Must be less than physicalMax.
        Set the value of this and physicalMax to 0 to remove
        axis limits.
        """
        return _cam.MachineAxis__get_physicalMin(self)

    def _set_physicalMin(self, value: "double") -> "bool":
        r"""
        The minimum possible value for this axis (in mm/deg).
        Must be less than physicalMax.
        Set the value of this and physicalMax to 0 to remove
        axis limits.
        """
        return _cam.MachineAxis__set_physicalMin(self, value)

    def _get_physicalMax(self) -> "double":
        r"""
        The maximum possible value for this axis (in mm/deg).
        Must be less than physicalMin.
        Set the value of this and physicalMin to 0 to remove
        axis limits.
        """
        return _cam.MachineAxis__get_physicalMax(self)

    def _set_physicalMax(self, value: "double") -> "bool":
        r"""
        The maximum possible value for this axis (in mm/deg).
        Must be less than physicalMin.
        Set the value of this and physicalMin to 0 to remove
        axis limits.
        """
        return _cam.MachineAxis__set_physicalMax(self, value)

    def _get_homePosition(self) -> "double":
        r"""Specifies the value (in mm/deg) that this axis returns to when the machine is homed."""
        return _cam.MachineAxis__get_homePosition(self)

    def _set_homePosition(self, value: "double") -> "bool":
        r"""Specifies the value (in mm/deg) that this axis returns to when the machine is homed."""
        return _cam.MachineAxis__set_homePosition(self, value)

    def _get_objectType(self) -> "char const *":
        return _cam.MachineAxis__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.MachineAxis__get_isValid(self)

# Register MachineAxis in _cam:
_cam.MachineAxis_swigregister(MachineAxis)

def MachineAxis_classType() -> "char const *":
    return _cam.MachineAxis_classType()


MachineAxis.name = property(MachineAxis._get_name, MachineAxis._set_name, doc="The name of this axis.")


MachineAxis.axisType = property(MachineAxis._get_axisType, doc="The type of axis.")


MachineAxis.hasLimits = property(MachineAxis._get_hasLimits, doc="Does this axis have a limited range of motion.")


MachineAxis.physicalMin = property(MachineAxis._get_physicalMin, MachineAxis._set_physicalMin, doc="The minimum possible value for this axis (in mm/deg).\nMust be less than physicalMax.\nSet the value of this and physicalMax to 0 to remove\naxis limits.")


MachineAxis.physicalMax = property(MachineAxis._get_physicalMax, MachineAxis._set_physicalMax, doc="The maximum possible value for this axis (in mm/deg).\nMust be less than physicalMin.\nSet the value of this and physicalMin to 0 to remove\naxis limits.")


MachineAxis.homePosition = property(MachineAxis._get_homePosition, MachineAxis._set_homePosition, doc="Specifies the value (in mm/deg) that this axis returns to when the machine is homed.")


MachineAxis.cast = lambda arg: arg if isinstance(arg, MachineAxis) else None

class MachineAxisInput(Base):
    r"""Object that defines the properties required to create a machine axis object."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::MachineAxisInput *":
        return _cam.MachineAxisInput___deref__(self)

    def __eq__(self, rhs: "MachineAxisInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.MachineAxisInput___eq__(self, rhs)


    def __ne__(self, rhs: "MachineAxisInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.MachineAxisInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.MachineAxisInput_classType()
    __swig_destroy__ = _cam.delete_MachineAxisInput

    def _get_axisType(self) -> "adsk::cam::MachineAxisTypes":
        r"""
        The type of axis.
        This axis type determines which parameters of this object are valid to be accessed
        or modified.
        """
        return _cam.MachineAxisInput__get_axisType(self)

    def _get_name(self) -> "std::string":
        r"""The user facing name of this axis."""
        return _cam.MachineAxisInput__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""The user facing name of this axis."""
        return _cam.MachineAxisInput__set_name(self, value)

    def _get_homePosition(self) -> "double":
        r"""Specifies the value (in mm/deg) that this axis returns to when the machine is homed."""
        return _cam.MachineAxisInput__get_homePosition(self)

    def _set_homePosition(self, value: "double") -> "bool":
        r"""Specifies the value (in mm/deg) that this axis returns to when the machine is homed."""
        return _cam.MachineAxisInput__set_homePosition(self, value)

    def _get_physicalMin(self) -> "double":
        r"""
        The minimum possible value for this axis (in mm/deg).
        Set the value of this and physicalMax to 0 to create an
        unlimited axis.
        """
        return _cam.MachineAxisInput__get_physicalMin(self)

    def _set_physicalMin(self, value: "double") -> "bool":
        r"""
        The minimum possible value for this axis (in mm/deg).
        Set the value of this and physicalMax to 0 to create an
        unlimited axis.
        """
        return _cam.MachineAxisInput__set_physicalMin(self, value)

    def _get_physicalMax(self) -> "double":
        r"""
        The maximum possible value for this axis (in mm/deg).
        Set the value of this and physicalMin to 0 to create an
        unlimited axis.
        """
        return _cam.MachineAxisInput__get_physicalMax(self)

    def _set_physicalMax(self, value: "double") -> "bool":
        r"""
        The maximum possible value for this axis (in mm/deg).
        Set the value of this and physicalMin to 0 to create an
        unlimited axis.
        """
        return _cam.MachineAxisInput__set_physicalMax(self, value)

    def _get_objectType(self) -> "char const *":
        return _cam.MachineAxisInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.MachineAxisInput__get_isValid(self)

# Register MachineAxisInput in _cam:
_cam.MachineAxisInput_swigregister(MachineAxisInput)

def MachineAxisInput_classType() -> "char const *":
    return _cam.MachineAxisInput_classType()


MachineAxisInput.axisType = property(MachineAxisInput._get_axisType, doc="The type of axis.\nThis axis type determines which parameters of this object are valid to be accessed\nor modified.")


MachineAxisInput.name = property(MachineAxisInput._get_name, MachineAxisInput._set_name, doc="The user facing name of this axis.")


MachineAxisInput.homePosition = property(MachineAxisInput._get_homePosition, MachineAxisInput._set_homePosition, doc="Specifies the value (in mm/deg) that this axis returns to when the machine is homed.")


MachineAxisInput.physicalMin = property(MachineAxisInput._get_physicalMin, MachineAxisInput._set_physicalMin, doc="The minimum possible value for this axis (in mm/deg).\nSet the value of this and physicalMax to 0 to create an\nunlimited axis.")


MachineAxisInput.physicalMax = property(MachineAxisInput._get_physicalMax, MachineAxisInput._set_physicalMax, doc="The maximum possible value for this axis (in mm/deg).\nSet the value of this and physicalMin to 0 to create an\nunlimited axis.")


MachineAxisInput.cast = lambda arg: arg if isinstance(arg, MachineAxisInput) else None

class MachineCapabilities(Base):
    r"""Object that represents the capabilities of the machine."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::MachineCapabilities *":
        return _cam.MachineCapabilities___deref__(self)

    def __eq__(self, rhs: "MachineCapabilities") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.MachineCapabilities___eq__(self, rhs)


    def __ne__(self, rhs: "MachineCapabilities") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.MachineCapabilities___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.MachineCapabilities_classType()
    __swig_destroy__ = _cam.delete_MachineCapabilities

    def _get_isMillingSupported(self) -> "bool":
        r"""Gets and sets if the machine is capable of subtractive milling."""
        return _cam.MachineCapabilities__get_isMillingSupported(self)

    def _set_isMillingSupported(self, value: "bool") -> "bool":
        r"""Gets and sets if the machine is capable of subtractive milling."""
        return _cam.MachineCapabilities__set_isMillingSupported(self, value)

    def _get_isTurningSupported(self) -> "bool":
        r"""Gets and sets if the machine is capable of subtractive turning."""
        return _cam.MachineCapabilities__get_isTurningSupported(self)

    def _set_isTurningSupported(self, value: "bool") -> "bool":
        r"""Gets and sets if the machine is capable of subtractive turning."""
        return _cam.MachineCapabilities__set_isTurningSupported(self, value)

    def _get_isCuttingSupported(self) -> "bool":
        r"""Gets and sets if the machine is capable of subtractive cutting."""
        return _cam.MachineCapabilities__get_isCuttingSupported(self)

    def _set_isCuttingSupported(self, value: "bool") -> "bool":
        r"""Gets and sets if the machine is capable of subtractive cutting."""
        return _cam.MachineCapabilities__set_isCuttingSupported(self, value)

    def _get_objectType(self) -> "char const *":
        return _cam.MachineCapabilities__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.MachineCapabilities__get_isValid(self)

# Register MachineCapabilities in _cam:
_cam.MachineCapabilities_swigregister(MachineCapabilities)

def MachineCapabilities_classType() -> "char const *":
    return _cam.MachineCapabilities_classType()


MachineCapabilities.isMillingSupported = property(MachineCapabilities._get_isMillingSupported, MachineCapabilities._set_isMillingSupported, doc="Gets and sets if the machine is capable of subtractive milling.")


MachineCapabilities.isTurningSupported = property(MachineCapabilities._get_isTurningSupported, MachineCapabilities._set_isTurningSupported, doc="Gets and sets if the machine is capable of subtractive turning.")


MachineCapabilities.isCuttingSupported = property(MachineCapabilities._get_isCuttingSupported, MachineCapabilities._set_isCuttingSupported, doc="Gets and sets if the machine is capable of subtractive cutting.")


MachineCapabilities.cast = lambda arg: arg if isinstance(arg, MachineCapabilities) else None

class MachineKinematics(Base):
    r"""Object that represents the kinematics tree in the machine."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::MachineKinematics *":
        return _cam.MachineKinematics___deref__(self)

    def __eq__(self, rhs: "MachineKinematics") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.MachineKinematics___eq__(self, rhs)


    def __ne__(self, rhs: "MachineKinematics") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.MachineKinematics___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.MachineKinematics_classType()
    __swig_destroy__ = _cam.delete_MachineKinematics

    def _get_parts(self) -> "adsk::core::Ptr< adsk::cam::MachineParts >":
        r"""Get the root parts collection."""
        return _cam.MachineKinematics__get_parts(self)

    def _get_objectType(self) -> "char const *":
        return _cam.MachineKinematics__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.MachineKinematics__get_isValid(self)

# Register MachineKinematics in _cam:
_cam.MachineKinematics_swigregister(MachineKinematics)

def MachineKinematics_classType() -> "char const *":
    return _cam.MachineKinematics_classType()


MachineKinematics.parts = property(MachineKinematics._get_parts, doc="Get the root parts collection.")


MachineKinematics.cast = lambda arg: arg if isinstance(arg, MachineKinematics) else None

class MachinePart(Base):
    r"""
    Object representing some part of a machine, such as the static base of the machine, an
    axis, or the attachment points for tools and fixtures.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::MachinePart *":
        return _cam.MachinePart___deref__(self)

    def __eq__(self, rhs: "MachinePart") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.MachinePart___eq__(self, rhs)


    def __ne__(self, rhs: "MachinePart") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.MachinePart___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.MachinePart_classType()
    __swig_destroy__ = _cam.delete_MachinePart

    def deleteMe(self) -> "void":
        r"""Delete this part and its children from the kinematics tree."""
        return _cam.MachinePart_deleteMe(self)

    def _get_children(self) -> "adsk::core::Ptr< adsk::cam::MachineParts >":
        r"""Get the collection of child parts."""
        return _cam.MachinePart__get_children(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::cam::MachinePart >":
        r"""
        Get or set the parent of this part.
        Setting the parent will add this part to the end of the parent's children
        collection. Setting the parent will throw an error if the new parent is this
        part or a child this part.
        """
        return _cam.MachinePart__get_parent(self)

    def _set_parent(self, value: "MachinePart") -> "bool":
        r"""
        Get or set the parent of this part.
        Setting the parent will add this part to the end of the parent's children
        collection. Setting the parent will throw an error if the new parent is this
        part or a child this part.
        """
        return _cam.MachinePart__set_parent(self, value)

    def _get_partType(self) -> "adsk::cam::MachinePartTypes":
        r"""Get the type of this part."""
        return _cam.MachinePart__get_partType(self)

    def _get_id(self) -> "std::string":
        r"""
        Get the internal ID of the part.
        This is unique with respect to other MachineParts in the Machine.
        """
        return _cam.MachinePart__get_id(self)

    def _get_axis(self) -> "adsk::core::Ptr< adsk::cam::MachineAxis >":
        r"""
        Get the axis object for this part used to reference this part for other
        operations.
        Only valid when partType is Axis, otherwise returns null
        """
        return _cam.MachinePart__get_axis(self)

    def _get_objectType(self) -> "char const *":
        return _cam.MachinePart__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.MachinePart__get_isValid(self)

# Register MachinePart in _cam:
_cam.MachinePart_swigregister(MachinePart)

def MachinePart_classType() -> "char const *":
    return _cam.MachinePart_classType()


MachinePart.children = property(MachinePart._get_children, doc="Get the collection of child parts.")


MachinePart.parent = property(MachinePart._get_parent, MachinePart._set_parent, doc="Get or set the parent of this part.\nSetting the parent will add this part to the end of the parent's children\ncollection. Setting the parent will throw an error if the new parent is this\npart or a child this part.")


MachinePart.partType = property(MachinePart._get_partType, doc="Get the type of this part.")


MachinePart.id = property(MachinePart._get_id, doc="Get the internal ID of the part.\nThis is unique with respect to other MachineParts in the Machine.")


MachinePart.axis = property(MachinePart._get_axis, doc="Get the axis object for this part used to reference this part for other\noperations.\nOnly valid when partType is Axis, otherwise returns null")


MachinePart.cast = lambda arg: arg if isinstance(arg, MachinePart) else None

class MachinePartInput(Base):
    r"""
    Object representing the set of inputs required to create a new MachinePart.
    Set an MachineAxisInput object on this object's axisInput parameter to create
    a new MachineAxis with this part.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::MachinePartInput *":
        return _cam.MachinePartInput___deref__(self)

    def __eq__(self, rhs: "MachinePartInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.MachinePartInput___eq__(self, rhs)


    def __ne__(self, rhs: "MachinePartInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.MachinePartInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.MachinePartInput_classType()
    __swig_destroy__ = _cam.delete_MachinePartInput

    def _get_id(self) -> "std::string":
        r"""
        Get or set the internal ID of the part, used to reference this part for other
        operations. This ID can be any string.
        This must be unique with respect to other MachineParts in the Machine.
        """
        return _cam.MachinePartInput__get_id(self)

    def _set_id(self, value: "std::string const &") -> "bool":
        r"""
        Get or set the internal ID of the part, used to reference this part for other
        operations. This ID can be any string.
        This must be unique with respect to other MachineParts in the Machine.
        """
        return _cam.MachinePartInput__set_id(self, value)

    def _get_partType(self) -> "adsk::cam::MachinePartTypes":
        r"""Get the type of part this input will create."""
        return _cam.MachinePartInput__get_partType(self)

    def createAxisInput(self, axisType: "MachineAxisTypes") -> "adsk::core::Ptr< adsk::cam::MachineAxisInput >":
        r"""
        Create a new MachineAxisInput object to be used to create a new MachineAxis.
        Set this object on to an axis type MachinePartInput to create a new MachineAxis
        with that part. 
        axisType : The type of MachineAxisInput to create. 
        Returns a LinearMachineAxisInput or RotaryMachineAxisInput, or null if the creation failed.
        """
        return _cam.MachinePartInput_createAxisInput(self, axisType)

    def _get_axisInput(self) -> "adsk::core::Ptr< adsk::cam::MachineAxisInput >":
        r"""
        Get or Set an axis input object to create a new MachineAxis with this part.
        Only valid when partType is Axis.
        """
        return _cam.MachinePartInput__get_axisInput(self)

    def _set_axisInput(self, value: "MachineAxisInput") -> "bool":
        r"""
        Get or Set an axis input object to create a new MachineAxis with this part.
        Only valid when partType is Axis.
        """
        return _cam.MachinePartInput__set_axisInput(self, value)

    def _get_objectType(self) -> "char const *":
        return _cam.MachinePartInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.MachinePartInput__get_isValid(self)

# Register MachinePartInput in _cam:
_cam.MachinePartInput_swigregister(MachinePartInput)

def MachinePartInput_classType() -> "char const *":
    return _cam.MachinePartInput_classType()


MachinePartInput.id = property(MachinePartInput._get_id, MachinePartInput._set_id, doc="Get or set the internal ID of the part, used to reference this part for other\noperations. This ID can be any string.\nThis must be unique with respect to other MachineParts in the Machine.")


MachinePartInput.partType = property(MachinePartInput._get_partType, doc="Get the type of part this input will create.")


MachinePartInput.axisInput = property(MachinePartInput._get_axisInput, MachinePartInput._set_axisInput, doc="Get or Set an axis input object to create a new MachineAxis with this part.\nOnly valid when partType is Axis.")


MachinePartInput.cast = lambda arg: arg if isinstance(arg, MachinePartInput) else None

class MachineParts(Base):
    r"""
    Object that represents a collection of machine parts.
    These parts are the children of another part or the collection of base parts from MachineKinematics
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::MachineParts *":
        return _cam.MachineParts___deref__(self)

    def __eq__(self, rhs: "MachineParts") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.MachineParts___eq__(self, rhs)


    def __ne__(self, rhs: "MachineParts") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.MachineParts___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _cam.MachineParts___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::cam::MachinePart >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _cam.MachineParts___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _cam.MachineParts_classType()
    __swig_destroy__ = _cam.delete_MachineParts

    def add(self, partInput: "MachinePartInput") -> "adsk::core::Ptr< adsk::cam::MachinePart >":
        r"""
        Add a new part to this collection. The part's parent will be set to the the owner of
        this collection, or null if this is the root parts collection.
        If the passed MachinePartInput has a MachineAxisInput a new MachineAxis will be created. 
        partInput : Part input object used to create the new MachinePart. 
        Returns the newly creted MachinePart or null if creation failed.
        """
        return _cam.MachineParts_add(self, partInput)

    def createPartInput(self, partType: "MachinePartTypes") -> "adsk::core::Ptr< adsk::cam::MachinePartInput >":
        r"""
        Create a new MachinePartInput. 
        partType : The type of part to create.
        When this parameter is Axis, you must set a value for axisInput. 
        Returns the new MachinePartInput or null if creation failed.
        """
        return _cam.MachineParts_createPartInput(self, partType)

    def item(self, index: "int") -> "adsk::core::Ptr< adsk::cam::MachinePart >":
        r"""
        Get the part at index in this collection. 
        index : The index of the part. 
        The MachinePart at index.
        """
        return _cam.MachineParts_item(self, index)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::cam::MachinePart >":
        r"""
        Get the part with the given ID. 
        id : The ID for the part to get. 
        Returns the MachinePart with the given ID, or null if the given ID does not
        match any part in the collection.
        """
        return _cam.MachineParts_itemById(self, id)

    def _get_count(self) -> "size_t":
        r"""Get the number of parts in this collection."""
        return _cam.MachineParts__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _cam.MachineParts__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.MachineParts__get_isValid(self)

# Register MachineParts in _cam:
_cam.MachineParts_swigregister(MachineParts)

def MachineParts_classType() -> "char const *":
    return _cam.MachineParts_classType()


MachineParts.count = property(MachineParts._get_count, doc="Get the number of parts in this collection.")


MachineParts.cast = lambda arg: arg if isinstance(arg, MachineParts) else None

class MachiningTime(Base):
    r"""
    Object returned when using the getMachiningTime method from the CAM class.
    Use the properties on this object to get the machining time results.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::MachiningTime *":
        return _cam.MachiningTime___deref__(self)

    def __eq__(self, rhs: "MachiningTime") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.MachiningTime___eq__(self, rhs)


    def __ne__(self, rhs: "MachiningTime") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.MachiningTime___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.MachiningTime_classType()
    __swig_destroy__ = _cam.delete_MachiningTime

    def _get_feedDistance(self) -> "double":
        r"""Gets the feed distance in centimeters."""
        return _cam.MachiningTime__get_feedDistance(self)

    def _get_totalFeedTime(self) -> "double":
        r"""Get the total feed time in seconds."""
        return _cam.MachiningTime__get_totalFeedTime(self)

    def _get_rapidDistance(self) -> "double":
        r"""Gets the calculated rapid distance in centimeters."""
        return _cam.MachiningTime__get_rapidDistance(self)

    def _get_totalRapidTime(self) -> "double":
        r"""Gets the total rapid feed time in seconds."""
        return _cam.MachiningTime__get_totalRapidTime(self)

    def _get_toolChangeCount(self) -> "int":
        r"""Gets the number of tool changes."""
        return _cam.MachiningTime__get_toolChangeCount(self)

    def _get_totalToolChangeTime(self) -> "double":
        r"""Gets the total tool change time in seconds."""
        return _cam.MachiningTime__get_totalToolChangeTime(self)

    def _get_machiningTime(self) -> "double":
        r"""Gets the machining time in seconds."""
        return _cam.MachiningTime__get_machiningTime(self)

    def _get_objectType(self) -> "char const *":
        return _cam.MachiningTime__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.MachiningTime__get_isValid(self)

# Register MachiningTime in _cam:
_cam.MachiningTime_swigregister(MachiningTime)

def MachiningTime_classType() -> "char const *":
    return _cam.MachiningTime_classType()


MachiningTime.feedDistance = property(MachiningTime._get_feedDistance, doc="Gets the feed distance in centimeters.")


MachiningTime.totalFeedTime = property(MachiningTime._get_totalFeedTime, doc="Get the total feed time in seconds.")


MachiningTime.rapidDistance = property(MachiningTime._get_rapidDistance, doc="Gets the calculated rapid distance in centimeters.")


MachiningTime.totalRapidTime = property(MachiningTime._get_totalRapidTime, doc="Gets the total rapid feed time in seconds.")


MachiningTime.toolChangeCount = property(MachiningTime._get_toolChangeCount, doc="Gets the number of tool changes.")


MachiningTime.totalToolChangeTime = property(MachiningTime._get_totalToolChangeTime, doc="Gets the total tool change time in seconds.")


MachiningTime.machiningTime = property(MachiningTime._get_machiningTime, doc="Gets the machining time in seconds.")


MachiningTime.cast = lambda arg: arg if isinstance(arg, MachiningTime) else None

class OperationBase(Base):
    r"""Base class object representing all operations, folders, patterns and setups."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::OperationBase *":
        return _cam.OperationBase___deref__(self)

    def __eq__(self, rhs: "OperationBase") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.OperationBase___eq__(self, rhs)


    def __ne__(self, rhs: "OperationBase") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.OperationBase___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.OperationBase_classType()
    __swig_destroy__ = _cam.delete_OperationBase

    def _get_name(self) -> "std::string":
        r"""
        Gets and sets the name of the operation as seen in the browser. This name is unique as compared
        to the names of all other operations in the document.
        """
        return _cam.OperationBase__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the name of the operation as seen in the browser. This name is unique as compared
        to the names of all other operations in the document.
        """
        return _cam.OperationBase__set_name(self, value)

    def _get_isProtected(self) -> "bool":
        r"""
        Gets and sets the 'protected' property value of the operation.
        Gets/sets true if the operation is protected.
        """
        return _cam.OperationBase__get_isProtected(self)

    def _set_isProtected(self, value: "bool") -> "bool":
        r"""
        Gets and sets the 'protected' property value of the operation.
        Gets/sets true if the operation is protected.
        """
        return _cam.OperationBase__set_isProtected(self, value)

    def _get_isOptional(self) -> "bool":
        r"""
        Gets and sets the 'Optional' property value of the operation.
        Gets/sets true if the operation is optional.
        """
        return _cam.OperationBase__get_isOptional(self)

    def _set_isOptional(self, value: "bool") -> "bool":
        r"""
        Gets and sets the 'Optional' property value of the operation.
        Gets/sets true if the operation is optional.
        """
        return _cam.OperationBase__set_isOptional(self, value)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets the 'Suppressed' property value of the operation.
        Gets/sets true if the operation is suppressed.
        """
        return _cam.OperationBase__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets the 'Suppressed' property value of the operation.
        Gets/sets true if the operation is suppressed.
        """
        return _cam.OperationBase__set_isSuppressed(self, value)

    def _get_parentSetup(self) -> "adsk::core::Ptr< adsk::cam::Setup >":
        r"""Gets the Setup this operation belongs to."""
        return _cam.OperationBase__get_parentSetup(self)

    def _get_isSelected(self) -> "bool":
        r"""Gets if this operation is selected in the 'Setups' browser."""
        return _cam.OperationBase__get_isSelected(self)

    def _get_notes(self) -> "std::string":
        r"""Gets and sets the notes of the operation."""
        return _cam.OperationBase__get_notes(self)

    def _set_notes(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the notes of the operation."""
        return _cam.OperationBase__set_notes(self, value)

    def _get_operationId(self) -> "int":
        r"""
        Returns the id of the operation. This id is unique as compared 
        to the ids of all other operations in the document. 
        This id will not change when changing the order or parent of the operation. 
        This id will remain valid when the document is saved and reloaded.
        """
        return _cam.OperationBase__get_operationId(self)

    def _get_parameters(self) -> "adsk::core::Ptr< adsk::cam::CAMParameters >":
        r"""Gets the CAMParameters collection for this operation."""
        return _cam.OperationBase__get_parameters(self)

    def _get_objectType(self) -> "char const *":
        return _cam.OperationBase__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.OperationBase__get_isValid(self)

# Register OperationBase in _cam:
_cam.OperationBase_swigregister(OperationBase)

def OperationBase_classType() -> "char const *":
    return _cam.OperationBase_classType()


OperationBase.name = property(OperationBase._get_name, OperationBase._set_name, doc="Gets and sets the name of the operation as seen in the browser. This name is unique as compared\nto the names of all other operations in the document.")


OperationBase.isProtected = property(OperationBase._get_isProtected, OperationBase._set_isProtected, doc="Gets and sets the 'protected' property value of the operation.\nGets/sets true if the operation is protected.")


OperationBase.isOptional = property(OperationBase._get_isOptional, OperationBase._set_isOptional, doc="Gets and sets the 'Optional' property value of the operation.\nGets/sets true if the operation is optional.")


OperationBase.isSuppressed = property(OperationBase._get_isSuppressed, OperationBase._set_isSuppressed, doc="Gets and sets the 'Suppressed' property value of the operation.\nGets/sets true if the operation is suppressed.")


OperationBase.parentSetup = property(OperationBase._get_parentSetup, doc="Gets the Setup this operation belongs to.")


OperationBase.isSelected = property(OperationBase._get_isSelected, doc="Gets if this operation is selected in the 'Setups' browser.")


OperationBase.notes = property(OperationBase._get_notes, OperationBase._set_notes, doc="Gets and sets the notes of the operation.")


OperationBase.operationId = property(OperationBase._get_operationId, doc="Returns the id of the operation. This id is unique as compared\nto the ids of all other operations in the document.\nThis id will not change when changing the order or parent of the operation.\nThis id will remain valid when the document is saved and reloaded.")


OperationBase.parameters = property(OperationBase._get_parameters, doc="Gets the CAMParameters collection for this operation.")


OperationBase.cast = lambda arg: arg if isinstance(arg, OperationBase) else None

class Operations(Base):
    r"""Collection that provides access to the individual operations within an existing setup, folder or pattern."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::Operations *":
        return _cam.Operations___deref__(self)

    def __eq__(self, rhs: "Operations") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.Operations___eq__(self, rhs)


    def __ne__(self, rhs: "Operations") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.Operations___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _cam.Operations___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::cam::Operation >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _cam.Operations___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _cam.Operations_classType()
    __swig_destroy__ = _cam.delete_Operations

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::cam::Operation >":
        r"""
        Function that returns the specified operation using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _cam.Operations_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::cam::Operation >":
        r"""
        Returns the operation with the specified name (as appears in the browser). 
        name : The name (as it appears in the browser) of the operation. 
        Returns the specified operation or null in the case where there is no operation with the specified name.
        """
        return _cam.Operations_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of items in the collection."""
        return _cam.Operations__get_count(self)

    def itemByOperationId(self, id: "int") -> "adsk::core::Ptr< adsk::cam::Operation >":
        r"""
        Returns the operation with the specified operation id. 
        id : The id of the operation. 
        Returns the specified operation or null in the case where there is no operation with the specified operation id.
        """
        return _cam.Operations_itemByOperationId(self, id)

    def _get_objectType(self) -> "char const *":
        return _cam.Operations__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.Operations__get_isValid(self)

# Register Operations in _cam:
_cam.Operations_swigregister(Operations)

def Operations_classType() -> "char const *":
    return _cam.Operations_classType()


Operations.count = property(Operations._get_count, doc="The number of items in the collection.")


Operations.cast = lambda arg: arg if isinstance(arg, Operations) else None

class PostProcessInput(Base):
    r"""
    This class defines the properties that pertain to the settings and options required for posting a
    toolpath to generate a CNC file. A PostProcessInput object is a required parameter for the
    postProcessAll() and postProcess() methods on the CAM class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::PostProcessInput *":
        return _cam.PostProcessInput___deref__(self)

    def __eq__(self, rhs: "PostProcessInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.PostProcessInput___eq__(self, rhs)


    def __ne__(self, rhs: "PostProcessInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.PostProcessInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.PostProcessInput_classType()

    @staticmethod
    def create(programName: "std::string const &", postConfiguration: "std::string const &", outputFolder: "std::string const &", outputUnits: "PostOutputUnitOptions") -> "adsk::core::Ptr< adsk::cam::PostProcessInput >":
        return _cam.PostProcessInput_create(programName, postConfiguration, outputFolder, outputUnits)
    __swig_destroy__ = _cam.delete_PostProcessInput

    def _get_programName(self) -> "std::string":
        r"""
        Gets and sets the program name or number.
        If the post configuration specifies the parameter programNameIsInteger = true, then the program name must be a number.
        """
        return _cam.PostProcessInput__get_programName(self)

    def _set_programName(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the program name or number.
        If the post configuration specifies the parameter programNameIsInteger = true, then the program name must be a number.
        """
        return _cam.PostProcessInput__set_programName(self, value)

    def _get_programComment(self) -> "std::string":
        r"""Gets and sets the program comment. The default value for this property is an empty string ('')."""
        return _cam.PostProcessInput__get_programComment(self)

    def _set_programComment(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the program comment. The default value for this property is an empty string ('')."""
        return _cam.PostProcessInput__set_programComment(self, value)

    def _get_postConfiguration(self) -> "std::string":
        r"""Gets and sets the full filename (including the path) for the post configuration file (.cps)"""
        return _cam.PostProcessInput__get_postConfiguration(self)

    def _set_postConfiguration(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the full filename (including the path) for the post configuration file (.cps)"""
        return _cam.PostProcessInput__set_postConfiguration(self, value)

    def _get_outputFolder(self) -> "std::string":
        r"""Gets and sets the path for the output folder where the .cnc files will be located."""
        return _cam.PostProcessInput__get_outputFolder(self)

    def _set_outputFolder(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the path for the output folder where the .cnc files will be located."""
        return _cam.PostProcessInput__set_outputFolder(self, value)

    def _get_outputUnits(self) -> "adsk::cam::PostOutputUnitOptions":
        r"""
        Gets and sets the units option for the cnc output.
        Valid options are DocumentUnitsOutput, InchesOutput or MillimetersOutput
        """
        return _cam.PostProcessInput__get_outputUnits(self)

    def _set_outputUnits(self, value: "PostOutputUnitOptions") -> "bool":
        r"""
        Gets and sets the units option for the cnc output.
        Valid options are DocumentUnitsOutput, InchesOutput or MillimetersOutput
        """
        return _cam.PostProcessInput__set_outputUnits(self, value)

    def _get_isOpenInEditor(self) -> "bool":
        r"""
        Gets and sets the option if opening the cnc file with the editor after it is created.
        The default value for this property is true.
        """
        return _cam.PostProcessInput__get_isOpenInEditor(self)

    def _set_isOpenInEditor(self, value: "bool") -> "bool":
        r"""
        Gets and sets the option if opening the cnc file with the editor after it is created.
        The default value for this property is true.
        """
        return _cam.PostProcessInput__set_isOpenInEditor(self, value)

    def _get_areToolChangesMinimized(self) -> "bool":
        r"""
        Gets and sets that operations may be reordered between setups to minimize the number of tool changes.
        Operations within each setup will still be executed in the programmed order.
        This is commonly used for tombstone machining where you have multiple setups.
        The default value for this property is false.
        """
        return _cam.PostProcessInput__get_areToolChangesMinimized(self)

    def _set_areToolChangesMinimized(self, value: "bool") -> "bool":
        r"""
        Gets and sets that operations may be reordered between setups to minimize the number of tool changes.
        Operations within each setup will still be executed in the programmed order.
        This is commonly used for tombstone machining where you have multiple setups.
        The default value for this property is false.
        """
        return _cam.PostProcessInput__set_areToolChangesMinimized(self, value)

    def _get_postProperties(self) -> "adsk::core::Ptr< adsk::core::NamedValues >":
        r"""
        Gets and sets the list of post properties.
        Each property has a string name and a ValueInput object.
        The default value for this is an empty NamedValues.
        """
        return _cam.PostProcessInput__get_postProperties(self)

    def _set_postProperties(self, value: "NamedValues") -> "bool":
        r"""
        Gets and sets the list of post properties.
        Each property has a string name and a ValueInput object.
        The default value for this is an empty NamedValues.
        """
        return _cam.PostProcessInput__set_postProperties(self, value)

    def _get_machine(self) -> "adsk::core::Ptr< adsk::cam::Machine >":
        r"""
        Gets and sets the machine used for post processing.
        It will override the machines associated with the operations or setup when posting.
        The default value for this property is null.
        """
        return _cam.PostProcessInput__get_machine(self)

    def _set_machine(self, value: "Machine") -> "bool":
        r"""
        Gets and sets the machine used for post processing.
        It will override the machines associated with the operations or setup when posting.
        The default value for this property is null.
        """
        return _cam.PostProcessInput__set_machine(self, value)

    def _get_objectType(self) -> "char const *":
        return _cam.PostProcessInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.PostProcessInput__get_isValid(self)

# Register PostProcessInput in _cam:
_cam.PostProcessInput_swigregister(PostProcessInput)

def PostProcessInput_classType() -> "char const *":
    return _cam.PostProcessInput_classType()

def PostProcessInput_create(programName: "std::string const &", postConfiguration: "std::string const &", outputFolder: "std::string const &", outputUnits: "PostOutputUnitOptions") -> "adsk::core::Ptr< adsk::cam::PostProcessInput >":
    return _cam.PostProcessInput_create(programName, postConfiguration, outputFolder, outputUnits)


PostProcessInput.programName = property(PostProcessInput._get_programName, PostProcessInput._set_programName, doc="Gets and sets the program name or number.\nIf the post configuration specifies the parameter programNameIsInteger = true, then the program name must be a number.")


PostProcessInput.programComment = property(PostProcessInput._get_programComment, PostProcessInput._set_programComment, doc="Gets and sets the program comment. The default value for this property is an empty string ('').")


PostProcessInput.postConfiguration = property(PostProcessInput._get_postConfiguration, PostProcessInput._set_postConfiguration, doc="Gets and sets the full filename (including the path) for the post configuration file (.cps)")


PostProcessInput.outputFolder = property(PostProcessInput._get_outputFolder, PostProcessInput._set_outputFolder, doc="Gets and sets the path for the output folder where the .cnc files will be located.")


PostProcessInput.outputUnits = property(PostProcessInput._get_outputUnits, PostProcessInput._set_outputUnits, doc="Gets and sets the units option for the cnc output.\nValid options are DocumentUnitsOutput, InchesOutput or MillimetersOutput")


PostProcessInput.isOpenInEditor = property(PostProcessInput._get_isOpenInEditor, PostProcessInput._set_isOpenInEditor, doc="Gets and sets the option if opening the cnc file with the editor after it is created.\nThe default value for this property is true.")


PostProcessInput.areToolChangesMinimized = property(PostProcessInput._get_areToolChangesMinimized, PostProcessInput._set_areToolChangesMinimized, doc="Gets and sets that operations may be reordered between setups to minimize the number of tool changes.\nOperations within each setup will still be executed in the programmed order.\nThis is commonly used for tombstone machining where you have multiple setups.\nThe default value for this property is false.")


PostProcessInput.postProperties = property(PostProcessInput._get_postProperties, PostProcessInput._set_postProperties, doc="Gets and sets the list of post properties.\nEach property has a string name and a ValueInput object.\nThe default value for this is an empty NamedValues.")


PostProcessInput.machine = property(PostProcessInput._get_machine, PostProcessInput._set_machine, doc="Gets and sets the machine used for post processing.\nIt will override the machines associated with the operations or setup when posting.\nThe default value for this property is null.")


PostProcessInput.cast = lambda arg: arg if isinstance(arg, PostProcessInput) else None

class SetupChangeEvent(adsk.core.Event):
    r"""A SetupChangeEvent represents a setup related change event. It is used for SetupChanged notifications."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::SetupChangeEvent *":
        return _cam.SetupChangeEvent___deref__(self)

    def __eq__(self, rhs: "SetupChangeEvent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.SetupChangeEvent___eq__(self, rhs)


    def __ne__(self, rhs: "SetupChangeEvent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.SetupChangeEvent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.SetupChangeEvent_classType()
    __swig_destroy__ = _cam.delete_SetupChangeEvent

    def add(self, handler: "SetupChangeEventHandler") -> "bool":
        r"""
        Add a handler to be notified when the file event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _cam.SetupChangeEvent_add(self, handler)

    def remove(self, handler: "SetupChangeEventHandler") -> "bool":
        r"""
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _cam.SetupChangeEvent_remove(self, handler)

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _cam.SetupChangeEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _cam.SetupChangeEvent__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _cam.SetupChangeEvent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.SetupChangeEvent__get_isValid(self)

# Register SetupChangeEvent in _cam:
_cam.SetupChangeEvent_swigregister(SetupChangeEvent)

def SetupChangeEvent_classType() -> "char const *":
    return _cam.SetupChangeEvent_classType()


SetupChangeEvent.cast = lambda arg: arg if isinstance(arg, SetupChangeEvent) else None

class SetupChangeEventArgs(adsk.core.EventArgs):
    r"""The SetupChangeEventArgs provides information associated with a change event of a setup."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::SetupChangeEventArgs *":
        return _cam.SetupChangeEventArgs___deref__(self)

    def __eq__(self, rhs: "SetupChangeEventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.SetupChangeEventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "SetupChangeEventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.SetupChangeEventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.SetupChangeEventArgs_classType()
    __swig_destroy__ = _cam.delete_SetupChangeEventArgs

    def _get_setup(self) -> "adsk::core::Ptr< adsk::cam::Setup >":
        r"""
        Provides access to the setup. Can be null in the case
        where the event is fired before the setup has been created or after it has been deleted.
        """
        return _cam.SetupChangeEventArgs__get_setup(self)

    def _get_info(self) -> "std::string":
        r"""
        Provides access to an information string.
        The optional string may contain additional information about the change.
        """
        return _cam.SetupChangeEventArgs__get_info(self)

    def _get_type(self) -> "adsk::cam::SetupChangeEventType":
        r"""The type specifies the actual change."""
        return _cam.SetupChangeEventArgs__get_type(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _cam.SetupChangeEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _cam.SetupChangeEventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.SetupChangeEventArgs__get_isValid(self)

# Register SetupChangeEventArgs in _cam:
_cam.SetupChangeEventArgs_swigregister(SetupChangeEventArgs)

def SetupChangeEventArgs_classType() -> "char const *":
    return _cam.SetupChangeEventArgs_classType()


SetupChangeEventArgs.setup = property(SetupChangeEventArgs._get_setup, doc="Provides access to the setup. Can be null in the case\nwhere the event is fired before the setup has been created or after it has been deleted.")


SetupChangeEventArgs.info = property(SetupChangeEventArgs._get_info, doc="Provides access to an information string.\nThe optional string may contain additional information about the change.")


SetupChangeEventArgs.type = property(SetupChangeEventArgs._get_type, doc="The type specifies the actual change.")


SetupChangeEventArgs.cast = lambda arg: arg if isinstance(arg, SetupChangeEventArgs) else None

class SetupChangeEventHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notify(self, eventArgs: "SetupChangeEventArgs") -> "void":
        return _cam.SetupChangeEventHandler_notify(self, eventArgs)

    def __init__(self):
        if self.__class__ == SetupChangeEventHandler:
            _self = None
        else:
            _self = self
        _cam.SetupChangeEventHandler_swiginit(self, _cam.new_SetupChangeEventHandler(_self, ))
    __swig_destroy__ = _cam.delete_SetupChangeEventHandler
    def __disown__(self):
        self.this.disown()
        _cam.disown_SetupChangeEventHandler(self)
        return weakref.proxy(self)

# Register SetupChangeEventHandler in _cam:
_cam.SetupChangeEventHandler_swigregister(SetupChangeEventHandler)


SetupChangeEventHandler.cast = lambda arg: arg if isinstance(arg, SetupChangeEventHandler) else None

class SetupEvent(adsk.core.Event):
    r"""A SetupEvent represents a setup related event. For example, SetupCreated or SetupDestroying."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::SetupEvent *":
        return _cam.SetupEvent___deref__(self)

    def __eq__(self, rhs: "SetupEvent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.SetupEvent___eq__(self, rhs)


    def __ne__(self, rhs: "SetupEvent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.SetupEvent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.SetupEvent_classType()
    __swig_destroy__ = _cam.delete_SetupEvent

    def add(self, handler: "SetupEventHandler") -> "bool":
        r"""
        Add a handler to be notified when the file event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _cam.SetupEvent_add(self, handler)

    def remove(self, handler: "SetupEventHandler") -> "bool":
        r"""
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _cam.SetupEvent_remove(self, handler)

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _cam.SetupEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _cam.SetupEvent__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _cam.SetupEvent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.SetupEvent__get_isValid(self)

# Register SetupEvent in _cam:
_cam.SetupEvent_swigregister(SetupEvent)

def SetupEvent_classType() -> "char const *":
    return _cam.SetupEvent_classType()


SetupEvent.cast = lambda arg: arg if isinstance(arg, SetupEvent) else None

class SetupEventArgs(adsk.core.EventArgs):
    r"""The SetupEventArgs provides information associated with a setup event."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::SetupEventArgs *":
        return _cam.SetupEventArgs___deref__(self)

    def __eq__(self, rhs: "SetupEventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.SetupEventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "SetupEventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.SetupEventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.SetupEventArgs_classType()
    __swig_destroy__ = _cam.delete_SetupEventArgs

    def _get_setup(self) -> "adsk::core::Ptr< adsk::cam::Setup >":
        r"""
        Provides access to the setup. Can be null in the case
        where the event is fired before the setup has been created or after it has been deleted.
        """
        return _cam.SetupEventArgs__get_setup(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _cam.SetupEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _cam.SetupEventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.SetupEventArgs__get_isValid(self)

# Register SetupEventArgs in _cam:
_cam.SetupEventArgs_swigregister(SetupEventArgs)

def SetupEventArgs_classType() -> "char const *":
    return _cam.SetupEventArgs_classType()


SetupEventArgs.setup = property(SetupEventArgs._get_setup, doc="Provides access to the setup. Can be null in the case\nwhere the event is fired before the setup has been created or after it has been deleted.")


SetupEventArgs.cast = lambda arg: arg if isinstance(arg, SetupEventArgs) else None

class SetupEventHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notify(self, eventArgs: "SetupEventArgs") -> "void":
        return _cam.SetupEventHandler_notify(self, eventArgs)

    def __init__(self):
        if self.__class__ == SetupEventHandler:
            _self = None
        else:
            _self = self
        _cam.SetupEventHandler_swiginit(self, _cam.new_SetupEventHandler(_self, ))
    __swig_destroy__ = _cam.delete_SetupEventHandler
    def __disown__(self):
        self.this.disown()
        _cam.disown_SetupEventHandler(self)
        return weakref.proxy(self)

# Register SetupEventHandler in _cam:
_cam.SetupEventHandler_swigregister(SetupEventHandler)


SetupEventHandler.cast = lambda arg: arg if isinstance(arg, SetupEventHandler) else None

class Setups(Base):
    r"""Collection that provides access to all of the existing setups in a document."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::Setups *":
        return _cam.Setups___deref__(self)

    def __eq__(self, rhs: "Setups") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.Setups___eq__(self, rhs)


    def __ne__(self, rhs: "Setups") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.Setups___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _cam.Setups___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::cam::Setup >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _cam.Setups___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _cam.Setups_classType()
    __swig_destroy__ = _cam.delete_Setups

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::cam::Setup >":
        r"""
        Function that returns the specified setup using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _cam.Setups_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::cam::Setup >":
        r"""
        Returns the setup with the specified name. 
        name : The name (as it appears in the browser) of the operation. 
        Returns the specified setup or null in the case where there is no setup with the specified name.
        """
        return _cam.Setups_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of setups in the collection."""
        return _cam.Setups__get_count(self)

    def itemByOperationId(self, id: "int") -> "adsk::core::Ptr< adsk::cam::Setup >":
        r"""
        Returns the setup with the specified operation id. 
        id : The id of the operation. 
        Returns the specified setup or null in the case where there is no setup with the specified operation id.
        """
        return _cam.Setups_itemByOperationId(self, id)

    def _get_objectType(self) -> "char const *":
        return _cam.Setups__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.Setups__get_isValid(self)

# Register Setups in _cam:
_cam.Setups_swigregister(Setups)

def Setups_classType() -> "char const *":
    return _cam.Setups_classType()


Setups.count = property(Setups._get_count, doc="The number of setups in the collection.")


Setups.cast = lambda arg: arg if isinstance(arg, Setups) else None

class CAMFolder(OperationBase):
    r"""Object that represents a folder in an existing Setup, Folder or Pattern."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::CAMFolder *":
        return _cam.CAMFolder___deref__(self)

    def __eq__(self, rhs: "CAMFolder") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.CAMFolder___eq__(self, rhs)


    def __ne__(self, rhs: "CAMFolder") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.CAMFolder___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.CAMFolder_classType()
    __swig_destroy__ = _cam.delete_CAMFolder

    def _get_isActive(self) -> "bool":
        r"""Gets if this folder is active."""
        return _cam.CAMFolder__get_isActive(self)

    def _get_operations(self) -> "adsk::core::Ptr< adsk::cam::Operations >":
        r"""
        Returns the Operations collection that provides access to existing individual operations
        in this folder.
        """
        return _cam.CAMFolder__get_operations(self)

    def _get_folders(self) -> "adsk::core::Ptr< adsk::cam::CAMFolders >":
        r"""
        Returns the Folders collection that provides access to existing folders
        in this folder.
        """
        return _cam.CAMFolder__get_folders(self)

    def _get_patterns(self) -> "adsk::core::Ptr< adsk::cam::CAMPatterns >":
        r"""
        Returns the Patterns collection that provides access to existing patterns
        in this folder.
        """
        return _cam.CAMFolder__get_patterns(self)

    def _get_children(self) -> "adsk::core::Ptr< adsk::cam::ChildOperationList >":
        r"""
        Returns a collection containing all of the immediate (top level) child operations, folders and patterns in this folder
        in the order they appear in the browser.
        """
        return _cam.CAMFolder__get_children(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the parent Setup, Folder or Pattern for this Folder."""
        return _cam.CAMFolder__get_parent(self)

    def _get_allOperations(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets a collection containing all of the operations in this folder.
        This includes all operations nested in folders and patterns.
        """
        return _cam.CAMFolder__get_allOperations(self)

    def createFromTemplate(self, templateFilePath: "std::string const &") -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Create and add operations, folders or patterns from the specified template file to the end of this folder. 
        templateFilePath : The full path to the template file. 
        Returns the collection containing all of the operations, folders and patterns created from the template file.
        """
        return _cam.CAMFolder_createFromTemplate(self, templateFilePath)

    def _get_name(self) -> "std::string":
        r"""
        Gets and sets the name of the operation as seen in the browser. This name is unique as compared
        to the names of all other operations in the document.
        """
        return _cam.CAMFolder__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the name of the operation as seen in the browser. This name is unique as compared
        to the names of all other operations in the document.
        """
        return _cam.CAMFolder__set_name(self, value)

    def _get_isProtected(self) -> "bool":
        r"""
        Gets and sets the 'protected' property value of the operation.
        Gets/sets true if the operation is protected.
        """
        return _cam.CAMFolder__get_isProtected(self)

    def _set_isProtected(self, value: "bool") -> "bool":
        r"""
        Gets and sets the 'protected' property value of the operation.
        Gets/sets true if the operation is protected.
        """
        return _cam.CAMFolder__set_isProtected(self, value)

    def _get_isOptional(self) -> "bool":
        r"""
        Gets and sets the 'Optional' property value of the operation.
        Gets/sets true if the operation is optional.
        """
        return _cam.CAMFolder__get_isOptional(self)

    def _set_isOptional(self, value: "bool") -> "bool":
        r"""
        Gets and sets the 'Optional' property value of the operation.
        Gets/sets true if the operation is optional.
        """
        return _cam.CAMFolder__set_isOptional(self, value)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets the 'Suppressed' property value of the operation.
        Gets/sets true if the operation is suppressed.
        """
        return _cam.CAMFolder__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets the 'Suppressed' property value of the operation.
        Gets/sets true if the operation is suppressed.
        """
        return _cam.CAMFolder__set_isSuppressed(self, value)

    def _get_parentSetup(self) -> "adsk::core::Ptr< adsk::cam::Setup >":
        r"""Gets the Setup this operation belongs to."""
        return _cam.CAMFolder__get_parentSetup(self)

    def _get_isSelected(self) -> "bool":
        r"""Gets if this operation is selected in the 'Setups' browser."""
        return _cam.CAMFolder__get_isSelected(self)

    def _get_notes(self) -> "std::string":
        r"""Gets and sets the notes of the operation."""
        return _cam.CAMFolder__get_notes(self)

    def _set_notes(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the notes of the operation."""
        return _cam.CAMFolder__set_notes(self, value)

    def _get_operationId(self) -> "int":
        r"""
        Returns the id of the operation. This id is unique as compared 
        to the ids of all other operations in the document. 
        This id will not change when changing the order or parent of the operation. 
        This id will remain valid when the document is saved and reloaded.
        """
        return _cam.CAMFolder__get_operationId(self)

    def _get_parameters(self) -> "adsk::core::Ptr< adsk::cam::CAMParameters >":
        r"""Gets the CAMParameters collection for this operation."""
        return _cam.CAMFolder__get_parameters(self)

    def _get_objectType(self) -> "char const *":
        return _cam.CAMFolder__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.CAMFolder__get_isValid(self)

# Register CAMFolder in _cam:
_cam.CAMFolder_swigregister(CAMFolder)

def CAMFolder_classType() -> "char const *":
    return _cam.CAMFolder_classType()


CAMFolder.isActive = property(CAMFolder._get_isActive, doc="Gets if this folder is active.")


CAMFolder.operations = property(CAMFolder._get_operations, doc="Returns the Operations collection that provides access to existing individual operations\nin this folder.")


CAMFolder.folders = property(CAMFolder._get_folders, doc="Returns the Folders collection that provides access to existing folders\nin this folder.")


CAMFolder.patterns = property(CAMFolder._get_patterns, doc="Returns the Patterns collection that provides access to existing patterns\nin this folder.")


CAMFolder.children = property(CAMFolder._get_children, doc="Returns a collection containing all of the immediate (top level) child operations, folders and patterns in this folder\nin the order they appear in the browser.")


CAMFolder.parent = property(CAMFolder._get_parent, doc="Returns the parent Setup, Folder or Pattern for this Folder.")


CAMFolder.allOperations = property(CAMFolder._get_allOperations, doc="Gets a collection containing all of the operations in this folder.\nThis includes all operations nested in folders and patterns.")


CAMFolder.cast = lambda arg: arg if isinstance(arg, CAMFolder) else None

class LinearMachineAxis(MachineAxis):
    r"""Object that represents an axis with linear motion (e.g. X, Y, and Z)."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::LinearMachineAxis *":
        return _cam.LinearMachineAxis___deref__(self)

    def __eq__(self, rhs: "LinearMachineAxis") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.LinearMachineAxis___eq__(self, rhs)


    def __ne__(self, rhs: "LinearMachineAxis") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.LinearMachineAxis___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.LinearMachineAxis_classType()
    __swig_destroy__ = _cam.delete_LinearMachineAxis

    def _get_direction(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""The unit vector that represents the direction along which the axis will move."""
        return _cam.LinearMachineAxis__get_direction(self)

    def _set_direction(self, value: "Vector3D") -> "bool":
        r"""The unit vector that represents the direction along which the axis will move."""
        return _cam.LinearMachineAxis__set_direction(self, value)

    def _get_name(self) -> "std::string":
        r"""The name of this axis."""
        return _cam.LinearMachineAxis__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""The name of this axis."""
        return _cam.LinearMachineAxis__set_name(self, value)

    def _get_axisType(self) -> "adsk::cam::MachineAxisTypes":
        r"""The type of axis."""
        return _cam.LinearMachineAxis__get_axisType(self)

    def _get_hasLimits(self) -> "bool":
        r"""Does this axis have a limited range of motion."""
        return _cam.LinearMachineAxis__get_hasLimits(self)

    def _get_physicalMin(self) -> "double":
        r"""
        The minimum possible value for this axis (in mm/deg).
        Must be less than physicalMax.
        Set the value of this and physicalMax to 0 to remove
        axis limits.
        """
        return _cam.LinearMachineAxis__get_physicalMin(self)

    def _set_physicalMin(self, value: "double") -> "bool":
        r"""
        The minimum possible value for this axis (in mm/deg).
        Must be less than physicalMax.
        Set the value of this and physicalMax to 0 to remove
        axis limits.
        """
        return _cam.LinearMachineAxis__set_physicalMin(self, value)

    def _get_physicalMax(self) -> "double":
        r"""
        The maximum possible value for this axis (in mm/deg).
        Must be less than physicalMin.
        Set the value of this and physicalMin to 0 to remove
        axis limits.
        """
        return _cam.LinearMachineAxis__get_physicalMax(self)

    def _set_physicalMax(self, value: "double") -> "bool":
        r"""
        The maximum possible value for this axis (in mm/deg).
        Must be less than physicalMin.
        Set the value of this and physicalMin to 0 to remove
        axis limits.
        """
        return _cam.LinearMachineAxis__set_physicalMax(self, value)

    def _get_homePosition(self) -> "double":
        r"""Specifies the value (in mm/deg) that this axis returns to when the machine is homed."""
        return _cam.LinearMachineAxis__get_homePosition(self)

    def _set_homePosition(self, value: "double") -> "bool":
        r"""Specifies the value (in mm/deg) that this axis returns to when the machine is homed."""
        return _cam.LinearMachineAxis__set_homePosition(self, value)

    def _get_objectType(self) -> "char const *":
        return _cam.LinearMachineAxis__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.LinearMachineAxis__get_isValid(self)

# Register LinearMachineAxis in _cam:
_cam.LinearMachineAxis_swigregister(LinearMachineAxis)

def LinearMachineAxis_classType() -> "char const *":
    return _cam.LinearMachineAxis_classType()


LinearMachineAxis.direction = property(LinearMachineAxis._get_direction, LinearMachineAxis._set_direction, doc="The unit vector that represents the direction along which the axis will move.")


LinearMachineAxis.cast = lambda arg: arg if isinstance(arg, LinearMachineAxis) else None

class LinearMachineAxisInput(MachineAxisInput):
    r"""Object that defines the properties required to create a new linear machine axis object."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::LinearMachineAxisInput *":
        return _cam.LinearMachineAxisInput___deref__(self)

    def __eq__(self, rhs: "LinearMachineAxisInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.LinearMachineAxisInput___eq__(self, rhs)


    def __ne__(self, rhs: "LinearMachineAxisInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.LinearMachineAxisInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.LinearMachineAxisInput_classType()
    __swig_destroy__ = _cam.delete_LinearMachineAxisInput

    def _get_direction(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        The unit vector that represents the direction along which the linear axis will move.
        This vector is in the machine's coordinate system (e.g. the X axis is always (1,0,0)).
        """
        return _cam.LinearMachineAxisInput__get_direction(self)

    def _set_direction(self, value: "Vector3D") -> "bool":
        r"""
        The unit vector that represents the direction along which the linear axis will move.
        This vector is in the machine's coordinate system (e.g. the X axis is always (1,0,0)).
        """
        return _cam.LinearMachineAxisInput__set_direction(self, value)

    def _get_axisType(self) -> "adsk::cam::MachineAxisTypes":
        r"""
        The type of axis.
        This axis type determines which parameters of this object are valid to be accessed
        or modified.
        """
        return _cam.LinearMachineAxisInput__get_axisType(self)

    def _get_name(self) -> "std::string":
        r"""The user facing name of this axis."""
        return _cam.LinearMachineAxisInput__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""The user facing name of this axis."""
        return _cam.LinearMachineAxisInput__set_name(self, value)

    def _get_homePosition(self) -> "double":
        r"""Specifies the value (in mm/deg) that this axis returns to when the machine is homed."""
        return _cam.LinearMachineAxisInput__get_homePosition(self)

    def _set_homePosition(self, value: "double") -> "bool":
        r"""Specifies the value (in mm/deg) that this axis returns to when the machine is homed."""
        return _cam.LinearMachineAxisInput__set_homePosition(self, value)

    def _get_physicalMin(self) -> "double":
        r"""
        The minimum possible value for this axis (in mm/deg).
        Set the value of this and physicalMax to 0 to create an
        unlimited axis.
        """
        return _cam.LinearMachineAxisInput__get_physicalMin(self)

    def _set_physicalMin(self, value: "double") -> "bool":
        r"""
        The minimum possible value for this axis (in mm/deg).
        Set the value of this and physicalMax to 0 to create an
        unlimited axis.
        """
        return _cam.LinearMachineAxisInput__set_physicalMin(self, value)

    def _get_physicalMax(self) -> "double":
        r"""
        The maximum possible value for this axis (in mm/deg).
        Set the value of this and physicalMin to 0 to create an
        unlimited axis.
        """
        return _cam.LinearMachineAxisInput__get_physicalMax(self)

    def _set_physicalMax(self, value: "double") -> "bool":
        r"""
        The maximum possible value for this axis (in mm/deg).
        Set the value of this and physicalMin to 0 to create an
        unlimited axis.
        """
        return _cam.LinearMachineAxisInput__set_physicalMax(self, value)

    def _get_objectType(self) -> "char const *":
        return _cam.LinearMachineAxisInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.LinearMachineAxisInput__get_isValid(self)

# Register LinearMachineAxisInput in _cam:
_cam.LinearMachineAxisInput_swigregister(LinearMachineAxisInput)

def LinearMachineAxisInput_classType() -> "char const *":
    return _cam.LinearMachineAxisInput_classType()


LinearMachineAxisInput.direction = property(LinearMachineAxisInput._get_direction, LinearMachineAxisInput._set_direction, doc="The unit vector that represents the direction along which the linear axis will move.\nThis vector is in the machine's coordinate system (e.g. the X axis is always (1,0,0)).")


LinearMachineAxisInput.cast = lambda arg: arg if isinstance(arg, LinearMachineAxisInput) else None

class Operation(OperationBase):
    r"""Object that represents an operation in an existing Setup, Folder or Pattern."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::Operation *":
        return _cam.Operation___deref__(self)

    def __eq__(self, rhs: "Operation") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.Operation___eq__(self, rhs)


    def __ne__(self, rhs: "Operation") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.Operation___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.Operation_classType()
    __swig_destroy__ = _cam.delete_Operation

    def _get_strategyType(self) -> "adsk::cam::OperationStrategyTypes":
        r"""Gets the strategy type for this operation."""
        return _cam.Operation__get_strategyType(self)

    def _get_isToolpathValid(self) -> "bool":
        r"""Gets if the toolpath for this operation is currently valid. (has not become invalidated by model changes)."""
        return _cam.Operation__get_isToolpathValid(self)

    def _get_isGenerating(self) -> "bool":
        r"""Gets if the toolpath is in the process of generating."""
        return _cam.Operation__get_isGenerating(self)

    def _get_hasWarning(self) -> "bool":
        r"""Gets if problems were encountered when generating the toolpath for this operation."""
        return _cam.Operation__get_hasWarning(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the parent Setup, Folder or Pattern for this operation."""
        return _cam.Operation__get_parent(self)

    def _get_hasToolpath(self) -> "bool":
        r"""Gets if a toolpath currently exists (has been generated) for this operation."""
        return _cam.Operation__get_hasToolpath(self)

    def _get_operationState(self) -> "adsk::cam::OperationStates":
        r"""Gets the current state of this operation."""
        return _cam.Operation__get_operationState(self)

    def _get_generatingProgress(self) -> "std::string":
        r"""Gets the toolpath generation progress value for this operation."""
        return _cam.Operation__get_generatingProgress(self)

    def _get_name(self) -> "std::string":
        r"""
        Gets and sets the name of the operation as seen in the browser. This name is unique as compared
        to the names of all other operations in the document.
        """
        return _cam.Operation__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the name of the operation as seen in the browser. This name is unique as compared
        to the names of all other operations in the document.
        """
        return _cam.Operation__set_name(self, value)

    def _get_isProtected(self) -> "bool":
        r"""
        Gets and sets the 'protected' property value of the operation.
        Gets/sets true if the operation is protected.
        """
        return _cam.Operation__get_isProtected(self)

    def _set_isProtected(self, value: "bool") -> "bool":
        r"""
        Gets and sets the 'protected' property value of the operation.
        Gets/sets true if the operation is protected.
        """
        return _cam.Operation__set_isProtected(self, value)

    def _get_isOptional(self) -> "bool":
        r"""
        Gets and sets the 'Optional' property value of the operation.
        Gets/sets true if the operation is optional.
        """
        return _cam.Operation__get_isOptional(self)

    def _set_isOptional(self, value: "bool") -> "bool":
        r"""
        Gets and sets the 'Optional' property value of the operation.
        Gets/sets true if the operation is optional.
        """
        return _cam.Operation__set_isOptional(self, value)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets the 'Suppressed' property value of the operation.
        Gets/sets true if the operation is suppressed.
        """
        return _cam.Operation__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets the 'Suppressed' property value of the operation.
        Gets/sets true if the operation is suppressed.
        """
        return _cam.Operation__set_isSuppressed(self, value)

    def _get_parentSetup(self) -> "adsk::core::Ptr< adsk::cam::Setup >":
        r"""Gets the Setup this operation belongs to."""
        return _cam.Operation__get_parentSetup(self)

    def _get_isSelected(self) -> "bool":
        r"""Gets if this operation is selected in the 'Setups' browser."""
        return _cam.Operation__get_isSelected(self)

    def _get_notes(self) -> "std::string":
        r"""Gets and sets the notes of the operation."""
        return _cam.Operation__get_notes(self)

    def _set_notes(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the notes of the operation."""
        return _cam.Operation__set_notes(self, value)

    def _get_operationId(self) -> "int":
        r"""
        Returns the id of the operation. This id is unique as compared 
        to the ids of all other operations in the document. 
        This id will not change when changing the order or parent of the operation. 
        This id will remain valid when the document is saved and reloaded.
        """
        return _cam.Operation__get_operationId(self)

    def _get_parameters(self) -> "adsk::core::Ptr< adsk::cam::CAMParameters >":
        r"""Gets the CAMParameters collection for this operation."""
        return _cam.Operation__get_parameters(self)

    def _get_objectType(self) -> "char const *":
        return _cam.Operation__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.Operation__get_isValid(self)

# Register Operation in _cam:
_cam.Operation_swigregister(Operation)

def Operation_classType() -> "char const *":
    return _cam.Operation_classType()


Operation.strategyType = property(Operation._get_strategyType, doc="Gets the strategy type for this operation.")


Operation.isToolpathValid = property(Operation._get_isToolpathValid, doc="Gets if the toolpath for this operation is currently valid. (has not become invalidated by model changes).")


Operation.isGenerating = property(Operation._get_isGenerating, doc="Gets if the toolpath is in the process of generating.")


Operation.hasWarning = property(Operation._get_hasWarning, doc="Gets if problems were encountered when generating the toolpath for this operation.")


Operation.parent = property(Operation._get_parent, doc="Returns the parent Setup, Folder or Pattern for this operation.")


Operation.hasToolpath = property(Operation._get_hasToolpath, doc="Gets if a toolpath currently exists (has been generated) for this operation.")


Operation.operationState = property(Operation._get_operationState, doc="Gets the current state of this operation.")


Operation.generatingProgress = property(Operation._get_generatingProgress, doc="Gets the toolpath generation progress value for this operation.")


Operation.cast = lambda arg: arg if isinstance(arg, Operation) else None

class RotaryMachineAxis(MachineAxis):
    r"""Object that represents an axis with rotary motion (e.g. A, B, and C)."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::RotaryMachineAxis *":
        return _cam.RotaryMachineAxis___deref__(self)

    def __eq__(self, rhs: "RotaryMachineAxis") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.RotaryMachineAxis___eq__(self, rhs)


    def __ne__(self, rhs: "RotaryMachineAxis") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.RotaryMachineAxis___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.RotaryMachineAxis_classType()
    __swig_destroy__ = _cam.delete_RotaryMachineAxis

    def _get_rotationAxis(self) -> "adsk::core::Ptr< adsk::core::InfiniteLine3D >":
        r"""The infinite line that defines the direction and location of the axis of rotation."""
        return _cam.RotaryMachineAxis__get_rotationAxis(self)

    def _set_rotationAxis(self, value: "InfiniteLine3D") -> "bool":
        r"""The infinite line that defines the direction and location of the axis of rotation."""
        return _cam.RotaryMachineAxis__set_rotationAxis(self, value)

    def _get_name(self) -> "std::string":
        r"""The name of this axis."""
        return _cam.RotaryMachineAxis__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""The name of this axis."""
        return _cam.RotaryMachineAxis__set_name(self, value)

    def _get_axisType(self) -> "adsk::cam::MachineAxisTypes":
        r"""The type of axis."""
        return _cam.RotaryMachineAxis__get_axisType(self)

    def _get_hasLimits(self) -> "bool":
        r"""Does this axis have a limited range of motion."""
        return _cam.RotaryMachineAxis__get_hasLimits(self)

    def _get_physicalMin(self) -> "double":
        r"""
        The minimum possible value for this axis (in mm/deg).
        Must be less than physicalMax.
        Set the value of this and physicalMax to 0 to remove
        axis limits.
        """
        return _cam.RotaryMachineAxis__get_physicalMin(self)

    def _set_physicalMin(self, value: "double") -> "bool":
        r"""
        The minimum possible value for this axis (in mm/deg).
        Must be less than physicalMax.
        Set the value of this and physicalMax to 0 to remove
        axis limits.
        """
        return _cam.RotaryMachineAxis__set_physicalMin(self, value)

    def _get_physicalMax(self) -> "double":
        r"""
        The maximum possible value for this axis (in mm/deg).
        Must be less than physicalMin.
        Set the value of this and physicalMin to 0 to remove
        axis limits.
        """
        return _cam.RotaryMachineAxis__get_physicalMax(self)

    def _set_physicalMax(self, value: "double") -> "bool":
        r"""
        The maximum possible value for this axis (in mm/deg).
        Must be less than physicalMin.
        Set the value of this and physicalMin to 0 to remove
        axis limits.
        """
        return _cam.RotaryMachineAxis__set_physicalMax(self, value)

    def _get_homePosition(self) -> "double":
        r"""Specifies the value (in mm/deg) that this axis returns to when the machine is homed."""
        return _cam.RotaryMachineAxis__get_homePosition(self)

    def _set_homePosition(self, value: "double") -> "bool":
        r"""Specifies the value (in mm/deg) that this axis returns to when the machine is homed."""
        return _cam.RotaryMachineAxis__set_homePosition(self, value)

    def _get_objectType(self) -> "char const *":
        return _cam.RotaryMachineAxis__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.RotaryMachineAxis__get_isValid(self)

# Register RotaryMachineAxis in _cam:
_cam.RotaryMachineAxis_swigregister(RotaryMachineAxis)

def RotaryMachineAxis_classType() -> "char const *":
    return _cam.RotaryMachineAxis_classType()


RotaryMachineAxis.rotationAxis = property(RotaryMachineAxis._get_rotationAxis, RotaryMachineAxis._set_rotationAxis, doc="The infinite line that defines the direction and location of the axis of rotation.")


RotaryMachineAxis.cast = lambda arg: arg if isinstance(arg, RotaryMachineAxis) else None

class RotaryMachineAxisInput(MachineAxisInput):
    r"""Object that defines the properties required to create a new rotary machine axis object."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::RotaryMachineAxisInput *":
        return _cam.RotaryMachineAxisInput___deref__(self)

    def __eq__(self, rhs: "RotaryMachineAxisInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.RotaryMachineAxisInput___eq__(self, rhs)


    def __ne__(self, rhs: "RotaryMachineAxisInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.RotaryMachineAxisInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.RotaryMachineAxisInput_classType()
    __swig_destroy__ = _cam.delete_RotaryMachineAxisInput

    def _get_rotationAxis(self) -> "adsk::core::Ptr< adsk::core::InfiniteLine3D >":
        r"""
        The infinite line that defines the direction and location of the axis of rotation.
        This direction is in the machine's coordinate system (e.g. an A axis would
        typically use (1,0,0) for the direction), and follows the right-hand rule.
        """
        return _cam.RotaryMachineAxisInput__get_rotationAxis(self)

    def _set_rotationAxis(self, value: "InfiniteLine3D") -> "bool":
        r"""
        The infinite line that defines the direction and location of the axis of rotation.
        This direction is in the machine's coordinate system (e.g. an A axis would
        typically use (1,0,0) for the direction), and follows the right-hand rule.
        """
        return _cam.RotaryMachineAxisInput__set_rotationAxis(self, value)

    def _get_axisType(self) -> "adsk::cam::MachineAxisTypes":
        r"""
        The type of axis.
        This axis type determines which parameters of this object are valid to be accessed
        or modified.
        """
        return _cam.RotaryMachineAxisInput__get_axisType(self)

    def _get_name(self) -> "std::string":
        r"""The user facing name of this axis."""
        return _cam.RotaryMachineAxisInput__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""The user facing name of this axis."""
        return _cam.RotaryMachineAxisInput__set_name(self, value)

    def _get_homePosition(self) -> "double":
        r"""Specifies the value (in mm/deg) that this axis returns to when the machine is homed."""
        return _cam.RotaryMachineAxisInput__get_homePosition(self)

    def _set_homePosition(self, value: "double") -> "bool":
        r"""Specifies the value (in mm/deg) that this axis returns to when the machine is homed."""
        return _cam.RotaryMachineAxisInput__set_homePosition(self, value)

    def _get_physicalMin(self) -> "double":
        r"""
        The minimum possible value for this axis (in mm/deg).
        Set the value of this and physicalMax to 0 to create an
        unlimited axis.
        """
        return _cam.RotaryMachineAxisInput__get_physicalMin(self)

    def _set_physicalMin(self, value: "double") -> "bool":
        r"""
        The minimum possible value for this axis (in mm/deg).
        Set the value of this and physicalMax to 0 to create an
        unlimited axis.
        """
        return _cam.RotaryMachineAxisInput__set_physicalMin(self, value)

    def _get_physicalMax(self) -> "double":
        r"""
        The maximum possible value for this axis (in mm/deg).
        Set the value of this and physicalMin to 0 to create an
        unlimited axis.
        """
        return _cam.RotaryMachineAxisInput__get_physicalMax(self)

    def _set_physicalMax(self, value: "double") -> "bool":
        r"""
        The maximum possible value for this axis (in mm/deg).
        Set the value of this and physicalMin to 0 to create an
        unlimited axis.
        """
        return _cam.RotaryMachineAxisInput__set_physicalMax(self, value)

    def _get_objectType(self) -> "char const *":
        return _cam.RotaryMachineAxisInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.RotaryMachineAxisInput__get_isValid(self)

# Register RotaryMachineAxisInput in _cam:
_cam.RotaryMachineAxisInput_swigregister(RotaryMachineAxisInput)

def RotaryMachineAxisInput_classType() -> "char const *":
    return _cam.RotaryMachineAxisInput_classType()


RotaryMachineAxisInput.rotationAxis = property(RotaryMachineAxisInput._get_rotationAxis, RotaryMachineAxisInput._set_rotationAxis, doc="The infinite line that defines the direction and location of the axis of rotation.\nThis direction is in the machine's coordinate system (e.g. an A axis would\ntypically use (1,0,0) for the direction), and follows the right-hand rule.")


RotaryMachineAxisInput.cast = lambda arg: arg if isinstance(arg, RotaryMachineAxisInput) else None

class Setup(OperationBase):
    r"""Object that represents an existing Setup."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::Setup *":
        return _cam.Setup___deref__(self)

    def __eq__(self, rhs: "Setup") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.Setup___eq__(self, rhs)


    def __ne__(self, rhs: "Setup") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.Setup___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.Setup_classType()
    __swig_destroy__ = _cam.delete_Setup

    def _get_operationType(self) -> "adsk::cam::OperationTypes":
        r"""
        Gets the Operation Type.
        It can be MillingOperation, TurningOperation, JetOperation or AdditiveOperation.
        """
        return _cam.Setup__get_operationType(self)

    def _get_isActive(self) -> "bool":
        r"""Gets if this setup is active."""
        return _cam.Setup__get_isActive(self)

    def _get_operations(self) -> "adsk::core::Ptr< adsk::cam::Operations >":
        r"""
        Returns the Operations collection that provides access to existing operations
        in this setup.
        """
        return _cam.Setup__get_operations(self)

    def _get_folders(self) -> "adsk::core::Ptr< adsk::cam::CAMFolders >":
        r"""
        Returns the Folders collection that provides access to existing folders
        in this setup.
        """
        return _cam.Setup__get_folders(self)

    def _get_patterns(self) -> "adsk::core::Ptr< adsk::cam::CAMPatterns >":
        r"""
        Returns the Patterns collection that provides access to existing patterns
        in this setup.
        """
        return _cam.Setup__get_patterns(self)

    def _get_children(self) -> "adsk::core::Ptr< adsk::cam::ChildOperationList >":
        r"""
        Returns a collection containing all of the immediate (top level) child operations, folders and patterns in this setup
        in the order they appear in the browser.
        """
        return _cam.Setup__get_children(self)

    def _get_allOperations(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets a collection containing all of the operations in this setup.
        This includes all operations nested in folders and patterns.
        """
        return _cam.Setup__get_allOperations(self)

    def _get_models(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the bodies associated with the setup. Passing in an empty ObjectCollection
        will remove all current bodies. Valid input is MeshBody and/or BRepBody objects.
        """
        return _cam.Setup__get_models(self)

    def _set_models(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the bodies associated with the setup. Passing in an empty ObjectCollection
        will remove all current bodies. Valid input is MeshBody and/or BRepBody objects.
        """
        return _cam.Setup__set_models(self, value)

    def _get_fixtures(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""Gets the fixtures associated with the setup."""
        return _cam.Setup__get_fixtures(self)

    def _get_stockSolids(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""Gets the stock solids associated with the setup."""
        return _cam.Setup__get_stockSolids(self)

    def _get_machine(self) -> "adsk::core::Ptr< adsk::cam::Machine >":
        r"""Gets the Machine associated with the setup."""
        return _cam.Setup__get_machine(self)

    def createFromTemplate(self, templateFilePath: "std::string const &") -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Create and add operations, folders or patterns from the specified template file to the end of this setup. 
        templateFilePath : The full path to the template file. 
        Returns the collection containing all of the operations, folders and patterns created from the template file.
        """
        return _cam.Setup_createFromTemplate(self, templateFilePath)

    def _get_name(self) -> "std::string":
        r"""
        Gets and sets the name of the operation as seen in the browser. This name is unique as compared
        to the names of all other operations in the document.
        """
        return _cam.Setup__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the name of the operation as seen in the browser. This name is unique as compared
        to the names of all other operations in the document.
        """
        return _cam.Setup__set_name(self, value)

    def _get_isProtected(self) -> "bool":
        r"""
        Gets and sets the 'protected' property value of the operation.
        Gets/sets true if the operation is protected.
        """
        return _cam.Setup__get_isProtected(self)

    def _set_isProtected(self, value: "bool") -> "bool":
        r"""
        Gets and sets the 'protected' property value of the operation.
        Gets/sets true if the operation is protected.
        """
        return _cam.Setup__set_isProtected(self, value)

    def _get_isOptional(self) -> "bool":
        r"""
        Gets and sets the 'Optional' property value of the operation.
        Gets/sets true if the operation is optional.
        """
        return _cam.Setup__get_isOptional(self)

    def _set_isOptional(self, value: "bool") -> "bool":
        r"""
        Gets and sets the 'Optional' property value of the operation.
        Gets/sets true if the operation is optional.
        """
        return _cam.Setup__set_isOptional(self, value)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets the 'Suppressed' property value of the operation.
        Gets/sets true if the operation is suppressed.
        """
        return _cam.Setup__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets the 'Suppressed' property value of the operation.
        Gets/sets true if the operation is suppressed.
        """
        return _cam.Setup__set_isSuppressed(self, value)

    def _get_parentSetup(self) -> "adsk::core::Ptr< adsk::cam::Setup >":
        r"""Gets the Setup this operation belongs to."""
        return _cam.Setup__get_parentSetup(self)

    def _get_isSelected(self) -> "bool":
        r"""Gets if this operation is selected in the 'Setups' browser."""
        return _cam.Setup__get_isSelected(self)

    def _get_notes(self) -> "std::string":
        r"""Gets and sets the notes of the operation."""
        return _cam.Setup__get_notes(self)

    def _set_notes(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the notes of the operation."""
        return _cam.Setup__set_notes(self, value)

    def _get_operationId(self) -> "int":
        r"""
        Returns the id of the operation. This id is unique as compared 
        to the ids of all other operations in the document. 
        This id will not change when changing the order or parent of the operation. 
        This id will remain valid when the document is saved and reloaded.
        """
        return _cam.Setup__get_operationId(self)

    def _get_parameters(self) -> "adsk::core::Ptr< adsk::cam::CAMParameters >":
        r"""Gets the CAMParameters collection for this operation."""
        return _cam.Setup__get_parameters(self)

    def _get_objectType(self) -> "char const *":
        return _cam.Setup__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.Setup__get_isValid(self)

# Register Setup in _cam:
_cam.Setup_swigregister(Setup)

def Setup_classType() -> "char const *":
    return _cam.Setup_classType()


Setup.operationType = property(Setup._get_operationType, doc="Gets the Operation Type.\nIt can be MillingOperation, TurningOperation, JetOperation or AdditiveOperation.")


Setup.isActive = property(Setup._get_isActive, doc="Gets if this setup is active.")


Setup.operations = property(Setup._get_operations, doc="Returns the Operations collection that provides access to existing operations\nin this setup.")


Setup.folders = property(Setup._get_folders, doc="Returns the Folders collection that provides access to existing folders\nin this setup.")


Setup.patterns = property(Setup._get_patterns, doc="Returns the Patterns collection that provides access to existing patterns\nin this setup.")


Setup.children = property(Setup._get_children, doc="Returns a collection containing all of the immediate (top level) child operations, folders and patterns in this setup\nin the order they appear in the browser.")


Setup.allOperations = property(Setup._get_allOperations, doc="Gets a collection containing all of the operations in this setup.\nThis includes all operations nested in folders and patterns.")


Setup.models = property(Setup._get_models, Setup._set_models, doc="Gets and sets the bodies associated with the setup. Passing in an empty ObjectCollection\nwill remove all current bodies. Valid input is MeshBody and/or BRepBody objects.")


Setup.fixtures = property(Setup._get_fixtures, doc="Gets the fixtures associated with the setup.")


Setup.stockSolids = property(Setup._get_stockSolids, doc="Gets the stock solids associated with the setup.")


Setup.machine = property(Setup._get_machine, doc="Gets the Machine associated with the setup.")


Setup.cast = lambda arg: arg if isinstance(arg, Setup) else None

class CAMPattern(CAMFolder):
    r"""Object that represents a pattern in an existing Setup, Folder or Pattern."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::cam::CAMPattern *":
        return _cam.CAMPattern___deref__(self)

    def __eq__(self, rhs: "CAMPattern") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _cam.CAMPattern___eq__(self, rhs)


    def __ne__(self, rhs: "CAMPattern") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _cam.CAMPattern___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _cam.CAMPattern_classType()
    __swig_destroy__ = _cam.delete_CAMPattern

    def _get_isActive(self) -> "bool":
        r"""Gets if this folder is active."""
        return _cam.CAMPattern__get_isActive(self)

    def _get_operations(self) -> "adsk::core::Ptr< adsk::cam::Operations >":
        r"""
        Returns the Operations collection that provides access to existing individual operations
        in this folder.
        """
        return _cam.CAMPattern__get_operations(self)

    def _get_folders(self) -> "adsk::core::Ptr< adsk::cam::CAMFolders >":
        r"""
        Returns the Folders collection that provides access to existing folders
        in this folder.
        """
        return _cam.CAMPattern__get_folders(self)

    def _get_patterns(self) -> "adsk::core::Ptr< adsk::cam::CAMPatterns >":
        r"""
        Returns the Patterns collection that provides access to existing patterns
        in this folder.
        """
        return _cam.CAMPattern__get_patterns(self)

    def _get_children(self) -> "adsk::core::Ptr< adsk::cam::ChildOperationList >":
        r"""
        Returns a collection containing all of the immediate (top level) child operations, folders and patterns in this folder
        in the order they appear in the browser.
        """
        return _cam.CAMPattern__get_children(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the parent Setup, Folder or Pattern for this Folder."""
        return _cam.CAMPattern__get_parent(self)

    def _get_allOperations(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets a collection containing all of the operations in this folder.
        This includes all operations nested in folders and patterns.
        """
        return _cam.CAMPattern__get_allOperations(self)

    def createFromTemplate(self, templateFilePath: "std::string const &") -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Create and add operations, folders or patterns from the specified template file to the end of this folder. 
        templateFilePath : The full path to the template file. 
        Returns the collection containing all of the operations, folders and patterns created from the template file.
        """
        return _cam.CAMPattern_createFromTemplate(self, templateFilePath)

    def _get_name(self) -> "std::string":
        r"""
        Gets and sets the name of the operation as seen in the browser. This name is unique as compared
        to the names of all other operations in the document.
        """
        return _cam.CAMPattern__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the name of the operation as seen in the browser. This name is unique as compared
        to the names of all other operations in the document.
        """
        return _cam.CAMPattern__set_name(self, value)

    def _get_isProtected(self) -> "bool":
        r"""
        Gets and sets the 'protected' property value of the operation.
        Gets/sets true if the operation is protected.
        """
        return _cam.CAMPattern__get_isProtected(self)

    def _set_isProtected(self, value: "bool") -> "bool":
        r"""
        Gets and sets the 'protected' property value of the operation.
        Gets/sets true if the operation is protected.
        """
        return _cam.CAMPattern__set_isProtected(self, value)

    def _get_isOptional(self) -> "bool":
        r"""
        Gets and sets the 'Optional' property value of the operation.
        Gets/sets true if the operation is optional.
        """
        return _cam.CAMPattern__get_isOptional(self)

    def _set_isOptional(self, value: "bool") -> "bool":
        r"""
        Gets and sets the 'Optional' property value of the operation.
        Gets/sets true if the operation is optional.
        """
        return _cam.CAMPattern__set_isOptional(self, value)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets the 'Suppressed' property value of the operation.
        Gets/sets true if the operation is suppressed.
        """
        return _cam.CAMPattern__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets the 'Suppressed' property value of the operation.
        Gets/sets true if the operation is suppressed.
        """
        return _cam.CAMPattern__set_isSuppressed(self, value)

    def _get_parentSetup(self) -> "adsk::core::Ptr< adsk::cam::Setup >":
        r"""Gets the Setup this operation belongs to."""
        return _cam.CAMPattern__get_parentSetup(self)

    def _get_isSelected(self) -> "bool":
        r"""Gets if this operation is selected in the 'Setups' browser."""
        return _cam.CAMPattern__get_isSelected(self)

    def _get_notes(self) -> "std::string":
        r"""Gets and sets the notes of the operation."""
        return _cam.CAMPattern__get_notes(self)

    def _set_notes(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the notes of the operation."""
        return _cam.CAMPattern__set_notes(self, value)

    def _get_operationId(self) -> "int":
        r"""
        Returns the id of the operation. This id is unique as compared 
        to the ids of all other operations in the document. 
        This id will not change when changing the order or parent of the operation. 
        This id will remain valid when the document is saved and reloaded.
        """
        return _cam.CAMPattern__get_operationId(self)

    def _get_parameters(self) -> "adsk::core::Ptr< adsk::cam::CAMParameters >":
        r"""Gets the CAMParameters collection for this operation."""
        return _cam.CAMPattern__get_parameters(self)

    def _get_objectType(self) -> "char const *":
        return _cam.CAMPattern__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _cam.CAMPattern__get_isValid(self)

# Register CAMPattern in _cam:
_cam.CAMPattern_swigregister(CAMPattern)

def CAMPattern_classType() -> "char const *":
    return _cam.CAMPattern_classType()


CAMPattern.cast = lambda arg: arg if isinstance(arg, CAMPattern) else None



