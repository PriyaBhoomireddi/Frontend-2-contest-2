# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _fusion
else:
    import _fusion

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fusion.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _fusion.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _fusion.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _fusion.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _fusion.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _fusion.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _fusion.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _fusion.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _fusion.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _fusion.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _fusion.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _fusion.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _fusion.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _fusion.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _fusion.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _fusion.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _fusion.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _fusion:
_fusion.SwigPyIterator_swigregister(SwigPyIterator)

class StringVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.StringVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.StringVector___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _fusion.StringVector___len__(self)

    def __getslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "std::vector< std::string,std::allocator< std::string > > *":
        return _fusion.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.StringVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "void":
        return _fusion.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.StringVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _fusion.StringVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.StringVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _fusion.StringVector_pop(self)

    def append(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _fusion.StringVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.StringVector_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _fusion.StringVector_size(self)

    def swap(self, v: "StringVector") -> "void":
        return _fusion.StringVector_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _fusion.StringVector_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _fusion.StringVector_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _fusion.StringVector_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _fusion.StringVector_rend(self)

    def clear(self) -> "void":
        return _fusion.StringVector_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _fusion.StringVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.StringVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _fusion.StringVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.StringVector_swiginit(self, _fusion.new_StringVector(*args))

    def push_back(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _fusion.StringVector_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _fusion.StringVector_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _fusion.StringVector_back(self)

    def assign(self, n: "std::vector< std::string >::size_type", x: "std::vector< std::string >::value_type const &") -> "void":
        return _fusion.StringVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.StringVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.StringVector_insert(self, *args)

    def reserve(self, n: "std::vector< std::string >::size_type") -> "void":
        return _fusion.StringVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _fusion.StringVector_capacity(self)
    __swig_destroy__ = _fusion.delete_StringVector

# Register StringVector in _fusion:
_fusion.StringVector_swigregister(StringVector)

class DoubleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.DoubleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.DoubleVector___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _fusion.DoubleVector___len__(self)

    def __getslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "std::vector< double,std::allocator< double > > *":
        return _fusion.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "void":
        return _fusion.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _fusion.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.DoubleVector___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _fusion.DoubleVector_pop(self)

    def append(self, x: "std::vector< double >::value_type const &") -> "void":
        return _fusion.DoubleVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.DoubleVector_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _fusion.DoubleVector_size(self)

    def swap(self, v: "DoubleVector") -> "void":
        return _fusion.DoubleVector_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _fusion.DoubleVector_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _fusion.DoubleVector_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _fusion.DoubleVector_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _fusion.DoubleVector_rend(self)

    def clear(self) -> "void":
        return _fusion.DoubleVector_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _fusion.DoubleVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.DoubleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _fusion.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.DoubleVector_swiginit(self, _fusion.new_DoubleVector(*args))

    def push_back(self, x: "std::vector< double >::value_type const &") -> "void":
        return _fusion.DoubleVector_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _fusion.DoubleVector_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _fusion.DoubleVector_back(self)

    def assign(self, n: "std::vector< double >::size_type", x: "std::vector< double >::value_type const &") -> "void":
        return _fusion.DoubleVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.DoubleVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.DoubleVector_insert(self, *args)

    def reserve(self, n: "std::vector< double >::size_type") -> "void":
        return _fusion.DoubleVector_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _fusion.DoubleVector_capacity(self)
    __swig_destroy__ = _fusion.delete_DoubleVector

# Register DoubleVector in _fusion:
_fusion.DoubleVector_swigregister(DoubleVector)

class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.IntVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.IntVector___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _fusion.IntVector___len__(self)

    def __getslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "std::vector< int,std::allocator< int > > *":
        return _fusion.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.IntVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "void":
        return _fusion.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.IntVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _fusion.IntVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.IntVector___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _fusion.IntVector_pop(self)

    def append(self, x: "std::vector< int >::value_type const &") -> "void":
        return _fusion.IntVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.IntVector_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _fusion.IntVector_size(self)

    def swap(self, v: "IntVector") -> "void":
        return _fusion.IntVector_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _fusion.IntVector_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _fusion.IntVector_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _fusion.IntVector_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _fusion.IntVector_rend(self)

    def clear(self) -> "void":
        return _fusion.IntVector_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _fusion.IntVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.IntVector_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _fusion.IntVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.IntVector_swiginit(self, _fusion.new_IntVector(*args))

    def push_back(self, x: "std::vector< int >::value_type const &") -> "void":
        return _fusion.IntVector_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _fusion.IntVector_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _fusion.IntVector_back(self)

    def assign(self, n: "std::vector< int >::size_type", x: "std::vector< int >::value_type const &") -> "void":
        return _fusion.IntVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.IntVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.IntVector_insert(self, *args)

    def reserve(self, n: "std::vector< int >::size_type") -> "void":
        return _fusion.IntVector_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _fusion.IntVector_capacity(self)
    __swig_destroy__ = _fusion.delete_IntVector

# Register IntVector in _fusion:
_fusion.IntVector_swigregister(IntVector)

class UintVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.UintVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.UintVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.UintVector___bool__(self)

    def __len__(self) -> "std::vector< size_t >::size_type":
        return _fusion.UintVector___len__(self)

    def __getslice__(self, i: "std::vector< size_t >::difference_type", j: "std::vector< size_t >::difference_type") -> "std::vector< size_t,std::allocator< size_t > > *":
        return _fusion.UintVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.UintVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< size_t >::difference_type", j: "std::vector< size_t >::difference_type") -> "void":
        return _fusion.UintVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.UintVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< size_t >::value_type const &":
        return _fusion.UintVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.UintVector___setitem__(self, *args)

    def pop(self) -> "std::vector< size_t >::value_type":
        return _fusion.UintVector_pop(self)

    def append(self, x: "std::vector< size_t >::value_type const &") -> "void":
        return _fusion.UintVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.UintVector_empty(self)

    def size(self) -> "std::vector< size_t >::size_type":
        return _fusion.UintVector_size(self)

    def swap(self, v: "UintVector") -> "void":
        return _fusion.UintVector_swap(self, v)

    def begin(self) -> "std::vector< size_t >::iterator":
        return _fusion.UintVector_begin(self)

    def end(self) -> "std::vector< size_t >::iterator":
        return _fusion.UintVector_end(self)

    def rbegin(self) -> "std::vector< size_t >::reverse_iterator":
        return _fusion.UintVector_rbegin(self)

    def rend(self) -> "std::vector< size_t >::reverse_iterator":
        return _fusion.UintVector_rend(self)

    def clear(self) -> "void":
        return _fusion.UintVector_clear(self)

    def get_allocator(self) -> "std::vector< size_t >::allocator_type":
        return _fusion.UintVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.UintVector_pop_back(self)

    def erase(self, *args) -> "std::vector< size_t >::iterator":
        return _fusion.UintVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.UintVector_swiginit(self, _fusion.new_UintVector(*args))

    def push_back(self, x: "std::vector< size_t >::value_type const &") -> "void":
        return _fusion.UintVector_push_back(self, x)

    def front(self) -> "std::vector< size_t >::value_type const &":
        return _fusion.UintVector_front(self)

    def back(self) -> "std::vector< size_t >::value_type const &":
        return _fusion.UintVector_back(self)

    def assign(self, n: "std::vector< size_t >::size_type", x: "std::vector< size_t >::value_type const &") -> "void":
        return _fusion.UintVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.UintVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.UintVector_insert(self, *args)

    def reserve(self, n: "std::vector< size_t >::size_type") -> "void":
        return _fusion.UintVector_reserve(self, n)

    def capacity(self) -> "std::vector< size_t >::size_type":
        return _fusion.UintVector_capacity(self)
    __swig_destroy__ = _fusion.delete_UintVector

# Register UintVector in _fusion:
_fusion.UintVector_swigregister(UintVector)

class ShortVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.ShortVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.ShortVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.ShortVector___bool__(self)

    def __len__(self) -> "std::vector< short >::size_type":
        return _fusion.ShortVector___len__(self)

    def __getslice__(self, i: "std::vector< short >::difference_type", j: "std::vector< short >::difference_type") -> "std::vector< short,std::allocator< short > > *":
        return _fusion.ShortVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.ShortVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< short >::difference_type", j: "std::vector< short >::difference_type") -> "void":
        return _fusion.ShortVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.ShortVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< short >::value_type const &":
        return _fusion.ShortVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.ShortVector___setitem__(self, *args)

    def pop(self) -> "std::vector< short >::value_type":
        return _fusion.ShortVector_pop(self)

    def append(self, x: "std::vector< short >::value_type const &") -> "void":
        return _fusion.ShortVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.ShortVector_empty(self)

    def size(self) -> "std::vector< short >::size_type":
        return _fusion.ShortVector_size(self)

    def swap(self, v: "ShortVector") -> "void":
        return _fusion.ShortVector_swap(self, v)

    def begin(self) -> "std::vector< short >::iterator":
        return _fusion.ShortVector_begin(self)

    def end(self) -> "std::vector< short >::iterator":
        return _fusion.ShortVector_end(self)

    def rbegin(self) -> "std::vector< short >::reverse_iterator":
        return _fusion.ShortVector_rbegin(self)

    def rend(self) -> "std::vector< short >::reverse_iterator":
        return _fusion.ShortVector_rend(self)

    def clear(self) -> "void":
        return _fusion.ShortVector_clear(self)

    def get_allocator(self) -> "std::vector< short >::allocator_type":
        return _fusion.ShortVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.ShortVector_pop_back(self)

    def erase(self, *args) -> "std::vector< short >::iterator":
        return _fusion.ShortVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.ShortVector_swiginit(self, _fusion.new_ShortVector(*args))

    def push_back(self, x: "std::vector< short >::value_type const &") -> "void":
        return _fusion.ShortVector_push_back(self, x)

    def front(self) -> "std::vector< short >::value_type const &":
        return _fusion.ShortVector_front(self)

    def back(self) -> "std::vector< short >::value_type const &":
        return _fusion.ShortVector_back(self)

    def assign(self, n: "std::vector< short >::size_type", x: "std::vector< short >::value_type const &") -> "void":
        return _fusion.ShortVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.ShortVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.ShortVector_insert(self, *args)

    def reserve(self, n: "std::vector< short >::size_type") -> "void":
        return _fusion.ShortVector_reserve(self, n)

    def capacity(self) -> "std::vector< short >::size_type":
        return _fusion.ShortVector_capacity(self)
    __swig_destroy__ = _fusion.delete_ShortVector

# Register ShortVector in _fusion:
_fusion.ShortVector_swigregister(ShortVector)

class FloatVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.FloatVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.FloatVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.FloatVector___bool__(self)

    def __len__(self) -> "std::vector< float >::size_type":
        return _fusion.FloatVector___len__(self)

    def __getslice__(self, i: "std::vector< float >::difference_type", j: "std::vector< float >::difference_type") -> "std::vector< float,std::allocator< float > > *":
        return _fusion.FloatVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.FloatVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< float >::difference_type", j: "std::vector< float >::difference_type") -> "void":
        return _fusion.FloatVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.FloatVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< float >::value_type const &":
        return _fusion.FloatVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.FloatVector___setitem__(self, *args)

    def pop(self) -> "std::vector< float >::value_type":
        return _fusion.FloatVector_pop(self)

    def append(self, x: "std::vector< float >::value_type const &") -> "void":
        return _fusion.FloatVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.FloatVector_empty(self)

    def size(self) -> "std::vector< float >::size_type":
        return _fusion.FloatVector_size(self)

    def swap(self, v: "FloatVector") -> "void":
        return _fusion.FloatVector_swap(self, v)

    def begin(self) -> "std::vector< float >::iterator":
        return _fusion.FloatVector_begin(self)

    def end(self) -> "std::vector< float >::iterator":
        return _fusion.FloatVector_end(self)

    def rbegin(self) -> "std::vector< float >::reverse_iterator":
        return _fusion.FloatVector_rbegin(self)

    def rend(self) -> "std::vector< float >::reverse_iterator":
        return _fusion.FloatVector_rend(self)

    def clear(self) -> "void":
        return _fusion.FloatVector_clear(self)

    def get_allocator(self) -> "std::vector< float >::allocator_type":
        return _fusion.FloatVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.FloatVector_pop_back(self)

    def erase(self, *args) -> "std::vector< float >::iterator":
        return _fusion.FloatVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.FloatVector_swiginit(self, _fusion.new_FloatVector(*args))

    def push_back(self, x: "std::vector< float >::value_type const &") -> "void":
        return _fusion.FloatVector_push_back(self, x)

    def front(self) -> "std::vector< float >::value_type const &":
        return _fusion.FloatVector_front(self)

    def back(self) -> "std::vector< float >::value_type const &":
        return _fusion.FloatVector_back(self)

    def assign(self, n: "std::vector< float >::size_type", x: "std::vector< float >::value_type const &") -> "void":
        return _fusion.FloatVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.FloatVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.FloatVector_insert(self, *args)

    def reserve(self, n: "std::vector< float >::size_type") -> "void":
        return _fusion.FloatVector_reserve(self, n)

    def capacity(self) -> "std::vector< float >::size_type":
        return _fusion.FloatVector_capacity(self)
    __swig_destroy__ = _fusion.delete_FloatVector

# Register FloatVector in _fusion:
_fusion.FloatVector_swigregister(FloatVector)

class Base(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::core::Base *":
        return _fusion.Base___deref__(self)

    def __eq__(self, rhs: "Application") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.Base___eq__(self, rhs)


    def __ne__(self, rhs: "Base") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.Base___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.Base_classType()
    __swig_destroy__ = _fusion.delete_Base

    def _get_objectType(self) -> "char const *":
        return _fusion.Base__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.Base__get_isValid(self)

# Register Base in _fusion:
_fusion.Base_swigregister(Base)

def Base_classType() -> "char const *":
    return _fusion.Base_classType()


Base.objectType = property(Base._get_objectType, doc="Returns a string indicating the type of the object.")
Base.isValid = property(Base._get_isValid, doc="Indicates if this object is still valid, i.e. hasn't been deleted or some other action done to invalidate the reference.")

import adsk.core
class PointContainment(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    PointInsidePointContainment = _fusion.PointContainment_PointInsidePointContainment
    PointOnPointContainment = _fusion.PointContainment_PointOnPointContainment
    PointOutsidePointContainment = _fusion.PointContainment_PointOutsidePointContainment
    UnknownPointContainment = _fusion.PointContainment_UnknownPointContainment

    def __init__(self):
        _fusion.PointContainment_swiginit(self, _fusion.new_PointContainment())
    __swig_destroy__ = _fusion.delete_PointContainment

# Register PointContainment in _fusion:
_fusion.PointContainment_swigregister(PointContainment)

class BRepConvertOptions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ProceduralToNURBSConversion = _fusion.BRepConvertOptions_ProceduralToNURBSConversion
    AnalyticsToNURBSConversion = _fusion.BRepConvertOptions_AnalyticsToNURBSConversion
    PlanesToNURBSConversion = _fusion.BRepConvertOptions_PlanesToNURBSConversion
    SplitPeriodicFacesConversion = _fusion.BRepConvertOptions_SplitPeriodicFacesConversion

    def __init__(self):
        _fusion.BRepConvertOptions_swiginit(self, _fusion.new_BRepConvertOptions())
    __swig_destroy__ = _fusion.delete_BRepConvertOptions

# Register BRepConvertOptions in _fusion:
_fusion.BRepConvertOptions_swigregister(BRepConvertOptions)

class CalculationAccuracy(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    LowCalculationAccuracy = _fusion.CalculationAccuracy_LowCalculationAccuracy
    MediumCalculationAccuracy = _fusion.CalculationAccuracy_MediumCalculationAccuracy
    HighCalculationAccuracy = _fusion.CalculationAccuracy_HighCalculationAccuracy
    VeryHighCalculationAccuracy = _fusion.CalculationAccuracy_VeryHighCalculationAccuracy

    def __init__(self):
        _fusion.CalculationAccuracy_swiginit(self, _fusion.new_CalculationAccuracy())
    __swig_destroy__ = _fusion.delete_CalculationAccuracy

# Register CalculationAccuracy in _fusion:
_fusion.CalculationAccuracy_swigregister(CalculationAccuracy)

class OffsetCornerTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    CircularOffsetCornerType = _fusion.OffsetCornerTypes_CircularOffsetCornerType
    LinearOffsetCornerType = _fusion.OffsetCornerTypes_LinearOffsetCornerType
    ExtendedOffsetCornerType = _fusion.OffsetCornerTypes_ExtendedOffsetCornerType

    def __init__(self):
        _fusion.OffsetCornerTypes_swiginit(self, _fusion.new_OffsetCornerTypes())
    __swig_destroy__ = _fusion.delete_OffsetCornerTypes

# Register OffsetCornerTypes in _fusion:
_fusion.OffsetCornerTypes_swigregister(OffsetCornerTypes)

class BooleanTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DifferenceBooleanType = _fusion.BooleanTypes_DifferenceBooleanType
    IntersectionBooleanType = _fusion.BooleanTypes_IntersectionBooleanType
    UnionBooleanType = _fusion.BooleanTypes_UnionBooleanType

    def __init__(self):
        _fusion.BooleanTypes_swiginit(self, _fusion.new_BooleanTypes())
    __swig_destroy__ = _fusion.delete_BooleanTypes

# Register BooleanTypes in _fusion:
_fusion.BooleanTypes_swigregister(BooleanTypes)

class BRepEntityTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BRepBodyEntityType = _fusion.BRepEntityTypes_BRepBodyEntityType
    BRepFaceEntityType = _fusion.BRepEntityTypes_BRepFaceEntityType
    BRepEdgeEntityType = _fusion.BRepEntityTypes_BRepEdgeEntityType
    BRepVertexEntityType = _fusion.BRepEntityTypes_BRepVertexEntityType

    def __init__(self):
        _fusion.BRepEntityTypes_swiginit(self, _fusion.new_BRepEntityTypes())
    __swig_destroy__ = _fusion.delete_BRepEntityTypes

# Register BRepEntityTypes in _fusion:
_fusion.BRepEntityTypes_swigregister(BRepEntityTypes)

class JointDirections(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    XAxisJointDirection = _fusion.JointDirections_XAxisJointDirection
    YAxisJointDirection = _fusion.JointDirections_YAxisJointDirection
    ZAxisJointDirection = _fusion.JointDirections_ZAxisJointDirection
    CustomJointDirection = _fusion.JointDirections_CustomJointDirection

    def __init__(self):
        _fusion.JointDirections_swiginit(self, _fusion.new_JointDirections())
    __swig_destroy__ = _fusion.delete_JointDirections

# Register JointDirections in _fusion:
_fusion.JointDirections_swigregister(JointDirections)

class FeatureHealthStates(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    HealthyFeatureHealthState = _fusion.FeatureHealthStates_HealthyFeatureHealthState
    WarningFeatureHealthState = _fusion.FeatureHealthStates_WarningFeatureHealthState
    ErrorFeatureHealthState = _fusion.FeatureHealthStates_ErrorFeatureHealthState
    SuppressedFeatureHealthState = _fusion.FeatureHealthStates_SuppressedFeatureHealthState
    RolledBackFeatureHealthState = _fusion.FeatureHealthStates_RolledBackFeatureHealthState
    UnknownFeatureHealthState = _fusion.FeatureHealthStates_UnknownFeatureHealthState

    def __init__(self):
        _fusion.FeatureHealthStates_swiginit(self, _fusion.new_FeatureHealthStates())
    __swig_destroy__ = _fusion.delete_FeatureHealthStates

# Register FeatureHealthStates in _fusion:
_fusion.FeatureHealthStates_swigregister(FeatureHealthStates)

class JointKeyPointTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    StartKeyPoint = _fusion.JointKeyPointTypes_StartKeyPoint
    MiddleKeyPoint = _fusion.JointKeyPointTypes_MiddleKeyPoint
    EndKeyPoint = _fusion.JointKeyPointTypes_EndKeyPoint
    CenterKeyPoint = _fusion.JointKeyPointTypes_CenterKeyPoint

    def __init__(self):
        _fusion.JointKeyPointTypes_swiginit(self, _fusion.new_JointKeyPointTypes())
    __swig_destroy__ = _fusion.delete_JointKeyPointTypes

# Register JointKeyPointTypes in _fusion:
_fusion.JointKeyPointTypes_swigregister(JointKeyPointTypes)

class JointGeometryTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    JointConstructionPointGeometry = _fusion.JointGeometryTypes_JointConstructionPointGeometry
    JointSketchPointGeometry = _fusion.JointGeometryTypes_JointSketchPointGeometry
    JointBRepVertexGeometry = _fusion.JointGeometryTypes_JointBRepVertexGeometry
    JointBRepEdgeGeometry = _fusion.JointGeometryTypes_JointBRepEdgeGeometry
    JointSketchCurveGeometry = _fusion.JointGeometryTypes_JointSketchCurveGeometry
    JointProfileGeometry = _fusion.JointGeometryTypes_JointProfileGeometry
    JointPlanarBRepFaceGeometry = _fusion.JointGeometryTypes_JointPlanarBRepFaceGeometry
    JointNonPlanarBRepFaceGeometry = _fusion.JointGeometryTypes_JointNonPlanarBRepFaceGeometry
    JointBetweenTwoPlanesGeometry = _fusion.JointGeometryTypes_JointBetweenTwoPlanesGeometry

    def __init__(self):
        _fusion.JointGeometryTypes_swiginit(self, _fusion.new_JointGeometryTypes())
    __swig_destroy__ = _fusion.delete_JointGeometryTypes

# Register JointGeometryTypes in _fusion:
_fusion.JointGeometryTypes_swigregister(JointGeometryTypes)

class JointTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    RigidJointType = _fusion.JointTypes_RigidJointType
    RevoluteJointType = _fusion.JointTypes_RevoluteJointType
    SliderJointType = _fusion.JointTypes_SliderJointType
    CylindricalJointType = _fusion.JointTypes_CylindricalJointType
    PinSlotJointType = _fusion.JointTypes_PinSlotJointType
    PlanarJointType = _fusion.JointTypes_PlanarJointType
    BallJointType = _fusion.JointTypes_BallJointType

    def __init__(self):
        _fusion.JointTypes_swiginit(self, _fusion.new_JointTypes())
    __swig_destroy__ = _fusion.delete_JointTypes

# Register JointTypes in _fusion:
_fusion.JointTypes_swigregister(JointTypes)

class ExtentDirections(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    PositiveExtentDirection = _fusion.ExtentDirections_PositiveExtentDirection
    NegativeExtentDirection = _fusion.ExtentDirections_NegativeExtentDirection
    SymmetricExtentDirection = _fusion.ExtentDirections_SymmetricExtentDirection

    def __init__(self):
        _fusion.ExtentDirections_swiginit(self, _fusion.new_ExtentDirections())
    __swig_destroy__ = _fusion.delete_ExtentDirections

# Register ExtentDirections in _fusion:
_fusion.ExtentDirections_swigregister(ExtentDirections)

class FeatureOperations(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    JoinFeatureOperation = _fusion.FeatureOperations_JoinFeatureOperation
    CutFeatureOperation = _fusion.FeatureOperations_CutFeatureOperation
    IntersectFeatureOperation = _fusion.FeatureOperations_IntersectFeatureOperation
    NewBodyFeatureOperation = _fusion.FeatureOperations_NewBodyFeatureOperation
    NewComponentFeatureOperation = _fusion.FeatureOperations_NewComponentFeatureOperation

    def __init__(self):
        _fusion.FeatureOperations_swiginit(self, _fusion.new_FeatureOperations())
    __swig_destroy__ = _fusion.delete_FeatureOperations

# Register FeatureOperations in _fusion:
_fusion.FeatureOperations_swigregister(FeatureOperations)

class PatternEntityTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    FacesPatternType = _fusion.PatternEntityTypes_FacesPatternType
    FeaturesPatternType = _fusion.PatternEntityTypes_FeaturesPatternType
    BodiesPatternType = _fusion.PatternEntityTypes_BodiesPatternType
    OccurrencesPatternType = _fusion.PatternEntityTypes_OccurrencesPatternType

    def __init__(self):
        _fusion.PatternEntityTypes_swiginit(self, _fusion.new_PatternEntityTypes())
    __swig_destroy__ = _fusion.delete_PatternEntityTypes

# Register PatternEntityTypes in _fusion:
_fusion.PatternEntityTypes_swigregister(PatternEntityTypes)

class FeatureExtentTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    OneSideFeatureExtentType = _fusion.FeatureExtentTypes_OneSideFeatureExtentType
    TwoSidesFeatureExtentType = _fusion.FeatureExtentTypes_TwoSidesFeatureExtentType
    SymmetricFeatureExtentType = _fusion.FeatureExtentTypes_SymmetricFeatureExtentType

    def __init__(self):
        _fusion.FeatureExtentTypes_swiginit(self, _fusion.new_FeatureExtentTypes())
    __swig_destroy__ = _fusion.delete_FeatureExtentTypes

# Register FeatureExtentTypes in _fusion:
_fusion.FeatureExtentTypes_swigregister(FeatureExtentTypes)

class ThinExtrudeWallLocation(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Side1 = _fusion.ThinExtrudeWallLocation_Side1
    Center = _fusion.ThinExtrudeWallLocation_Center
    Side2 = _fusion.ThinExtrudeWallLocation_Side2

    def __init__(self):
        _fusion.ThinExtrudeWallLocation_swiginit(self, _fusion.new_ThinExtrudeWallLocation())
    __swig_destroy__ = _fusion.delete_ThinExtrudeWallLocation

# Register ThinExtrudeWallLocation in _fusion:
_fusion.ThinExtrudeWallLocation_swigregister(ThinExtrudeWallLocation)

class HoleTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    SimpleHoleType = _fusion.HoleTypes_SimpleHoleType
    CounterboreHoleType = _fusion.HoleTypes_CounterboreHoleType
    CountersinkHoleType = _fusion.HoleTypes_CountersinkHoleType

    def __init__(self):
        _fusion.HoleTypes_swiginit(self, _fusion.new_HoleTypes())
    __swig_destroy__ = _fusion.delete_HoleTypes

# Register HoleTypes in _fusion:
_fusion.HoleTypes_swigregister(HoleTypes)

class HoleEdgePositions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EdgeStartPointPosition = _fusion.HoleEdgePositions_EdgeStartPointPosition
    EdgeMidPointPosition = _fusion.HoleEdgePositions_EdgeMidPointPosition
    EdgeEndPointPosition = _fusion.HoleEdgePositions_EdgeEndPointPosition

    def __init__(self):
        _fusion.HoleEdgePositions_swiginit(self, _fusion.new_HoleEdgePositions())
    __swig_destroy__ = _fusion.delete_HoleEdgePositions

# Register HoleEdgePositions in _fusion:
_fusion.HoleEdgePositions_swigregister(HoleEdgePositions)

class ChamferCornerTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ChamferCornerType = _fusion.ChamferCornerTypes_ChamferCornerType
    MiterCornerType = _fusion.ChamferCornerTypes_MiterCornerType
    BlendCornertype = _fusion.ChamferCornerTypes_BlendCornertype

    def __init__(self):
        _fusion.ChamferCornerTypes_swiginit(self, _fusion.new_ChamferCornerTypes())
    __swig_destroy__ = _fusion.delete_ChamferCornerTypes

# Register ChamferCornerTypes in _fusion:
_fusion.ChamferCornerTypes_swigregister(ChamferCornerTypes)

class ChamferTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EqualDistanceChamferType = _fusion.ChamferTypes_EqualDistanceChamferType
    TwoDistancesChamferType = _fusion.ChamferTypes_TwoDistancesChamferType
    DistanceAndAngleChamferType = _fusion.ChamferTypes_DistanceAndAngleChamferType

    def __init__(self):
        _fusion.ChamferTypes_swiginit(self, _fusion.new_ChamferTypes())
    __swig_destroy__ = _fusion.delete_ChamferTypes

# Register ChamferTypes in _fusion:
_fusion.ChamferTypes_swigregister(ChamferTypes)

class ChainedCurveOptions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    noChainedCurves = _fusion.ChainedCurveOptions_noChainedCurves
    connectedChainedCurves = _fusion.ChainedCurveOptions_connectedChainedCurves
    tangentChainedCurves = _fusion.ChainedCurveOptions_tangentChainedCurves
    openEdgesChainedCurves = _fusion.ChainedCurveOptions_openEdgesChainedCurves
    tangentAndOpenEdgesChainedCurves = _fusion.ChainedCurveOptions_tangentAndOpenEdgesChainedCurves

    def __init__(self):
        _fusion.ChainedCurveOptions_swiginit(self, _fusion.new_ChainedCurveOptions())
    __swig_destroy__ = _fusion.delete_ChainedCurveOptions

# Register ChainedCurveOptions in _fusion:
_fusion.ChainedCurveOptions_swigregister(ChainedCurveOptions)

class SweepOrientationTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ParallelOrientationType = _fusion.SweepOrientationTypes_ParallelOrientationType
    PerpendicularOrientationType = _fusion.SweepOrientationTypes_PerpendicularOrientationType

    def __init__(self):
        _fusion.SweepOrientationTypes_swiginit(self, _fusion.new_SweepOrientationTypes())
    __swig_destroy__ = _fusion.delete_SweepOrientationTypes

# Register SweepOrientationTypes in _fusion:
_fusion.SweepOrientationTypes_swigregister(SweepOrientationTypes)

class SweepProfileScalingOptions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    SweepProfileScaleOption = _fusion.SweepProfileScalingOptions_SweepProfileScaleOption
    SweepProfileStretchOption = _fusion.SweepProfileScalingOptions_SweepProfileStretchOption
    SweepProfileNoScalingOption = _fusion.SweepProfileScalingOptions_SweepProfileNoScalingOption

    def __init__(self):
        _fusion.SweepProfileScalingOptions_swiginit(self, _fusion.new_SweepProfileScalingOptions())
    __swig_destroy__ = _fusion.delete_SweepProfileScalingOptions

# Register SweepProfileScalingOptions in _fusion:
_fusion.SweepProfileScalingOptions_swigregister(SweepProfileScalingOptions)

class SweepExtentTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    PerpendicularToPathExtentType = _fusion.SweepExtentTypes_PerpendicularToPathExtentType
    FullExtentsExtentType = _fusion.SweepExtentTypes_FullExtentsExtentType

    def __init__(self):
        _fusion.SweepExtentTypes_swiginit(self, _fusion.new_SweepExtentTypes())
    __swig_destroy__ = _fusion.delete_SweepExtentTypes

# Register SweepExtentTypes in _fusion:
_fusion.SweepExtentTypes_swigregister(SweepExtentTypes)

class PatternComputeOptions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    OptimizedPatternCompute = _fusion.PatternComputeOptions_OptimizedPatternCompute
    IdenticalPatternCompute = _fusion.PatternComputeOptions_IdenticalPatternCompute
    AdjustPatternCompute = _fusion.PatternComputeOptions_AdjustPatternCompute

    def __init__(self):
        _fusion.PatternComputeOptions_swiginit(self, _fusion.new_PatternComputeOptions())
    __swig_destroy__ = _fusion.delete_PatternComputeOptions

# Register PatternComputeOptions in _fusion:
_fusion.PatternComputeOptions_swigregister(PatternComputeOptions)

class PatternDistanceType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ExtentPatternDistanceType = _fusion.PatternDistanceType_ExtentPatternDistanceType
    SpacingPatternDistanceType = _fusion.PatternDistanceType_SpacingPatternDistanceType

    def __init__(self):
        _fusion.PatternDistanceType_swiginit(self, _fusion.new_PatternDistanceType())
    __swig_destroy__ = _fusion.delete_PatternDistanceType

# Register PatternDistanceType in _fusion:
_fusion.PatternDistanceType_swigregister(PatternDistanceType)

class ThreadLocations(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    HighEndThreadLocation = _fusion.ThreadLocations_HighEndThreadLocation
    LowEndThreadLocation = _fusion.ThreadLocations_LowEndThreadLocation

    def __init__(self):
        _fusion.ThreadLocations_swiginit(self, _fusion.new_ThreadLocations())
    __swig_destroy__ = _fusion.delete_ThreadLocations

# Register ThreadLocations in _fusion:
_fusion.ThreadLocations_swigregister(ThreadLocations)

class SplitFaceSplitTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    surfaceIntersectionSplitType = _fusion.SplitFaceSplitTypes_surfaceIntersectionSplitType
    alongVectorSplitType = _fusion.SplitFaceSplitTypes_alongVectorSplitType
    closestPointSplitType = _fusion.SplitFaceSplitTypes_closestPointSplitType

    def __init__(self):
        _fusion.SplitFaceSplitTypes_swiginit(self, _fusion.new_SplitFaceSplitTypes())
    __swig_destroy__ = _fusion.delete_SplitFaceSplitTypes

# Register SplitFaceSplitTypes in _fusion:
_fusion.SplitFaceSplitTypes_swigregister(SplitFaceSplitTypes)

class SilhouetteSplitOperations(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    SilhouetteSplitFacesOnlyOperation = _fusion.SilhouetteSplitOperations_SilhouetteSplitFacesOnlyOperation
    SilhouetteSplitShelledBodyOperation = _fusion.SilhouetteSplitOperations_SilhouetteSplitShelledBodyOperation
    SilhouetteSplitSolidBodyOperation = _fusion.SilhouetteSplitOperations_SilhouetteSplitSolidBodyOperation

    def __init__(self):
        _fusion.SilhouetteSplitOperations_swiginit(self, _fusion.new_SilhouetteSplitOperations())
    __swig_destroy__ = _fusion.delete_SilhouetteSplitOperations

# Register SilhouetteSplitOperations in _fusion:
_fusion.SilhouetteSplitOperations_swigregister(SilhouetteSplitOperations)

class CoilFeatureTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    RevolutionsAndHeightCoilFeatureType = _fusion.CoilFeatureTypes_RevolutionsAndHeightCoilFeatureType
    RevolutionsAndPitchCoilFeatureType = _fusion.CoilFeatureTypes_RevolutionsAndPitchCoilFeatureType
    HeightAndPitchCoilFeatureType = _fusion.CoilFeatureTypes_HeightAndPitchCoilFeatureType
    SpiralCoilFeatureType = _fusion.CoilFeatureTypes_SpiralCoilFeatureType

    def __init__(self):
        _fusion.CoilFeatureTypes_swiginit(self, _fusion.new_CoilFeatureTypes())
    __swig_destroy__ = _fusion.delete_CoilFeatureTypes

# Register CoilFeatureTypes in _fusion:
_fusion.CoilFeatureTypes_swigregister(CoilFeatureTypes)

class CoilFeatureSectionTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    CircularCoilFeatureSectionType = _fusion.CoilFeatureSectionTypes_CircularCoilFeatureSectionType
    SquareCoilFeatureSectionType = _fusion.CoilFeatureSectionTypes_SquareCoilFeatureSectionType
    TriangularExternalCoilFeatureSectionType = _fusion.CoilFeatureSectionTypes_TriangularExternalCoilFeatureSectionType
    TriangularInternalCoilFeatureSectionType = _fusion.CoilFeatureSectionTypes_TriangularInternalCoilFeatureSectionType

    def __init__(self):
        _fusion.CoilFeatureSectionTypes_swiginit(self, _fusion.new_CoilFeatureSectionTypes())
    __swig_destroy__ = _fusion.delete_CoilFeatureSectionTypes

# Register CoilFeatureSectionTypes in _fusion:
_fusion.CoilFeatureSectionTypes_swigregister(CoilFeatureSectionTypes)

class CoilFeatureSectionPositions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    InsideCoilFeatureSectionPosition = _fusion.CoilFeatureSectionPositions_InsideCoilFeatureSectionPosition
    OnCenterCoilFeatureSectionPosition = _fusion.CoilFeatureSectionPositions_OnCenterCoilFeatureSectionPosition
    OutsideCoilFeatureSectionPosition = _fusion.CoilFeatureSectionPositions_OutsideCoilFeatureSectionPosition

    def __init__(self):
        _fusion.CoilFeatureSectionPositions_swiginit(self, _fusion.new_CoilFeatureSectionPositions())
    __swig_destroy__ = _fusion.delete_CoilFeatureSectionPositions

# Register CoilFeatureSectionPositions in _fusion:
_fusion.CoilFeatureSectionPositions_swigregister(CoilFeatureSectionPositions)

class SurfaceContinuityTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ConnectedSurfaceContinuityType = _fusion.SurfaceContinuityTypes_ConnectedSurfaceContinuityType
    TangentSurfaceContinuityType = _fusion.SurfaceContinuityTypes_TangentSurfaceContinuityType
    CurvatureSurfaceContinuityType = _fusion.SurfaceContinuityTypes_CurvatureSurfaceContinuityType

    def __init__(self):
        _fusion.SurfaceContinuityTypes_swiginit(self, _fusion.new_SurfaceContinuityTypes())
    __swig_destroy__ = _fusion.delete_SurfaceContinuityTypes

# Register SurfaceContinuityTypes in _fusion:
_fusion.SurfaceContinuityTypes_swigregister(SurfaceContinuityTypes)

class SurfaceExtendTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    NaturalSurfaceExtendType = _fusion.SurfaceExtendTypes_NaturalSurfaceExtendType
    TangentSurfaceExtendType = _fusion.SurfaceExtendTypes_TangentSurfaceExtendType
    PerpendicularSurfaceExtendType = _fusion.SurfaceExtendTypes_PerpendicularSurfaceExtendType

    def __init__(self):
        _fusion.SurfaceExtendTypes_swiginit(self, _fusion.new_SurfaceExtendTypes())
    __swig_destroy__ = _fusion.delete_SurfaceExtendTypes

# Register SurfaceExtendTypes in _fusion:
_fusion.SurfaceExtendTypes_swigregister(SurfaceExtendTypes)

class SurfaceExtendAlignment(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    FreeEdges = _fusion.SurfaceExtendAlignment_FreeEdges
    AlignEdges = _fusion.SurfaceExtendAlignment_AlignEdges

    def __init__(self):
        _fusion.SurfaceExtendAlignment_swiginit(self, _fusion.new_SurfaceExtendAlignment())
    __swig_destroy__ = _fusion.delete_SurfaceExtendAlignment

# Register SurfaceExtendAlignment in _fusion:
_fusion.SurfaceExtendAlignment_swigregister(SurfaceExtendAlignment)

class RuledSurfaceTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    TangentRuledSurfaceType = _fusion.RuledSurfaceTypes_TangentRuledSurfaceType
    NormalRuledSurfaceType = _fusion.RuledSurfaceTypes_NormalRuledSurfaceType
    DirectionRuledSurfaceType = _fusion.RuledSurfaceTypes_DirectionRuledSurfaceType

    def __init__(self):
        _fusion.RuledSurfaceTypes_swiginit(self, _fusion.new_RuledSurfaceTypes())
    __swig_destroy__ = _fusion.delete_RuledSurfaceTypes

# Register RuledSurfaceTypes in _fusion:
_fusion.RuledSurfaceTypes_swigregister(RuledSurfaceTypes)

class UntrimLoopTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    AllLoopsUntrimType = _fusion.UntrimLoopTypes_AllLoopsUntrimType
    ExternalLoopsUntrimType = _fusion.UntrimLoopTypes_ExternalLoopsUntrimType
    InternalLoopsUntrimType = _fusion.UntrimLoopTypes_InternalLoopsUntrimType
    ManualLoopsUntrimType = _fusion.UntrimLoopTypes_ManualLoopsUntrimType

    def __init__(self):
        _fusion.UntrimLoopTypes_swiginit(self, _fusion.new_UntrimLoopTypes())
    __swig_destroy__ = _fusion.delete_UntrimLoopTypes

# Register UntrimLoopTypes in _fusion:
_fusion.UntrimLoopTypes_swigregister(UntrimLoopTypes)

class DistanceUnits(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    MillimeterDistanceUnits = _fusion.DistanceUnits_MillimeterDistanceUnits
    CentimeterDistanceUnits = _fusion.DistanceUnits_CentimeterDistanceUnits
    MeterDistanceUnits = _fusion.DistanceUnits_MeterDistanceUnits
    InchDistanceUnits = _fusion.DistanceUnits_InchDistanceUnits
    FootDistanceUnits = _fusion.DistanceUnits_FootDistanceUnits

    def __init__(self):
        _fusion.DistanceUnits_swiginit(self, _fusion.new_DistanceUnits())
    __swig_destroy__ = _fusion.delete_DistanceUnits

# Register DistanceUnits in _fusion:
_fusion.DistanceUnits_swigregister(DistanceUnits)

class DefaultDesignTypeOptions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    PromptForDesignTypeOption = _fusion.DefaultDesignTypeOptions_PromptForDesignTypeOption
    DirectDesignTypeOption = _fusion.DefaultDesignTypeOptions_DirectDesignTypeOption
    ParametricDesignTypeOption = _fusion.DefaultDesignTypeOptions_ParametricDesignTypeOption

    def __init__(self):
        _fusion.DefaultDesignTypeOptions_swiginit(self, _fusion.new_DefaultDesignTypeOptions())
    __swig_destroy__ = _fusion.delete_DefaultDesignTypeOptions

# Register DefaultDesignTypeOptions in _fusion:
_fusion.DefaultDesignTypeOptions_swigregister(DefaultDesignTypeOptions)

class DefaultWorkspaces(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ModelWorkspace = _fusion.DefaultWorkspaces_ModelWorkspace
    SculptWorkspace = _fusion.DefaultWorkspaces_SculptWorkspace
    PatchWorkspace = _fusion.DefaultWorkspaces_PatchWorkspace

    def __init__(self):
        _fusion.DefaultWorkspaces_swiginit(self, _fusion.new_DefaultWorkspaces())
    __swig_destroy__ = _fusion.delete_DefaultWorkspaces

# Register DefaultWorkspaces in _fusion:
_fusion.DefaultWorkspaces_swigregister(DefaultWorkspaces)

class DesignTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DirectDesignType = _fusion.DesignTypes_DirectDesignType
    ParametricDesignType = _fusion.DesignTypes_ParametricDesignType

    def __init__(self):
        _fusion.DesignTypes_swiginit(self, _fusion.new_DesignTypes())
    __swig_destroy__ = _fusion.delete_DesignTypes

# Register DesignTypes in _fusion:
_fusion.DesignTypes_swigregister(DesignTypes)

class ExpressionError(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    CyclicParameterReferenceError = _fusion.ExpressionError_CyclicParameterReferenceError

    def __init__(self):
        _fusion.ExpressionError_swiginit(self, _fusion.new_ExpressionError())
    __swig_destroy__ = _fusion.delete_ExpressionError

# Register ExpressionError in _fusion:
_fusion.ExpressionError_swigregister(ExpressionError)

class DeleteMeError(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ParameterReferencedByOtherParameterError = _fusion.DeleteMeError_ParameterReferencedByOtherParameterError

    def __init__(self):
        _fusion.DeleteMeError_swiginit(self, _fusion.new_DeleteMeError())
    __swig_destroy__ = _fusion.delete_DeleteMeError

# Register DeleteMeError in _fusion:
_fusion.DeleteMeError_swigregister(DeleteMeError)

class MeshRefinementSettings(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    MeshRefinementHigh = _fusion.MeshRefinementSettings_MeshRefinementHigh
    MeshRefinementMedium = _fusion.MeshRefinementSettings_MeshRefinementMedium
    MeshRefinementLow = _fusion.MeshRefinementSettings_MeshRefinementLow
    MeshRefinementCustom = _fusion.MeshRefinementSettings_MeshRefinementCustom

    def __init__(self):
        _fusion.MeshRefinementSettings_swiginit(self, _fusion.new_MeshRefinementSettings())
    __swig_destroy__ = _fusion.delete_MeshRefinementSettings

# Register MeshRefinementSettings in _fusion:
_fusion.MeshRefinementSettings_swigregister(MeshRefinementSettings)

class CustomGraphicsCullModes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    CustomGraphicsCullFront = _fusion.CustomGraphicsCullModes_CustomGraphicsCullFront
    CustomGraphicsCullBack = _fusion.CustomGraphicsCullModes_CustomGraphicsCullBack
    CustomGraphicsCullNone = _fusion.CustomGraphicsCullModes_CustomGraphicsCullNone

    def __init__(self):
        _fusion.CustomGraphicsCullModes_swiginit(self, _fusion.new_CustomGraphicsCullModes())
    __swig_destroy__ = _fusion.delete_CustomGraphicsCullModes

# Register CustomGraphicsCullModes in _fusion:
_fusion.CustomGraphicsCullModes_swigregister(CustomGraphicsCullModes)

class CustomGraphicsBillBoardStyles(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ScreenBillBoardStyle = _fusion.CustomGraphicsBillBoardStyles_ScreenBillBoardStyle
    AxialBillBoardStyle = _fusion.CustomGraphicsBillBoardStyles_AxialBillBoardStyle
    RightReadingBillBoardStyle = _fusion.CustomGraphicsBillBoardStyles_RightReadingBillBoardStyle

    def __init__(self):
        _fusion.CustomGraphicsBillBoardStyles_swiginit(self, _fusion.new_CustomGraphicsBillBoardStyles())
    __swig_destroy__ = _fusion.delete_CustomGraphicsBillBoardStyles

# Register CustomGraphicsBillBoardStyles in _fusion:
_fusion.CustomGraphicsBillBoardStyles_swigregister(CustomGraphicsBillBoardStyles)

class ViewCorners(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    upperLeftViewCorner = _fusion.ViewCorners_upperLeftViewCorner
    upperRightViewCorner = _fusion.ViewCorners_upperRightViewCorner
    lowerLeftViewCorner = _fusion.ViewCorners_lowerLeftViewCorner
    lowerRightViewCorner = _fusion.ViewCorners_lowerRightViewCorner

    def __init__(self):
        _fusion.ViewCorners_swiginit(self, _fusion.new_ViewCorners())
    __swig_destroy__ = _fusion.delete_ViewCorners

# Register ViewCorners in _fusion:
_fusion.ViewCorners_swigregister(ViewCorners)

class CustomGraphicsPointTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    UserDefinedCustomGraphicsPointType = _fusion.CustomGraphicsPointTypes_UserDefinedCustomGraphicsPointType
    PointCloudCustomGraphicsPointType = _fusion.CustomGraphicsPointTypes_PointCloudCustomGraphicsPointType

    def __init__(self):
        _fusion.CustomGraphicsPointTypes_swiginit(self, _fusion.new_CustomGraphicsPointTypes())
    __swig_destroy__ = _fusion.delete_CustomGraphicsPointTypes

# Register CustomGraphicsPointTypes in _fusion:
_fusion.CustomGraphicsPointTypes_swigregister(CustomGraphicsPointTypes)

class LineStylePatterns(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    continuousLineStylePattern = _fusion.LineStylePatterns_continuousLineStylePattern
    centerLineStylePattern = _fusion.LineStylePatterns_centerLineStylePattern
    dashedLineStylePattern = _fusion.LineStylePatterns_dashedLineStylePattern
    dotLineStylePattern = _fusion.LineStylePatterns_dotLineStylePattern
    hiddenLineStylePattern = _fusion.LineStylePatterns_hiddenLineStylePattern
    phantomLineStylePattern = _fusion.LineStylePatterns_phantomLineStylePattern
    tracksLineStylePattern = _fusion.LineStylePatterns_tracksLineStylePattern
    zigzagLineStylePattern = _fusion.LineStylePatterns_zigzagLineStylePattern

    def __init__(self):
        _fusion.LineStylePatterns_swiginit(self, _fusion.new_LineStylePatterns())
    __swig_destroy__ = _fusion.delete_LineStylePatterns

# Register LineStylePatterns in _fusion:
_fusion.LineStylePatterns_swigregister(LineStylePatterns)

class MeshUnits(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    CentimeterMeshUnit = _fusion.MeshUnits_CentimeterMeshUnit
    MillimeterMeshUnit = _fusion.MeshUnits_MillimeterMeshUnit
    MeterMeshUnit = _fusion.MeshUnits_MeterMeshUnit
    InchMeshUnit = _fusion.MeshUnits_InchMeshUnit
    FootMeshUnit = _fusion.MeshUnits_FootMeshUnit

    def __init__(self):
        _fusion.MeshUnits_swiginit(self, _fusion.new_MeshUnits())
    __swig_destroy__ = _fusion.delete_MeshUnits

# Register MeshUnits in _fusion:
_fusion.MeshUnits_swigregister(MeshUnits)

class TriangleMeshQualityOptions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    LowQualityTriangleMesh = _fusion.TriangleMeshQualityOptions_LowQualityTriangleMesh
    NormalQualityTriangleMesh = _fusion.TriangleMeshQualityOptions_NormalQualityTriangleMesh
    HighQualityTriangleMesh = _fusion.TriangleMeshQualityOptions_HighQualityTriangleMesh
    VeryHighQualityTriangleMesh = _fusion.TriangleMeshQualityOptions_VeryHighQualityTriangleMesh

    def __init__(self):
        _fusion.TriangleMeshQualityOptions_swiginit(self, _fusion.new_TriangleMeshQualityOptions())
    __swig_destroy__ = _fusion.delete_TriangleMeshQualityOptions

# Register TriangleMeshQualityOptions in _fusion:
_fusion.TriangleMeshQualityOptions_swigregister(TriangleMeshQualityOptions)

class SurfaceProjectTypes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ClosestPointSurfaceProjectType = _fusion.SurfaceProjectTypes_ClosestPointSurfaceProjectType
    AlongVectorSurfaceProjectType = _fusion.SurfaceProjectTypes_AlongVectorSurfaceProjectType

    def __init__(self):
        _fusion.SurfaceProjectTypes_swiginit(self, _fusion.new_SurfaceProjectTypes())
    __swig_destroy__ = _fusion.delete_SurfaceProjectTypes

# Register SurfaceProjectTypes in _fusion:
_fusion.SurfaceProjectTypes_swigregister(SurfaceProjectTypes)

class TextStyles(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    TextStyleBold = _fusion.TextStyles_TextStyleBold
    TextStyleItalic = _fusion.TextStyles_TextStyleItalic
    TextStyleUnderline = _fusion.TextStyles_TextStyleUnderline

    def __init__(self):
        _fusion.TextStyles_swiginit(self, _fusion.new_TextStyles())
    __swig_destroy__ = _fusion.delete_TextStyles

# Register TextStyles in _fusion:
_fusion.TextStyles_swigregister(TextStyles)

class TextBoxKeyPoints(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    TopLeftTextBoxKeyPoint = _fusion.TextBoxKeyPoints_TopLeftTextBoxKeyPoint
    TopMiddleTextBoxKeyPoint = _fusion.TextBoxKeyPoints_TopMiddleTextBoxKeyPoint
    TopRightTextBoxKeyPoint = _fusion.TextBoxKeyPoints_TopRightTextBoxKeyPoint
    MiddleLeftTextBoxKeyPoint = _fusion.TextBoxKeyPoints_MiddleLeftTextBoxKeyPoint
    MiddleTextBoxKeyPoint = _fusion.TextBoxKeyPoints_MiddleTextBoxKeyPoint
    MiddleRightTextBoxKeyPoint = _fusion.TextBoxKeyPoints_MiddleRightTextBoxKeyPoint
    BottomLeftTextBoxKeyPoint = _fusion.TextBoxKeyPoints_BottomLeftTextBoxKeyPoint
    BottomMiddleTextBoxKeyPoint = _fusion.TextBoxKeyPoints_BottomMiddleTextBoxKeyPoint
    BottomRightTextBoxKeyPoint = _fusion.TextBoxKeyPoints_BottomRightTextBoxKeyPoint

    def __init__(self):
        _fusion.TextBoxKeyPoints_swiginit(self, _fusion.new_TextBoxKeyPoints())
    __swig_destroy__ = _fusion.delete_TextBoxKeyPoints

# Register TextBoxKeyPoints in _fusion:
_fusion.TextBoxKeyPoints_swigregister(TextBoxKeyPoints)

class DimensionOrientations(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    AlignedDimensionOrientation = _fusion.DimensionOrientations_AlignedDimensionOrientation
    HorizontalDimensionOrientation = _fusion.DimensionOrientations_HorizontalDimensionOrientation
    VerticalDimensionOrientation = _fusion.DimensionOrientations_VerticalDimensionOrientation

    def __init__(self):
        _fusion.DimensionOrientations_swiginit(self, _fusion.new_DimensionOrientations())
    __swig_destroy__ = _fusion.delete_DimensionOrientations

# Register DimensionOrientations in _fusion:
_fusion.DimensionOrientations_swigregister(DimensionOrientations)

class AsBuiltJointVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.AsBuiltJointVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.AsBuiltJointVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.AsBuiltJointVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::size_type":
        return _fusion.AsBuiltJointVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint >,std::allocator< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > > > *":
        return _fusion.AsBuiltJointVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.AsBuiltJointVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::difference_type") -> "void":
        return _fusion.AsBuiltJointVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.AsBuiltJointVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::value_type const &":
        return _fusion.AsBuiltJointVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.AsBuiltJointVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::value_type":
        return _fusion.AsBuiltJointVector_pop(self)

    def append(self, x: "AsBuiltJoint") -> "void":
        return _fusion.AsBuiltJointVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.AsBuiltJointVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::size_type":
        return _fusion.AsBuiltJointVector_size(self)

    def swap(self, v: "AsBuiltJointVector") -> "void":
        return _fusion.AsBuiltJointVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::iterator":
        return _fusion.AsBuiltJointVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::iterator":
        return _fusion.AsBuiltJointVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::reverse_iterator":
        return _fusion.AsBuiltJointVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::reverse_iterator":
        return _fusion.AsBuiltJointVector_rend(self)

    def clear(self) -> "void":
        return _fusion.AsBuiltJointVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::allocator_type":
        return _fusion.AsBuiltJointVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.AsBuiltJointVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::iterator":
        return _fusion.AsBuiltJointVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.AsBuiltJointVector_swiginit(self, _fusion.new_AsBuiltJointVector(*args))

    def push_back(self, x: "AsBuiltJoint") -> "void":
        return _fusion.AsBuiltJointVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::value_type const &":
        return _fusion.AsBuiltJointVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::value_type const &":
        return _fusion.AsBuiltJointVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::size_type", x: "AsBuiltJoint") -> "void":
        return _fusion.AsBuiltJointVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.AsBuiltJointVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.AsBuiltJointVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::size_type") -> "void":
        return _fusion.AsBuiltJointVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::size_type":
        return _fusion.AsBuiltJointVector_capacity(self)
    __swig_destroy__ = _fusion.delete_AsBuiltJointVector

# Register AsBuiltJointVector in _fusion:
_fusion.AsBuiltJointVector_swigregister(AsBuiltJointVector)

class BRepBodyVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.BRepBodyVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.BRepBodyVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.BRepBodyVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::size_type":
        return _fusion.BRepBodyVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepBody > > > *":
        return _fusion.BRepBodyVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.BRepBodyVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::difference_type") -> "void":
        return _fusion.BRepBodyVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.BRepBodyVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::value_type const &":
        return _fusion.BRepBodyVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.BRepBodyVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::value_type":
        return _fusion.BRepBodyVector_pop(self)

    def append(self, x: "BRepBody") -> "void":
        return _fusion.BRepBodyVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.BRepBodyVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::size_type":
        return _fusion.BRepBodyVector_size(self)

    def swap(self, v: "BRepBodyVector") -> "void":
        return _fusion.BRepBodyVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::iterator":
        return _fusion.BRepBodyVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::iterator":
        return _fusion.BRepBodyVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::reverse_iterator":
        return _fusion.BRepBodyVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::reverse_iterator":
        return _fusion.BRepBodyVector_rend(self)

    def clear(self) -> "void":
        return _fusion.BRepBodyVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::allocator_type":
        return _fusion.BRepBodyVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.BRepBodyVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::iterator":
        return _fusion.BRepBodyVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.BRepBodyVector_swiginit(self, _fusion.new_BRepBodyVector(*args))

    def push_back(self, x: "BRepBody") -> "void":
        return _fusion.BRepBodyVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::value_type const &":
        return _fusion.BRepBodyVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::value_type const &":
        return _fusion.BRepBodyVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::size_type", x: "BRepBody") -> "void":
        return _fusion.BRepBodyVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.BRepBodyVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.BRepBodyVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::size_type") -> "void":
        return _fusion.BRepBodyVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::size_type":
        return _fusion.BRepBodyVector_capacity(self)
    __swig_destroy__ = _fusion.delete_BRepBodyVector

# Register BRepBodyVector in _fusion:
_fusion.BRepBodyVector_swigregister(BRepBodyVector)

class BRepEdgeVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.BRepEdgeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.BRepEdgeVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.BRepEdgeVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::size_type":
        return _fusion.BRepEdgeVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepEdge > > > *":
        return _fusion.BRepEdgeVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.BRepEdgeVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::difference_type") -> "void":
        return _fusion.BRepEdgeVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.BRepEdgeVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::value_type const &":
        return _fusion.BRepEdgeVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.BRepEdgeVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::value_type":
        return _fusion.BRepEdgeVector_pop(self)

    def append(self, x: "BRepEdge") -> "void":
        return _fusion.BRepEdgeVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.BRepEdgeVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::size_type":
        return _fusion.BRepEdgeVector_size(self)

    def swap(self, v: "BRepEdgeVector") -> "void":
        return _fusion.BRepEdgeVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::iterator":
        return _fusion.BRepEdgeVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::iterator":
        return _fusion.BRepEdgeVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::reverse_iterator":
        return _fusion.BRepEdgeVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::reverse_iterator":
        return _fusion.BRepEdgeVector_rend(self)

    def clear(self) -> "void":
        return _fusion.BRepEdgeVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::allocator_type":
        return _fusion.BRepEdgeVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.BRepEdgeVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::iterator":
        return _fusion.BRepEdgeVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.BRepEdgeVector_swiginit(self, _fusion.new_BRepEdgeVector(*args))

    def push_back(self, x: "BRepEdge") -> "void":
        return _fusion.BRepEdgeVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::value_type const &":
        return _fusion.BRepEdgeVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::value_type const &":
        return _fusion.BRepEdgeVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::size_type", x: "BRepEdge") -> "void":
        return _fusion.BRepEdgeVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.BRepEdgeVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.BRepEdgeVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::size_type") -> "void":
        return _fusion.BRepEdgeVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::size_type":
        return _fusion.BRepEdgeVector_capacity(self)
    __swig_destroy__ = _fusion.delete_BRepEdgeVector

# Register BRepEdgeVector in _fusion:
_fusion.BRepEdgeVector_swigregister(BRepEdgeVector)

class BRepFaceVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.BRepFaceVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.BRepFaceVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.BRepFaceVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::size_type":
        return _fusion.BRepFaceVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepFace > > > *":
        return _fusion.BRepFaceVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.BRepFaceVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::difference_type") -> "void":
        return _fusion.BRepFaceVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.BRepFaceVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::value_type const &":
        return _fusion.BRepFaceVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.BRepFaceVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::value_type":
        return _fusion.BRepFaceVector_pop(self)

    def append(self, x: "BRepFace") -> "void":
        return _fusion.BRepFaceVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.BRepFaceVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::size_type":
        return _fusion.BRepFaceVector_size(self)

    def swap(self, v: "BRepFaceVector") -> "void":
        return _fusion.BRepFaceVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::iterator":
        return _fusion.BRepFaceVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::iterator":
        return _fusion.BRepFaceVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::reverse_iterator":
        return _fusion.BRepFaceVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::reverse_iterator":
        return _fusion.BRepFaceVector_rend(self)

    def clear(self) -> "void":
        return _fusion.BRepFaceVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::allocator_type":
        return _fusion.BRepFaceVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.BRepFaceVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::iterator":
        return _fusion.BRepFaceVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.BRepFaceVector_swiginit(self, _fusion.new_BRepFaceVector(*args))

    def push_back(self, x: "BRepFace") -> "void":
        return _fusion.BRepFaceVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::value_type const &":
        return _fusion.BRepFaceVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::value_type const &":
        return _fusion.BRepFaceVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::size_type", x: "BRepFace") -> "void":
        return _fusion.BRepFaceVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.BRepFaceVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.BRepFaceVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::size_type") -> "void":
        return _fusion.BRepFaceVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::size_type":
        return _fusion.BRepFaceVector_capacity(self)
    __swig_destroy__ = _fusion.delete_BRepFaceVector

# Register BRepFaceVector in _fusion:
_fusion.BRepFaceVector_swigregister(BRepFaceVector)

class BRepLoopVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.BRepLoopVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.BRepLoopVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.BRepLoopVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepLoop > >::size_type":
        return _fusion.BRepLoopVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::BRepLoop > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::BRepLoop > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepLoop >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepLoop > > > *":
        return _fusion.BRepLoopVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.BRepLoopVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::BRepLoop > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::BRepLoop > >::difference_type") -> "void":
        return _fusion.BRepLoopVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.BRepLoopVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepLoop > >::value_type const &":
        return _fusion.BRepLoopVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.BRepLoopVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepLoop > >::value_type":
        return _fusion.BRepLoopVector_pop(self)

    def append(self, x: "BRepLoop") -> "void":
        return _fusion.BRepLoopVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.BRepLoopVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepLoop > >::size_type":
        return _fusion.BRepLoopVector_size(self)

    def swap(self, v: "BRepLoopVector") -> "void":
        return _fusion.BRepLoopVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepLoop > >::iterator":
        return _fusion.BRepLoopVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepLoop > >::iterator":
        return _fusion.BRepLoopVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepLoop > >::reverse_iterator":
        return _fusion.BRepLoopVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepLoop > >::reverse_iterator":
        return _fusion.BRepLoopVector_rend(self)

    def clear(self) -> "void":
        return _fusion.BRepLoopVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepLoop > >::allocator_type":
        return _fusion.BRepLoopVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.BRepLoopVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepLoop > >::iterator":
        return _fusion.BRepLoopVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.BRepLoopVector_swiginit(self, _fusion.new_BRepLoopVector(*args))

    def push_back(self, x: "BRepLoop") -> "void":
        return _fusion.BRepLoopVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepLoop > >::value_type const &":
        return _fusion.BRepLoopVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepLoop > >::value_type const &":
        return _fusion.BRepLoopVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::BRepLoop > >::size_type", x: "BRepLoop") -> "void":
        return _fusion.BRepLoopVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.BRepLoopVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.BRepLoopVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::BRepLoop > >::size_type") -> "void":
        return _fusion.BRepLoopVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepLoop > >::size_type":
        return _fusion.BRepLoopVector_capacity(self)
    __swig_destroy__ = _fusion.delete_BRepLoopVector

# Register BRepLoopVector in _fusion:
_fusion.BRepLoopVector_swigregister(BRepLoopVector)

class ConstructionAxisVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.ConstructionAxisVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.ConstructionAxisVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.ConstructionAxisVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::size_type":
        return _fusion.ConstructionAxisVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis >,std::allocator< adsk::core::Ptr< adsk::fusion::ConstructionAxis > > > *":
        return _fusion.ConstructionAxisVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.ConstructionAxisVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::difference_type") -> "void":
        return _fusion.ConstructionAxisVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.ConstructionAxisVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::value_type const &":
        return _fusion.ConstructionAxisVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.ConstructionAxisVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::value_type":
        return _fusion.ConstructionAxisVector_pop(self)

    def append(self, x: "ConstructionAxis") -> "void":
        return _fusion.ConstructionAxisVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.ConstructionAxisVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::size_type":
        return _fusion.ConstructionAxisVector_size(self)

    def swap(self, v: "ConstructionAxisVector") -> "void":
        return _fusion.ConstructionAxisVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::iterator":
        return _fusion.ConstructionAxisVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::iterator":
        return _fusion.ConstructionAxisVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::reverse_iterator":
        return _fusion.ConstructionAxisVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::reverse_iterator":
        return _fusion.ConstructionAxisVector_rend(self)

    def clear(self) -> "void":
        return _fusion.ConstructionAxisVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::allocator_type":
        return _fusion.ConstructionAxisVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.ConstructionAxisVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::iterator":
        return _fusion.ConstructionAxisVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.ConstructionAxisVector_swiginit(self, _fusion.new_ConstructionAxisVector(*args))

    def push_back(self, x: "ConstructionAxis") -> "void":
        return _fusion.ConstructionAxisVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::value_type const &":
        return _fusion.ConstructionAxisVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::value_type const &":
        return _fusion.ConstructionAxisVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::size_type", x: "ConstructionAxis") -> "void":
        return _fusion.ConstructionAxisVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.ConstructionAxisVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.ConstructionAxisVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::size_type") -> "void":
        return _fusion.ConstructionAxisVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::size_type":
        return _fusion.ConstructionAxisVector_capacity(self)
    __swig_destroy__ = _fusion.delete_ConstructionAxisVector

# Register ConstructionAxisVector in _fusion:
_fusion.ConstructionAxisVector_swigregister(ConstructionAxisVector)

class ConstructionPlaneVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.ConstructionPlaneVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.ConstructionPlaneVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.ConstructionPlaneVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::size_type":
        return _fusion.ConstructionPlaneVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane >,std::allocator< adsk::core::Ptr< adsk::fusion::ConstructionPlane > > > *":
        return _fusion.ConstructionPlaneVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.ConstructionPlaneVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::difference_type") -> "void":
        return _fusion.ConstructionPlaneVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.ConstructionPlaneVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::value_type const &":
        return _fusion.ConstructionPlaneVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.ConstructionPlaneVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::value_type":
        return _fusion.ConstructionPlaneVector_pop(self)

    def append(self, x: "ConstructionPlane") -> "void":
        return _fusion.ConstructionPlaneVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.ConstructionPlaneVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::size_type":
        return _fusion.ConstructionPlaneVector_size(self)

    def swap(self, v: "ConstructionPlaneVector") -> "void":
        return _fusion.ConstructionPlaneVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::iterator":
        return _fusion.ConstructionPlaneVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::iterator":
        return _fusion.ConstructionPlaneVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::reverse_iterator":
        return _fusion.ConstructionPlaneVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::reverse_iterator":
        return _fusion.ConstructionPlaneVector_rend(self)

    def clear(self) -> "void":
        return _fusion.ConstructionPlaneVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::allocator_type":
        return _fusion.ConstructionPlaneVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.ConstructionPlaneVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::iterator":
        return _fusion.ConstructionPlaneVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.ConstructionPlaneVector_swiginit(self, _fusion.new_ConstructionPlaneVector(*args))

    def push_back(self, x: "ConstructionPlane") -> "void":
        return _fusion.ConstructionPlaneVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::value_type const &":
        return _fusion.ConstructionPlaneVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::value_type const &":
        return _fusion.ConstructionPlaneVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::size_type", x: "ConstructionPlane") -> "void":
        return _fusion.ConstructionPlaneVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.ConstructionPlaneVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.ConstructionPlaneVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::size_type") -> "void":
        return _fusion.ConstructionPlaneVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::size_type":
        return _fusion.ConstructionPlaneVector_capacity(self)
    __swig_destroy__ = _fusion.delete_ConstructionPlaneVector

# Register ConstructionPlaneVector in _fusion:
_fusion.ConstructionPlaneVector_swigregister(ConstructionPlaneVector)

class ConstructionPointVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.ConstructionPointVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.ConstructionPointVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.ConstructionPointVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::size_type":
        return _fusion.ConstructionPointVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint >,std::allocator< adsk::core::Ptr< adsk::fusion::ConstructionPoint > > > *":
        return _fusion.ConstructionPointVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.ConstructionPointVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::difference_type") -> "void":
        return _fusion.ConstructionPointVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.ConstructionPointVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::value_type const &":
        return _fusion.ConstructionPointVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.ConstructionPointVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::value_type":
        return _fusion.ConstructionPointVector_pop(self)

    def append(self, x: "ConstructionPoint") -> "void":
        return _fusion.ConstructionPointVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.ConstructionPointVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::size_type":
        return _fusion.ConstructionPointVector_size(self)

    def swap(self, v: "ConstructionPointVector") -> "void":
        return _fusion.ConstructionPointVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::iterator":
        return _fusion.ConstructionPointVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::iterator":
        return _fusion.ConstructionPointVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::reverse_iterator":
        return _fusion.ConstructionPointVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::reverse_iterator":
        return _fusion.ConstructionPointVector_rend(self)

    def clear(self) -> "void":
        return _fusion.ConstructionPointVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::allocator_type":
        return _fusion.ConstructionPointVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.ConstructionPointVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::iterator":
        return _fusion.ConstructionPointVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.ConstructionPointVector_swiginit(self, _fusion.new_ConstructionPointVector(*args))

    def push_back(self, x: "ConstructionPoint") -> "void":
        return _fusion.ConstructionPointVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::value_type const &":
        return _fusion.ConstructionPointVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::value_type const &":
        return _fusion.ConstructionPointVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::size_type", x: "ConstructionPoint") -> "void":
        return _fusion.ConstructionPointVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.ConstructionPointVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.ConstructionPointVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::size_type") -> "void":
        return _fusion.ConstructionPointVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::size_type":
        return _fusion.ConstructionPointVector_capacity(self)
    __swig_destroy__ = _fusion.delete_ConstructionPointVector

# Register ConstructionPointVector in _fusion:
_fusion.ConstructionPointVector_swigregister(ConstructionPointVector)

class JointVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.JointVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.JointVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.JointVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::size_type":
        return _fusion.JointVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint >,std::allocator< adsk::core::Ptr< adsk::fusion::Joint > > > *":
        return _fusion.JointVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.JointVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::difference_type") -> "void":
        return _fusion.JointVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.JointVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::value_type const &":
        return _fusion.JointVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.JointVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::value_type":
        return _fusion.JointVector_pop(self)

    def append(self, x: "Joint") -> "void":
        return _fusion.JointVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.JointVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::size_type":
        return _fusion.JointVector_size(self)

    def swap(self, v: "JointVector") -> "void":
        return _fusion.JointVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::iterator":
        return _fusion.JointVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::iterator":
        return _fusion.JointVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::reverse_iterator":
        return _fusion.JointVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::reverse_iterator":
        return _fusion.JointVector_rend(self)

    def clear(self) -> "void":
        return _fusion.JointVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::allocator_type":
        return _fusion.JointVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.JointVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::iterator":
        return _fusion.JointVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.JointVector_swiginit(self, _fusion.new_JointVector(*args))

    def push_back(self, x: "Joint") -> "void":
        return _fusion.JointVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::value_type const &":
        return _fusion.JointVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::value_type const &":
        return _fusion.JointVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::size_type", x: "Joint") -> "void":
        return _fusion.JointVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.JointVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.JointVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::size_type") -> "void":
        return _fusion.JointVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::size_type":
        return _fusion.JointVector_capacity(self)
    __swig_destroy__ = _fusion.delete_JointVector

# Register JointVector in _fusion:
_fusion.JointVector_swigregister(JointVector)

class JointOriginVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.JointOriginVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.JointOriginVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.JointOriginVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::size_type":
        return _fusion.JointOriginVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin >,std::allocator< adsk::core::Ptr< adsk::fusion::JointOrigin > > > *":
        return _fusion.JointOriginVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.JointOriginVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::difference_type") -> "void":
        return _fusion.JointOriginVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.JointOriginVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::value_type const &":
        return _fusion.JointOriginVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.JointOriginVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::value_type":
        return _fusion.JointOriginVector_pop(self)

    def append(self, x: "JointOrigin") -> "void":
        return _fusion.JointOriginVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.JointOriginVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::size_type":
        return _fusion.JointOriginVector_size(self)

    def swap(self, v: "JointOriginVector") -> "void":
        return _fusion.JointOriginVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::iterator":
        return _fusion.JointOriginVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::iterator":
        return _fusion.JointOriginVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::reverse_iterator":
        return _fusion.JointOriginVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::reverse_iterator":
        return _fusion.JointOriginVector_rend(self)

    def clear(self) -> "void":
        return _fusion.JointOriginVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::allocator_type":
        return _fusion.JointOriginVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.JointOriginVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::iterator":
        return _fusion.JointOriginVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.JointOriginVector_swiginit(self, _fusion.new_JointOriginVector(*args))

    def push_back(self, x: "JointOrigin") -> "void":
        return _fusion.JointOriginVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::value_type const &":
        return _fusion.JointOriginVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::value_type const &":
        return _fusion.JointOriginVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::size_type", x: "JointOrigin") -> "void":
        return _fusion.JointOriginVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.JointOriginVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.JointOriginVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::size_type") -> "void":
        return _fusion.JointOriginVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::size_type":
        return _fusion.JointOriginVector_capacity(self)
    __swig_destroy__ = _fusion.delete_JointOriginVector

# Register JointOriginVector in _fusion:
_fusion.JointOriginVector_swigregister(JointOriginVector)

class MeshBodyVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.MeshBodyVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.MeshBodyVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.MeshBodyVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::size_type":
        return _fusion.MeshBodyVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody >,std::allocator< adsk::core::Ptr< adsk::fusion::MeshBody > > > *":
        return _fusion.MeshBodyVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.MeshBodyVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::difference_type") -> "void":
        return _fusion.MeshBodyVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.MeshBodyVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::value_type const &":
        return _fusion.MeshBodyVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.MeshBodyVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::value_type":
        return _fusion.MeshBodyVector_pop(self)

    def append(self, x: "MeshBody") -> "void":
        return _fusion.MeshBodyVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.MeshBodyVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::size_type":
        return _fusion.MeshBodyVector_size(self)

    def swap(self, v: "MeshBodyVector") -> "void":
        return _fusion.MeshBodyVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::iterator":
        return _fusion.MeshBodyVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::iterator":
        return _fusion.MeshBodyVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::reverse_iterator":
        return _fusion.MeshBodyVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::reverse_iterator":
        return _fusion.MeshBodyVector_rend(self)

    def clear(self) -> "void":
        return _fusion.MeshBodyVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::allocator_type":
        return _fusion.MeshBodyVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.MeshBodyVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::iterator":
        return _fusion.MeshBodyVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.MeshBodyVector_swiginit(self, _fusion.new_MeshBodyVector(*args))

    def push_back(self, x: "MeshBody") -> "void":
        return _fusion.MeshBodyVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::value_type const &":
        return _fusion.MeshBodyVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::value_type const &":
        return _fusion.MeshBodyVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::size_type", x: "MeshBody") -> "void":
        return _fusion.MeshBodyVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.MeshBodyVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.MeshBodyVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::size_type") -> "void":
        return _fusion.MeshBodyVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::size_type":
        return _fusion.MeshBodyVector_capacity(self)
    __swig_destroy__ = _fusion.delete_MeshBodyVector

# Register MeshBodyVector in _fusion:
_fusion.MeshBodyVector_swigregister(MeshBodyVector)

class OccurrenceVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.OccurrenceVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.OccurrenceVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.OccurrenceVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::size_type":
        return _fusion.OccurrenceVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence >,std::allocator< adsk::core::Ptr< adsk::fusion::Occurrence > > > *":
        return _fusion.OccurrenceVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.OccurrenceVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::difference_type") -> "void":
        return _fusion.OccurrenceVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.OccurrenceVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::value_type const &":
        return _fusion.OccurrenceVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.OccurrenceVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::value_type":
        return _fusion.OccurrenceVector_pop(self)

    def append(self, x: "Occurrence") -> "void":
        return _fusion.OccurrenceVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.OccurrenceVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::size_type":
        return _fusion.OccurrenceVector_size(self)

    def swap(self, v: "OccurrenceVector") -> "void":
        return _fusion.OccurrenceVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::iterator":
        return _fusion.OccurrenceVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::iterator":
        return _fusion.OccurrenceVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::reverse_iterator":
        return _fusion.OccurrenceVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::reverse_iterator":
        return _fusion.OccurrenceVector_rend(self)

    def clear(self) -> "void":
        return _fusion.OccurrenceVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::allocator_type":
        return _fusion.OccurrenceVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.OccurrenceVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::iterator":
        return _fusion.OccurrenceVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.OccurrenceVector_swiginit(self, _fusion.new_OccurrenceVector(*args))

    def push_back(self, x: "Occurrence") -> "void":
        return _fusion.OccurrenceVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::value_type const &":
        return _fusion.OccurrenceVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::value_type const &":
        return _fusion.OccurrenceVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::size_type", x: "Occurrence") -> "void":
        return _fusion.OccurrenceVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.OccurrenceVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.OccurrenceVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::size_type") -> "void":
        return _fusion.OccurrenceVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::size_type":
        return _fusion.OccurrenceVector_capacity(self)
    __swig_destroy__ = _fusion.delete_OccurrenceVector

# Register OccurrenceVector in _fusion:
_fusion.OccurrenceVector_swigregister(OccurrenceVector)

class RigidGroupVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.RigidGroupVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.RigidGroupVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.RigidGroupVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::size_type":
        return _fusion.RigidGroupVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup >,std::allocator< adsk::core::Ptr< adsk::fusion::RigidGroup > > > *":
        return _fusion.RigidGroupVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.RigidGroupVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::difference_type") -> "void":
        return _fusion.RigidGroupVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.RigidGroupVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::value_type const &":
        return _fusion.RigidGroupVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.RigidGroupVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::value_type":
        return _fusion.RigidGroupVector_pop(self)

    def append(self, x: "RigidGroup") -> "void":
        return _fusion.RigidGroupVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.RigidGroupVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::size_type":
        return _fusion.RigidGroupVector_size(self)

    def swap(self, v: "RigidGroupVector") -> "void":
        return _fusion.RigidGroupVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::iterator":
        return _fusion.RigidGroupVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::iterator":
        return _fusion.RigidGroupVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::reverse_iterator":
        return _fusion.RigidGroupVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::reverse_iterator":
        return _fusion.RigidGroupVector_rend(self)

    def clear(self) -> "void":
        return _fusion.RigidGroupVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::allocator_type":
        return _fusion.RigidGroupVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.RigidGroupVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::iterator":
        return _fusion.RigidGroupVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.RigidGroupVector_swiginit(self, _fusion.new_RigidGroupVector(*args))

    def push_back(self, x: "RigidGroup") -> "void":
        return _fusion.RigidGroupVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::value_type const &":
        return _fusion.RigidGroupVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::value_type const &":
        return _fusion.RigidGroupVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::size_type", x: "RigidGroup") -> "void":
        return _fusion.RigidGroupVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.RigidGroupVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.RigidGroupVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::size_type") -> "void":
        return _fusion.RigidGroupVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::size_type":
        return _fusion.RigidGroupVector_capacity(self)
    __swig_destroy__ = _fusion.delete_RigidGroupVector

# Register RigidGroupVector in _fusion:
_fusion.RigidGroupVector_swigregister(RigidGroupVector)

class SketchVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.SketchVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.SketchVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.SketchVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::size_type":
        return _fusion.SketchVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch >,std::allocator< adsk::core::Ptr< adsk::fusion::Sketch > > > *":
        return _fusion.SketchVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.SketchVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::difference_type") -> "void":
        return _fusion.SketchVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.SketchVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::value_type const &":
        return _fusion.SketchVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.SketchVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::value_type":
        return _fusion.SketchVector_pop(self)

    def append(self, x: "Sketch") -> "void":
        return _fusion.SketchVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.SketchVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::size_type":
        return _fusion.SketchVector_size(self)

    def swap(self, v: "SketchVector") -> "void":
        return _fusion.SketchVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::iterator":
        return _fusion.SketchVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::iterator":
        return _fusion.SketchVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::reverse_iterator":
        return _fusion.SketchVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::reverse_iterator":
        return _fusion.SketchVector_rend(self)

    def clear(self) -> "void":
        return _fusion.SketchVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::allocator_type":
        return _fusion.SketchVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.SketchVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::iterator":
        return _fusion.SketchVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.SketchVector_swiginit(self, _fusion.new_SketchVector(*args))

    def push_back(self, x: "Sketch") -> "void":
        return _fusion.SketchVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::value_type const &":
        return _fusion.SketchVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::value_type const &":
        return _fusion.SketchVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::size_type", x: "Sketch") -> "void":
        return _fusion.SketchVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.SketchVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.SketchVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::size_type") -> "void":
        return _fusion.SketchVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::size_type":
        return _fusion.SketchVector_capacity(self)
    __swig_destroy__ = _fusion.delete_SketchVector

# Register SketchVector in _fusion:
_fusion.SketchVector_swigregister(SketchVector)

class SketchEntityVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.SketchEntityVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.SketchEntityVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.SketchEntityVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::size_type":
        return _fusion.SketchEntityVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity >,std::allocator< adsk::core::Ptr< adsk::fusion::SketchEntity > > > *":
        return _fusion.SketchEntityVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.SketchEntityVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::difference_type") -> "void":
        return _fusion.SketchEntityVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.SketchEntityVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::value_type const &":
        return _fusion.SketchEntityVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.SketchEntityVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::value_type":
        return _fusion.SketchEntityVector_pop(self)

    def append(self, x: "SketchEntity") -> "void":
        return _fusion.SketchEntityVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.SketchEntityVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::size_type":
        return _fusion.SketchEntityVector_size(self)

    def swap(self, v: "SketchEntityVector") -> "void":
        return _fusion.SketchEntityVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::iterator":
        return _fusion.SketchEntityVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::iterator":
        return _fusion.SketchEntityVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::reverse_iterator":
        return _fusion.SketchEntityVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::reverse_iterator":
        return _fusion.SketchEntityVector_rend(self)

    def clear(self) -> "void":
        return _fusion.SketchEntityVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::allocator_type":
        return _fusion.SketchEntityVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.SketchEntityVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::iterator":
        return _fusion.SketchEntityVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.SketchEntityVector_swiginit(self, _fusion.new_SketchEntityVector(*args))

    def push_back(self, x: "SketchEntity") -> "void":
        return _fusion.SketchEntityVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::value_type const &":
        return _fusion.SketchEntityVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::value_type const &":
        return _fusion.SketchEntityVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::size_type", x: "SketchEntity") -> "void":
        return _fusion.SketchEntityVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.SketchEntityVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.SketchEntityVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::size_type") -> "void":
        return _fusion.SketchEntityVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::size_type":
        return _fusion.SketchEntityVector_capacity(self)
    __swig_destroy__ = _fusion.delete_SketchEntityVector

# Register SketchEntityVector in _fusion:
_fusion.SketchEntityVector_swigregister(SketchEntityVector)

class SketchCurveVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.SketchCurveVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.SketchCurveVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.SketchCurveVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::size_type":
        return _fusion.SketchCurveVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve >,std::allocator< adsk::core::Ptr< adsk::fusion::SketchCurve > > > *":
        return _fusion.SketchCurveVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.SketchCurveVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::difference_type") -> "void":
        return _fusion.SketchCurveVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.SketchCurveVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::value_type const &":
        return _fusion.SketchCurveVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.SketchCurveVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::value_type":
        return _fusion.SketchCurveVector_pop(self)

    def append(self, x: "SketchCurve") -> "void":
        return _fusion.SketchCurveVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.SketchCurveVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::size_type":
        return _fusion.SketchCurveVector_size(self)

    def swap(self, v: "SketchCurveVector") -> "void":
        return _fusion.SketchCurveVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::iterator":
        return _fusion.SketchCurveVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::iterator":
        return _fusion.SketchCurveVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::reverse_iterator":
        return _fusion.SketchCurveVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::reverse_iterator":
        return _fusion.SketchCurveVector_rend(self)

    def clear(self) -> "void":
        return _fusion.SketchCurveVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::allocator_type":
        return _fusion.SketchCurveVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.SketchCurveVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::iterator":
        return _fusion.SketchCurveVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.SketchCurveVector_swiginit(self, _fusion.new_SketchCurveVector(*args))

    def push_back(self, x: "SketchCurve") -> "void":
        return _fusion.SketchCurveVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::value_type const &":
        return _fusion.SketchCurveVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::value_type const &":
        return _fusion.SketchCurveVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::size_type", x: "SketchCurve") -> "void":
        return _fusion.SketchCurveVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.SketchCurveVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.SketchCurveVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::size_type") -> "void":
        return _fusion.SketchCurveVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::size_type":
        return _fusion.SketchCurveVector_capacity(self)
    __swig_destroy__ = _fusion.delete_SketchCurveVector

# Register SketchCurveVector in _fusion:
_fusion.SketchCurveVector_swigregister(SketchCurveVector)

class SketchLineVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.SketchLineVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.SketchLineVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.SketchLineVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::size_type":
        return _fusion.SketchLineVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine >,std::allocator< adsk::core::Ptr< adsk::fusion::SketchLine > > > *":
        return _fusion.SketchLineVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.SketchLineVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::difference_type") -> "void":
        return _fusion.SketchLineVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.SketchLineVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::value_type const &":
        return _fusion.SketchLineVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.SketchLineVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::value_type":
        return _fusion.SketchLineVector_pop(self)

    def append(self, x: "SketchLine") -> "void":
        return _fusion.SketchLineVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.SketchLineVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::size_type":
        return _fusion.SketchLineVector_size(self)

    def swap(self, v: "SketchLineVector") -> "void":
        return _fusion.SketchLineVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::iterator":
        return _fusion.SketchLineVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::iterator":
        return _fusion.SketchLineVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::reverse_iterator":
        return _fusion.SketchLineVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::reverse_iterator":
        return _fusion.SketchLineVector_rend(self)

    def clear(self) -> "void":
        return _fusion.SketchLineVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::allocator_type":
        return _fusion.SketchLineVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.SketchLineVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::iterator":
        return _fusion.SketchLineVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.SketchLineVector_swiginit(self, _fusion.new_SketchLineVector(*args))

    def push_back(self, x: "SketchLine") -> "void":
        return _fusion.SketchLineVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::value_type const &":
        return _fusion.SketchLineVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::value_type const &":
        return _fusion.SketchLineVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::size_type", x: "SketchLine") -> "void":
        return _fusion.SketchLineVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.SketchLineVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.SketchLineVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::size_type") -> "void":
        return _fusion.SketchLineVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::size_type":
        return _fusion.SketchLineVector_capacity(self)
    __swig_destroy__ = _fusion.delete_SketchLineVector

# Register SketchLineVector in _fusion:
_fusion.SketchLineVector_swigregister(SketchLineVector)

class Matrix3DVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.Matrix3DVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.Matrix3DVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.Matrix3DVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::size_type":
        return _fusion.Matrix3DVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D >,std::allocator< adsk::core::Ptr< adsk::core::Matrix3D > > > *":
        return _fusion.Matrix3DVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.Matrix3DVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::difference_type") -> "void":
        return _fusion.Matrix3DVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.Matrix3DVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::value_type const &":
        return _fusion.Matrix3DVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.Matrix3DVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::value_type":
        return _fusion.Matrix3DVector_pop(self)

    def append(self, x: "Matrix3D") -> "void":
        return _fusion.Matrix3DVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.Matrix3DVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::size_type":
        return _fusion.Matrix3DVector_size(self)

    def swap(self, v: "Matrix3DVector") -> "void":
        return _fusion.Matrix3DVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::iterator":
        return _fusion.Matrix3DVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::iterator":
        return _fusion.Matrix3DVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::reverse_iterator":
        return _fusion.Matrix3DVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::reverse_iterator":
        return _fusion.Matrix3DVector_rend(self)

    def clear(self) -> "void":
        return _fusion.Matrix3DVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::allocator_type":
        return _fusion.Matrix3DVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.Matrix3DVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::iterator":
        return _fusion.Matrix3DVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.Matrix3DVector_swiginit(self, _fusion.new_Matrix3DVector(*args))

    def push_back(self, x: "Matrix3D") -> "void":
        return _fusion.Matrix3DVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::value_type const &":
        return _fusion.Matrix3DVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::value_type const &":
        return _fusion.Matrix3DVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::size_type", x: "Matrix3D") -> "void":
        return _fusion.Matrix3DVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.Matrix3DVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.Matrix3DVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::size_type") -> "void":
        return _fusion.Matrix3DVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::size_type":
        return _fusion.Matrix3DVector_capacity(self)
    __swig_destroy__ = _fusion.delete_Matrix3DVector

# Register Matrix3DVector in _fusion:
_fusion.Matrix3DVector_swigregister(Matrix3DVector)

class Curve3DVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.Curve3DVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.Curve3DVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.Curve3DVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::size_type":
        return _fusion.Curve3DVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D >,std::allocator< adsk::core::Ptr< adsk::core::Curve3D > > > *":
        return _fusion.Curve3DVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.Curve3DVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::difference_type") -> "void":
        return _fusion.Curve3DVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.Curve3DVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::value_type const &":
        return _fusion.Curve3DVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.Curve3DVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::value_type":
        return _fusion.Curve3DVector_pop(self)

    def append(self, x: "Curve3D") -> "void":
        return _fusion.Curve3DVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.Curve3DVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::size_type":
        return _fusion.Curve3DVector_size(self)

    def swap(self, v: "Curve3DVector") -> "void":
        return _fusion.Curve3DVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::iterator":
        return _fusion.Curve3DVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::iterator":
        return _fusion.Curve3DVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::reverse_iterator":
        return _fusion.Curve3DVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::reverse_iterator":
        return _fusion.Curve3DVector_rend(self)

    def clear(self) -> "void":
        return _fusion.Curve3DVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::allocator_type":
        return _fusion.Curve3DVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.Curve3DVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::iterator":
        return _fusion.Curve3DVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.Curve3DVector_swiginit(self, _fusion.new_Curve3DVector(*args))

    def push_back(self, x: "Curve3D") -> "void":
        return _fusion.Curve3DVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::value_type const &":
        return _fusion.Curve3DVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::value_type const &":
        return _fusion.Curve3DVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::size_type", x: "Curve3D") -> "void":
        return _fusion.Curve3DVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.Curve3DVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.Curve3DVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::size_type") -> "void":
        return _fusion.Curve3DVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::size_type":
        return _fusion.Curve3DVector_capacity(self)
    __swig_destroy__ = _fusion.delete_Curve3DVector

# Register Curve3DVector in _fusion:
_fusion.Curve3DVector_swigregister(Curve3DVector)

class ValueInputVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fusion.ValueInputVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fusion.ValueInputVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fusion.ValueInputVector___bool__(self)

    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::size_type":
        return _fusion.ValueInputVector___len__(self)

    def __getslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::difference_type") -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput >,std::allocator< adsk::core::Ptr< adsk::core::ValueInput > > > *":
        return _fusion.ValueInputVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fusion.ValueInputVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::difference_type", j: "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::difference_type") -> "void":
        return _fusion.ValueInputVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fusion.ValueInputVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::value_type const &":
        return _fusion.ValueInputVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fusion.ValueInputVector___setitem__(self, *args)

    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::value_type":
        return _fusion.ValueInputVector_pop(self)

    def append(self, x: "ValueInput") -> "void":
        return _fusion.ValueInputVector_append(self, x)

    def empty(self) -> "bool":
        return _fusion.ValueInputVector_empty(self)

    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::size_type":
        return _fusion.ValueInputVector_size(self)

    def swap(self, v: "ValueInputVector") -> "void":
        return _fusion.ValueInputVector_swap(self, v)

    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::iterator":
        return _fusion.ValueInputVector_begin(self)

    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::iterator":
        return _fusion.ValueInputVector_end(self)

    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::reverse_iterator":
        return _fusion.ValueInputVector_rbegin(self)

    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::reverse_iterator":
        return _fusion.ValueInputVector_rend(self)

    def clear(self) -> "void":
        return _fusion.ValueInputVector_clear(self)

    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::allocator_type":
        return _fusion.ValueInputVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fusion.ValueInputVector_pop_back(self)

    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::iterator":
        return _fusion.ValueInputVector_erase(self, *args)

    def __init__(self, *args):
        _fusion.ValueInputVector_swiginit(self, _fusion.new_ValueInputVector(*args))

    def push_back(self, x: "ValueInput") -> "void":
        return _fusion.ValueInputVector_push_back(self, x)

    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::value_type const &":
        return _fusion.ValueInputVector_front(self)

    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::value_type const &":
        return _fusion.ValueInputVector_back(self)

    def assign(self, n: "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::size_type", x: "ValueInput") -> "void":
        return _fusion.ValueInputVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fusion.ValueInputVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fusion.ValueInputVector_insert(self, *args)

    def reserve(self, n: "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::size_type") -> "void":
        return _fusion.ValueInputVector_reserve(self, n)

    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::size_type":
        return _fusion.ValueInputVector_capacity(self)
    __swig_destroy__ = _fusion.delete_ValueInputVector

# Register ValueInputVector in _fusion:
_fusion.ValueInputVector_swigregister(ValueInputVector)

class AreaProperties(Base):
    r"""The Area properties of a sketch profile or planar surface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::AreaProperties *":
        return _fusion.AreaProperties___deref__(self)

    def __eq__(self, rhs: "AreaProperties") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.AreaProperties___eq__(self, rhs)


    def __ne__(self, rhs: "AreaProperties") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.AreaProperties___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.AreaProperties_classType()
    __swig_destroy__ = _fusion.delete_AreaProperties

    def _get_area(self) -> "double":
        r"""Gets the area in the square centimeters."""
        return _fusion.AreaProperties__get_area(self)

    def _get_centroid(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""
        Gets the centroid where the units are centimeters.
        The Location is relative to the sketch origin for a profile or relative to the world coordinate system for a planar face.
        """
        return _fusion.AreaProperties__get_centroid(self)

    def _get_perimeter(self) -> "double":
        r"""
        Gets the perimeter in centimeters.
        The perimeter is the sum of the length of all the curves or edges of the profile or planar surface
        """
        return _fusion.AreaProperties__get_perimeter(self)

    def _get_rotationToPrincipal(self) -> "double":
        r"""Gets the angle of rotation of the principal axes."""
        return _fusion.AreaProperties__get_rotationToPrincipal(self)

    def _get_accuracy(self) -> "adsk::fusion::CalculationAccuracy":
        r"""Returns the accuracy that was used for the calculation."""
        return _fusion.AreaProperties__get_accuracy(self)

    def getPrincipalAxes(self) -> "bool":
        r"""
        Method that returns the principal axes. 
        xAxis : The output Vector3D object that indicates the direction of the x axis. 
        yAxis : The output Vector3D object that indicates the direction of the y axis. 
        Returns true if successful
        """
        return _fusion.AreaProperties_getPrincipalAxes(self)

    def getMomentsOfInertia(self) -> "bool":
        r"""
        Method that, for a sketch, returns the moments of inertia about the sketch origin. 
        For a planar face, this method returns the moments about the world coordinate system origin.
        Unit for returned values is kg/cm^2. 
        ixx : Output Double that returns the XX partial moment. 
        iyy : Output Double that returns the YY partial moment. 
        izz : Output Double that returns the ZZ partial moment. 
        ixy : Output Double that returns the XY partial moment. 
        iyz : Output Double that returns the YZ partial moment. 
        ixz : Output Double that returns the XZ partial moment. 
        Returns true if successful
        """
        return _fusion.AreaProperties_getMomentsOfInertia(self)

    def getCentroidMomentsOfInertia(self) -> "bool":
        r"""
        Method that returns the moments of inertia about the centroid. Unit for returned values is kg/cm^2. 
        ixx : Output Double that returns the XX partial moment. 
        iyy : Output Double that returns the YY partial moment. 
        izz : Output Double that returns the ZZ partial moment. 
        ixy : Output Double that returns the XY partial moment. 
        iyz : Output Double that returns the YZ partial moment. 
        ixz : Output Double that returns the XZ partial moment. 
        Returns true if successful
        """
        return _fusion.AreaProperties_getCentroidMomentsOfInertia(self)

    def getPrincipalMomentsOfInertia(self) -> "bool":
        r"""
        Method that returns the moments of inertia about the principal axes. Unit for returned values is kg/cm^2. 
        i1 : Output Double that specifies the first moment of inertia. 
        i2 : Output Double that specifies the second moment of inertia. 
        i3 : Output Double that specifies the third moment of inertia. 
        Returns true if successful
        """
        return _fusion.AreaProperties_getPrincipalMomentsOfInertia(self)

    def getRadiusOfGyration(self) -> "bool":
        r"""
        Method that returns the radius of gyration about the principal axes. Unit for returned values is cm. 
        kxx : Output Double that returns the X partial radius of gyration. 
        kyy : Output Double that returns the Y partial radius of gyration. 
        kzz : Output Double that returns the Z partial radius of gyration. 
        Returns true if successful
        """
        return _fusion.AreaProperties_getRadiusOfGyration(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.AreaProperties__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.AreaProperties__get_isValid(self)

# Register AreaProperties in _fusion:
_fusion.AreaProperties_swigregister(AreaProperties)

def AreaProperties_classType() -> "char const *":
    return _fusion.AreaProperties_classType()


AreaProperties.area = property(AreaProperties._get_area, doc="Gets the area in the square centimeters.")


AreaProperties.centroid = property(AreaProperties._get_centroid, doc="Gets the centroid where the units are centimeters.\nThe Location is relative to the sketch origin for a profile or relative to the world coordinate system for a planar face.")


AreaProperties.perimeter = property(AreaProperties._get_perimeter, doc="Gets the perimeter in centimeters.\nThe perimeter is the sum of the length of all the curves or edges of the profile or planar surface")


AreaProperties.rotationToPrincipal = property(AreaProperties._get_rotationToPrincipal, doc="Gets the angle of rotation of the principal axes.")


AreaProperties.accuracy = property(AreaProperties._get_accuracy, doc="Returns the accuracy that was used for the calculation.")


AreaProperties.cast = lambda arg: arg if isinstance(arg, AreaProperties) else None

class AsBuiltJoint(Base):
    r"""Represent an as-built joint."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::AsBuiltJoint *":
        return _fusion.AsBuiltJoint___deref__(self)

    def __eq__(self, rhs: "AsBuiltJoint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.AsBuiltJoint___eq__(self, rhs)


    def __ne__(self, rhs: "AsBuiltJoint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.AsBuiltJoint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.AsBuiltJoint_classType()
    __swig_destroy__ = _fusion.delete_AsBuiltJoint

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this AsBuiltJoint."""
        return _fusion.AsBuiltJoint__get_parentComponent(self)

    def _get_name(self) -> "std::string":
        r"""
        The name of the as-built joint as it is displayed in the timeline and the browser. The
        name can be changed.
        """
        return _fusion.AsBuiltJoint__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""
        The name of the as-built joint as it is displayed in the timeline and the browser. The
        name can be changed.
        """
        return _fusion.AsBuiltJoint__set_name(self, value)

    def _get_occurrenceOne(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""Specifies the first of two occurrences the joint is between."""
        return _fusion.AsBuiltJoint__get_occurrenceOne(self)

    def _get_occurrenceTwo(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""Specifies the second of two occurrences the joint is between."""
        return _fusion.AsBuiltJoint__get_occurrenceTwo(self)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::fusion::JointGeometry >":
        r"""
        Specifies the position of the joint. Getting this property will return null and
        setting it will be ignored in the case where the joint motion is rigid.
        """
        return _fusion.AsBuiltJoint__get_geometry(self)

    def _set_geometry(self, value: "JointGeometry") -> "bool":
        r"""
        Specifies the position of the joint. Getting this property will return null and
        setting it will be ignored in the case where the joint motion is rigid.
        """
        return _fusion.AsBuiltJoint__set_geometry(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this as-built joint. 
        Returns true if the delete was successful.
        """
        return _fusion.AsBuiltJoint_deleteMe(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this as-built joint."""
        return _fusion.AsBuiltJoint__get_timelineObject(self)

    def _get_jointMotion(self) -> "adsk::core::Ptr< adsk::fusion::JointMotion >":
        r"""Returns a JointMotion object that defines the motion relationship between the two geometries."""
        return _fusion.AsBuiltJoint__get_jointMotion(self)

    def setAsRigidJointMotion(self) -> "bool":
        r"""
        Redefines the relationship between the two joint geometries as a rigid joint. 
        Returns true if successful.
        """
        return _fusion.AsBuiltJoint_setAsRigidJointMotion(self)

    def setAsRevoluteJointMotion(self, *args) -> "bool":
        r"""
        Redefines the relationship between the two joint geometries as a revolute joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        geometry : Redefines the joint geometry. If not provided, the existing geometry is used. This argument is 
        required if the current joint motion is rigid. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived
        from. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJoint_setAsRevoluteJointMotion(self, *args)

    def setAsSliderJointMotion(self, *args) -> "bool":
        r"""
        Redefines the relationship between the two joint geometries as a slider joint. 
        sliderDirection : Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the 
        customSliderDirectionEntity argument must also be provided. 
        geometry : Redefines the joint geometry. If not provided, the existing geometry is used. This argument is 
        required if the current joint motion is rigid. 
        customSliderDirectionEntity : If the sliderDirection is CustomJointDirection this argument is used to specify the entity that defines
        the custom slider direction. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJoint_setAsSliderJointMotion(self, *args)

    def setAsCylindricalJointMotion(self, *args) -> "bool":
        r"""
        Redefines the relationship between the two joint geometries as a cylindrical joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        geometry : Redefines the joint geometry. If not provided, the existing geometry is used. This argument is 
        required if the current joint motion is rigid. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived
        from. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJoint_setAsCylindricalJointMotion(self, *args)

    def setAsPinSlotJointMotion(self, *args) -> "bool":
        r"""
        Redefines the relationship between the two joint geometries as a pin-slot joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        slideDirection : Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the 
        customSlideDirectionEntity argument must also be provided. 
        geometry : Redefines the joint geometry. If not provided, the existing geometry is used. This argument is 
        required if the current joint motion is rigid. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived 
        customSlideDirectionEntity : If the slideDirection is CustomJointDirection this argument is used to specify the entity that defines
        the custom slide direction. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJoint_setAsPinSlotJointMotion(self, *args)

    def setAsPlanarJointMotion(self, *args) -> "bool":
        r"""
        Redefines the relationship between the two joint geometries as a planar joint. 
        normalDirection : Defines the direction of the normal of the single degree of rotation.
        This can be set to XAxisJointDirection, YAxisJointDirection, ZAxisJointDirection, 
        or CustomJointDirection. If set to CustomJointDirection then the customNormalDirectionEntity
        argument must also be provided. 
        geometry : Redefines the joint geometry. If not provided, the existing geometry is used. This argument is 
        required if the current joint motion is rigid. 
        customNormalDirectionEntity : If the normalDirection is CustomJointDirection this argument is used to specify the entity that defines
        the direction of the normal. This can be several types of entities that can define a direction. 
        customPrimarySlideDirection : This arguments defines the direction of the primary slide direction. A default primary slide direction 
        is automatically chosen and will be used if this argument is not provided or is null. The secondary slide
        direction is automatically inferred from the normal and primary slide directions. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJoint_setAsPlanarJointMotion(self, *args)

    def setAsBallJointMotion(self, *args) -> "bool":
        r"""
        Redefines the relationship between the two joint geometries as a ball joint. 
        pitchDirection : Defines the direction the pitch angle is measured from. This can be ZAxisJointDirection or CustomJointDirection. If
        CustomJointDirection is specified then you must also provide a value for the customPitchDirection argument. 
        yawDirection : Defines the direction the yaw is measured from. This can be XAxisJointDirection or CustomJointDirection. If
        CustomJointDirection is specified then you must also provide a value for the customYawDirection argument. 
        geometry : Redefines the joint geometry. If not provided, the existing geometry is used. This argument is 
        required if the current joint motion is rigid. 
        customPitchDirection : If the pitchDirection argument is customPitchDirection this argument is used to define the direction the pitch
        angel is measured from. This can be several types of entities that can define a direction. 
        customYawDirection : If the yawDirection argument is customPitchDirection this argument is used to define the direction the yaw
        angel is measured from. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJoint_setAsBallJointMotion(self, *args)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::AsBuiltJoint >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.AsBuiltJoint__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::AsBuiltJoint >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.AsBuiltJoint_createForAssemblyContext(self, occurrence)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.AsBuiltJoint__get_assemblyContext(self)

    def _get_isSuppressed(self) -> "bool":
        r"""Gets and sets if this as-built joint is suppressed."""
        return _fusion.AsBuiltJoint__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""Gets and sets if this as-built joint is suppressed."""
        return _fusion.AsBuiltJoint__set_isSuppressed(self, value)

    def _get_isLightBulbOn(self) -> "bool":
        r"""
        Gets and sets if the light bulb of this as-built joint as displayed in the browser is on or off.
        A joint will only be visible if the light bulb is switched on. However,
        the light bulb can be on and the joint still invisible if a higher level occurrence 
        in the assembly context is not visible because its light bulb is off or the joints folder
        is light bulb is off.
        """
        return _fusion.AsBuiltJoint__get_isLightBulbOn(self)

    def _set_isLightBulbOn(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the light bulb of this as-built joint as displayed in the browser is on or off.
        A joint will only be visible if the light bulb is switched on. However,
        the light bulb can be on and the joint still invisible if a higher level occurrence 
        in the assembly context is not visible because its light bulb is off or the joints folder
        is light bulb is off.
        """
        return _fusion.AsBuiltJoint__set_isLightBulbOn(self, value)

    def _get_isVisible(self) -> "bool":
        r"""
        Gets whether the as-built joint is visible. To change the visibility see the isLightBulbOn property.
        This property is affected by the assembly context.
        """
        return _fusion.AsBuiltJoint__get_isVisible(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this as-built joint."""
        return _fusion.AsBuiltJoint__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the AsBuiltJoint object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same as-built joint.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.AsBuiltJoint__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.AsBuiltJoint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.AsBuiltJoint__get_isValid(self)

# Register AsBuiltJoint in _fusion:
_fusion.AsBuiltJoint_swigregister(AsBuiltJoint)

def AsBuiltJoint_classType() -> "char const *":
    return _fusion.AsBuiltJoint_classType()


AsBuiltJoint.parentComponent = property(AsBuiltJoint._get_parentComponent, doc="Returns the parent component that owns this AsBuiltJoint.")


AsBuiltJoint.name = property(AsBuiltJoint._get_name, AsBuiltJoint._set_name, doc="The name of the as-built joint as it is displayed in the timeline and the browser. The\nname can be changed.")


AsBuiltJoint.occurrenceOne = property(AsBuiltJoint._get_occurrenceOne, doc="Specifies the first of two occurrences the joint is between.")


AsBuiltJoint.occurrenceTwo = property(AsBuiltJoint._get_occurrenceTwo, doc="Specifies the second of two occurrences the joint is between.")


AsBuiltJoint.geometry = property(AsBuiltJoint._get_geometry, AsBuiltJoint._set_geometry, doc="Specifies the position of the joint. Getting this property will return null and\nsetting it will be ignored in the case where the joint motion is rigid.")


AsBuiltJoint.timelineObject = property(AsBuiltJoint._get_timelineObject, doc="Returns the timeline object associated with this as-built joint.")


AsBuiltJoint.jointMotion = property(AsBuiltJoint._get_jointMotion, doc="Returns a JointMotion object that defines the motion relationship between the two geometries.")


AsBuiltJoint.nativeObject = property(AsBuiltJoint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


AsBuiltJoint.assemblyContext = property(AsBuiltJoint._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")


AsBuiltJoint.isSuppressed = property(AsBuiltJoint._get_isSuppressed, AsBuiltJoint._set_isSuppressed, doc="Gets and sets if this as-built joint is suppressed.")


AsBuiltJoint.isLightBulbOn = property(AsBuiltJoint._get_isLightBulbOn, AsBuiltJoint._set_isLightBulbOn, doc="Gets and sets if the light bulb of this as-built joint as displayed in the browser is on or off.\nA joint will only be visible if the light bulb is switched on. However,\nthe light bulb can be on and the joint still invisible if a higher level occurrence\nin the assembly context is not visible because its light bulb is off or the joints folder\nis light bulb is off.")


AsBuiltJoint.isVisible = property(AsBuiltJoint._get_isVisible, doc="Gets whether the as-built joint is visible. To change the visibility see the isLightBulbOn property.\nThis property is affected by the assembly context.")


AsBuiltJoint.attributes = property(AsBuiltJoint._get_attributes, doc="Returns the collection of attributes associated with this as-built joint.")


AsBuiltJoint.entityToken = property(AsBuiltJoint._get_entityToken, doc="Returns a token for the AsBuiltJoint object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same as-built joint.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.")


AsBuiltJoint.cast = lambda arg: arg if isinstance(arg, AsBuiltJoint) else None

class AsBuiltJointInput(Base):
    r"""Defines all of the information needed to create an as-built joint."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::AsBuiltJointInput *":
        return _fusion.AsBuiltJointInput___deref__(self)

    def __eq__(self, rhs: "AsBuiltJointInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.AsBuiltJointInput___eq__(self, rhs)


    def __ne__(self, rhs: "AsBuiltJointInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.AsBuiltJointInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.AsBuiltJointInput_classType()
    __swig_destroy__ = _fusion.delete_AsBuiltJointInput

    def _get_occurrenceOne(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""Specifies the first of two occurrences the joint is between."""
        return _fusion.AsBuiltJointInput__get_occurrenceOne(self)

    def _set_occurrenceOne(self, value: "Occurrence") -> "bool":
        r"""Specifies the first of two occurrences the joint is between."""
        return _fusion.AsBuiltJointInput__set_occurrenceOne(self, value)

    def _get_occurrenceTwo(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""Specifies the second of two occurrences the joint is between."""
        return _fusion.AsBuiltJointInput__get_occurrenceTwo(self)

    def _set_occurrenceTwo(self, value: "Occurrence") -> "bool":
        r"""Specifies the second of two occurrences the joint is between."""
        return _fusion.AsBuiltJointInput__set_occurrenceTwo(self, value)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::fusion::JointGeometry >":
        r"""Specifies the position of the joint."""
        return _fusion.AsBuiltJointInput__get_geometry(self)

    def _set_geometry(self, value: "JointGeometry") -> "bool":
        r"""Specifies the position of the joint."""
        return _fusion.AsBuiltJointInput__set_geometry(self, value)

    def setAsRigidJointMotion(self) -> "bool":
        r"""
        Defines the relationship between the two joint geometries as a rigid joint. 
        Returns true if successful.
        """
        return _fusion.AsBuiltJointInput_setAsRigidJointMotion(self)

    def setAsRevoluteJointMotion(self, *args) -> "bool":
        r"""
        Defines the relationship between the two joint geometries as a revolute joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived
        from. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJointInput_setAsRevoluteJointMotion(self, *args)

    def setAsSliderJointMotion(self, *args) -> "bool":
        r"""
        Defines the relationship between the two joint geometries as a slider joint. 
        sliderDirection : Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the 
        customSliderDirectionEntity argument must also be provided. 
        customSliderDirectionEntity : If the sliderDirection is CustomJointDirection this argument is used to specify the entity that defines
        the custom slider direction. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJointInput_setAsSliderJointMotion(self, *args)

    def setAsCylindricalJointMotion(self, *args) -> "bool":
        r"""
        Defines the relationship between the two joint geometries as a cylindrical joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived
        from. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJointInput_setAsCylindricalJointMotion(self, *args)

    def setAsPinSlotJointMotion(self, *args) -> "bool":
        r"""
        Defines the relationship between the two joint geometries as a pin-slot joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        slideDirection : Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the 
        customSlideDirectionEntity argument must also be provided. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived 
        customSlideDirectionEntity : If the slideDirection is CustomJointDirection this argument is used to specify the entity that defines
        the custom slide direction. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJointInput_setAsPinSlotJointMotion(self, *args)

    def setAsPlanarJointMotion(self, *args) -> "bool":
        r"""
        Defines the relationship between the two joint geometries as a planar joint. 
        normalDirection : Defines the direction of the normal of the single degree of rotation.
        This can be set to XAxisJointDirection, YAxisJointDirection, ZAxisJointDirection, 
        or CustomJointDirection. If set to CustomJointDirection then the customNormalDirectionEntity
        argument must also be provided. 
        customNormalDirectionEntity : If the normalDirection is CustomJointDirection this argument is used to specify the entity that defines
        the direction of the normal. This can be several types of entities that can define a direction. 
        customPrimarySlideDirection : This arguments defines the direction of the primary slide direction. A default primary slide direction 
        is automatically chosen and will be used if this argument is not provided or is null. The secondary slide
        direction is automatically inferred from the normal and primary slide directions. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJointInput_setAsPlanarJointMotion(self, *args)

    def setAsBallJointMotion(self, *args) -> "bool":
        r"""
        Defines the relationship between the two joint geometries as a ball joint. 
        pitchDirection : Defines the direction the pitch angle is measured from. This can be ZAxisJointDirection or CustomJointDirection. If
        CustomJointDirection is specified then you must also provide a value for the customPitchDirection argument. 
        yawDirection : Defines the direction the yaw is measured from. This can be XAxisJointDirection or CustomJointDirection. If
        CustomJointDirection is specified then you must also provide a value for the customYawDirection argument. 
        customPitchDirection : If the pitchDirection argument is customPitchDirection this argument is used to define the direction the pitch
        angel is measured from. This can be several types of entities that can define a direction. 
        customYawDirection : If the yawDirection argument is customPitchDirection this argument is used to define the direction the yaw
        angel is measured from. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJointInput_setAsBallJointMotion(self, *args)

    def _get_jointMotion(self) -> "adsk::core::Ptr< adsk::fusion::JointMotion >":
        r"""
        Returns one of the objects derived from JointMotion that defines how the motion between
        the two joint geometries is defined. Can be null if the motion hasn't yet been defined.
        """
        return _fusion.AsBuiltJointInput__get_jointMotion(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.AsBuiltJointInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.AsBuiltJointInput__get_isValid(self)

# Register AsBuiltJointInput in _fusion:
_fusion.AsBuiltJointInput_swigregister(AsBuiltJointInput)

def AsBuiltJointInput_classType() -> "char const *":
    return _fusion.AsBuiltJointInput_classType()


AsBuiltJointInput.occurrenceOne = property(AsBuiltJointInput._get_occurrenceOne, AsBuiltJointInput._set_occurrenceOne, doc="Specifies the first of two occurrences the joint is between.")


AsBuiltJointInput.occurrenceTwo = property(AsBuiltJointInput._get_occurrenceTwo, AsBuiltJointInput._set_occurrenceTwo, doc="Specifies the second of two occurrences the joint is between.")


AsBuiltJointInput.geometry = property(AsBuiltJointInput._get_geometry, AsBuiltJointInput._set_geometry, doc="Specifies the position of the joint.")


AsBuiltJointInput.jointMotion = property(AsBuiltJointInput._get_jointMotion, doc="Returns one of the objects derived from JointMotion that defines how the motion between\nthe two joint geometries is defined. Can be null if the motion hasn't yet been defined.")


AsBuiltJointInput.cast = lambda arg: arg if isinstance(arg, AsBuiltJointInput) else None

class AsBuiltJointList(Base):
    r"""A list of as-built joints."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::AsBuiltJointList *":
        return _fusion.AsBuiltJointList___deref__(self)

    def __eq__(self, rhs: "AsBuiltJointList") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.AsBuiltJointList___eq__(self, rhs)


    def __ne__(self, rhs: "AsBuiltJointList") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.AsBuiltJointList___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.AsBuiltJointList___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::AsBuiltJoint >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.AsBuiltJointList___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.AsBuiltJointList_classType()
    __swig_destroy__ = _fusion.delete_AsBuiltJointList

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::AsBuiltJoint >":
        r"""
        Function that returns the specified as-built joint using an index into the list. 
        index : The index of the item within the list to return. The first item in the list has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.AsBuiltJointList_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::AsBuiltJoint >":
        r"""
        Function that returns the specified as-built joint using a name. 
        name : The name of the item within the list to return. 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.AsBuiltJointList_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""Returns number of as-built joints in the list."""
        return _fusion.AsBuiltJointList__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.AsBuiltJointList__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.AsBuiltJointList__get_isValid(self)

# Register AsBuiltJointList in _fusion:
_fusion.AsBuiltJointList_swigregister(AsBuiltJointList)

def AsBuiltJointList_classType() -> "char const *":
    return _fusion.AsBuiltJointList_classType()


AsBuiltJointList.count = property(AsBuiltJointList._get_count, doc="Returns number of as-built joints in the list.")


AsBuiltJointList.cast = lambda arg: arg if isinstance(arg, AsBuiltJointList) else None

class AsBuiltJoints(Base):
    r"""
    The collection of as-built joints in this component. This provides access to all existing 
    as-built joints and supports the ability to create new as-built joints.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::AsBuiltJoints *":
        return _fusion.AsBuiltJoints___deref__(self)

    def __eq__(self, rhs: "AsBuiltJoints") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.AsBuiltJoints___eq__(self, rhs)


    def __ne__(self, rhs: "AsBuiltJoints") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.AsBuiltJoints___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.AsBuiltJoints___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::AsBuiltJoint >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.AsBuiltJoints___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.AsBuiltJoints_classType()
    __swig_destroy__ = _fusion.delete_AsBuiltJoints

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::AsBuiltJoint >":
        r"""
        Function that returns the specified as-built joint using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.AsBuiltJoints_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::AsBuiltJoint >":
        r"""
        Function that returns the specified as-built joint using a name. 
        name : The name of the item within the collection to return. 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.AsBuiltJoints_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""Returns number of joint origins in the collection."""
        return _fusion.AsBuiltJoints__get_count(self)

    def createInput(self, occurrenceOne: "Occurrence", occurrenceTwo: "Occurrence", geometry: "JointGeometry") -> "adsk::core::Ptr< adsk::fusion::AsBuiltJointInput >":
        r"""
        Creates an AsBuiltJointInput object which is used to collect all of the information needed
        to create an as-built joint. This object is equivalent to the as-built joint dialog in the 
        user-interface in that it doesn't represent an actual joint but just the information needed
        to create an as-built joint. Once this is fully defined the add method can be called, passing
        this object in to create the actual joint. 
        occurrenceOne : Specifies the first of two occurrences the joint is between. 
        occurrenceTwo : Specifies the second of two occurrences the joint is between. 
        geometry : Specifies the geometry of where the joint will be positioned. If the as-built joint is
        a rigid joint, this argument should be null because no geometry is needed. 
        Returns the new AsBuiltJointInput object or null in the case of failure.
        """
        return _fusion.AsBuiltJoints_createInput(self, occurrenceOne, occurrenceTwo, geometry)

    def add(self, input: "AsBuiltJointInput") -> "adsk::core::Ptr< adsk::fusion::AsBuiltJoint >":
        r"""
        Creates a new as-built joint. 
        input : An AsBuiltJointInput object that was created using the AsBuiltJoints.createInput method and then fully defined
        using the properties and methods on the AsBuiltJointInput object. 
        Returns the new AsBuiltJoint object or null in the case of failure.
        """
        return _fusion.AsBuiltJoints_add(self, input)

    def _get_objectType(self) -> "char const *":
        return _fusion.AsBuiltJoints__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.AsBuiltJoints__get_isValid(self)

# Register AsBuiltJoints in _fusion:
_fusion.AsBuiltJoints_swigregister(AsBuiltJoints)

def AsBuiltJoints_classType() -> "char const *":
    return _fusion.AsBuiltJoints_classType()


AsBuiltJoints.count = property(AsBuiltJoints._get_count, doc="Returns number of joint origins in the collection.")


AsBuiltJoints.cast = lambda arg: arg if isinstance(arg, AsBuiltJoints) else None

class BaseComponent(Base):
    r"""
    The BaseComponent object that defines all of the common design data
    and is the base class for the product specific components.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BaseComponent *":
        return _fusion.BaseComponent___deref__(self)

    def __eq__(self, rhs: "BaseComponent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BaseComponent___eq__(self, rhs)


    def __ne__(self, rhs: "BaseComponent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BaseComponent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BaseComponent_classType()
    __swig_destroy__ = _fusion.delete_BaseComponent

    def _get_name(self) -> "std::string":
        r"""
        Property that gets and sets the name of this component. This is the name
        shown in the browser for each occurrence referencing this component.
        """
        return _fusion.BaseComponent__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""
        Property that gets and sets the name of this component. This is the name
        shown in the browser for each occurrence referencing this component.
        """
        return _fusion.BaseComponent__set_name(self, value)

    def _get_occurrences(self) -> "adsk::core::Ptr< adsk::fusion::Occurrences >":
        r"""
        Property that returns the Occurrences collection associated with this component.
        This provides access to the occurrences at the top-level of this component and provides
        the functionality to add new occurrences.
        """
        return _fusion.BaseComponent__get_occurrences(self)

    def occurrencesByComponent(self, component: "Component") -> "adsk::core::Ptr< adsk::fusion::OccurrenceList >":
        r"""
        Returns all occurrences at the top-level of this component that reference the specified component.
        The returned list is read-only. 
        component : The component that is being referenced by the occurrences that will be returned. 
        The occurrences referenced by the specified component.
        """
        return _fusion.BaseComponent_occurrencesByComponent(self, component)

    def _get_allOccurrences(self) -> "adsk::core::Ptr< adsk::fusion::OccurrenceList >":
        r"""
        Returns all of the occurrences in the assembly regardless of their level within the assembly structure.
        The returned list is read-only.
        """
        return _fusion.BaseComponent__get_allOccurrences(self)

    def allOccurrencesByComponent(self, component: "Component") -> "adsk::core::Ptr< adsk::fusion::OccurrenceList >":
        r"""
        Returns all occurrences, at any level of the assembly, that reference the specified component.
        The returned list is read-only. 
        component : The component that is being referenced by the occurrences that will be returned. 
        The occurrences referenced by the specified component.
        """
        return _fusion.BaseComponent_allOccurrencesByComponent(self, component)

    def _get_constructionPlanes(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlanes >":
        r"""
        Returns the construction planes collection associated with this component.
        This provides access to the existing construction planes and supports
        the creation of new construction planes.
        """
        return _fusion.BaseComponent__get_constructionPlanes(self)

    def _get_constructionAxes(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxes >":
        r"""
        Returns the construction axes collection associated with this component.
        This provides access to the existing construction axes and supports
        the creation of new construction axes.
        """
        return _fusion.BaseComponent__get_constructionAxes(self)

    def _get_constructionPoints(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoints >":
        r"""
        Returns the construction points collection associated with this component.
        This provides access to the existing construction points and supports
        the creation of new construction points.
        """
        return _fusion.BaseComponent__get_constructionPoints(self)

    def _get_bRepBodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""Returns the B-Rep bodies collection associated with this component."""
        return _fusion.BaseComponent__get_bRepBodies(self)

    def _get_parentDesign(self) -> "adsk::core::Ptr< adsk::fusion::Design >":
        r"""Returns the parent product this component is owned by."""
        return _fusion.BaseComponent__get_parentDesign(self)

    def findBRepUsingRay(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Finds all the B-Rep entities that are intersected by the specified ray. This can return BRepFace, BrepEdge,
        and BRepVertex objects. 
        originPoint : Input point that defines the origin of the ray. The search for entities begins at this point. 
        rayDirection : Input vector that defines the direction of the ray. The ray is infinite so the length of the vector is ignored. 
        entityType : The type of B-Rep entity wanted. You can also take advantage of B-Rep topology to infer other intersections. For example,
        If you get a BRepEdge it implies that the faces the edge connects were also intersected. If a BRepVertex is returned it 
        implies the edges that the vertex connects were intersected and the faces that the edges connect were intersected. 
        proximityTolerance : Optional argument that specifies the tolerance for the search. All entities within this distance from the ray and of the specified type will be returned. If not specified a default small tolerance is used. 
        visibleEntitiesOnly : Optional argument that indicates whether or not invisible entities should be included in the search. Defaults to True indicating that invisible entities will be ignored. 
        hitPoints : An ObjectCollection of Point3D objects that represent the coordinates where the ray hit the found entity. There will be the same number of hit points as returned entities
        and they will be in the collections in the same order. In other words, hit point 1 corresponds with found entity 1, hit point 2 corresponds with found entity 2, and so on.
        Because of the proximity tolerance the hitPoint may not actually lie on the entity but will be within the proximity tolerance to it.
        It's an optional out argument, returns the hit points if an existing ObjectCollection is input. You can create a new ObjectCollection by using
        the static create method on the ObjectCollection class. 
        Returns an ObjectCollection containing the entities found. The returned collection can be empty indicating nothing was found. The points are returned
        in an order where they are arranged based on their distance from the origin point where the closest point is first. If an entity is hit more than
        once, the entity is returned once for the first intersection.
        """
        return _fusion.BaseComponent_findBRepUsingRay(self, *args)

    def findBRepUsingPoint(self, point: "Point3D", entityType: "BRepEntityTypes", proximityTolerance: "double"=-1, visibleEntitiesOnly: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Finds all the entities of the specified type at the specified location. 
        point : Input coordinate that specifies the component space point at which to find the entities. 
        entityType : The type of B-Rep entity wanted. You can also take advantage of B-Rep topology to infer other that other entities were found. For example,
        If you get a BRepEdge it implies that the faces the edge connects were also found. If a BRepVertex is returned it 
        implies the edges that the vertex connects were found and the faces that the edges connect were found. 
        proximityTolerance : Specifies the tolerance for the search. All entities within this distance from the search point that match the filter will be returned. If not specified a default tolerance is used. 
        visibleEntitiesOnly : indicates whether or not invisible objects should be included in the search. Defaults to True indicating that invisible objects will be ignored. 
        Returns an ObjectCollection containing the entities found. The returned collection can be empty indicating nothing was found.
        """
        return _fusion.BaseComponent_findBRepUsingPoint(self, point, entityType, proximityTolerance, visibleEntitiesOnly)

    def _get_objectType(self) -> "char const *":
        return _fusion.BaseComponent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BaseComponent__get_isValid(self)

# Register BaseComponent in _fusion:
_fusion.BaseComponent_swigregister(BaseComponent)

def BaseComponent_classType() -> "char const *":
    return _fusion.BaseComponent_classType()


BaseComponent.name = property(BaseComponent._get_name, BaseComponent._set_name, doc="Property that gets and sets the name of this component. This is the name\nshown in the browser for each occurrence referencing this component.")


BaseComponent.occurrences = property(BaseComponent._get_occurrences, doc="Property that returns the Occurrences collection associated with this component.\nThis provides access to the occurrences at the top-level of this component and provides\nthe functionality to add new occurrences.")


BaseComponent.allOccurrences = property(BaseComponent._get_allOccurrences, doc="Returns all of the occurrences in the assembly regardless of their level within the assembly structure.\nThe returned list is read-only.")


BaseComponent.constructionPlanes = property(BaseComponent._get_constructionPlanes, doc="Returns the construction planes collection associated with this component.\nThis provides access to the existing construction planes and supports\nthe creation of new construction planes.")


BaseComponent.constructionAxes = property(BaseComponent._get_constructionAxes, doc="Returns the construction axes collection associated with this component.\nThis provides access to the existing construction axes and supports\nthe creation of new construction axes.")


BaseComponent.constructionPoints = property(BaseComponent._get_constructionPoints, doc="Returns the construction points collection associated with this component.\nThis provides access to the existing construction points and supports\nthe creation of new construction points.")


BaseComponent.bRepBodies = property(BaseComponent._get_bRepBodies, doc="Returns the B-Rep bodies collection associated with this component.")


BaseComponent.parentDesign = property(BaseComponent._get_parentDesign, doc="Returns the parent product this component is owned by.")


BaseComponent.cast = lambda arg: arg if isinstance(arg, BaseComponent) else None

class BaseFeatures(Base):
    r"""The BaseFeature class represents a direct edit feature within a parametric design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BaseFeatures *":
        return _fusion.BaseFeatures___deref__(self)

    def __eq__(self, rhs: "BaseFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BaseFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "BaseFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BaseFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.BaseFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.BaseFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BaseFeatures_classType()
    __swig_destroy__ = _fusion.delete_BaseFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        Function that returns the specified base feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BaseFeatures_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        Function that returns the specified base feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.BaseFeatures_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of base features in the collection."""
        return _fusion.BaseFeatures__get_count(self)

    def add(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        Creates a new empty base feature in the parent component. 
        Returns the new BaseFeature or null in the case of an error.
        """
        return _fusion.BaseFeatures_add(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BaseFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BaseFeatures__get_isValid(self)

# Register BaseFeatures in _fusion:
_fusion.BaseFeatures_swigregister(BaseFeatures)

def BaseFeatures_classType() -> "char const *":
    return _fusion.BaseFeatures_classType()


BaseFeatures.count = property(BaseFeatures._get_count, doc="The number of base features in the collection.")


BaseFeatures.cast = lambda arg: arg if isinstance(arg, BaseFeatures) else None

class BoundaryFillFeatureInput(Base):
    r"""This class defines the methods and properties that pertain to the definition of a BoundaryFillFeatureInput."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BoundaryFillFeatureInput *":
        return _fusion.BoundaryFillFeatureInput___deref__(self)

    def __eq__(self, rhs: "BoundaryFillFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BoundaryFillFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "BoundaryFillFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BoundaryFillFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BoundaryFillFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_BoundaryFillFeatureInput

    def _get_bRepCells(self) -> "adsk::core::Ptr< adsk::fusion::BRepCells >":
        r"""
        Returns the collection of the valid cells that have been calculated based on the set of input tools.
        You use this collection to specify which cells you want included in the output.
        """
        return _fusion.BoundaryFillFeatureInput__get_bRepCells(self)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations":
        r"""Gets and sets the type of operation performed by the boundary fill feature."""
        return _fusion.BoundaryFillFeatureInput__get_operation(self)

    def _set_operation(self, value: "FeatureOperations") -> "bool":
        r"""Gets and sets the type of operation performed by the boundary fill feature."""
        return _fusion.BoundaryFillFeatureInput__set_operation(self, value)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the Boundary Fill is created based on geometry (e.g. a profile and/or face(s))
        in another component AND (the Boundary Fill) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.BoundaryFillFeatureInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, value: "Occurrence") -> "bool":
        r"""
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the Boundary Fill is created based on geometry (e.g. a profile and/or face(s))
        in another component AND (the Boundary Fill) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.BoundaryFillFeatureInput__set_creationOccurrence(self, value)

    def _get_tools(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the collection of one or more construction planes and open or closed 
        BRepBody objects that are used in calculating the possible closed boundaries.
        """
        return _fusion.BoundaryFillFeatureInput__get_tools(self)

    def _set_tools(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the collection of one or more construction planes and open or closed 
        BRepBody objects that are used in calculating the possible closed boundaries.
        """
        return _fusion.BoundaryFillFeatureInput__set_tools(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.BoundaryFillFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.BoundaryFillFeatureInput__set_targetBaseFeature(self, value)

    def cancel(self) -> "bool":
        r"""
        To determine the possible boundaries and allow you to choose which cells to keep, the boundary 
        fill feature does a partial compute when the input object is created. To do this it starts a boundary
        fill feature transaction and completes the transaction when you call the add method. If you don't 
        call the add method to finish the transaction it leaves Fusion 360 in a bad state and there will be undo
        problems and possibly a crash. If you have created a BoundFillFeatureInput object and don't want to finish
        the feature creation, you need to call the cancel method on the BoundaryFillFeatureInput object to 
        safely abort the current boundary fill transaction.
        """
        return _fusion.BoundaryFillFeatureInput_cancel(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BoundaryFillFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BoundaryFillFeatureInput__get_isValid(self)

# Register BoundaryFillFeatureInput in _fusion:
_fusion.BoundaryFillFeatureInput_swigregister(BoundaryFillFeatureInput)

def BoundaryFillFeatureInput_classType() -> "char const *":
    return _fusion.BoundaryFillFeatureInput_classType()


BoundaryFillFeatureInput.bRepCells = property(BoundaryFillFeatureInput._get_bRepCells, doc="Returns the collection of the valid cells that have been calculated based on the set of input tools.\nYou use this collection to specify which cells you want included in the output.")


BoundaryFillFeatureInput.operation = property(BoundaryFillFeatureInput._get_operation, BoundaryFillFeatureInput._set_operation, doc="Gets and sets the type of operation performed by the boundary fill feature.")


BoundaryFillFeatureInput.creationOccurrence = property(BoundaryFillFeatureInput._get_creationOccurrence, BoundaryFillFeatureInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an Occurrence for creation needs to be\nspecified when the Boundary Fill is created based on geometry (e.g. a profile and/or face(s))\nin another component AND (the Boundary Fill) is not in the root component.\nThe CreationOccurrence is analogous to the active occurrence in the UI")


BoundaryFillFeatureInput.tools = property(BoundaryFillFeatureInput._get_tools, BoundaryFillFeatureInput._set_tools, doc="Gets and sets the collection of one or more construction planes and open or closed\nBRepBody objects that are used in calculating the possible closed boundaries.")


BoundaryFillFeatureInput.targetBaseFeature = property(BoundaryFillFeatureInput._get_targetBaseFeature, BoundaryFillFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


BoundaryFillFeatureInput.cast = lambda arg: arg if isinstance(arg, BoundaryFillFeatureInput) else None

class BoundaryFillFeatures(Base):
    r"""
    Collection that provides access to all of the existing boundary fill features in a component
    and supports the ability to create new boundary fill features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BoundaryFillFeatures *":
        return _fusion.BoundaryFillFeatures___deref__(self)

    def __eq__(self, rhs: "BoundaryFillFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BoundaryFillFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "BoundaryFillFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BoundaryFillFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.BoundaryFillFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::BoundaryFillFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.BoundaryFillFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BoundaryFillFeatures_classType()
    __swig_destroy__ = _fusion.delete_BoundaryFillFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::BoundaryFillFeature >":
        r"""
        Function that returns the specified boundary fill feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BoundaryFillFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of boundary fill features in the collection."""
        return _fusion.BoundaryFillFeatures__get_count(self)

    def createInput(self, tools: "ObjectCollection", operation: "FeatureOperations") -> "adsk::core::Ptr< adsk::fusion::BoundaryFillFeatureInput >":
        r"""
        Creates a BoundaryFillFeatureInput object. Use properties and methods on this object
        to define the boundary fill you want to create and then use the Add method, passing in 
        the BoundaryFillFeatureInput object.
        To determine the possible boundaries and allow you to choose which cells to keep, the boundary 
        fill feature does a partial compute when the input object is created. To do this it starts a boundary
        fill feature transaction and completes the transaction when you call the add method. If you don't 
        call the add method to finish the transaction it leaves Fusion 360 in a bad state and there will be undo
        problems and possibly a crash. If you have created a BoundFillFeatureInput object and don't want to finish
        the feature creation, you need to call the cancel method on the BoundaryFillFeatureInput object to 
        safely abort the current boundary fill transaction. 
        tools : A collection of one or more construction planes and open or closed BRepBody objects that will be 
        used in calculating the possible closed boundaries. 
        operation : The operation type to perform. 
        Returns the newly created BoundaryFillFeatureInput object or null if the creation failed.
        """
        return _fusion.BoundaryFillFeatures_createInput(self, tools, operation)

    def add(self, input: "BoundaryFillFeatureInput") -> "adsk::core::Ptr< adsk::fusion::BoundaryFillFeature >":
        r"""
        Creates a new boundary fill feature. 
        input : A BoundaryFillFeatureInput object that defines the desired boundary fill feature. Use the createInput 
        method to create a new BoundaryFillFeatureInput object and then use methods on it 
        (the BoundaryFillFeatureInput object) to define the boundary fill feature. 
        Returns the newly created BoundaryFillFeature object or null if the creation failed.
        """
        return _fusion.BoundaryFillFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::BoundaryFillFeature >":
        r"""
        Function that returns the specified boundary fill feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.BoundaryFillFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.BoundaryFillFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BoundaryFillFeatures__get_isValid(self)

# Register BoundaryFillFeatures in _fusion:
_fusion.BoundaryFillFeatures_swigregister(BoundaryFillFeatures)

def BoundaryFillFeatures_classType() -> "char const *":
    return _fusion.BoundaryFillFeatures_classType()


BoundaryFillFeatures.count = property(BoundaryFillFeatures._get_count, doc="The number of boundary fill features in the collection.")


BoundaryFillFeatures.cast = lambda arg: arg if isinstance(arg, BoundaryFillFeatures) else None

class BoxFeatures(Base):
    r"""Collection that provides access to all of the existing box features in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BoxFeatures *":
        return _fusion.BoxFeatures___deref__(self)

    def __eq__(self, rhs: "BoxFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BoxFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "BoxFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BoxFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.BoxFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::BoxFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.BoxFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BoxFeatures_classType()
    __swig_destroy__ = _fusion.delete_BoxFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::BoxFeature >":
        r"""
        Function that returns the specified box feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BoxFeatures_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::BoxFeature >":
        r"""
        Function that returns the specified box feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.BoxFeatures_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of box features in the collection."""
        return _fusion.BoxFeatures__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BoxFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BoxFeatures__get_isValid(self)

# Register BoxFeatures in _fusion:
_fusion.BoxFeatures_swigregister(BoxFeatures)

def BoxFeatures_classType() -> "char const *":
    return _fusion.BoxFeatures_classType()


BoxFeatures.count = property(BoxFeatures._get_count, doc="The number of box features in the collection.")


BoxFeatures.cast = lambda arg: arg if isinstance(arg, BoxFeatures) else None

class BRepBodies(Base):
    r"""
    The BRepBodies collection provides access to all of the B-Rep
    bodies within a component.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepBodies *":
        return _fusion.BRepBodies___deref__(self)

    def __eq__(self, rhs: "BRepBodies") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepBodies___eq__(self, rhs)


    def __ne__(self, rhs: "BRepBodies") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepBodies___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.BRepBodies___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::BRepBody >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.BRepBodies___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepBodies_classType()
    __swig_destroy__ = _fusion.delete_BRepBodies

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Function that returns the specified body using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepBodies_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Returns a specific body using the name of the body within the collection. 
        name : The name of the body, as seen in the browser, to return. 
        The BRepBody or null if a body with the defined name is not found.
        """
        return _fusion.BRepBodies_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""Returns the number of bodies in the collection."""
        return _fusion.BRepBodies__get_count(self)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Creates a new BRepBody object. The input can be a persisted or transient BRepBody and the
        result is a persisted BRepBody. In a model where the design history is ignored (direct edit model)
        the BRepBody is created within the component the BRepBodies collection was obtained from. In
        a model where the design history is captured (parametric model), the new BRepBody is created
        within the specified Base Feature.
        Because of a current limitation, if you want to create a BRepBody in a parametric model, 
        you must first call the edit method of the base feature, then use the add method to create 
        the body, and finally call the finishEdit method of the base feature. The base 
        feature must be in an 'edit' state to be able to add any additional items to it. 
        body : The input BRepBody. Typically this is a transient BRepBody but that's not a requirement. In 
        any case, there is not any association back to the original BRepBody. 
        targetBaseFeature : The BaseFeature object that this B-Rep body will be associated with. This is an optional
        requirement but is required when the model design history is being captured (parametric model) but is
        ignored otherwise (direct edit model). 
        Returns the newly created BRepBody or null if the creation failed.
        """
        return _fusion.BRepBodies_add(self, *args)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepBodies__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepBodies__get_isValid(self)

# Register BRepBodies in _fusion:
_fusion.BRepBodies_swigregister(BRepBodies)

def BRepBodies_classType() -> "char const *":
    return _fusion.BRepBodies_classType()


BRepBodies.count = property(BRepBodies._get_count, doc="Returns the number of bodies in the collection.")


BRepBodies.cast = lambda arg: arg if isinstance(arg, BRepBodies) else None

class BRepBody(Base):
    r"""Represents a B-Rep (Boundary Representation) body."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepBody *":
        return _fusion.BRepBody___deref__(self)

    def __eq__(self, rhs: "BRepBody") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepBody___eq__(self, rhs)


    def __ne__(self, rhs: "BRepBody") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepBody___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepBody_classType()
    __swig_destroy__ = _fusion.delete_BRepBody

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the component this body is owned by."""
        return _fusion.BRepBody__get_parentComponent(self)

    def _get_lumps(self) -> "adsk::core::Ptr< adsk::fusion::BRepLumps >":
        r"""Returns a collection of all of the lumps in the body."""
        return _fusion.BRepBody__get_lumps(self)

    def _get_shells(self) -> "adsk::core::Ptr< adsk::fusion::BRepShells >":
        r"""Returns a collection of all of the shells in the body."""
        return _fusion.BRepBody__get_shells(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""Returns a collection of all of the faces in the body."""
        return _fusion.BRepBody__get_faces(self)

    def _get_edges(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdges >":
        r"""Returns a collection of all of the edges in the body."""
        return _fusion.BRepBody__get_edges(self)

    def _get_vertices(self) -> "adsk::core::Ptr< adsk::fusion::BRepVertices >":
        r"""Returns a collection of all of the vertices in the body."""
        return _fusion.BRepBody__get_vertices(self)

    def _get_isSolid(self) -> "bool":
        r"""Returns whether this body is closed (solid) or not."""
        return _fusion.BRepBody__get_isSolid(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the bounding box of this body."""
        return _fusion.BRepBody__get_boundingBox(self)

    def _get_concaveEdges(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdges >":
        r"""Returns all of the edges that connect concave faces."""
        return _fusion.BRepBody__get_concaveEdges(self)

    def _get_convexEdges(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdges >":
        r"""Returns all of the edges that connect convex faces."""
        return _fusion.BRepBody__get_convexEdges(self)

    def _get_area(self) -> "double":
        r"""Returns the area in cm ^ 2."""
        return _fusion.BRepBody__get_area(self)

    def _get_volume(self) -> "double":
        r"""Returns the volume in cm ^ 3. Returns 0 in the case the body is not solid."""
        return _fusion.BRepBody__get_volume(self)

    def pointContainment(self, point: "Point3D") -> "adsk::fusion::PointContainment":
        r"""
        Determines the relationship of the input point with respect to this body. 
        point : The point to do the containment check for. 
        Returns a value from the PointContainment enum indicating the relationship of
        the input point to the body.
        """
        return _fusion.BRepBody_pointContainment(self, point)

    def _get_isTransient(self) -> "bool":
        r"""Indicates if this body is represented in the model or is transient."""
        return _fusion.BRepBody__get_isTransient(self)

    def _get_name(self) -> "std::string":
        r"""
        Gets and sets the name of the body. 
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the name of the body. 
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__set_name(self, value)

    def _get_isVisible(self) -> "bool":
        r"""
        Gets if this body is currently visible in the graphics window. Use the
        isLightBulbOn to change if the light bulb beside the body node in the 
        browser is on or not. Parent nodes in the browser can have their light
        bulb off which affects all of their children. This property indicates 
        the final result and whether this body is actually visible or not.
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""
        Gets if this body is currently visible in the graphics window. Use the
        isLightBulbOn to change if the light bulb beside the body node in the 
        browser is on or not. Parent nodes in the browser can have their light
        bulb off which affects all of their children. This property indicates 
        the final result and whether this body is actually visible or not.
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__set_isVisible(self, value)

    def _get_isSelectable(self) -> "bool":
        r"""
        Gets and sets if this body is selectable.
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__get_isSelectable(self)

    def _set_isSelectable(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this body is selectable.
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__set_isSelectable(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the body.
        This property is only valid if the IsTransient property is false. 
        Returns true if the delete was successful.
        """
        return _fusion.BRepBody_deleteMe(self)

    def copy(self) -> "bool":
        r"""
        Copies the body to the clipboard.
        This property is only valid if the IsTransient property is false. 
        Returns true if the copy was successful.
        """
        return _fusion.BRepBody_copy(self)

    def cut(self) -> "bool":
        r"""
        Cuts the body to the clipboard.
        This property is only valid if the IsTransient property is false. 
        Returns true if the cut was successful.
        """
        return _fusion.BRepBody_cut(self)

    def _get_appearance(self) -> "adsk::core::Ptr< adsk::core::Appearance >":
        r"""
        Read-write property that gets and sets the current appearance of the body. Setting this property will result in applying
        an override appearance to the body and the AppearanceSourceType property will return OverrideAppearanceSource. Setting
        this property to null will remove any override.
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__get_appearance(self)

    def _set_appearance(self, value: "Appearance") -> "bool":
        r"""
        Read-write property that gets and sets the current appearance of the body. Setting this property will result in applying
        an override appearance to the body and the AppearanceSourceType property will return OverrideAppearanceSource. Setting
        this property to null will remove any override.
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__set_appearance(self, value)

    def _get_appearanceSourceType(self) -> "adsk::core::AppearanceSourceTypes":
        r"""
        Read-write property that gets the source of the appearance for the body. If this returns OverrideAppearanceSource, an override exists
        on this body. The override can be removed by setting the Appearance property to null.
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__get_appearanceSourceType(self)

    def _get_material(self) -> "adsk::core::Ptr< adsk::core::Material >":
        r"""
        Gets and sets the material assigned to this body.
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__get_material(self)

    def _set_material(self, value: "Material") -> "bool":
        r"""
        Gets and sets the material assigned to this body.
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__set_material(self, value)

    def _get_meshManager(self) -> "adsk::core::Ptr< adsk::fusion::MeshManager >":
        r"""Returns the mesh manager object for this body."""
        return _fusion.BRepBody__get_meshManager(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this
        object in an assembly. This is only valid in the case where this
        BRepBody object is acting as a proxy in an assembly. Returns null 
        in the case where the object is not in the context of an assembly.
        but is already the native object. Also returns null in the case
        where this body is transient.
        """
        return _fusion.BRepBody__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.BRepBody__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence.
        This method is only valid if the IsTransient property is false. 
        occurrence : The occurrence that defines the context for the created proxy. 
        Returns the new BRepBoy proxy or null if this isn't the NativeObject.
        """
        return _fusion.BRepBody_createForAssemblyContext(self, occurrence)

    def createComponent(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Creates a new component and occurrence within the component that currently owns this body.
        This body is moved into the new component and returned. The newly created component can be
        obtained by using the parentComponent property of the BRepBody object.
        This method is only valid if the IsTransient property is false. 
        Returns the BRrepBody in the new component or null in the case the creation failed.
        """
        return _fusion.BRepBody_createComponent(self)

    def moveToComponent(self, target: "Base") -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Moves this body from it's current component into the root component or the component owned by the 
        specified occurrence. 
        target : The target can be either the root component or an occurrence. 
        In the case where an occurrence is specified, the body will be moved into the parent component of the target 
        occurrence and the target occurrence defines the transform of how the body will be copied so that the body 
        maintains it's same position with respect to the assembly. 
        Returns the moved BRepBody or null in the case the move failed.
        """
        return _fusion.BRepBody_moveToComponent(self, target)

    def copyToComponent(self, target: "Base") -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Creates a copy of this body into the specified target. 
        target : The target can be either the root component or an occurrence. 
        In the case where an occurrence is specified, the body will be copied into the parent component of the target 
        occurrence and the target occurrence defines the transform of how the body will be copied so that the body 
        maintains it's same position with respect to the assembly.
        If target is null, then a copy of the body is created in the owning component of the original body. 
        Returns the moved BRepBody or null in the case the move failed.
        """
        return _fusion.BRepBody_copyToComponent(self, target)

    def _get_physicalProperties(self) -> "adsk::core::Ptr< adsk::fusion::PhysicalProperties >":
        r"""
        Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc 
        of this body. Property values will be calulated using the 'LowCalculationAccuracy' setting when using this property
        to get the PhysicalProperties object. To specify a higher calculation tolerance, use the getPhysicalProperties method 
        on the Design class instead.
        """
        return _fusion.BRepBody__get_physicalProperties(self)

    def _get_isLightBulbOn(self) -> "bool":
        r"""
        Gets and set if the light bulb beside the body node in the 
        browser is on or not. Parent nodes in the browser can have their light
        bulb off which affects all of their children so this property does not
        indicate if the body is actually visible, just that it should be visible
        if all of it's parent nodes are also visible. Use the isVisible property
        to determine if it's actually visible.
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__get_isLightBulbOn(self)

    def _set_isLightBulbOn(self, value: "bool") -> "bool":
        r"""
        Gets and set if the light bulb beside the body node in the 
        browser is on or not. Parent nodes in the browser can have their light
        bulb off which affects all of their children so this property does not
        indicate if the body is actually visible, just that it should be visible
        if all of it's parent nodes are also visible. Use the isVisible property
        to determine if it's actually visible.
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__set_isLightBulbOn(self, value)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.BRepBody__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this body is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.BRepBody__get_baseFeature(self)

    def convert(self, options: "BRepConvertOptions") -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Creates a new body where the faces and edges are converted to different
        types of geometry based on the input options. This is particularly useful
        when you need a body made up entirely of NURBS surfaces.
        The tempId on the faces, edges, and vertices on the new body will match
        with the corresponding tempId on the original body. In cases where faces are
        split as a result of the conversion there can be more than one face or edge in
        the new body that matches to a single face or edge in the original body. The 
        findByTempId method will find the entity with the matching id. 
        options : Input options that define how the conversion should be done. These are
        bitwise options so they can be combined. 
        Returns the new converted body or null in the case of failure.
        """
        return _fusion.BRepBody_convert(self, options)

    def findByTempId(self, tempId: "int") -> "std::vector< adsk::core::Ptr< adsk::core::Base >,std::allocator< adsk::core::Ptr< adsk::core::Base > > >":
        r"""
        Returns all of the faces, edges, or vertices that match the input ID. 
        tempId : The ID of the B-Rep entity to find. 
        Returns an array of entities that have the specified ID. This
        returns an array because it's possible that a body created by converting a
        body can have multiple entities with the same ID in the case where a curve
        or face was split. Returns an empty array in the case where no match is found.
        """
        return _fusion.BRepBody_findByTempId(self, tempId)

    def _get_opacity(self) -> "double":
        r"""
        Gets and sets the opacity override assigned to this body. A value of 1.0 specifies
        that is it completely opaque and a value of 0.0 specifies that is it completely transparent.
        This value is not necessarily related to what the user sees because the opacity is inherited.
        For example, if you this body is in a component and that component's opacity is set to something
        other than 1.0, the body will also be shown as slightly transparent even though the opacity 
        property for the body will return 1.0. Because the component that contains the body can be 
        referenced as an occurrence in other components and they can have different opacity settings, 
        it's possible that different instances of the same body can display using different opacity levels. 
        To get the opacity that it is being displayed with use the BrepBody.visibleOpacity property.
        This is the API equivalent of the 'Opacity Control' command available for the body in the browser.
        """
        return _fusion.BRepBody__get_opacity(self)

    def _set_opacity(self, value: "double") -> "bool":
        r"""
        Gets and sets the opacity override assigned to this body. A value of 1.0 specifies
        that is it completely opaque and a value of 0.0 specifies that is it completely transparent.
        This value is not necessarily related to what the user sees because the opacity is inherited.
        For example, if you this body is in a component and that component's opacity is set to something
        other than 1.0, the body will also be shown as slightly transparent even though the opacity 
        property for the body will return 1.0. Because the component that contains the body can be 
        referenced as an occurrence in other components and they can have different opacity settings, 
        it's possible that different instances of the same body can display using different opacity levels. 
        To get the opacity that it is being displayed with use the BrepBody.visibleOpacity property.
        This is the API equivalent of the 'Opacity Control' command available for the body in the browser.
        """
        return _fusion.BRepBody__set_opacity(self, value)

    def _get_visibleOpacity(self) -> "double":
        r"""
        The user can set an override opacity for components and bodies these opacity overrides combine if
        children and parent components have overrides. This property returns the actual opacity that is
        being used to render the body. To set the opacity use the opacity property of the BRepBody object.
        """
        return _fusion.BRepBody__get_visibleOpacity(self)

    def _get_revisionId(self) -> "std::string":
        r"""
        Returns the current revision ID of the body. This ID changes any time the body is modified in any way. By getting
        and saving the ID when you create any data that is dependent on the body, you can then compare the saved
        ID with the current ID to determine if the body has changed to know if you should update your data.
        """
        return _fusion.BRepBody__get_revisionId(self)

    def _get_wires(self) -> "adsk::core::Ptr< adsk::fusion::BRepWires >":
        r"""Returns any wire bodies that exist within this body."""
        return _fusion.BRepBody__get_wires(self)

    def _get_isTemporary(self) -> "bool":
        r"""Indicates if this body is represented in the model or is temporary."""
        return _fusion.BRepBody__get_isTemporary(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the BRepBody object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same body.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        This is only valid for bodies that exist in the design, (the isTemporary 
        property is false).
        """
        return _fusion.BRepBody__get_entityToken(self)

    def getPhysicalProperties(self, *args) -> "adsk::core::Ptr< adsk::fusion::PhysicalProperties >":
        r"""
        Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc 
        of this body. 
        accuracy : Specifies the desired level of computational accuracy of the property calculations.
        The default value of 'LowCalculationAccuracy' returns results within a +/- 1% error margin.
        """
        return _fusion.BRepBody_getPhysicalProperties(self, *args)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepBody__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepBody__get_isValid(self)

# Register BRepBody in _fusion:
_fusion.BRepBody_swigregister(BRepBody)

def BRepBody_classType() -> "char const *":
    return _fusion.BRepBody_classType()


BRepBody.parentComponent = property(BRepBody._get_parentComponent, doc="Returns the component this body is owned by.")


BRepBody.lumps = property(BRepBody._get_lumps, doc="Returns a collection of all of the lumps in the body.")


BRepBody.shells = property(BRepBody._get_shells, doc="Returns a collection of all of the shells in the body.")


BRepBody.faces = property(BRepBody._get_faces, doc="Returns a collection of all of the faces in the body.")


BRepBody.edges = property(BRepBody._get_edges, doc="Returns a collection of all of the edges in the body.")


BRepBody.vertices = property(BRepBody._get_vertices, doc="Returns a collection of all of the vertices in the body.")


BRepBody.isSolid = property(BRepBody._get_isSolid, doc="Returns whether this body is closed (solid) or not.")


BRepBody.boundingBox = property(BRepBody._get_boundingBox, doc="Returns the bounding box of this body.")


BRepBody.concaveEdges = property(BRepBody._get_concaveEdges, doc="Returns all of the edges that connect concave faces.")


BRepBody.convexEdges = property(BRepBody._get_convexEdges, doc="Returns all of the edges that connect convex faces.")


BRepBody.area = property(BRepBody._get_area, doc="Returns the area in cm ^ 2.")


BRepBody.volume = property(BRepBody._get_volume, doc="Returns the volume in cm ^ 3. Returns 0 in the case the body is not solid.")


BRepBody.isTransient = property(BRepBody._get_isTransient, doc="Indicates if this body is represented in the model or is transient.")


BRepBody.name = property(BRepBody._get_name, BRepBody._set_name, doc="Gets and sets the name of the body.\nThis property is only valid if the IsTransient property is false.")


BRepBody.isVisible = property(BRepBody._get_isVisible, BRepBody._set_isVisible, doc="Gets if this body is currently visible in the graphics window. Use the\nisLightBulbOn to change if the light bulb beside the body node in the\nbrowser is on or not. Parent nodes in the browser can have their light\nbulb off which affects all of their children. This property indicates\nthe final result and whether this body is actually visible or not.\nThis property is only valid if the IsTransient property is false.")


BRepBody.isSelectable = property(BRepBody._get_isSelectable, BRepBody._set_isSelectable, doc="Gets and sets if this body is selectable.\nThis property is only valid if the IsTransient property is false.")


BRepBody.appearance = property(BRepBody._get_appearance, BRepBody._set_appearance, doc="Read-write property that gets and sets the current appearance of the body. Setting this property will result in applying\nan override appearance to the body and the AppearanceSourceType property will return OverrideAppearanceSource. Setting\nthis property to null will remove any override.\nThis property is only valid if the IsTransient property is false.")


BRepBody.appearanceSourceType = property(BRepBody._get_appearanceSourceType, doc="Read-write property that gets the source of the appearance for the body. If this returns OverrideAppearanceSource, an override exists\non this body. The override can be removed by setting the Appearance property to null.\nThis property is only valid if the IsTransient property is false.")


BRepBody.material = property(BRepBody._get_material, BRepBody._set_material, doc="Gets and sets the material assigned to this body.\nThis property is only valid if the IsTransient property is false.")


BRepBody.meshManager = property(BRepBody._get_meshManager, doc="Returns the mesh manager object for this body.")


BRepBody.assemblyContext = property(BRepBody._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this\nobject in an assembly. This is only valid in the case where this\nBRepBody object is acting as a proxy in an assembly. Returns null\nin the case where the object is not in the context of an assembly.\nbut is already the native object. Also returns null in the case\nwhere this body is transient.")


BRepBody.nativeObject = property(BRepBody._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


BRepBody.physicalProperties = property(BRepBody._get_physicalProperties, doc="Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc\nof this body. Property values will be calulated using the 'LowCalculationAccuracy' setting when using this property\nto get the PhysicalProperties object. To specify a higher calculation tolerance, use the getPhysicalProperties method\non the Design class instead.")


BRepBody.isLightBulbOn = property(BRepBody._get_isLightBulbOn, BRepBody._set_isLightBulbOn, doc="Gets and set if the light bulb beside the body node in the\nbrowser is on or not. Parent nodes in the browser can have their light\nbulb off which affects all of their children so this property does not\nindicate if the body is actually visible, just that it should be visible\nif all of it's parent nodes are also visible. Use the isVisible property\nto determine if it's actually visible.\nThis property is only valid if the IsTransient property is false.")


BRepBody.attributes = property(BRepBody._get_attributes, doc="Returns the collection of attributes associated with this face.")


BRepBody.baseFeature = property(BRepBody._get_baseFeature, doc="If this body is associated with a base feature, this property will return that base feature.\nIf it's not associated with a base feature, this property will return null.")


BRepBody.opacity = property(BRepBody._get_opacity, BRepBody._set_opacity, doc="Gets and sets the opacity override assigned to this body. A value of 1.0 specifies\nthat is it completely opaque and a value of 0.0 specifies that is it completely transparent.\nThis value is not necessarily related to what the user sees because the opacity is inherited.\nFor example, if you this body is in a component and that component's opacity is set to something\nother than 1.0, the body will also be shown as slightly transparent even though the opacity\nproperty for the body will return 1.0. Because the component that contains the body can be\nreferenced as an occurrence in other components and they can have different opacity settings,\nit's possible that different instances of the same body can display using different opacity levels.\nTo get the opacity that it is being displayed with use the BrepBody.visibleOpacity property.\nThis is the API equivalent of the 'Opacity Control' command available for the body in the browser.")


BRepBody.visibleOpacity = property(BRepBody._get_visibleOpacity, doc="The user can set an override opacity for components and bodies these opacity overrides combine if\nchildren and parent components have overrides. This property returns the actual opacity that is\nbeing used to render the body. To set the opacity use the opacity property of the BRepBody object.")


BRepBody.revisionId = property(BRepBody._get_revisionId, doc="Returns the current revision ID of the body. This ID changes any time the body is modified in any way. By getting\nand saving the ID when you create any data that is dependent on the body, you can then compare the saved\nID with the current ID to determine if the body has changed to know if you should update your data.")


BRepBody.wires = property(BRepBody._get_wires, doc="Returns any wire bodies that exist within this body.")


BRepBody.isTemporary = property(BRepBody._get_isTemporary, doc="Indicates if this body is represented in the model or is temporary.")


BRepBody.entityToken = property(BRepBody._get_entityToken, doc="Returns a token for the BRepBody object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same body.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.\nThis is only valid for bodies that exist in the design, (the isTemporary\nproperty is false).")


BRepBody.cast = lambda arg: arg if isinstance(arg, BRepBody) else None

class BRepBodyDefinition(Base):
    r"""
    This object is used to define a temporary B-Rep body. This includes solid, surface, and wire
    bodies. The class supports the ability to define the geometry and topology of the B-Rep and 
    once the definition is complete, it supports the creation of a temporary BRepBody object.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepBodyDefinition *":
        return _fusion.BRepBodyDefinition___deref__(self)

    def __eq__(self, rhs: "BRepBodyDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepBodyDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "BRepBodyDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepBodyDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepBodyDefinition_classType()

    @staticmethod
    def create() -> "adsk::core::Ptr< adsk::fusion::BRepBodyDefinition >":
        return _fusion.BRepBodyDefinition_create()
    __swig_destroy__ = _fusion.delete_BRepBodyDefinition

    def createBody(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Attempts to create a temporary BRepBody object using the definition
        provided by this BRepBodyDefinition object. Properties on this BRepBodyDefinition
        are used to define some of the criteria that control how the body is created. 
        Returns the newly created BRepBody object if successful, otherwise null is returned.
        Information about the body creation can be obtained by using the outcomeInfo property.
        The outcom info is especially useful when initially writing and debugging your code to understand
        why the creation of the body is failing.
        """
        return _fusion.BRepBodyDefinition_createBody(self)

    def _get_doFullHealing(self) -> "bool":
        r"""
        Specifies if full healing is done when creating the body. This defaults to true and it's highly recommended
        that you do full healing because it can find and correct problems with the input. If you're sure that the
        B-Rep definition that you've constructed is correct then you can set this to false to skip the full 
        healing process.
        """
        return _fusion.BRepBodyDefinition__get_doFullHealing(self)

    def _set_doFullHealing(self, value: "bool") -> "bool":
        r"""
        Specifies if full healing is done when creating the body. This defaults to true and it's highly recommended
        that you do full healing because it can find and correct problems with the input. If you're sure that the
        B-Rep definition that you've constructed is correct then you can set this to false to skip the full 
        healing process.
        """
        return _fusion.BRepBodyDefinition__set_doFullHealing(self, value)

    def _get_outcomeInfo(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Returns an array of strings that contain information about the outcome of the previous 
        call of the createBody method. This is especially useful when the createBody method fails,
        (returns null), because it provides information about why the failure occurred. It can
        also sometimes provide some information even when createBody succeeds.
        Each string that's returned represents a single set of information and is packaged as JSON 
        such as '{'description':'vertex data is null or inconsistent with edge geometry','associativeID':'unknown','code':37}'
        The description is an English description of the error or warning. The associativeID maps back to the
        entity provided that is the cause of the problem. The ID is the associative ID you can optionally
        assign to the entity definition. The code is an internal code for the error or warning.
        An empty array is returned if createBody succeeded and there's no additional information.
        """
        return _fusion.BRepBodyDefinition__get_outcomeInfo(self)

    def _get_lumpDefinitions(self) -> "adsk::core::Ptr< adsk::fusion::BRepLumpDefinitions >":
        r"""
        Provides access to the BRepLumpDefinitions object associated with this BRepBodyDefinition.
        It's through the returned collection that you can create new BRepLumpDefinition objects.
        """
        return _fusion.BRepBodyDefinition__get_lumpDefinitions(self)

    def createEdgeDefinitionByCurve(self, startVertex: "BRepVertexDefinition", endVertex: "BRepVertexDefinition", modelSpaceCurve: "Curve3D") -> "adsk::core::Ptr< adsk::fusion::BRepEdgeDefinition >":
        r"""
        Using a curve in model space it creates a new BRepEdgeDefinition object that's associated with the body. 
        startVertex : Vertex definition that defines the start of the edge. For a closed curve, like a circle, you still
        need to provide a vertex on the curve but you should use the same BRepVertexDefinition for both the start and end verices. 
        endVertex : Vertex definition that defines the end of the edge. For a closed curve, like a circle, this should be the
        same vertex as used for the start vertex. 
        modelSpaceCurve : A Curve3D object that defines the shape of the edge using 3D geometry in model space. 
        Valid input is an Arc3D, NurbsCurve3D, Circle3D, Ellipse3D, EllipticalArc3D, or Line3D. 
        Returns the created BRepEdgeDefinition object or null in the case of failure.
        """
        return _fusion.BRepBodyDefinition_createEdgeDefinitionByCurve(self, startVertex, endVertex, modelSpaceCurve)

    def createVertexDefinition(self, position: "Point3D") -> "adsk::core::Ptr< adsk::fusion::BRepVertexDefinition >":
        r"""
        Creates a new BRepVertexDefinition object that's associated with the body. 
        position : Specifies the position of the vertex in model space. 
        Returns the created BRepVertexDefinition object or null in the case of failure.
        """
        return _fusion.BRepBodyDefinition_createVertexDefinition(self, position)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepBodyDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepBodyDefinition__get_isValid(self)

# Register BRepBodyDefinition in _fusion:
_fusion.BRepBodyDefinition_swigregister(BRepBodyDefinition)

def BRepBodyDefinition_classType() -> "char const *":
    return _fusion.BRepBodyDefinition_classType()

def BRepBodyDefinition_create() -> "adsk::core::Ptr< adsk::fusion::BRepBodyDefinition >":
    return _fusion.BRepBodyDefinition_create()


BRepBodyDefinition.doFullHealing = property(BRepBodyDefinition._get_doFullHealing, BRepBodyDefinition._set_doFullHealing, doc="Specifies if full healing is done when creating the body. This defaults to true and it's highly recommended\nthat you do full healing because it can find and correct problems with the input. If you're sure that the\nB-Rep definition that you've constructed is correct then you can set this to false to skip the full\nhealing process.")


BRepBodyDefinition.outcomeInfo = property(BRepBodyDefinition._get_outcomeInfo, doc="Returns an array of strings that contain information about the outcome of the previous\ncall of the createBody method. This is especially useful when the createBody method fails,\n(returns null), because it provides information about why the failure occurred. It can\nalso sometimes provide some information even when createBody succeeds.\nEach string that's returned represents a single set of information and is packaged as JSON\nsuch as '{'description':'vertex data is null or inconsistent with edge geometry','associativeID':'unknown','code':37}'\nThe description is an English description of the error or warning. The associativeID maps back to the\nentity provided that is the cause of the problem. The ID is the associative ID you can optionally\nassign to the entity definition. The code is an internal code for the error or warning.\nAn empty array is returned if createBody succeeded and there's no additional information.")


BRepBodyDefinition.lumpDefinitions = property(BRepBodyDefinition._get_lumpDefinitions, doc="Provides access to the BRepLumpDefinitions object associated with this BRepBodyDefinition.\nIt's through the returned collection that you can create new BRepLumpDefinition objects.")


BRepBodyDefinition.cast = lambda arg: arg if isinstance(arg, BRepBodyDefinition) else None

class BRepCell(Base):
    r"""Object that represents an existing BRepCell."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepCell *":
        return _fusion.BRepCell___deref__(self)

    def __eq__(self, rhs: "BRepCell") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepCell___eq__(self, rhs)


    def __ne__(self, rhs: "BRepCell") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepCell___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepCell_classType()
    __swig_destroy__ = _fusion.delete_BRepCell

    def _get_isSelected(self) -> "bool":
        r"""
        Gets and sets whether the cell is selected. For a Trim feature a selected cell is removed, 
        whereas for a boundary fill feature, a selected cell is kept and used in the feature operation.
        """
        return _fusion.BRepCell__get_isSelected(self)

    def _set_isSelected(self, value: "bool") -> "bool":
        r"""
        Gets and sets whether the cell is selected. For a Trim feature a selected cell is removed, 
        whereas for a boundary fill feature, a selected cell is kept and used in the feature operation.
        """
        return _fusion.BRepCell__set_isSelected(self, value)

    def _get_sourceTools(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""Returns the tools that we're using in the definition of this cell."""
        return _fusion.BRepCell__get_sourceTools(self)

    def _get_cellBody(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""Returns a BRepBody that represents this cell. This is a transient B-Rep body."""
        return _fusion.BRepCell__get_cellBody(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepCell__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepCell__get_isValid(self)

# Register BRepCell in _fusion:
_fusion.BRepCell_swigregister(BRepCell)

def BRepCell_classType() -> "char const *":
    return _fusion.BRepCell_classType()


BRepCell.isSelected = property(BRepCell._get_isSelected, BRepCell._set_isSelected, doc="Gets and sets whether the cell is selected. For a Trim feature a selected cell is removed,\nwhereas for a boundary fill feature, a selected cell is kept and used in the feature operation.")


BRepCell.sourceTools = property(BRepCell._get_sourceTools, doc="Returns the tools that we're using in the definition of this cell.")


BRepCell.cellBody = property(BRepCell._get_cellBody, doc="Returns a BRepBody that represents this cell. This is a transient B-Rep body.")


BRepCell.cast = lambda arg: arg if isinstance(arg, BRepCell) else None

class BRepCells(Base):
    r"""Collection that provides access to all of the existing BRepCells defined by a BoundaryFillFeatureInput"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepCells *":
        return _fusion.BRepCells___deref__(self)

    def __eq__(self, rhs: "BRepCells") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepCells___eq__(self, rhs)


    def __ne__(self, rhs: "BRepCells") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepCells___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.BRepCells___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::BRepCell >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.BRepCells___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepCells_classType()
    __swig_destroy__ = _fusion.delete_BRepCells

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::BRepCell >":
        r"""
        Function that returns the specified BRepCell using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepCells_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of BRepCells in the collection."""
        return _fusion.BRepCells__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepCells__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepCells__get_isValid(self)

# Register BRepCells in _fusion:
_fusion.BRepCells_swigregister(BRepCells)

def BRepCells_classType() -> "char const *":
    return _fusion.BRepCells_classType()


BRepCells.count = property(BRepCells._get_count, doc="The number of BRepCells in the collection.")


BRepCells.cast = lambda arg: arg if isinstance(arg, BRepCells) else None

class BRepCoEdge(Base):
    r"""Represents the use of a BRepEdge by a BRepFace."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepCoEdge *":
        return _fusion.BRepCoEdge___deref__(self)

    def __eq__(self, rhs: "BRepCoEdge") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepCoEdge___eq__(self, rhs)


    def __ne__(self, rhs: "BRepCoEdge") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepCoEdge___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepCoEdge_classType()
    __swig_destroy__ = _fusion.delete_BRepCoEdge

    def _get_edge(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdge >":
        r"""Returns the edge this co-edge is associated with."""
        return _fusion.BRepCoEdge__get_edge(self)

    def _get_loop(self) -> "adsk::core::Ptr< adsk::fusion::BRepLoop >":
        r"""Returns the loop this co-edge is part of."""
        return _fusion.BRepCoEdge__get_loop(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator2D >":
        r"""Returns a curve evaluator that can be used to perform geometric evaluations on the co-edge."""
        return _fusion.BRepCoEdge__get_evaluator(self)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Curve2D >":
        r"""Returns a geometry object that represents the shape of this co-edge in parameter space of the parent face's surface."""
        return _fusion.BRepCoEdge__get_geometry(self)

    def _get_isOpposedToEdge(self) -> "bool":
        r"""Indicates if the orientation of this co-edge is in the same direction or opposed to its associated edge."""
        return _fusion.BRepCoEdge__get_isOpposedToEdge(self)

    def _get_isParamReversed(self) -> "bool":
        r"""
        Returns if the parametric direction of this co-edge is reversed
        from the parametric direction of the underlying curve obtained from the geometry property.
        A co-edge's parametric direction is from the start vertex to the end vertex.
        But the underlying curve geometry may have the opposite parameterization.
        This property indicates if the parameterization order of the evaluator obtained from
        this co-edge is reversed from the order of the geometry curve's evaluator.
        """
        return _fusion.BRepCoEdge__get_isParamReversed(self)

    def _get_next(self) -> "adsk::core::Ptr< adsk::fusion::BRepCoEdge >":
        r"""Returns the next co-edge in the loop."""
        return _fusion.BRepCoEdge__get_next(self)

    def _get_body(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""Returns the body this co-edge is part of."""
        return _fusion.BRepCoEdge__get_body(self)

    def _get_partner(self) -> "adsk::core::Ptr< adsk::fusion::BRepCoEdge >":
        r"""Returns the co-edge on the adjacent face"""
        return _fusion.BRepCoEdge__get_partner(self)

    def _get_previous(self) -> "adsk::core::Ptr< adsk::fusion::BRepCoEdge >":
        r"""Returns the previous co-edge in the loop."""
        return _fusion.BRepCoEdge__get_previous(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this
        object in an assembly. This is only valid in the case where this
        BRepCoEdge object is acting as a proxy in an assembly. Returns null 
        in the case where the object is not in the context of an assembly.
        but is already the native object.
        """
        return _fusion.BRepCoEdge__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::BRepCoEdge >":
        r"""
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.BRepCoEdge__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::BRepCoEdge >":
        r"""
        Returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context for the created proxy. 
        Returns the new BrepCoEdge proxy or null if this isn't the NativeObject.
        """
        return _fusion.BRepCoEdge_createForAssemblyContext(self, occurrence)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the BRepCoEdge object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same co-edge.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        This is only valid for co-edges that exist in the design, (the isTemporary 
        property is false).
        """
        return _fusion.BRepCoEdge__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepCoEdge__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepCoEdge__get_isValid(self)

# Register BRepCoEdge in _fusion:
_fusion.BRepCoEdge_swigregister(BRepCoEdge)

def BRepCoEdge_classType() -> "char const *":
    return _fusion.BRepCoEdge_classType()


BRepCoEdge.edge = property(BRepCoEdge._get_edge, doc="Returns the edge this co-edge is associated with.")


BRepCoEdge.loop = property(BRepCoEdge._get_loop, doc="Returns the loop this co-edge is part of.")


BRepCoEdge.evaluator = property(BRepCoEdge._get_evaluator, doc="Returns a curve evaluator that can be used to perform geometric evaluations on the co-edge.")


BRepCoEdge.geometry = property(BRepCoEdge._get_geometry, doc="Returns a geometry object that represents the shape of this co-edge in parameter space of the parent face's surface.")


BRepCoEdge.isOpposedToEdge = property(BRepCoEdge._get_isOpposedToEdge, doc="Indicates if the orientation of this co-edge is in the same direction or opposed to its associated edge.")


BRepCoEdge.isParamReversed = property(BRepCoEdge._get_isParamReversed, doc="Returns if the parametric direction of this co-edge is reversed\nfrom the parametric direction of the underlying curve obtained from the geometry property.\nA co-edge's parametric direction is from the start vertex to the end vertex.\nBut the underlying curve geometry may have the opposite parameterization.\nThis property indicates if the parameterization order of the evaluator obtained from\nthis co-edge is reversed from the order of the geometry curve's evaluator.")


BRepCoEdge.next = property(BRepCoEdge._get_next, doc="Returns the next co-edge in the loop.")


BRepCoEdge.body = property(BRepCoEdge._get_body, doc="Returns the body this co-edge is part of.")


BRepCoEdge.partner = property(BRepCoEdge._get_partner, doc="Returns the co-edge on the adjacent face")


BRepCoEdge.previous = property(BRepCoEdge._get_previous, doc="Returns the previous co-edge in the loop.")


BRepCoEdge.assemblyContext = property(BRepCoEdge._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this\nobject in an assembly. This is only valid in the case where this\nBRepCoEdge object is acting as a proxy in an assembly. Returns null\nin the case where the object is not in the context of an assembly.\nbut is already the native object.")


BRepCoEdge.nativeObject = property(BRepCoEdge._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


BRepCoEdge.entityToken = property(BRepCoEdge._get_entityToken, doc="Returns a token for the BRepCoEdge object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same co-edge.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.\nThis is only valid for co-edges that exist in the design, (the isTemporary\nproperty is false).")


BRepCoEdge.cast = lambda arg: arg if isinstance(arg, BRepCoEdge) else None

class BRepCoEdgeDefinition(Base):
    r"""Represents the definition of a B-Rep co-edge that can be used as input to create a BRepBody that includes this co-edge."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepCoEdgeDefinition *":
        return _fusion.BRepCoEdgeDefinition___deref__(self)

    def __eq__(self, rhs: "BRepCoEdgeDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepCoEdgeDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "BRepCoEdgeDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepCoEdgeDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepCoEdgeDefinition_classType()
    __swig_destroy__ = _fusion.delete_BRepCoEdgeDefinition

    def _get_edgeDefinition(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdgeDefinition >":
        r"""Gets and sets the BRepEdgeDefinition object associated with this BrepCoEdgeDefinition object."""
        return _fusion.BRepCoEdgeDefinition__get_edgeDefinition(self)

    def _set_edgeDefinition(self, value: "BRepEdgeDefinition") -> "bool":
        r"""Gets and sets the BRepEdgeDefinition object associated with this BrepCoEdgeDefinition object."""
        return _fusion.BRepCoEdgeDefinition__set_edgeDefinition(self, value)

    def _get_isOpposedToEdge(self) -> "bool":
        r"""
        Gets and sets if the orientation of this BRepCoEdgeDefinition object is reversed with
        respect to the associated BRepEdgeDefinition object.
        """
        return _fusion.BRepCoEdgeDefinition__get_isOpposedToEdge(self)

    def _set_isOpposedToEdge(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the orientation of this BRepCoEdgeDefinition object is reversed with
        respect to the associated BRepEdgeDefinition object.
        """
        return _fusion.BRepCoEdgeDefinition__set_isOpposedToEdge(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepCoEdgeDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepCoEdgeDefinition__get_isValid(self)

# Register BRepCoEdgeDefinition in _fusion:
_fusion.BRepCoEdgeDefinition_swigregister(BRepCoEdgeDefinition)

def BRepCoEdgeDefinition_classType() -> "char const *":
    return _fusion.BRepCoEdgeDefinition_classType()


BRepCoEdgeDefinition.edgeDefinition = property(BRepCoEdgeDefinition._get_edgeDefinition, BRepCoEdgeDefinition._set_edgeDefinition, doc="Gets and sets the BRepEdgeDefinition object associated with this BrepCoEdgeDefinition object.")


BRepCoEdgeDefinition.isOpposedToEdge = property(BRepCoEdgeDefinition._get_isOpposedToEdge, BRepCoEdgeDefinition._set_isOpposedToEdge, doc="Gets and sets if the orientation of this BRepCoEdgeDefinition object is reversed with\nrespect to the associated BRepEdgeDefinition object.")


BRepCoEdgeDefinition.cast = lambda arg: arg if isinstance(arg, BRepCoEdgeDefinition) else None

class BRepCoEdgeDefinitions(Base):
    r"""
    Provides access to the BRepCoEdgeDefinition objects associated with the parent BRepLoopDefinition object.
    It's through this object that you create new BRepCoEdgeDefinition objects.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepCoEdgeDefinitions *":
        return _fusion.BRepCoEdgeDefinitions___deref__(self)

    def __eq__(self, rhs: "BRepCoEdgeDefinitions") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepCoEdgeDefinitions___eq__(self, rhs)


    def __ne__(self, rhs: "BRepCoEdgeDefinitions") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepCoEdgeDefinitions___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.BRepCoEdgeDefinitions___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::BRepCoEdgeDefinition >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.BRepCoEdgeDefinitions___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepCoEdgeDefinitions_classType()
    __swig_destroy__ = _fusion.delete_BRepCoEdgeDefinitions

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::BRepCoEdgeDefinition >":
        r"""
        Function that returns the specified BRepCoEdgeDefinition object using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepCoEdgeDefinitions_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of B-Rep co-edge definition objects in the collection."""
        return _fusion.BRepCoEdgeDefinitions__get_count(self)

    def add(self, edgeDefinition: "BRepEdgeDefinition", isOpposedToEdge: "bool") -> "adsk::core::Ptr< adsk::fusion::BRepCoEdgeDefinition >":
        r"""
        Creates a new BrepCoEdgeDefinition object associated with the parent BrepLoopDefinition object. 
        edgeDefinition : The BRepEdgeDefinition object this co-edge is related to. 
        isOpposedToEdge : Boolean that indicates if the orientation of this BRepCoEdgeDefinition is reversed with respect 
        to the associated BRepEdgeDefinition object. 
        Returns the newly created BrepCoEdgeDefinition object or null in the case of failure.
        """
        return _fusion.BRepCoEdgeDefinitions_add(self, edgeDefinition, isOpposedToEdge)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepCoEdgeDefinitions__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepCoEdgeDefinitions__get_isValid(self)

# Register BRepCoEdgeDefinitions in _fusion:
_fusion.BRepCoEdgeDefinitions_swigregister(BRepCoEdgeDefinitions)

def BRepCoEdgeDefinitions_classType() -> "char const *":
    return _fusion.BRepCoEdgeDefinitions_classType()


BRepCoEdgeDefinitions.count = property(BRepCoEdgeDefinitions._get_count, doc="The number of B-Rep co-edge definition objects in the collection.")


BRepCoEdgeDefinitions.cast = lambda arg: arg if isinstance(arg, BRepCoEdgeDefinitions) else None

class BRepCoEdges(Base):
    r"""BRepCoEdge Collection."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepCoEdges *":
        return _fusion.BRepCoEdges___deref__(self)

    def __eq__(self, rhs: "BRepCoEdges") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepCoEdges___eq__(self, rhs)


    def __ne__(self, rhs: "BRepCoEdges") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepCoEdges___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.BRepCoEdges___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::BRepCoEdge >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.BRepCoEdges___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepCoEdges_classType()
    __swig_destroy__ = _fusion.delete_BRepCoEdges

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::BRepCoEdge >":
        r"""
        Function that returns the specified co-edge using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepCoEdges_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of co-edges in the collection."""
        return _fusion.BRepCoEdges__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepCoEdges__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepCoEdges__get_isValid(self)

# Register BRepCoEdges in _fusion:
_fusion.BRepCoEdges_swigregister(BRepCoEdges)

def BRepCoEdges_classType() -> "char const *":
    return _fusion.BRepCoEdges_classType()


BRepCoEdges.count = property(BRepCoEdges._get_count, doc="The number of co-edges in the collection.")


BRepCoEdges.cast = lambda arg: arg if isinstance(arg, BRepCoEdges) else None

class BRepEdge(Base):
    r"""Represents a one-dimensional topological element that can be used to bound a BRepFace A BRepEdge uses a single, connected and bounded subset of a curve for it geometry."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepEdge *":
        return _fusion.BRepEdge___deref__(self)

    def __eq__(self, rhs: "BRepEdge") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepEdge___eq__(self, rhs)


    def __ne__(self, rhs: "BRepEdge") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepEdge___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepEdge_classType()
    __swig_destroy__ = _fusion.delete_BRepEdge

    def _get_startVertex(self) -> "adsk::core::Ptr< adsk::fusion::BRepVertex >":
        r"""Returns the BRepVertex that bounds its low parameter end."""
        return _fusion.BRepEdge__get_startVertex(self)

    def _get_endVertex(self) -> "adsk::core::Ptr< adsk::fusion::BRepVertex >":
        r"""Returns the BRepVertex that bounds its high parameter end."""
        return _fusion.BRepEdge__get_endVertex(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""Returns the BRepFaces that are associated with this edge through its BRepCoEdges."""
        return _fusion.BRepEdge__get_faces(self)

    def _get_shell(self) -> "adsk::core::Ptr< adsk::fusion::BRepShell >":
        r"""Returns the parent shell of the edge."""
        return _fusion.BRepEdge__get_shell(self)

    def _get_body(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""Returns the parent body of the edge."""
        return _fusion.BRepEdge__get_body(self)

    def _get_isDegenerate(self) -> "bool":
        r"""
        Returns if the edge's geometry is degenerate.
        For example, the apex of a cone is a degerate edge.
        """
        return _fusion.BRepEdge__get_isDegenerate(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator3D >":
        r"""Returns CurveEvaluator3D for evaluation."""
        return _fusion.BRepEdge__get_evaluator(self)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Curve3D >":
        r"""Returns the underlying curve geometry of the edge."""
        return _fusion.BRepEdge__get_geometry(self)

    def _get_isTolerant(self) -> "bool":
        r"""
        Returns if the edge is tolerant.
        The tolerance used is available from the tolerance property.
        """
        return _fusion.BRepEdge__get_isTolerant(self)

    def _get_tolerance(self) -> "double":
        r"""
        Returns the tolerance used by a tolerant edge.
        This value is only useful when isTolerant is true.
        """
        return _fusion.BRepEdge__get_tolerance(self)

    def _get_pointOnEdge(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""
        Returns a sample point guaranteed to lie on the edge's curve, within its boundaries,
        and not on a vertex (unless this is a degenerate edge).
        """
        return _fusion.BRepEdge__get_pointOnEdge(self)

    def _get_coEdges(self) -> "adsk::core::Ptr< adsk::fusion::BRepCoEdges >":
        r"""Returns the BRepCoEdges on the edge."""
        return _fusion.BRepEdge__get_coEdges(self)

    def _get_isParamReversed(self) -> "bool":
        r"""
        Returns if the parametric direction of this edge is reversed
        from the parametric direction of the underlying curve obtained from the geometry property.
        An edge's parametric direction is from the start vertex to the end vertex.
        But the underlying curve geometry may have the opposite parameterization.
        This property indicates if the parameterization order of the evaluator obtained from
        this edge is reversed from the order of the geometry curve's evaluator.
        """
        return _fusion.BRepEdge__get_isParamReversed(self)

    def _get_tangentiallyConnectedEdges(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Returns a collection of edges that includes all of the edges tangentially connected
        to this edge. The result includes this edge. The edges are in the collection
        in their connected order.
        """
        return _fusion.BRepEdge__get_tangentiallyConnectedEdges(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this
        object in an assembly. This is only valid in the case where this
        BRepEdge object is acting as a proxy in an assembly. Returns null 
        in the case where the object is not in the context of an assembly.
        but is already the native object.
        """
        return _fusion.BRepEdge__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdge >":
        r"""
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.BRepEdge__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::BRepEdge >":
        r"""
        Returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context for the created proxy. 
        Returns the new BrepEdge proxy or null if this isn't the NativeObject.
        """
        return _fusion.BRepEdge_createForAssemblyContext(self, occurrence)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.BRepEdge__get_attributes(self)

    def _get_length(self) -> "double":
        r"""Returns the length of the edge in centimeters."""
        return _fusion.BRepEdge__get_length(self)

    def _get_tempId(self) -> "int":
        r"""
        Returns the temporary ID of this edge. This ID is only good while the document
        remains open and as long as the owning BRepBody is not modified in any way. 
        The findByTempId method of the BRepBody will return the entity in the body with the given ID.
        """
        return _fusion.BRepEdge__get_tempId(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the bounding box of this edge."""
        return _fusion.BRepEdge__get_boundingBox(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the BRepEdge object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same edge.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        This is only valid for edges that exist in the design, (the isTemporary 
        property is false).
        """
        return _fusion.BRepEdge__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepEdge__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepEdge__get_isValid(self)

# Register BRepEdge in _fusion:
_fusion.BRepEdge_swigregister(BRepEdge)

def BRepEdge_classType() -> "char const *":
    return _fusion.BRepEdge_classType()


BRepEdge.startVertex = property(BRepEdge._get_startVertex, doc="Returns the BRepVertex that bounds its low parameter end.")


BRepEdge.endVertex = property(BRepEdge._get_endVertex, doc="Returns the BRepVertex that bounds its high parameter end.")


BRepEdge.faces = property(BRepEdge._get_faces, doc="Returns the BRepFaces that are associated with this edge through its BRepCoEdges.")


BRepEdge.shell = property(BRepEdge._get_shell, doc="Returns the parent shell of the edge.")


BRepEdge.body = property(BRepEdge._get_body, doc="Returns the parent body of the edge.")


BRepEdge.isDegenerate = property(BRepEdge._get_isDegenerate, doc="Returns if the edge's geometry is degenerate.\nFor example, the apex of a cone is a degerate edge.")


BRepEdge.evaluator = property(BRepEdge._get_evaluator, doc="Returns CurveEvaluator3D for evaluation.")


BRepEdge.geometry = property(BRepEdge._get_geometry, doc="Returns the underlying curve geometry of the edge.")


BRepEdge.isTolerant = property(BRepEdge._get_isTolerant, doc="Returns if the edge is tolerant.\nThe tolerance used is available from the tolerance property.")


BRepEdge.tolerance = property(BRepEdge._get_tolerance, doc="Returns the tolerance used by a tolerant edge.\nThis value is only useful when isTolerant is true.")


BRepEdge.pointOnEdge = property(BRepEdge._get_pointOnEdge, doc="Returns a sample point guaranteed to lie on the edge's curve, within its boundaries,\nand not on a vertex (unless this is a degenerate edge).")


BRepEdge.coEdges = property(BRepEdge._get_coEdges, doc="Returns the BRepCoEdges on the edge.")


BRepEdge.isParamReversed = property(BRepEdge._get_isParamReversed, doc="Returns if the parametric direction of this edge is reversed\nfrom the parametric direction of the underlying curve obtained from the geometry property.\nAn edge's parametric direction is from the start vertex to the end vertex.\nBut the underlying curve geometry may have the opposite parameterization.\nThis property indicates if the parameterization order of the evaluator obtained from\nthis edge is reversed from the order of the geometry curve's evaluator.")


BRepEdge.tangentiallyConnectedEdges = property(BRepEdge._get_tangentiallyConnectedEdges, doc="Returns a collection of edges that includes all of the edges tangentially connected\nto this edge. The result includes this edge. The edges are in the collection\nin their connected order.")


BRepEdge.assemblyContext = property(BRepEdge._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this\nobject in an assembly. This is only valid in the case where this\nBRepEdge object is acting as a proxy in an assembly. Returns null\nin the case where the object is not in the context of an assembly.\nbut is already the native object.")


BRepEdge.nativeObject = property(BRepEdge._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


BRepEdge.attributes = property(BRepEdge._get_attributes, doc="Returns the collection of attributes associated with this face.")


BRepEdge.length = property(BRepEdge._get_length, doc="Returns the length of the edge in centimeters.")


BRepEdge.tempId = property(BRepEdge._get_tempId, doc="Returns the temporary ID of this edge. This ID is only good while the document\nremains open and as long as the owning BRepBody is not modified in any way.\nThe findByTempId method of the BRepBody will return the entity in the body with the given ID.")


BRepEdge.boundingBox = property(BRepEdge._get_boundingBox, doc="Returns the bounding box of this edge.")


BRepEdge.entityToken = property(BRepEdge._get_entityToken, doc="Returns a token for the BRepEdge object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same edge.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.\nThis is only valid for edges that exist in the design, (the isTemporary\nproperty is false).")


BRepEdge.cast = lambda arg: arg if isinstance(arg, BRepEdge) else None

class BRepEdgeDefinition(Base):
    r"""Represents the definition of a B-Rep edge that can be used as input to create a BRepBody."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepEdgeDefinition *":
        return _fusion.BRepEdgeDefinition___deref__(self)

    def __eq__(self, rhs: "BRepEdgeDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepEdgeDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "BRepEdgeDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepEdgeDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepEdgeDefinition_classType()
    __swig_destroy__ = _fusion.delete_BRepEdgeDefinition

    def _get_associativeID(self) -> "int":
        r"""
        Gets and sets the associate ID of this edge definition. This ID will be copied to the corresponding 
        edge when the BRepBodyDefinition is used to create a BrepBody. It is used internally by Fusion360 as 
        the identifier for the edge and is used for tracking this geometry for parametric recomputes.
        """
        return _fusion.BRepEdgeDefinition__get_associativeID(self)

    def _set_associativeID(self, value: "int") -> "bool":
        r"""
        Gets and sets the associate ID of this edge definition. This ID will be copied to the corresponding 
        edge when the BRepBodyDefinition is used to create a BrepBody. It is used internally by Fusion360 as 
        the identifier for the edge and is used for tracking this geometry for parametric recomputes.
        """
        return _fusion.BRepEdgeDefinition__set_associativeID(self, value)

    def _get_startVertex(self) -> "adsk::core::Ptr< adsk::fusion::BRepVertexDefinition >":
        r"""Gets and sets the start vertex of the edge definition."""
        return _fusion.BRepEdgeDefinition__get_startVertex(self)

    def _set_startVertex(self, value: "BRepVertexDefinition") -> "bool":
        r"""Gets and sets the start vertex of the edge definition."""
        return _fusion.BRepEdgeDefinition__set_startVertex(self, value)

    def _get_endVertex(self) -> "adsk::core::Ptr< adsk::fusion::BRepVertexDefinition >":
        r"""Gets and sets the end vertex of the edge definition."""
        return _fusion.BRepEdgeDefinition__get_endVertex(self)

    def _set_endVertex(self, value: "BRepVertexDefinition") -> "bool":
        r"""Gets and sets the end vertex of the edge definition."""
        return _fusion.BRepEdgeDefinition__set_endVertex(self, value)

    def _get_modelSpaceCurve(self) -> "adsk::core::Ptr< adsk::core::Curve3D >":
        r"""Gets and sets the curve that defines the shape of the edge."""
        return _fusion.BRepEdgeDefinition__get_modelSpaceCurve(self)

    def _set_modelSpaceCurve(self, value: "Curve3D") -> "bool":
        r"""Gets and sets the curve that defines the shape of the edge."""
        return _fusion.BRepEdgeDefinition__set_modelSpaceCurve(self, value)

    def _get_isMergeable(self) -> "bool":
        r"""
        Gets and sets if the two faces that share this edge can be merged along this
        edge. This property defaults to true so that merging is always done but this 
        can be set to false in cases where you want to preserve the edge.
        An example where merging is typically done is when you have multiple planar
        faces that all lie on the same plane and are connected. When merging is allowed
        these faces can be be replaced by a single face and the edges connecting the 
        faces (the merged edges) are no longer part of the body.
        """
        return _fusion.BRepEdgeDefinition__get_isMergeable(self)

    def _set_isMergeable(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the two faces that share this edge can be merged along this
        edge. This property defaults to true so that merging is always done but this 
        can be set to false in cases where you want to preserve the edge.
        An example where merging is typically done is when you have multiple planar
        faces that all lie on the same plane and are connected. When merging is allowed
        these faces can be be replaced by a single face and the edges connecting the 
        faces (the merged edges) are no longer part of the body.
        """
        return _fusion.BRepEdgeDefinition__set_isMergeable(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepEdgeDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepEdgeDefinition__get_isValid(self)

# Register BRepEdgeDefinition in _fusion:
_fusion.BRepEdgeDefinition_swigregister(BRepEdgeDefinition)

def BRepEdgeDefinition_classType() -> "char const *":
    return _fusion.BRepEdgeDefinition_classType()


BRepEdgeDefinition.associativeID = property(BRepEdgeDefinition._get_associativeID, BRepEdgeDefinition._set_associativeID, doc="Gets and sets the associate ID of this edge definition. This ID will be copied to the corresponding\nedge when the BRepBodyDefinition is used to create a BrepBody. It is used internally by Fusion360 as\nthe identifier for the edge and is used for tracking this geometry for parametric recomputes.")


BRepEdgeDefinition.startVertex = property(BRepEdgeDefinition._get_startVertex, BRepEdgeDefinition._set_startVertex, doc="Gets and sets the start vertex of the edge definition.")


BRepEdgeDefinition.endVertex = property(BRepEdgeDefinition._get_endVertex, BRepEdgeDefinition._set_endVertex, doc="Gets and sets the end vertex of the edge definition.")


BRepEdgeDefinition.modelSpaceCurve = property(BRepEdgeDefinition._get_modelSpaceCurve, BRepEdgeDefinition._set_modelSpaceCurve, doc="Gets and sets the curve that defines the shape of the edge.")


BRepEdgeDefinition.isMergeable = property(BRepEdgeDefinition._get_isMergeable, BRepEdgeDefinition._set_isMergeable, doc="Gets and sets if the two faces that share this edge can be merged along this\nedge. This property defaults to true so that merging is always done but this\ncan be set to false in cases where you want to preserve the edge.\nAn example where merging is typically done is when you have multiple planar\nfaces that all lie on the same plane and are connected. When merging is allowed\nthese faces can be be replaced by a single face and the edges connecting the\nfaces (the merged edges) are no longer part of the body.")


BRepEdgeDefinition.cast = lambda arg: arg if isinstance(arg, BRepEdgeDefinition) else None

class BRepEdges(Base):
    r"""BRepEdge collection."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepEdges *":
        return _fusion.BRepEdges___deref__(self)

    def __eq__(self, rhs: "BRepEdges") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepEdges___eq__(self, rhs)


    def __ne__(self, rhs: "BRepEdges") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepEdges___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.BRepEdges___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::BRepEdge >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.BRepEdges___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepEdges_classType()
    __swig_destroy__ = _fusion.delete_BRepEdges

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::BRepEdge >":
        r"""
        Function that returns the specified edge using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepEdges_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of edges in the collection."""
        return _fusion.BRepEdges__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepEdges__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepEdges__get_isValid(self)

# Register BRepEdges in _fusion:
_fusion.BRepEdges_swigregister(BRepEdges)

def BRepEdges_classType() -> "char const *":
    return _fusion.BRepEdges_classType()


BRepEdges.count = property(BRepEdges._get_count, doc="The number of edges in the collection.")


BRepEdges.cast = lambda arg: arg if isinstance(arg, BRepEdges) else None

class BRepFace(Base):
    r"""Represent a connected region on a single geometric surface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepFace *":
        return _fusion.BRepFace___deref__(self)

    def __eq__(self, rhs: "BRepFace") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepFace___eq__(self, rhs)


    def __ne__(self, rhs: "BRepFace") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepFace___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepFace_classType()
    __swig_destroy__ = _fusion.delete_BRepFace

    def _get_edges(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdges >":
        r"""Returns the BRepEdges used by this face"""
        return _fusion.BRepFace__get_edges(self)

    def _get_vertices(self) -> "adsk::core::Ptr< adsk::fusion::BRepVertices >":
        r"""Returns the BRepVertices used by this face"""
        return _fusion.BRepFace__get_vertices(self)

    def _get_shell(self) -> "adsk::core::Ptr< adsk::fusion::BRepShell >":
        r"""Returns the parent shell of the face."""
        return _fusion.BRepFace__get_shell(self)

    def _get_loops(self) -> "adsk::core::Ptr< adsk::fusion::BRepLoops >":
        r"""Returns the BRepLoops owned by this face"""
        return _fusion.BRepFace__get_loops(self)

    def _get_body(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""Returns the parent body of the face."""
        return _fusion.BRepFace__get_body(self)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Surface >":
        r"""Returns the underlying surface geometry of this face"""
        return _fusion.BRepFace__get_geometry(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::SurfaceEvaluator >":
        r"""
        Returns a SurfaceEvaluator to allow geometric evaluations across the face's surface.
        This evaluator differs from the evaluator available from the Surface obtained from the geometry
        property by being bounded by the topological boundaries of this face.
        """
        return _fusion.BRepFace__get_evaluator(self)

    def _get_pointOnFace(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Returns a sample point guaranteed to lie on the face's surface, within the face's boundaries, and not on a boundary edge."""
        return _fusion.BRepFace__get_pointOnFace(self)

    def _get_tangentiallyConnectedFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the set of faces that are tengentially adjacent to this face.
        In other words, it is the set of faces that are adjacent to this face's edges
        and have a smooth transition across those edges.
        """
        return _fusion.BRepFace__get_tangentiallyConnectedFaces(self)

    def _get_meshManager(self) -> "adsk::core::Ptr< adsk::fusion::MeshManager >":
        r"""Returns a MeshManager object that allows access to existing and new meshes of this face."""
        return _fusion.BRepFace__get_meshManager(self)

    def _get_appearance(self) -> "adsk::core::Ptr< adsk::core::Appearance >":
        r"""
        Read-write property that gets and sets the current appearance of the face. Setting this property will result in applying
        an override appearance to the face and the AppearanceSourceType property will return OverrideAppearanceSource. Setting
        this property to null will remove any override.
        """
        return _fusion.BRepFace__get_appearance(self)

    def _set_appearance(self, value: "Appearance") -> "bool":
        r"""
        Read-write property that gets and sets the current appearance of the face. Setting this property will result in applying
        an override appearance to the face and the AppearanceSourceType property will return OverrideAppearanceSource. Setting
        this property to null will remove any override.
        """
        return _fusion.BRepFace__set_appearance(self, value)

    def _get_appearanceSourceType(self) -> "adsk::core::AppearanceSourceTypes":
        r"""
        Read-write property that gets the source of the appearance for the face. If this returns OverrideAppearanceSource, an override exists
        on this face. The override can be removed by setting the Appearance property to null.
        """
        return _fusion.BRepFace__get_appearanceSourceType(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this
        object in an assembly. This is only valid in the case where this
        BRepFace object is acting as a proxy in an assembly. Returns null 
        in the case where the object is not in the context of an assembly.
        but is already the native object.
        """
        return _fusion.BRepFace__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::BRepFace >":
        r"""
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.BRepFace__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::BRepFace >":
        r"""
        Returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context for the created proxy. 
        Returns the new BRepFace proxy or null if this isn't the NativeObject.
        """
        return _fusion.BRepFace_createForAssemblyContext(self, occurrence)

    def _get_area(self) -> "double":
        r"""Returns the area in cm ^ 2."""
        return _fusion.BRepFace__get_area(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the bounding box of this face"""
        return _fusion.BRepFace__get_boundingBox(self)

    def _get_centroid(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Returns a point at the centroid (aka, geometric center) of the face."""
        return _fusion.BRepFace__get_centroid(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.BRepFace__get_attributes(self)

    def _get_tempId(self) -> "int":
        r"""
        Returns the temporary ID of this face. This ID is only good while the document
        remains open and as long as the owning BRepBody is not modified in any way. 
        The findByTempId method of the BRepBody will return the entity in the body with the given ID.
        """
        return _fusion.BRepFace__get_tempId(self)

    def convert(self, options: "BRepConvertOptions") -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Creates a new body where this face and its edges are converted to different
        types of geometry based on the input options. 
        The tempId on the faces, edges, and vertices on the new body will match
        with the corresponding tempId on the original body. In cases where the face is
        split as a result of the conversion there can be more than one face or edge in
        the new body that matches to a single face or edge in the original body. 
        options : Input options that define how the conversion should be done. These are
        bitwise options so they can be combined. 
        Returns the new converted body or null in the case of failure.
        """
        return _fusion.BRepFace_convert(self, options)

    def _get_isParamReversed(self) -> "bool":
        r"""
        Gets if the normal of this face is reversed with respect to the surface geometry associated 
        with this face.
        """
        return _fusion.BRepFace__get_isParamReversed(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the BRepFace object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same face.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        This is only valid for faces that exist in the design, (the isTemporary 
        property is false).
        """
        return _fusion.BRepFace__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepFace__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepFace__get_isValid(self)

# Register BRepFace in _fusion:
_fusion.BRepFace_swigregister(BRepFace)

def BRepFace_classType() -> "char const *":
    return _fusion.BRepFace_classType()


BRepFace.edges = property(BRepFace._get_edges, doc="Returns the BRepEdges used by this face")


BRepFace.vertices = property(BRepFace._get_vertices, doc="Returns the BRepVertices used by this face")


BRepFace.shell = property(BRepFace._get_shell, doc="Returns the parent shell of the face.")


BRepFace.loops = property(BRepFace._get_loops, doc="Returns the BRepLoops owned by this face")


BRepFace.body = property(BRepFace._get_body, doc="Returns the parent body of the face.")


BRepFace.geometry = property(BRepFace._get_geometry, doc="Returns the underlying surface geometry of this face")


BRepFace.evaluator = property(BRepFace._get_evaluator, doc="Returns a SurfaceEvaluator to allow geometric evaluations across the face's surface.\nThis evaluator differs from the evaluator available from the Surface obtained from the geometry\nproperty by being bounded by the topological boundaries of this face.")


BRepFace.pointOnFace = property(BRepFace._get_pointOnFace, doc="Returns a sample point guaranteed to lie on the face's surface, within the face's boundaries, and not on a boundary edge.")


BRepFace.tangentiallyConnectedFaces = property(BRepFace._get_tangentiallyConnectedFaces, doc="Returns the set of faces that are tengentially adjacent to this face.\nIn other words, it is the set of faces that are adjacent to this face's edges\nand have a smooth transition across those edges.")


BRepFace.meshManager = property(BRepFace._get_meshManager, doc="Returns a MeshManager object that allows access to existing and new meshes of this face.")


BRepFace.appearance = property(BRepFace._get_appearance, BRepFace._set_appearance, doc="Read-write property that gets and sets the current appearance of the face. Setting this property will result in applying\nan override appearance to the face and the AppearanceSourceType property will return OverrideAppearanceSource. Setting\nthis property to null will remove any override.")


BRepFace.appearanceSourceType = property(BRepFace._get_appearanceSourceType, doc="Read-write property that gets the source of the appearance for the face. If this returns OverrideAppearanceSource, an override exists\non this face. The override can be removed by setting the Appearance property to null.")


BRepFace.assemblyContext = property(BRepFace._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this\nobject in an assembly. This is only valid in the case where this\nBRepFace object is acting as a proxy in an assembly. Returns null\nin the case where the object is not in the context of an assembly.\nbut is already the native object.")


BRepFace.nativeObject = property(BRepFace._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


BRepFace.area = property(BRepFace._get_area, doc="Returns the area in cm ^ 2.")


BRepFace.boundingBox = property(BRepFace._get_boundingBox, doc="Returns the bounding box of this face")


BRepFace.centroid = property(BRepFace._get_centroid, doc="Returns a point at the centroid (aka, geometric center) of the face.")


BRepFace.attributes = property(BRepFace._get_attributes, doc="Returns the collection of attributes associated with this face.")


BRepFace.tempId = property(BRepFace._get_tempId, doc="Returns the temporary ID of this face. This ID is only good while the document\nremains open and as long as the owning BRepBody is not modified in any way.\nThe findByTempId method of the BRepBody will return the entity in the body with the given ID.")


BRepFace.isParamReversed = property(BRepFace._get_isParamReversed, doc="Gets if the normal of this face is reversed with respect to the surface geometry associated\nwith this face.")


BRepFace.entityToken = property(BRepFace._get_entityToken, doc="Returns a token for the BRepFace object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same face.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.\nThis is only valid for faces that exist in the design, (the isTemporary\nproperty is false).")


BRepFace.cast = lambda arg: arg if isinstance(arg, BRepFace) else None

class BRepFaceDefinition(Base):
    r"""Represents the definition of a B-Rep face that can be used as input to create a BRepBody that includes this face."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepFaceDefinition *":
        return _fusion.BRepFaceDefinition___deref__(self)

    def __eq__(self, rhs: "BRepFaceDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepFaceDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "BRepFaceDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepFaceDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepFaceDefinition_classType()
    __swig_destroy__ = _fusion.delete_BRepFaceDefinition

    def _get_associativeID(self) -> "int":
        r"""
        Gets and sets the associate ID of this face definition. This ID will be copied to the corresponding 
        face when the BRepBodyDefinition is used to create a BrepBody. It is used by Fusion360 as 
        the identifier for the face and is used for tracking this geometry for parametric recomputes.
        """
        return _fusion.BRepFaceDefinition__get_associativeID(self)

    def _set_associativeID(self, value: "int") -> "bool":
        r"""
        Gets and sets the associate ID of this face definition. This ID will be copied to the corresponding 
        face when the BRepBodyDefinition is used to create a BrepBody. It is used by Fusion360 as 
        the identifier for the face and is used for tracking this geometry for parametric recomputes.
        """
        return _fusion.BRepFaceDefinition__set_associativeID(self, value)

    def _get_loopDefinitions(self) -> "adsk::core::Ptr< adsk::fusion::BRepLoopDefinitions >":
        r"""
        Provides access to the BRepLoopDefinitions object associated with this BRepFaceDefinition.
        It's through the returned collection that you can create new BRepLoopDefinition objects.
        """
        return _fusion.BRepFaceDefinition__get_loopDefinitions(self)

    def _get_surfaceGeometry(self) -> "adsk::core::Ptr< adsk::core::Surface >":
        r"""Gets and sets the surface geometry associated with this face definition."""
        return _fusion.BRepFaceDefinition__get_surfaceGeometry(self)

    def _set_surfaceGeometry(self, value: "Surface") -> "bool":
        r"""Gets and sets the surface geometry associated with this face definition."""
        return _fusion.BRepFaceDefinition__set_surfaceGeometry(self, value)

    def _get_isParamReversed(self) -> "bool":
        r"""
        Gets and sets if the normal of this face is reversed with respect to the surface geometry associated 
        with this face definition.
        """
        return _fusion.BRepFaceDefinition__get_isParamReversed(self)

    def _set_isParamReversed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the normal of this face is reversed with respect to the surface geometry associated 
        with this face definition.
        """
        return _fusion.BRepFaceDefinition__set_isParamReversed(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepFaceDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepFaceDefinition__get_isValid(self)

# Register BRepFaceDefinition in _fusion:
_fusion.BRepFaceDefinition_swigregister(BRepFaceDefinition)

def BRepFaceDefinition_classType() -> "char const *":
    return _fusion.BRepFaceDefinition_classType()


BRepFaceDefinition.associativeID = property(BRepFaceDefinition._get_associativeID, BRepFaceDefinition._set_associativeID, doc="Gets and sets the associate ID of this face definition. This ID will be copied to the corresponding\nface when the BRepBodyDefinition is used to create a BrepBody. It is used by Fusion360 as\nthe identifier for the face and is used for tracking this geometry for parametric recomputes.")


BRepFaceDefinition.loopDefinitions = property(BRepFaceDefinition._get_loopDefinitions, doc="Provides access to the BRepLoopDefinitions object associated with this BRepFaceDefinition.\nIt's through the returned collection that you can create new BRepLoopDefinition objects.")


BRepFaceDefinition.surfaceGeometry = property(BRepFaceDefinition._get_surfaceGeometry, BRepFaceDefinition._set_surfaceGeometry, doc="Gets and sets the surface geometry associated with this face definition.")


BRepFaceDefinition.isParamReversed = property(BRepFaceDefinition._get_isParamReversed, BRepFaceDefinition._set_isParamReversed, doc="Gets and sets if the normal of this face is reversed with respect to the surface geometry associated\nwith this face definition.")


BRepFaceDefinition.cast = lambda arg: arg if isinstance(arg, BRepFaceDefinition) else None

class BRepFaceDefinitions(Base):
    r"""
    Provides access to the BRepFaceDefinition objects associated with the object the collection was obtained from.
    It's through this object that you create new BRepFaceDefinition objects.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepFaceDefinitions *":
        return _fusion.BRepFaceDefinitions___deref__(self)

    def __eq__(self, rhs: "BRepFaceDefinitions") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepFaceDefinitions___eq__(self, rhs)


    def __ne__(self, rhs: "BRepFaceDefinitions") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepFaceDefinitions___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.BRepFaceDefinitions___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::BRepFaceDefinition >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.BRepFaceDefinitions___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepFaceDefinitions_classType()
    __swig_destroy__ = _fusion.delete_BRepFaceDefinitions

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::BRepFaceDefinition >":
        r"""
        Function that returns the specified BRepFaceDefinition object using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepFaceDefinitions_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of B-Rep face definition objects in the collection."""
        return _fusion.BRepFaceDefinitions__get_count(self)

    def add(self, surfaceGeometry: "Surface", isParamReversed: "bool") -> "adsk::core::Ptr< adsk::fusion::BRepFaceDefinition >":
        r"""
        Creates a new BrepFaceDefinition within the parent BRepShellDefinition object. 
        surfaceGeometry : Input surface object that defines the geometry of the face. Valid objects for input are 
        NurbsSurface, Cone, Cylinder, EllipticalCone, EllipticalCylinder, Plane, Sphere, and Torus. 
        isParamReversed : Input Boolean that indicates if the normal of this face is reversed with respect to the 
        surface geometry associated with this face definition. 
        Returns the newly created BRepFaceDefinition object or null in the case of failure.
        """
        return _fusion.BRepFaceDefinitions_add(self, surfaceGeometry, isParamReversed)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepFaceDefinitions__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepFaceDefinitions__get_isValid(self)

# Register BRepFaceDefinitions in _fusion:
_fusion.BRepFaceDefinitions_swigregister(BRepFaceDefinitions)

def BRepFaceDefinitions_classType() -> "char const *":
    return _fusion.BRepFaceDefinitions_classType()


BRepFaceDefinitions.count = property(BRepFaceDefinitions._get_count, doc="The number of B-Rep face definition objects in the collection.")


BRepFaceDefinitions.cast = lambda arg: arg if isinstance(arg, BRepFaceDefinitions) else None

class BRepFaces(Base):
    r"""BRepFace collection."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepFaces *":
        return _fusion.BRepFaces___deref__(self)

    def __eq__(self, rhs: "BRepFaces") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepFaces___eq__(self, rhs)


    def __ne__(self, rhs: "BRepFaces") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepFaces___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.BRepFaces___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::BRepFace >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.BRepFaces___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepFaces_classType()
    __swig_destroy__ = _fusion.delete_BRepFaces

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::BRepFace >":
        r"""
        Function that returns the specified face using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepFaces_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of faces in the collection."""
        return _fusion.BRepFaces__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepFaces__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepFaces__get_isValid(self)

# Register BRepFaces in _fusion:
_fusion.BRepFaces_swigregister(BRepFaces)

def BRepFaces_classType() -> "char const *":
    return _fusion.BRepFaces_classType()


BRepFaces.count = property(BRepFaces._get_count, doc="The number of faces in the collection.")


BRepFaces.cast = lambda arg: arg if isinstance(arg, BRepFaces) else None

class BRepLoop(Base):
    r"""Represents a connected portion of a BRepFace boundary. It consists of a chain of BRepCoEdges."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepLoop *":
        return _fusion.BRepLoop___deref__(self)

    def __eq__(self, rhs: "BRepLoop") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepLoop___eq__(self, rhs)


    def __ne__(self, rhs: "BRepLoop") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepLoop___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepLoop_classType()
    __swig_destroy__ = _fusion.delete_BRepLoop

    def _get_edges(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdges >":
        r"""Returns the BRepEdges used by this loop"""
        return _fusion.BRepLoop__get_edges(self)

    def _get_coEdges(self) -> "adsk::core::Ptr< adsk::fusion::BRepCoEdges >":
        r"""Returns the BRepCoEdges consisting this loop"""
        return _fusion.BRepLoop__get_coEdges(self)

    def _get_isOuter(self) -> "bool":
        r"""Returns true of this loop is an outer loop of a face"""
        return _fusion.BRepLoop__get_isOuter(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the bounding box of this loop"""
        return _fusion.BRepLoop__get_boundingBox(self)

    def _get_face(self) -> "adsk::core::Ptr< adsk::fusion::BRepFace >":
        r"""Returns the parent face of the loop."""
        return _fusion.BRepLoop__get_face(self)

    def _get_body(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""Returns the parent body of the loop."""
        return _fusion.BRepLoop__get_body(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this
        object in an assembly. This is only valid in the case where this
        BRepLoop object is acting as a proxy in an assembly. Returns null 
        in the case where the object is not in the context of an assembly.
        but is already the native object.
        """
        return _fusion.BRepLoop__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::BRepLoop >":
        r"""
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.BRepLoop__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::BRepLoop >":
        r"""
        Returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context for the created proxy. 
        Returns the new BrepLoop proxy or null if this isn't the NativeObject.
        """
        return _fusion.BRepLoop_createForAssemblyContext(self, occurrence)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the BRepLoop object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same loop.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        This is only valid for loops that exist in the design, (the isTemporary 
        property is false).
        """
        return _fusion.BRepLoop__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepLoop__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepLoop__get_isValid(self)

# Register BRepLoop in _fusion:
_fusion.BRepLoop_swigregister(BRepLoop)

def BRepLoop_classType() -> "char const *":
    return _fusion.BRepLoop_classType()


BRepLoop.edges = property(BRepLoop._get_edges, doc="Returns the BRepEdges used by this loop")


BRepLoop.coEdges = property(BRepLoop._get_coEdges, doc="Returns the BRepCoEdges consisting this loop")


BRepLoop.isOuter = property(BRepLoop._get_isOuter, doc="Returns true of this loop is an outer loop of a face")


BRepLoop.boundingBox = property(BRepLoop._get_boundingBox, doc="Returns the bounding box of this loop")


BRepLoop.face = property(BRepLoop._get_face, doc="Returns the parent face of the loop.")


BRepLoop.body = property(BRepLoop._get_body, doc="Returns the parent body of the loop.")


BRepLoop.assemblyContext = property(BRepLoop._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this\nobject in an assembly. This is only valid in the case where this\nBRepLoop object is acting as a proxy in an assembly. Returns null\nin the case where the object is not in the context of an assembly.\nbut is already the native object.")


BRepLoop.nativeObject = property(BRepLoop._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


BRepLoop.entityToken = property(BRepLoop._get_entityToken, doc="Returns a token for the BRepLoop object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same loop.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.\nThis is only valid for loops that exist in the design, (the isTemporary\nproperty is false).")


BRepLoop.cast = lambda arg: arg if isinstance(arg, BRepLoop) else None

class BRepLoopDefinition(Base):
    r"""Represents the definition of a B-Rep loop that can be used as input to create a BRepBody that includes this loop."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepLoopDefinition *":
        return _fusion.BRepLoopDefinition___deref__(self)

    def __eq__(self, rhs: "BRepLoopDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepLoopDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "BRepLoopDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepLoopDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepLoopDefinition_classType()
    __swig_destroy__ = _fusion.delete_BRepLoopDefinition

    def _get_bRepCoEdgeDefinitions(self) -> "adsk::core::Ptr< adsk::fusion::BRepCoEdgeDefinitions >":
        r"""
        Provides access to the BRepCoEdgeDefinitions object associated with the parent BRepFaceDefinition object.
        It's through the returned collection that you can create new BRepCoEdgeDefinition objects.
        """
        return _fusion.BRepLoopDefinition__get_bRepCoEdgeDefinitions(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepLoopDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepLoopDefinition__get_isValid(self)

# Register BRepLoopDefinition in _fusion:
_fusion.BRepLoopDefinition_swigregister(BRepLoopDefinition)

def BRepLoopDefinition_classType() -> "char const *":
    return _fusion.BRepLoopDefinition_classType()


BRepLoopDefinition.bRepCoEdgeDefinitions = property(BRepLoopDefinition._get_bRepCoEdgeDefinitions, doc="Provides access to the BRepCoEdgeDefinitions object associated with the parent BRepFaceDefinition object.\nIt's through the returned collection that you can create new BRepCoEdgeDefinition objects.")


BRepLoopDefinition.cast = lambda arg: arg if isinstance(arg, BRepLoopDefinition) else None

class BRepLoopDefinitions(Base):
    r"""
    Provides access to the BRepLoopDefinition objects associated with the parent BRepFaceDefinition object.
    It's through this object that you create new BRepLoopDefinition objects.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepLoopDefinitions *":
        return _fusion.BRepLoopDefinitions___deref__(self)

    def __eq__(self, rhs: "BRepLoopDefinitions") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepLoopDefinitions___eq__(self, rhs)


    def __ne__(self, rhs: "BRepLoopDefinitions") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepLoopDefinitions___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.BRepLoopDefinitions___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::BRepLoopDefinition >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.BRepLoopDefinitions___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepLoopDefinitions_classType()
    __swig_destroy__ = _fusion.delete_BRepLoopDefinitions

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::BRepLoopDefinition >":
        r"""
        Function that returns the specified BRepLoopDefinition object using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepLoopDefinitions_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of B-Rep loop definition objects in the collection."""
        return _fusion.BRepLoopDefinitions__get_count(self)

    def add(self) -> "adsk::core::Ptr< adsk::fusion::BRepLoopDefinition >":
        r"""
        Creates a new empty loop associated with the parent face definition. 
        Returns the newly created BRepLoopDefinition object.
        """
        return _fusion.BRepLoopDefinitions_add(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepLoopDefinitions__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepLoopDefinitions__get_isValid(self)

# Register BRepLoopDefinitions in _fusion:
_fusion.BRepLoopDefinitions_swigregister(BRepLoopDefinitions)

def BRepLoopDefinitions_classType() -> "char const *":
    return _fusion.BRepLoopDefinitions_classType()


BRepLoopDefinitions.count = property(BRepLoopDefinitions._get_count, doc="The number of B-Rep loop definition objects in the collection.")


BRepLoopDefinitions.cast = lambda arg: arg if isinstance(arg, BRepLoopDefinitions) else None

class BRepLoops(Base):
    r"""BRepLoop collection."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepLoops *":
        return _fusion.BRepLoops___deref__(self)

    def __eq__(self, rhs: "BRepLoops") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepLoops___eq__(self, rhs)


    def __ne__(self, rhs: "BRepLoops") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepLoops___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.BRepLoops___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::BRepLoop >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.BRepLoops___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepLoops_classType()
    __swig_destroy__ = _fusion.delete_BRepLoops

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::BRepLoop >":
        r"""
        Function that returns the specified loop using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepLoops_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of loops in the collection."""
        return _fusion.BRepLoops__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepLoops__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepLoops__get_isValid(self)

# Register BRepLoops in _fusion:
_fusion.BRepLoops_swigregister(BRepLoops)

def BRepLoops_classType() -> "char const *":
    return _fusion.BRepLoops_classType()


BRepLoops.count = property(BRepLoops._get_count, doc="The number of loops in the collection.")


BRepLoops.cast = lambda arg: arg if isinstance(arg, BRepLoops) else None

class BRepLump(Base):
    r"""Represents an entirely connected set of entities. A BRepBody consists of BRepLumps."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepLump *":
        return _fusion.BRepLump___deref__(self)

    def __eq__(self, rhs: "BRepLump") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepLump___eq__(self, rhs)


    def __ne__(self, rhs: "BRepLump") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepLump___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepLump_classType()
    __swig_destroy__ = _fusion.delete_BRepLump

    def _get_shells(self) -> "adsk::core::Ptr< adsk::fusion::BRepShells >":
        r"""Returns the BRepShells owned by the lump"""
        return _fusion.BRepLump__get_shells(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""Returns the BRepFaces owned by the lump"""
        return _fusion.BRepLump__get_faces(self)

    def _get_edges(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdges >":
        r"""Returns the BRepEdges owned by the lump"""
        return _fusion.BRepLump__get_edges(self)

    def _get_vertices(self) -> "adsk::core::Ptr< adsk::fusion::BRepVertices >":
        r"""Returns the BRepVertices owned by the lump"""
        return _fusion.BRepLump__get_vertices(self)

    def _get_body(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""Returns the immediate owner BRepBody of the lump"""
        return _fusion.BRepLump__get_body(self)

    def _get_isClosed(self) -> "bool":
        r"""Returns true of the lump is closed"""
        return _fusion.BRepLump__get_isClosed(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the bounding box of the lump"""
        return _fusion.BRepLump__get_boundingBox(self)

    def _get_area(self) -> "double":
        r"""Returns the area in cm ^ 2."""
        return _fusion.BRepLump__get_area(self)

    def _get_volume(self) -> "double":
        r"""Returns the volume in cm ^ 3. Returns 0 in the case the lump is not solid."""
        return _fusion.BRepLump__get_volume(self)

    def pointContainment(self, point: "Point3D") -> "adsk::fusion::PointContainment":
        r"""
        Determines the relationship of the input point with respect to this lump. 
        point : The point to do the containment check for. 
        Returns a value from the PointContainment enum indicating the relationship of
        the input point to the lump.
        """
        return _fusion.BRepLump_pointContainment(self, point)

    def _get_meshManager(self) -> "adsk::core::Ptr< adsk::fusion::MeshManager >":
        r"""Returns the mesh manager object for this lump."""
        return _fusion.BRepLump__get_meshManager(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly context that is directly referencing this
        object in an assembly. This is only valid in the case where this
        BRepLump object is acting as a proxy in an assembly. Returns null 
        in the case where the object is not in the context of an assembly.
        but is already the native object.
        """
        return _fusion.BRepLump__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::BRepLump >":
        r"""
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.BRepLump__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::BRepLump >":
        r"""
        Returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context for the created proxy. 
        Returns the new BrepLump proxy or null if this isn't the NativeObject.
        """
        return _fusion.BRepLump_createForAssemblyContext(self, occurrence)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the BRepLump object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same lump.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        This is only valid for lump that exist in the design, (the isTemporary 
        property is false).
        """
        return _fusion.BRepLump__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepLump__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepLump__get_isValid(self)

# Register BRepLump in _fusion:
_fusion.BRepLump_swigregister(BRepLump)

def BRepLump_classType() -> "char const *":
    return _fusion.BRepLump_classType()


BRepLump.shells = property(BRepLump._get_shells, doc="Returns the BRepShells owned by the lump")


BRepLump.faces = property(BRepLump._get_faces, doc="Returns the BRepFaces owned by the lump")


BRepLump.edges = property(BRepLump._get_edges, doc="Returns the BRepEdges owned by the lump")


BRepLump.vertices = property(BRepLump._get_vertices, doc="Returns the BRepVertices owned by the lump")


BRepLump.body = property(BRepLump._get_body, doc="Returns the immediate owner BRepBody of the lump")


BRepLump.isClosed = property(BRepLump._get_isClosed, doc="Returns true of the lump is closed")


BRepLump.boundingBox = property(BRepLump._get_boundingBox, doc="Returns the bounding box of the lump")


BRepLump.area = property(BRepLump._get_area, doc="Returns the area in cm ^ 2.")


BRepLump.volume = property(BRepLump._get_volume, doc="Returns the volume in cm ^ 3. Returns 0 in the case the lump is not solid.")


BRepLump.meshManager = property(BRepLump._get_meshManager, doc="Returns the mesh manager object for this lump.")


BRepLump.assemblyContext = property(BRepLump._get_assemblyContext, doc="Returns the assembly context that is directly referencing this\nobject in an assembly. This is only valid in the case where this\nBRepLump object is acting as a proxy in an assembly. Returns null\nin the case where the object is not in the context of an assembly.\nbut is already the native object.")


BRepLump.nativeObject = property(BRepLump._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


BRepLump.entityToken = property(BRepLump._get_entityToken, doc="Returns a token for the BRepLump object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same lump.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.\nThis is only valid for lump that exist in the design, (the isTemporary\nproperty is false).")


BRepLump.cast = lambda arg: arg if isinstance(arg, BRepLump) else None

class BRepLumpDefinition(Base):
    r"""Represents the definition of a B-Rep lump which is used in defining the topology of a B-Rep body."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepLumpDefinition *":
        return _fusion.BRepLumpDefinition___deref__(self)

    def __eq__(self, rhs: "BRepLumpDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepLumpDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "BRepLumpDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepLumpDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepLumpDefinition_classType()
    __swig_destroy__ = _fusion.delete_BRepLumpDefinition

    def _get_shellDefinitions(self) -> "adsk::core::Ptr< adsk::fusion::BRepShellDefinitions >":
        r"""
        Provides access to the BRepShellDefinitions object associated with this BRepLumpDefinition.
        It's through the returned collection that you can create new BRepShellDefinition objects.
        """
        return _fusion.BRepLumpDefinition__get_shellDefinitions(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepLumpDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepLumpDefinition__get_isValid(self)

# Register BRepLumpDefinition in _fusion:
_fusion.BRepLumpDefinition_swigregister(BRepLumpDefinition)

def BRepLumpDefinition_classType() -> "char const *":
    return _fusion.BRepLumpDefinition_classType()


BRepLumpDefinition.shellDefinitions = property(BRepLumpDefinition._get_shellDefinitions, doc="Provides access to the BRepShellDefinitions object associated with this BRepLumpDefinition.\nIt's through the returned collection that you can create new BRepShellDefinition objects.")


BRepLumpDefinition.cast = lambda arg: arg if isinstance(arg, BRepLumpDefinition) else None

class BRepLumpDefinitions(Base):
    r"""
    Provides access to the BRepLumpDefinition objects associated with the BRepBodyDefinition
    and it's through this object that you create new BRepLumpDefinition objects.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepLumpDefinitions *":
        return _fusion.BRepLumpDefinitions___deref__(self)

    def __eq__(self, rhs: "BRepLumpDefinitions") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepLumpDefinitions___eq__(self, rhs)


    def __ne__(self, rhs: "BRepLumpDefinitions") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepLumpDefinitions___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.BRepLumpDefinitions___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::BRepLumpDefinition >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.BRepLumpDefinitions___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepLumpDefinitions_classType()
    __swig_destroy__ = _fusion.delete_BRepLumpDefinitions

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::BRepLumpDefinition >":
        r"""
        Function that returns the specified BRepLumpDefinition object using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepLumpDefinitions_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of B-Rep lump definition objects in the collection."""
        return _fusion.BRepLumpDefinitions__get_count(self)

    def add(self) -> "adsk::core::Ptr< adsk::fusion::BRepLumpDefinition >":
        r"""
        Creates a new empty BRepLumpDefinition associated with the parent BRepBodyDefinition object. 
        Returns the newly created BRepLumpDefinition object.
        """
        return _fusion.BRepLumpDefinitions_add(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepLumpDefinitions__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepLumpDefinitions__get_isValid(self)

# Register BRepLumpDefinitions in _fusion:
_fusion.BRepLumpDefinitions_swigregister(BRepLumpDefinitions)

def BRepLumpDefinitions_classType() -> "char const *":
    return _fusion.BRepLumpDefinitions_classType()


BRepLumpDefinitions.count = property(BRepLumpDefinitions._get_count, doc="The number of B-Rep lump definition objects in the collection.")


BRepLumpDefinitions.cast = lambda arg: arg if isinstance(arg, BRepLumpDefinitions) else None

class BRepLumps(Base):
    r"""BRepLump collection."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepLumps *":
        return _fusion.BRepLumps___deref__(self)

    def __eq__(self, rhs: "BRepLumps") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepLumps___eq__(self, rhs)


    def __ne__(self, rhs: "BRepLumps") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepLumps___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.BRepLumps___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::BRepLump >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.BRepLumps___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepLumps_classType()
    __swig_destroy__ = _fusion.delete_BRepLumps

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::BRepLump >":
        r"""
        Function that returns the specified lump using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepLumps_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of lumps in the collection."""
        return _fusion.BRepLumps__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepLumps__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepLumps__get_isValid(self)

# Register BRepLumps in _fusion:
_fusion.BRepLumps_swigregister(BRepLumps)

def BRepLumps_classType() -> "char const *":
    return _fusion.BRepLumps_classType()


BRepLumps.count = property(BRepLumps._get_count, doc="Returns the number of lumps in the collection.")


BRepLumps.cast = lambda arg: arg if isinstance(arg, BRepLumps) else None

class BRepShell(Base):
    r"""Represents an entirely connected set of BRepFaces. A BRepLump may contain multiple BRepShells."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepShell *":
        return _fusion.BRepShell___deref__(self)

    def __eq__(self, rhs: "BRepShell") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepShell___eq__(self, rhs)


    def __ne__(self, rhs: "BRepShell") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepShell___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepShell_classType()
    __swig_destroy__ = _fusion.delete_BRepShell

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""Returns the BRepFaces directly owned by this shell"""
        return _fusion.BRepShell__get_faces(self)

    def _get_edges(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdges >":
        r"""returns the BRepEdges owned by this shell"""
        return _fusion.BRepShell__get_edges(self)

    def _get_vertices(self) -> "adsk::core::Ptr< adsk::fusion::BRepVertices >":
        r"""Returns the BRepVertices owned by this shell"""
        return _fusion.BRepShell__get_vertices(self)

    def _get_lump(self) -> "adsk::core::Ptr< adsk::fusion::BRepLump >":
        r"""Returns the parent lump of this shell."""
        return _fusion.BRepShell__get_lump(self)

    def _get_body(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""Returns the parent body of the shell."""
        return _fusion.BRepShell__get_body(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the bounding box of this shell"""
        return _fusion.BRepShell__get_boundingBox(self)

    def pointContainment(self, point: "Point3D") -> "adsk::fusion::PointContainment":
        r"""
        Determines the relationship of the input point with respect to this shell. 
        point : The point to do the containment check for. 
        Returns a value from the PointContainment enum indicating the relationship of
        the input point to the shell.
        """
        return _fusion.BRepShell_pointContainment(self, point)

    def _get_isClosed(self) -> "bool":
        r"""Returns true if this shell is closed"""
        return _fusion.BRepShell__get_isClosed(self)

    def _get_isVoid(self) -> "bool":
        r"""Returns true if the faces of this shell bound a void or an empty space within an outer shell."""
        return _fusion.BRepShell__get_isVoid(self)

    def _get_area(self) -> "double":
        r"""Returns the area in cm ^ 2."""
        return _fusion.BRepShell__get_area(self)

    def _get_volume(self) -> "double":
        r"""Returns the volume in cm ^ 3. Returns 0 in the case the shell is not solid."""
        return _fusion.BRepShell__get_volume(self)

    def _get_meshManager(self) -> "adsk::core::Ptr< adsk::fusion::MeshManager >":
        r"""Returns the mesh manager object for this shell."""
        return _fusion.BRepShell__get_meshManager(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this
        object in an assembly. This is only valid in the case where this
        BRepShell object is acting as a proxy in an assembly. Returns null 
        in the case where the object is not in the context of an assembly.
        but is already the native object.
        """
        return _fusion.BRepShell__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::BRepShell >":
        r"""
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.BRepShell__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::BRepShell >":
        r"""
        Returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context for the created proxy. 
        Returns the new BrepShell proxy or null if this isn't the NativeObject.
        """
        return _fusion.BRepShell_createForAssemblyContext(self, occurrence)

    def _get_wire(self) -> "adsk::core::Ptr< adsk::fusion::BRepWire >":
        r"""
        Returns the wire body, if any, that exists in this shell. Returns null if the
        shell doesn't have a wire body.
        """
        return _fusion.BRepShell__get_wire(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the BRepShell object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same shell.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        This is only valid for shells that exist in the design, (the isTemporary 
        property is false).
        """
        return _fusion.BRepShell__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepShell__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepShell__get_isValid(self)

# Register BRepShell in _fusion:
_fusion.BRepShell_swigregister(BRepShell)

def BRepShell_classType() -> "char const *":
    return _fusion.BRepShell_classType()


BRepShell.faces = property(BRepShell._get_faces, doc="Returns the BRepFaces directly owned by this shell")


BRepShell.edges = property(BRepShell._get_edges, doc="returns the BRepEdges owned by this shell")


BRepShell.vertices = property(BRepShell._get_vertices, doc="Returns the BRepVertices owned by this shell")


BRepShell.lump = property(BRepShell._get_lump, doc="Returns the parent lump of this shell.")


BRepShell.body = property(BRepShell._get_body, doc="Returns the parent body of the shell.")


BRepShell.boundingBox = property(BRepShell._get_boundingBox, doc="Returns the bounding box of this shell")


BRepShell.isClosed = property(BRepShell._get_isClosed, doc="Returns true if this shell is closed")


BRepShell.isVoid = property(BRepShell._get_isVoid, doc="Returns true if the faces of this shell bound a void or an empty space within an outer shell.")


BRepShell.area = property(BRepShell._get_area, doc="Returns the area in cm ^ 2.")


BRepShell.volume = property(BRepShell._get_volume, doc="Returns the volume in cm ^ 3. Returns 0 in the case the shell is not solid.")


BRepShell.meshManager = property(BRepShell._get_meshManager, doc="Returns the mesh manager object for this shell.")


BRepShell.assemblyContext = property(BRepShell._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this\nobject in an assembly. This is only valid in the case where this\nBRepShell object is acting as a proxy in an assembly. Returns null\nin the case where the object is not in the context of an assembly.\nbut is already the native object.")


BRepShell.nativeObject = property(BRepShell._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


BRepShell.wire = property(BRepShell._get_wire, doc="Returns the wire body, if any, that exists in this shell. Returns null if the\nshell doesn't have a wire body.")


BRepShell.entityToken = property(BRepShell._get_entityToken, doc="Returns a token for the BRepShell object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same shell.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.\nThis is only valid for shells that exist in the design, (the isTemporary\nproperty is false).")


BRepShell.cast = lambda arg: arg if isinstance(arg, BRepShell) else None

class BRepShellDefinition(Base):
    r"""Represents the definition of a B-Rep shell that can be used as input to create a BRepBody that includes this shell."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepShellDefinition *":
        return _fusion.BRepShellDefinition___deref__(self)

    def __eq__(self, rhs: "BRepShellDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepShellDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "BRepShellDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepShellDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepShellDefinition_classType()
    __swig_destroy__ = _fusion.delete_BRepShellDefinition

    def _get_faceDefinitions(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaceDefinitions >":
        r"""
        Provides access to the BRepFaceDefinitions object associated with this BRepShellDefinition.
        It's through the returned collection that you can create new BRepFaceDefinition objects.
        """
        return _fusion.BRepShellDefinition__get_faceDefinitions(self)

    def _get_wireDefinition(self) -> "adsk::core::Ptr< adsk::fusion::BRepWireDefinition >":
        r"""Returns the single BRepWireDefinition associated with this shell definition."""
        return _fusion.BRepShellDefinition__get_wireDefinition(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepShellDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepShellDefinition__get_isValid(self)

# Register BRepShellDefinition in _fusion:
_fusion.BRepShellDefinition_swigregister(BRepShellDefinition)

def BRepShellDefinition_classType() -> "char const *":
    return _fusion.BRepShellDefinition_classType()


BRepShellDefinition.faceDefinitions = property(BRepShellDefinition._get_faceDefinitions, doc="Provides access to the BRepFaceDefinitions object associated with this BRepShellDefinition.\nIt's through the returned collection that you can create new BRepFaceDefinition objects.")


BRepShellDefinition.wireDefinition = property(BRepShellDefinition._get_wireDefinition, doc="Returns the single BRepWireDefinition associated with this shell definition.")


BRepShellDefinition.cast = lambda arg: arg if isinstance(arg, BRepShellDefinition) else None

class BRepShellDefinitions(Base):
    r"""
    Provides access to the BRepShellDefinition objects associated with the object the collection was obtained from.
    It's through this object that you create new BRepShellDefinition objects.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepShellDefinitions *":
        return _fusion.BRepShellDefinitions___deref__(self)

    def __eq__(self, rhs: "BRepShellDefinitions") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepShellDefinitions___eq__(self, rhs)


    def __ne__(self, rhs: "BRepShellDefinitions") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepShellDefinitions___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.BRepShellDefinitions___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::BRepShellDefinition >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.BRepShellDefinitions___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepShellDefinitions_classType()
    __swig_destroy__ = _fusion.delete_BRepShellDefinitions

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::BRepShellDefinition >":
        r"""
        Function that returns the specified BRepShellDefinition object using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepShellDefinitions_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of B-Rep shell definition objects in the collection."""
        return _fusion.BRepShellDefinitions__get_count(self)

    def add(self) -> "adsk::core::Ptr< adsk::fusion::BRepShellDefinition >":
        r"""
        Creates a new empty BRepShellDefinition objet associated with the parent BRepLumpDefinition. 
        Returns the newly created BRepShellDefinition object.
        """
        return _fusion.BRepShellDefinitions_add(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepShellDefinitions__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepShellDefinitions__get_isValid(self)

# Register BRepShellDefinitions in _fusion:
_fusion.BRepShellDefinitions_swigregister(BRepShellDefinitions)

def BRepShellDefinitions_classType() -> "char const *":
    return _fusion.BRepShellDefinitions_classType()


BRepShellDefinitions.count = property(BRepShellDefinitions._get_count, doc="The number of B-Rep shell definition objects in the collection.")


BRepShellDefinitions.cast = lambda arg: arg if isinstance(arg, BRepShellDefinitions) else None

class BRepShells(Base):
    r"""BRepShell collection."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepShells *":
        return _fusion.BRepShells___deref__(self)

    def __eq__(self, rhs: "BRepShells") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepShells___eq__(self, rhs)


    def __ne__(self, rhs: "BRepShells") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepShells___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.BRepShells___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::BRepShell >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.BRepShells___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepShells_classType()
    __swig_destroy__ = _fusion.delete_BRepShells

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::BRepShell >":
        r"""
        Function that returns the specified shell using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepShells_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of shells in the collection."""
        return _fusion.BRepShells__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepShells__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepShells__get_isValid(self)

# Register BRepShells in _fusion:
_fusion.BRepShells_swigregister(BRepShells)

def BRepShells_classType() -> "char const *":
    return _fusion.BRepShells_classType()


BRepShells.count = property(BRepShells._get_count, doc="The number of shells in the collection.")


BRepShells.cast = lambda arg: arg if isinstance(arg, BRepShells) else None

class BRepVertex(Base):
    r"""A 0-dimentional topological entity that bounds a BRepEdge."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepVertex *":
        return _fusion.BRepVertex___deref__(self)

    def __eq__(self, rhs: "BRepVertex") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepVertex___eq__(self, rhs)


    def __ne__(self, rhs: "BRepVertex") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepVertex___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepVertex_classType()
    __swig_destroy__ = _fusion.delete_BRepVertex

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""Returns the BRepFaces that uses this vertex through BRepEdge"""
        return _fusion.BRepVertex__get_faces(self)

    def _get_edges(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdges >":
        r"""Returns the BRepEdges bounded by this vertex"""
        return _fusion.BRepVertex__get_edges(self)

    def _get_isTolerant(self) -> "bool":
        r"""
        Returns if the vertex is tolerant.
        The tolerance used is available from the tolerance property.
        """
        return _fusion.BRepVertex__get_isTolerant(self)

    def _get_tolerance(self) -> "double":
        r"""
        Returns the tolerance used by a tolerant vertex.
        This value is only useful when isTolerant is true.
        """
        return _fusion.BRepVertex__get_tolerance(self)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Returns the underlying geometry point"""
        return _fusion.BRepVertex__get_geometry(self)

    def _get_shell(self) -> "adsk::core::Ptr< adsk::fusion::BRepShell >":
        r"""Returns the parent shell."""
        return _fusion.BRepVertex__get_shell(self)

    def _get_body(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""Returns the parent body."""
        return _fusion.BRepVertex__get_body(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this
        object in an assembly. This is only valid in the case where this
        BRepVertex object is acting as a proxy in an assembly. Returns null 
        in the case where the object is not in the context of an assembly.
        but is already the native object.
        """
        return _fusion.BRepVertex__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::BRepVertex >":
        r"""
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.BRepVertex__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::BRepVertex >":
        r"""
        Returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context for the created proxy. 
        Returns the new BrepVertex proxy or null if this isn't the NativeObject.
        """
        return _fusion.BRepVertex_createForAssemblyContext(self, occurrence)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.BRepVertex__get_attributes(self)

    def _get_tempId(self) -> "int":
        r"""
        Returns the temporary ID of this vertex. This ID is only good while the document
        remains open and as long as the owning BRepBody is not modified in any way. 
        The findByTempId method of the BRepBody will return the entity in the body with the given ID.
        """
        return _fusion.BRepVertex__get_tempId(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the BRepVertex object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same vertex.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        This is only valid for vertices that exist in the design, (the isTemporary 
        property is false).
        """
        return _fusion.BRepVertex__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepVertex__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepVertex__get_isValid(self)

# Register BRepVertex in _fusion:
_fusion.BRepVertex_swigregister(BRepVertex)

def BRepVertex_classType() -> "char const *":
    return _fusion.BRepVertex_classType()


BRepVertex.faces = property(BRepVertex._get_faces, doc="Returns the BRepFaces that uses this vertex through BRepEdge")


BRepVertex.edges = property(BRepVertex._get_edges, doc="Returns the BRepEdges bounded by this vertex")


BRepVertex.isTolerant = property(BRepVertex._get_isTolerant, doc="Returns if the vertex is tolerant.\nThe tolerance used is available from the tolerance property.")


BRepVertex.tolerance = property(BRepVertex._get_tolerance, doc="Returns the tolerance used by a tolerant vertex.\nThis value is only useful when isTolerant is true.")


BRepVertex.geometry = property(BRepVertex._get_geometry, doc="Returns the underlying geometry point")


BRepVertex.shell = property(BRepVertex._get_shell, doc="Returns the parent shell.")


BRepVertex.body = property(BRepVertex._get_body, doc="Returns the parent body.")


BRepVertex.assemblyContext = property(BRepVertex._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this\nobject in an assembly. This is only valid in the case where this\nBRepVertex object is acting as a proxy in an assembly. Returns null\nin the case where the object is not in the context of an assembly.\nbut is already the native object.")


BRepVertex.nativeObject = property(BRepVertex._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


BRepVertex.attributes = property(BRepVertex._get_attributes, doc="Returns the collection of attributes associated with this face.")


BRepVertex.tempId = property(BRepVertex._get_tempId, doc="Returns the temporary ID of this vertex. This ID is only good while the document\nremains open and as long as the owning BRepBody is not modified in any way.\nThe findByTempId method of the BRepBody will return the entity in the body with the given ID.")


BRepVertex.entityToken = property(BRepVertex._get_entityToken, doc="Returns a token for the BRepVertex object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same vertex.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.\nThis is only valid for vertices that exist in the design, (the isTemporary\nproperty is false).")


BRepVertex.cast = lambda arg: arg if isinstance(arg, BRepVertex) else None

class BRepVertexDefinition(Base):
    r"""Represents the definition of a B-Rep vertex that can be used as input to create a BRepBody that includes this vertex."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepVertexDefinition *":
        return _fusion.BRepVertexDefinition___deref__(self)

    def __eq__(self, rhs: "BRepVertexDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepVertexDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "BRepVertexDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepVertexDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepVertexDefinition_classType()
    __swig_destroy__ = _fusion.delete_BRepVertexDefinition

    def _get_position(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets the position of the vertex in model space."""
        return _fusion.BRepVertexDefinition__get_position(self)

    def _set_position(self, value: "Point3D") -> "bool":
        r"""Gets and sets the position of the vertex in model space."""
        return _fusion.BRepVertexDefinition__set_position(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepVertexDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepVertexDefinition__get_isValid(self)

# Register BRepVertexDefinition in _fusion:
_fusion.BRepVertexDefinition_swigregister(BRepVertexDefinition)

def BRepVertexDefinition_classType() -> "char const *":
    return _fusion.BRepVertexDefinition_classType()


BRepVertexDefinition.position = property(BRepVertexDefinition._get_position, BRepVertexDefinition._set_position, doc="Gets and sets the position of the vertex in model space.")


BRepVertexDefinition.cast = lambda arg: arg if isinstance(arg, BRepVertexDefinition) else None

class BRepVertices(Base):
    r"""BRepVertex collection."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepVertices *":
        return _fusion.BRepVertices___deref__(self)

    def __eq__(self, rhs: "BRepVertices") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepVertices___eq__(self, rhs)


    def __ne__(self, rhs: "BRepVertices") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepVertices___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.BRepVertices___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::BRepVertex >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.BRepVertices___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepVertices_classType()
    __swig_destroy__ = _fusion.delete_BRepVertices

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::BRepVertex >":
        r"""
        Function that returns the specified vertex using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepVertices_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of vertices in the collection."""
        return _fusion.BRepVertices__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepVertices__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepVertices__get_isValid(self)

# Register BRepVertices in _fusion:
_fusion.BRepVertices_swigregister(BRepVertices)

def BRepVertices_classType() -> "char const *":
    return _fusion.BRepVertices_classType()


BRepVertices.count = property(BRepVertices._get_count, doc="The number of vertices in the collection.")


BRepVertices.cast = lambda arg: arg if isinstance(arg, BRepVertices) else None

class BRepWire(Base):
    r"""
    Represents a single B-Rep wire body. A wire body consists of one or 
    more edges and their vertices.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepWire *":
        return _fusion.BRepWire___deref__(self)

    def __eq__(self, rhs: "BRepWire") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepWire___eq__(self, rhs)


    def __ne__(self, rhs: "BRepWire") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepWire___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepWire_classType()
    __swig_destroy__ = _fusion.delete_BRepWire

    def _get_edges(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdges >":
        r"""Returns the B-Rep edges associated with this wire body."""
        return _fusion.BRepWire__get_edges(self)

    def _get_vertices(self) -> "adsk::core::Ptr< adsk::fusion::BRepVertices >":
        r"""Returns the B-Rep vertices associated with this wire body."""
        return _fusion.BRepWire__get_vertices(self)

    def _get_coEdges(self) -> "adsk::core::Ptr< adsk::fusion::BRepCoEdges >":
        r"""
        Returns the co-edges associated with this wire body. The co-edges record
        the connections between the edges in the wire body.
        """
        return _fusion.BRepWire__get_coEdges(self)

    def _get_isPlanar(self) -> "bool":
        r"""Indicates if this entities making up this wire body are planar and all lie on the same plane."""
        return _fusion.BRepWire__get_isPlanar(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""Returns the parent BRepBody object that contains this wire."""
        return _fusion.BRepWire__get_parent(self)

    def offsetPlanarWire(self, planeNormal: "Vector3D", distance: "double", cornerType: "OffsetCornerTypes") -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Method that computes the offset for a planar wire. A BRepBody containing the resulting 
        BRepWire object(s) is returned. It's possible that the offset result of a single wire 
        can result in multiple wires. 
        planeNormal : Input Vector3D object that defines the positive direction of the
        plane the plane the wire lies on. This vector must be normal to the plane and is used to 
        determine the side to offset the curves to. A positive offset distance is in the direction 
        of the cross product (wire_tangent x wire_plane_normal). A negative offset is in the 
        opposite direction. 
        distance : The offset distance in centimeters. See the description for the Normal argument to see how 
        a positive or negative value for the distance specifies the direction of the offset. 
        cornerType : Specifies how the corners are connected when offseting the curves results in gaps in the corners.
        See the documentation of the enum for a detailed description of each option. 
        Returns a new temporary BRepBody that contains one or more wires that represent the offset.
        """
        return _fusion.BRepWire_offsetPlanarWire(self, planeNormal, distance, cornerType)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this
        object in an assembly. This is only valid in the case where this
        BRepFace object is acting as a proxy in an assembly. Returns null 
        in the case where the object is not in the context of an assembly.
        but is already the native object.
        """
        return _fusion.BRepWire__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::BRepWire >":
        r"""
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.BRepWire__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::BRepWire >":
        r"""
        Returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context for the created proxy. 
        Returns the new BRepWire proxy or null if this isn't the NativeObject.
        """
        return _fusion.BRepWire_createForAssemblyContext(self, occurrence)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepWire__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepWire__get_isValid(self)

# Register BRepWire in _fusion:
_fusion.BRepWire_swigregister(BRepWire)

def BRepWire_classType() -> "char const *":
    return _fusion.BRepWire_classType()


BRepWire.edges = property(BRepWire._get_edges, doc="Returns the B-Rep edges associated with this wire body.")


BRepWire.vertices = property(BRepWire._get_vertices, doc="Returns the B-Rep vertices associated with this wire body.")


BRepWire.coEdges = property(BRepWire._get_coEdges, doc="Returns the co-edges associated with this wire body. The co-edges record\nthe connections between the edges in the wire body.")


BRepWire.isPlanar = property(BRepWire._get_isPlanar, doc="Indicates if this entities making up this wire body are planar and all lie on the same plane.")


BRepWire.parent = property(BRepWire._get_parent, doc="Returns the parent BRepBody object that contains this wire.")


BRepWire.assemblyContext = property(BRepWire._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this\nobject in an assembly. This is only valid in the case where this\nBRepFace object is acting as a proxy in an assembly. Returns null\nin the case where the object is not in the context of an assembly.\nbut is already the native object.")


BRepWire.nativeObject = property(BRepWire._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


BRepWire.cast = lambda arg: arg if isinstance(arg, BRepWire) else None

class BRepWireDefinition(Base):
    r"""Represents the definition of a B-Rep wire that can be used as input to create a BRepBody that includes this wire."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepWireDefinition *":
        return _fusion.BRepWireDefinition___deref__(self)

    def __eq__(self, rhs: "BRepWireDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepWireDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "BRepWireDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepWireDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepWireDefinition_classType()
    __swig_destroy__ = _fusion.delete_BRepWireDefinition

    def _get_wireEdgeDefinitions(self) -> "adsk::core::Ptr< adsk::fusion::BRepWireEdgeDefinitions >":
        r"""
        Provides access to the BRepWireEdgeDefinitions object associated with the parent BRepWireDefinition object.
        It's through the returned collection that you can create new BRepWireEdgeDefinitions objects.
        """
        return _fusion.BRepWireDefinition__get_wireEdgeDefinitions(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepWireDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepWireDefinition__get_isValid(self)

# Register BRepWireDefinition in _fusion:
_fusion.BRepWireDefinition_swigregister(BRepWireDefinition)

def BRepWireDefinition_classType() -> "char const *":
    return _fusion.BRepWireDefinition_classType()


BRepWireDefinition.wireEdgeDefinitions = property(BRepWireDefinition._get_wireEdgeDefinitions, doc="Provides access to the BRepWireEdgeDefinitions object associated with the parent BRepWireDefinition object.\nIt's through the returned collection that you can create new BRepWireEdgeDefinitions objects.")


BRepWireDefinition.cast = lambda arg: arg if isinstance(arg, BRepWireDefinition) else None

class BRepWireEdgeDefinition(Base):
    r"""Represents the definition of an edge in B-Rep wire that can be used as input to create a BRepBody that includes this wire edge."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepWireEdgeDefinition *":
        return _fusion.BRepWireEdgeDefinition___deref__(self)

    def __eq__(self, rhs: "BRepWireEdgeDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepWireEdgeDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "BRepWireEdgeDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepWireEdgeDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepWireEdgeDefinition_classType()
    __swig_destroy__ = _fusion.delete_BRepWireEdgeDefinition

    def _get_associativeID(self) -> "int":
        r"""
        Gets and sets the associate ID of this B-Rep wire definition. This ID will be copied to the corresponding 
        edge when the BRepBodyDefinition is used to create a BrepBody. It is used by Fusion360 as 
        the identifier for the edge and is used for tracking this geometry for parametric recomputes.
        """
        return _fusion.BRepWireEdgeDefinition__get_associativeID(self)

    def _set_associativeID(self, value: "int") -> "bool":
        r"""
        Gets and sets the associate ID of this B-Rep wire definition. This ID will be copied to the corresponding 
        edge when the BRepBodyDefinition is used to create a BrepBody. It is used by Fusion360 as 
        the identifier for the edge and is used for tracking this geometry for parametric recomputes.
        """
        return _fusion.BRepWireEdgeDefinition__set_associativeID(self, value)

    def _get_startVertex(self) -> "adsk::core::Ptr< adsk::fusion::BRepVertexDefinition >":
        r"""Gets and sets the start vertex of the wire edge definition."""
        return _fusion.BRepWireEdgeDefinition__get_startVertex(self)

    def _set_startVertex(self, value: "BRepVertexDefinition") -> "bool":
        r"""Gets and sets the start vertex of the wire edge definition."""
        return _fusion.BRepWireEdgeDefinition__set_startVertex(self, value)

    def _get_endVertex(self) -> "adsk::core::Ptr< adsk::fusion::BRepVertexDefinition >":
        r"""Gets and sets the end vertex of the wire edge definition."""
        return _fusion.BRepWireEdgeDefinition__get_endVertex(self)

    def _set_endVertex(self, value: "BRepVertexDefinition") -> "bool":
        r"""Gets and sets the end vertex of the wire edge definition."""
        return _fusion.BRepWireEdgeDefinition__set_endVertex(self, value)

    def _get_modelSpaceCurve(self) -> "adsk::core::Ptr< adsk::core::Curve3D >":
        r"""
        Gets and sets the Curve3D object that defines the shape of the edge using 3D geometry in model space. 
        Valid objects are an Arc3D, NurbsCurve3D, Circle3D, Ellipse3D, EllipticalArc3D, or Line3D.
        """
        return _fusion.BRepWireEdgeDefinition__get_modelSpaceCurve(self)

    def _set_modelSpaceCurve(self, value: "Curve3D") -> "bool":
        r"""
        Gets and sets the Curve3D object that defines the shape of the edge using 3D geometry in model space. 
        Valid objects are an Arc3D, NurbsCurve3D, Circle3D, Ellipse3D, EllipticalArc3D, or Line3D.
        """
        return _fusion.BRepWireEdgeDefinition__set_modelSpaceCurve(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepWireEdgeDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepWireEdgeDefinition__get_isValid(self)

# Register BRepWireEdgeDefinition in _fusion:
_fusion.BRepWireEdgeDefinition_swigregister(BRepWireEdgeDefinition)

def BRepWireEdgeDefinition_classType() -> "char const *":
    return _fusion.BRepWireEdgeDefinition_classType()


BRepWireEdgeDefinition.associativeID = property(BRepWireEdgeDefinition._get_associativeID, BRepWireEdgeDefinition._set_associativeID, doc="Gets and sets the associate ID of this B-Rep wire definition. This ID will be copied to the corresponding\nedge when the BRepBodyDefinition is used to create a BrepBody. It is used by Fusion360 as\nthe identifier for the edge and is used for tracking this geometry for parametric recomputes.")


BRepWireEdgeDefinition.startVertex = property(BRepWireEdgeDefinition._get_startVertex, BRepWireEdgeDefinition._set_startVertex, doc="Gets and sets the start vertex of the wire edge definition.")


BRepWireEdgeDefinition.endVertex = property(BRepWireEdgeDefinition._get_endVertex, BRepWireEdgeDefinition._set_endVertex, doc="Gets and sets the end vertex of the wire edge definition.")


BRepWireEdgeDefinition.modelSpaceCurve = property(BRepWireEdgeDefinition._get_modelSpaceCurve, BRepWireEdgeDefinition._set_modelSpaceCurve, doc="Gets and sets the Curve3D object that defines the shape of the edge using 3D geometry in model space.\nValid objects are an Arc3D, NurbsCurve3D, Circle3D, Ellipse3D, EllipticalArc3D, or Line3D.")


BRepWireEdgeDefinition.cast = lambda arg: arg if isinstance(arg, BRepWireEdgeDefinition) else None

class BRepWireEdgeDefinitions(Base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepWireEdgeDefinitions *":
        return _fusion.BRepWireEdgeDefinitions___deref__(self)

    def __eq__(self, rhs: "BRepWireEdgeDefinitions") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepWireEdgeDefinitions___eq__(self, rhs)


    def __ne__(self, rhs: "BRepWireEdgeDefinitions") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepWireEdgeDefinitions___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.BRepWireEdgeDefinitions___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::BRepWireEdgeDefinition >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.BRepWireEdgeDefinitions___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepWireEdgeDefinitions_classType()
    __swig_destroy__ = _fusion.delete_BRepWireEdgeDefinitions

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::BRepWireEdgeDefinition >":
        r"""
        Function that returns the specified BRepWireEdgeDefinition object using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepWireEdgeDefinitions_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of B-Rep wire edge definition objects in the collection."""
        return _fusion.BRepWireEdgeDefinitions__get_count(self)

    def add(self, startVertex: "BRepVertexDefinition", endVertex: "BRepVertexDefinition", modelSpaceCurve: "Curve3D") -> "adsk::core::Ptr< adsk::fusion::BRepWireEdgeDefinition >":
        r"""
        Creates a new BRepWireEdgeDefinition object associated with the parent BRepWireDefinition object. 
        startVertex : Vertex definition that defines the start of the edge. For a closed curve, like a circle, you still
        need to provide a vertex on the curve but should use the same BRepVertexDefinition for both the start and end verices. 
        endVertex : Vertex definition that defines the end of the edge. For a closed curve, like a circle, this should be the
        same vertex as used for the start vertex. 
        modelSpaceCurve : A Curve3D object that defines the shape of the edge using 3D geometry in model space. 
        Valid input is an Arc3D, NurbsCurve3D, Circle3D, Ellipse3D, EllipticalArc3D, or Line3D. 
        Returns the newly created BRepWireEdgeDefinition object or null in the case of failure.
        """
        return _fusion.BRepWireEdgeDefinitions_add(self, startVertex, endVertex, modelSpaceCurve)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepWireEdgeDefinitions__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepWireEdgeDefinitions__get_isValid(self)

# Register BRepWireEdgeDefinitions in _fusion:
_fusion.BRepWireEdgeDefinitions_swigregister(BRepWireEdgeDefinitions)

def BRepWireEdgeDefinitions_classType() -> "char const *":
    return _fusion.BRepWireEdgeDefinitions_classType()


BRepWireEdgeDefinitions.count = property(BRepWireEdgeDefinitions._get_count, doc="The number of B-Rep wire edge definition objects in the collection.")


BRepWireEdgeDefinitions.cast = lambda arg: arg if isinstance(arg, BRepWireEdgeDefinitions) else None

class BRepWires(Base):
    r"""Provides access to B-Rep wire bodies."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BRepWires *":
        return _fusion.BRepWires___deref__(self)

    def __eq__(self, rhs: "BRepWires") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BRepWires___eq__(self, rhs)


    def __ne__(self, rhs: "BRepWires") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BRepWires___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.BRepWires___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::BRepWire >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.BRepWires___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BRepWires_classType()
    __swig_destroy__ = _fusion.delete_BRepWires

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::BRepWire >":
        r"""
        Function that returns the specified wire using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepWires_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of B-Rep wire bodies in the collection."""
        return _fusion.BRepWires__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BRepWires__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BRepWires__get_isValid(self)

# Register BRepWires in _fusion:
_fusion.BRepWires_swigregister(BRepWires)

def BRepWires_classType() -> "char const *":
    return _fusion.BRepWires_classType()


BRepWires.count = property(BRepWires._get_count, doc="The number of B-Rep wire bodies in the collection.")


BRepWires.cast = lambda arg: arg if isinstance(arg, BRepWires) else None

class ChamferEdgeSet(Base):
    r"""The base class for the classes that define the different types of chamfer edge sets."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ChamferEdgeSet *":
        return _fusion.ChamferEdgeSet___deref__(self)

    def __eq__(self, rhs: "ChamferEdgeSet") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ChamferEdgeSet___eq__(self, rhs)


    def __ne__(self, rhs: "ChamferEdgeSet") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ChamferEdgeSet___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ChamferEdgeSet_classType()
    __swig_destroy__ = _fusion.delete_ChamferEdgeSet

    def deleteMe(self) -> "bool":
        r"""
        Deletes the chamfer edge set from the chamfer.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        Returns true if the operation was successful.
        """
        return _fusion.ChamferEdgeSet_deleteMe(self)

    def _get_isTangentChain(self) -> "bool":
        r"""Gets and sets the Tangent chain for chamfer. This enables tangent chain option for chamfer."""
        return _fusion.ChamferEdgeSet__get_isTangentChain(self)

    def _set_isTangentChain(self, value: "bool") -> "bool":
        r"""Gets and sets the Tangent chain for chamfer. This enables tangent chain option for chamfer."""
        return _fusion.ChamferEdgeSet__set_isTangentChain(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.ChamferEdgeSet__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ChamferEdgeSet__get_isValid(self)

# Register ChamferEdgeSet in _fusion:
_fusion.ChamferEdgeSet_swigregister(ChamferEdgeSet)

def ChamferEdgeSet_classType() -> "char const *":
    return _fusion.ChamferEdgeSet_classType()


ChamferEdgeSet.isTangentChain = property(ChamferEdgeSet._get_isTangentChain, ChamferEdgeSet._set_isTangentChain, doc="Gets and sets the Tangent chain for chamfer. This enables tangent chain option for chamfer.")


ChamferEdgeSet.cast = lambda arg: arg if isinstance(arg, ChamferEdgeSet) else None

class ChamferEdgeSets(Base):
    r"""Collection that provides access to all of the existing chamfer edge sets associated with a chamfer feature."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ChamferEdgeSets *":
        return _fusion.ChamferEdgeSets___deref__(self)

    def __eq__(self, rhs: "ChamferEdgeSets") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ChamferEdgeSets___eq__(self, rhs)


    def __ne__(self, rhs: "ChamferEdgeSets") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ChamferEdgeSets___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.ChamferEdgeSets___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::ChamferEdgeSet >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.ChamferEdgeSets___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ChamferEdgeSets_classType()
    __swig_destroy__ = _fusion.delete_ChamferEdgeSets

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::ChamferEdgeSet >":
        r"""
        Function that returns the specified chamfer edge set using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ChamferEdgeSets_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of chamfer edge sets in the collection."""
        return _fusion.ChamferEdgeSets__get_count(self)

    def addEqualDistanceChamferEdgeSet(self, edges: "ObjectCollection", distance: "ValueInput", isTangentChain: "bool") -> "bool":
        r"""
        Adds a set of edges an equal distance offset to this chamfer feature.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        edges : An ObjectCollection containing the edges to be chamfered. Edges can be defined by passing in BrepEdge,
        BRepFace, or Feature objects. If BRepFace or Feature objects are passed in all of the edges associated
        with those objects will be chamfered. If BRepEdge objects are provided and the isTangentChain argument is true
        additional edges may also get chamfered if they are tangentially connected to any of the input edges. 
        distance : A ValueInput object that defines the distance offset of the chamfer. If the ValueInput uses
        a real then it is interpreted as centimeters. If it is a string then the units
        can be defined as part of the string (i.e. '2 in') or if no units are specified
        it is interpreted using the current default units for length. 
        isTangentChain : A boolean value for setting whether or not edges that are tangentially connected to 
        the input edges (if any) will also be chamfered. 
        Returns true if the set of edges was successfully added to the ChamferFeatureInput.
        """
        return _fusion.ChamferEdgeSets_addEqualDistanceChamferEdgeSet(self, edges, distance, isTangentChain)

    def addTwoDistancesChamferEdgeSet(self, edges: "ObjectCollection", distanceOne: "ValueInput", distanceTwo: "ValueInput", isFlipped: "bool", isTangentChain: "bool") -> "bool":
        r"""
        Adds a set of edges an equal distance offset to this chamfer feature.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        edges : An ObjectCollection containing the edges to be chamfered. Edges can be defined by passing in BrepEdge,
        BRepFace, or Feature objects. If BRepFace or Feature objects are passed in all of the edges associated
        with those objects will be chamfered. If BRepEdge objects are provided and the isTangentChain argument is true
        additional edges may also get chamfered if they are tangentially connected to any of the input edges. 
        distanceOne : A ValueInput object that defines the first distance offset of the chamfer. If the ValueInput uses
        a real then it is interpreted as centimeters. If it is a string then the units
        can be defined as part of the string (i.e. '2 in') or if no units are specified
        it is interpreted using the current default units for length. 
        distanceTwo : A ValueInput object that defines the second distance offset of the chamfer. If the ValueInput uses
        a real then it is interpreted as centimeters. If it is a string then the units
        can be defined as part of the string (i.e. '2 in') or if no units are specified
        it is interpreted using the current default units for length. 
        isFlipped : Swaps the directions for distance one and two. 
        isTangentChain : A boolean value for setting whether or not edges that are tangentially connected to 
        the input edges (if any) will also be chamfered. 
        Returns true if the set of edges was successfully added to the ChamferFeatureInput.
        """
        return _fusion.ChamferEdgeSets_addTwoDistancesChamferEdgeSet(self, edges, distanceOne, distanceTwo, isFlipped, isTangentChain)

    def addDistanceAndAngleChamferEdgeSet(self, edges: "ObjectCollection", distance: "ValueInput", angle: "ValueInput", isFlipped: "bool", isTangentChain: "bool") -> "bool":
        r"""
        Adds a set of edges an equal distance offset to this chamfer feature.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        edges : An ObjectCollection containing the edges to be chamfered. Edges can be defined by passing in BrepEdge,
        BRepFace, or Feature objects. If BRepFace or Feature objects are passed in all of the edges associated
        with those objects will be chamfered. If BRepEdge objects are provided and the isTangentChain argument is true
        additional edges may also get chamfered if they are tangentially connected to any of the input edges. 
        distance : A ValueInput object that defines the distance offset of the chamfer. If the ValueInput uses
        a real then it is interpreted as centimeters. If it is a string then the units
        can be defined as part of the string (i.e. '2 in') or if no units are specified
        it is interpreted using the current default units for length. 
        angle : A ValueInput object that defines the angle of the chamfer. If the ValueInput uses
        a real then it is interpreted as radians. If it is a string then the units
        can be defined as part of the string (i.e. '2 rad') or if no units are specified
        it is interpreted as degrees. 
        isFlipped : Swaps the directions for distance one and two. 
        isTangentChain : A boolean value for setting whether or not edges that are tangentially connected to 
        the input edges (if any) will also be chamfered. 
        Returns true if the set of edges was successfully added to the ChamferFeatureInput.
        """
        return _fusion.ChamferEdgeSets_addDistanceAndAngleChamferEdgeSet(self, edges, distance, angle, isFlipped, isTangentChain)

    def _get_objectType(self) -> "char const *":
        return _fusion.ChamferEdgeSets__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ChamferEdgeSets__get_isValid(self)

# Register ChamferEdgeSets in _fusion:
_fusion.ChamferEdgeSets_swigregister(ChamferEdgeSets)

def ChamferEdgeSets_classType() -> "char const *":
    return _fusion.ChamferEdgeSets_classType()


ChamferEdgeSets.count = property(ChamferEdgeSets._get_count, doc="The number of chamfer edge sets in the collection.")


ChamferEdgeSets.cast = lambda arg: arg if isinstance(arg, ChamferEdgeSets) else None

class ChamferFeatureInput(Base):
    r"""
    This class defines the methods and properties that pertain to the definition of a chamfer
    feature.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ChamferFeatureInput *":
        return _fusion.ChamferFeatureInput___deref__(self)

    def __eq__(self, rhs: "ChamferFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ChamferFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "ChamferFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ChamferFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ChamferFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_ChamferFeatureInput

    def _get_edges(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the collection of edges that will be chamfered.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ChamferFeatureInput__get_edges(self)

    def _set_edges(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the collection of edges that will be chamfered.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ChamferFeatureInput__set_edges(self, value)

    def setToEqualDistance(self, distance: "ValueInput") -> "bool":
        r"""
        Adds a set of edges to this input. 
        distance : A ValueInput object that defines the size of the chamfer. If the ValueInput uses
        a real then it is interpreted as centimeters. If it is a string then the units
        can be defined as part of the string (i.e. '2 in'). If no units are specified
        it is interpreted using the current default units for length. 
        Returns true if the set of edges was successfully added to the ChamferFeatureInput.
        """
        return _fusion.ChamferFeatureInput_setToEqualDistance(self, distance)

    def setToTwoDistances(self, distanceOne: "ValueInput", distanceTwo: "ValueInput") -> "bool":
        r"""
        Adds a set of edges to this input. 
        distanceOne : A ValueInput object that defines the distanceOne of the chamfer. This distance
        is along the face which is on the left of the selected edge.
        If the ValueInput uses a real then it is interpreted as centimeters.
        If it is a string then the units can be defined as part of the string (i.e. '2 in').
        If no units are specified it is interpreted using the current default units for length. 
        distanceTwo : A ValueInput object that defines the distanceTwo of the chamfer. This distance
        is along the face which is on the right of the selected edge.
        If the ValueInput uses a real then it is interpreted as centimeters.
        If it is a string then the units can be defined as part of the string (i.e. '2 in').
        If no units are specified it is interpreted using the current default units for length. 
        Returns true if successful.
        """
        return _fusion.ChamferFeatureInput_setToTwoDistances(self, distanceOne, distanceTwo)

    def setToDistanceAndAngle(self, distance: "ValueInput", angle: "ValueInput") -> "bool":
        r"""
        Adds a set of edges to this input. 
        distance : A ValueInput object that defines the distance of the chamfer. This distance
        is along the face which is on the right of the selected edge.
        If the ValueInput uses a real then it is interpreted as centimeters.
        If it is a string then the units can be defined as part of the string (i.e. '2 in').
        If no units are specified it is interpreted using the current default units for length. 
        angle : A valueInput object that defines the angle. The direction will be towards to the face
        which is on the left of the selected edge. This can be a string or a value.
        If it's a string it is interpreted using the current document units and can include
        equations. For example all of the following are valid as long as they result in
        angle units; '45', '45 deg', 'a1 / 2'. If a value is input it is interpreted
        as radians. It cannot be negative. 
        Returns true if successful.
        """
        return _fusion.ChamferFeatureInput_setToDistanceAndAngle(self, distance, angle)

    def _get_isTangentChain(self) -> "bool":
        r"""
        Gets and sets if any edges that are tangentially connected to any of chamfered
        edges will also be included in the chamfer.
        """
        return _fusion.ChamferFeatureInput__get_isTangentChain(self)

    def _set_isTangentChain(self, value: "bool") -> "bool":
        r"""
        Gets and sets if any edges that are tangentially connected to any of chamfered
        edges will also be included in the chamfer.
        """
        return _fusion.ChamferFeatureInput__set_isTangentChain(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ChamferFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ChamferFeatureInput__set_targetBaseFeature(self, value)

    def _get_cornerType(self) -> "adsk::fusion::ChamferCornerTypes":
        r"""Gets and sets the type of corner to be modeled when multiple edges connect at a vertex."""
        return _fusion.ChamferFeatureInput__get_cornerType(self)

    def _set_cornerType(self, value: "ChamferCornerTypes") -> "bool":
        r"""Gets and sets the type of corner to be modeled when multiple edges connect at a vertex."""
        return _fusion.ChamferFeatureInput__set_cornerType(self, value)

    def _get_chamferEdgeSets(self) -> "adsk::core::Ptr< adsk::fusion::ChamferEdgeSets >":
        r"""Returns the collection of edge sets for this chamfer feature input."""
        return _fusion.ChamferFeatureInput__get_chamferEdgeSets(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ChamferFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ChamferFeatureInput__get_isValid(self)

# Register ChamferFeatureInput in _fusion:
_fusion.ChamferFeatureInput_swigregister(ChamferFeatureInput)

def ChamferFeatureInput_classType() -> "char const *":
    return _fusion.ChamferFeatureInput_classType()


ChamferFeatureInput.edges = property(ChamferFeatureInput._get_edges, ChamferFeatureInput._set_edges, doc="Gets and sets the collection of edges that will be chamfered.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ChamferFeatureInput.isTangentChain = property(ChamferFeatureInput._get_isTangentChain, ChamferFeatureInput._set_isTangentChain, doc="Gets and sets if any edges that are tangentially connected to any of chamfered\nedges will also be included in the chamfer.")


ChamferFeatureInput.targetBaseFeature = property(ChamferFeatureInput._get_targetBaseFeature, ChamferFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


ChamferFeatureInput.cornerType = property(ChamferFeatureInput._get_cornerType, ChamferFeatureInput._set_cornerType, doc="Gets and sets the type of corner to be modeled when multiple edges connect at a vertex.")


ChamferFeatureInput.chamferEdgeSets = property(ChamferFeatureInput._get_chamferEdgeSets, doc="Returns the collection of edge sets for this chamfer feature input.")


ChamferFeatureInput.cast = lambda arg: arg if isinstance(arg, ChamferFeatureInput) else None

class ChamferFeatures(Base):
    r"""
    Collection that provides access to all of the existing chamfer features in a component
    and supports the ability to create new chamfer features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ChamferFeatures *":
        return _fusion.ChamferFeatures___deref__(self)

    def __eq__(self, rhs: "ChamferFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ChamferFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "ChamferFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ChamferFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.ChamferFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::ChamferFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.ChamferFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ChamferFeatures_classType()
    __swig_destroy__ = _fusion.delete_ChamferFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::ChamferFeature >":
        r"""
        Function that returns the specified chamfer feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ChamferFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of chamfer features in the collection."""
        return _fusion.ChamferFeatures__get_count(self)

    def createInput(self, edges: "ObjectCollection", isTangentChain: "bool") -> "adsk::core::Ptr< adsk::fusion::ChamferFeatureInput >":
        r"""
        Creates a ChamferFeatureInput object. Use properties and methods on this object
        to define the chamfer you want to create and then use the Add method, passing in 
        the ChamferFeatureInput object. 
        edges : The collection of edges that will be chamfered. 
        isTangentChain : Boolean indicating if all edges that are tangentially connected to any of the input edges should be included in the chamfer or not. 
        Returns the newly created ChamferFeatureInput object or null if the creation failed.
        """
        return _fusion.ChamferFeatures_createInput(self, edges, isTangentChain)

    def add(self, input: "ChamferFeatureInput") -> "adsk::core::Ptr< adsk::fusion::ChamferFeature >":
        r"""
        Creates a new chamfer feature. 
        input : A ChamferFeatureInput object that defines the desired chamfer. Use the createInput 
        method to create a new ChamferFeatureInput object and then use methods on it 
        (the ChamferFeatureInput object) to define the chamfer. 
        Returns the newly created ChamferFeature object or null if the creation failed.
        """
        return _fusion.ChamferFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::ChamferFeature >":
        r"""
        Function that returns the specified chamfer feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.ChamferFeatures_itemByName(self, name)

    def createInput2(self) -> "adsk::core::Ptr< adsk::fusion::ChamferFeatureInput >":
        r"""
        Creates a ChamferFeatureInput object. Use properties and methods on this object
        to define the chamfer you want to create and then use the Add method, passing in 
        the ChamferFeatureInput object. 
        Returns the newly created ChamferFeatureInput object or null if the creation failed.
        """
        return _fusion.ChamferFeatures_createInput2(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ChamferFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ChamferFeatures__get_isValid(self)

# Register ChamferFeatures in _fusion:
_fusion.ChamferFeatures_swigregister(ChamferFeatures)

def ChamferFeatures_classType() -> "char const *":
    return _fusion.ChamferFeatures_classType()


ChamferFeatures.count = property(ChamferFeatures._get_count, doc="The number of chamfer features in the collection.")


ChamferFeatures.cast = lambda arg: arg if isinstance(arg, ChamferFeatures) else None

class ChamferTypeDefinition(Base):
    r"""The base class for the classes that define how a chamfer can be defined."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ChamferTypeDefinition *":
        return _fusion.ChamferTypeDefinition___deref__(self)

    def __eq__(self, rhs: "ChamferTypeDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ChamferTypeDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ChamferTypeDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ChamferTypeDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ChamferTypeDefinition_classType()
    __swig_destroy__ = _fusion.delete_ChamferTypeDefinition

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::ChamferFeature >":
        r"""Returns the feature that owns this chamfer type definition"""
        return _fusion.ChamferTypeDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ChamferTypeDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ChamferTypeDefinition__get_isValid(self)

# Register ChamferTypeDefinition in _fusion:
_fusion.ChamferTypeDefinition_swigregister(ChamferTypeDefinition)

def ChamferTypeDefinition_classType() -> "char const *":
    return _fusion.ChamferTypeDefinition_classType()


ChamferTypeDefinition.parentFeature = property(ChamferTypeDefinition._get_parentFeature, doc="Returns the feature that owns this chamfer type definition")


ChamferTypeDefinition.cast = lambda arg: arg if isinstance(arg, ChamferTypeDefinition) else None

class CircularPatternFeatureInput(Base):
    r"""
    This class defines the methods and properties that pertain to the definition of a circular pattern 
    feature.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CircularPatternFeatureInput *":
        return _fusion.CircularPatternFeatureInput___deref__(self)

    def __eq__(self, rhs: "CircularPatternFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CircularPatternFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "CircularPatternFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CircularPatternFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CircularPatternFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_CircularPatternFeatureInput

    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        """
        return _fusion.CircularPatternFeatureInput__get_inputEntities(self)

    def _set_inputEntities(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        """
        return _fusion.CircularPatternFeatureInput__set_inputEntities(self, value)

    def _get_axis(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the axis of circular pattern. This can be a sketch line, linear edge,
        construction axis, an edge/sketch curve that defines an axis (circle, etc.) or a face that defines an axis (cylinder, cone, torus, etc.).
        """
        return _fusion.CircularPatternFeatureInput__get_axis(self)

    def _set_axis(self, value: "Base") -> "bool":
        r"""
        Gets and sets the axis of circular pattern. This can be a sketch line, linear edge,
        construction axis, an edge/sketch curve that defines an axis (circle, etc.) or a face that defines an axis (cylinder, cone, torus, etc.).
        """
        return _fusion.CircularPatternFeatureInput__set_axis(self, value)

    def _get_quantity(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets and sets quantity of the elements."""
        return _fusion.CircularPatternFeatureInput__get_quantity(self)

    def _set_quantity(self, value: "ValueInput") -> "bool":
        r"""Gets and sets quantity of the elements."""
        return _fusion.CircularPatternFeatureInput__set_quantity(self, value)

    def _get_totalAngle(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Gets and sets total angle. A negative angle can be used to reverse the direction.
        An angle of 360 degrees or 2 pi radians will create a full circular pattern.
        """
        return _fusion.CircularPatternFeatureInput__get_totalAngle(self)

    def _set_totalAngle(self, value: "ValueInput") -> "bool":
        r"""
        Gets and sets total angle. A negative angle can be used to reverse the direction.
        An angle of 360 degrees or 2 pi radians will create a full circular pattern.
        """
        return _fusion.CircularPatternFeatureInput__set_totalAngle(self, value)

    def _get_isSymmetric(self) -> "bool":
        r"""Gets and sets if the angle extent is in one direction or symmetric."""
        return _fusion.CircularPatternFeatureInput__get_isSymmetric(self)

    def _set_isSymmetric(self, value: "bool") -> "bool":
        r"""Gets and sets if the angle extent is in one direction or symmetric."""
        return _fusion.CircularPatternFeatureInput__set_isSymmetric(self, value)

    def _get_patternComputeOption(self) -> "adsk::fusion::PatternComputeOptions":
        r"""
        Gets and sets the compute option when patterning features. The default value for this is AdjustPatternCompute.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        """
        return _fusion.CircularPatternFeatureInput__get_patternComputeOption(self)

    def _set_patternComputeOption(self, value: "PatternComputeOptions") -> "bool":
        r"""
        Gets and sets the compute option when patterning features. The default value for this is AdjustPatternCompute.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        """
        return _fusion.CircularPatternFeatureInput__set_patternComputeOption(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.CircularPatternFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.CircularPatternFeatureInput__set_targetBaseFeature(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.CircularPatternFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CircularPatternFeatureInput__get_isValid(self)

# Register CircularPatternFeatureInput in _fusion:
_fusion.CircularPatternFeatureInput_swigregister(CircularPatternFeatureInput)

def CircularPatternFeatureInput_classType() -> "char const *":
    return _fusion.CircularPatternFeatureInput_classType()


CircularPatternFeatureInput.inputEntities = property(CircularPatternFeatureInput._get_inputEntities, CircularPatternFeatureInput._set_inputEntities, doc="Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.\nAll of the entities must be of a single type. For example, it can't contain features and occurrences\nbut only features or occurrences.")


CircularPatternFeatureInput.axis = property(CircularPatternFeatureInput._get_axis, CircularPatternFeatureInput._set_axis, doc="Gets and sets the axis of circular pattern. This can be a sketch line, linear edge,\nconstruction axis, an edge/sketch curve that defines an axis (circle, etc.) or a face that defines an axis (cylinder, cone, torus, etc.).")


CircularPatternFeatureInput.quantity = property(CircularPatternFeatureInput._get_quantity, CircularPatternFeatureInput._set_quantity, doc="Gets and sets quantity of the elements.")


CircularPatternFeatureInput.totalAngle = property(CircularPatternFeatureInput._get_totalAngle, CircularPatternFeatureInput._set_totalAngle, doc="Gets and sets total angle. A negative angle can be used to reverse the direction.\nAn angle of 360 degrees or 2 pi radians will create a full circular pattern.")


CircularPatternFeatureInput.isSymmetric = property(CircularPatternFeatureInput._get_isSymmetric, CircularPatternFeatureInput._set_isSymmetric, doc="Gets and sets if the angle extent is in one direction or symmetric.")


CircularPatternFeatureInput.patternComputeOption = property(CircularPatternFeatureInput._get_patternComputeOption, CircularPatternFeatureInput._set_patternComputeOption, doc="Gets and sets the compute option when patterning features. The default value for this is AdjustPatternCompute.\nThis property only applies when patterning features and is ignored in the direct modeling environment.")


CircularPatternFeatureInput.targetBaseFeature = property(CircularPatternFeatureInput._get_targetBaseFeature, CircularPatternFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


CircularPatternFeatureInput.cast = lambda arg: arg if isinstance(arg, CircularPatternFeatureInput) else None

class CircularPatternFeatures(Base):
    r"""
    Collection that provides access to all of the existing circular pattern features in a component
    and supports the ability to create new circular pattern features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CircularPatternFeatures *":
        return _fusion.CircularPatternFeatures___deref__(self)

    def __eq__(self, rhs: "CircularPatternFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CircularPatternFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "CircularPatternFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CircularPatternFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.CircularPatternFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::CircularPatternFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.CircularPatternFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CircularPatternFeatures_classType()
    __swig_destroy__ = _fusion.delete_CircularPatternFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::CircularPatternFeature >":
        r"""
        Function that returns the specified circular pattern feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.CircularPatternFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of circular pattern features in the collection."""
        return _fusion.CircularPatternFeatures__get_count(self)

    def createInput(self, inputEntities: "ObjectCollection", axis: "Base") -> "adsk::core::Ptr< adsk::fusion::CircularPatternFeatureInput >":
        r"""
        Creates a CircularPatternFeatureInput object. Use properties and methods on this object
        to define the circular pattern you want to create and then use the Add method, passing in 
        the CircularPatternFeatureInput object. 
        inputEntities : The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences. 
        axis : Input linear entity or the entity has axis that defines axis of circular pattern. This can be a sketch line, linear edge,
        construction axis, an edge/sketch curve that defines an axis (circle, etc.) or a face that defines an axis (cylinder, cone, torus, etc.). 
        Returns the newly created CircularPatternFeatureInput object or null if the creation failed.
        """
        return _fusion.CircularPatternFeatures_createInput(self, inputEntities, axis)

    def add(self, input: "CircularPatternFeatureInput") -> "adsk::core::Ptr< adsk::fusion::CircularPatternFeature >":
        r"""
        Creates a new circular pattern feature. 
        input : A CircularPatternFeatureInput object that defines the desired circular pattern. Use the createInput 
        method to create a new CircularPatternFeatureInput object and then use methods on it 
        (the CircularPatternFeatureInput object) to define the circular pattern. 
        Returns the newly created CircularPatternFeature object or null if the creation failed.
        """
        return _fusion.CircularPatternFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::CircularPatternFeature >":
        r"""
        Function that returns the specified circular pattern feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.CircularPatternFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.CircularPatternFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CircularPatternFeatures__get_isValid(self)

# Register CircularPatternFeatures in _fusion:
_fusion.CircularPatternFeatures_swigregister(CircularPatternFeatures)

def CircularPatternFeatures_classType() -> "char const *":
    return _fusion.CircularPatternFeatures_classType()


CircularPatternFeatures.count = property(CircularPatternFeatures._get_count, doc="The number of circular pattern features in the collection.")


CircularPatternFeatures.cast = lambda arg: arg if isinstance(arg, CircularPatternFeatures) else None

class CoilFeatureInput(Base):
    r"""This class defines the methods and properties that pertain to the definition of a coil feature."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CoilFeatureInput *":
        return _fusion.CoilFeatureInput___deref__(self)

    def __eq__(self, rhs: "CoilFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CoilFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "CoilFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CoilFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CoilFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_CoilFeatureInput

    def setToRevolutionAndHeight(self, revolutions: "ValueInput", height: "ValueInput", angle: "ValueInput") -> "bool":
        r"""
        Sets the coil type to RevolutionsAndHeightCoilType. 
        revolutions : A ValueInput object that defines the number of revolutions. 
        height : A ValueInput object that defines the height. 
        angle : A ValueInput object that defines angle. 
        Returns true if successful.
        """
        return _fusion.CoilFeatureInput_setToRevolutionAndHeight(self, revolutions, height, angle)

    def setToRevolutionsAndPitch(self, revolutions: "ValueInput", pitch: "ValueInput", angle: "ValueInput") -> "bool":
        r"""
        Sets the coil type to RevolutionsAndPitchCoilType. 
        revolutions : A ValueInput object that defines the number of revolutions. 
        pitch : A ValueInput object that defines the pitch. 
        angle : A ValueInput object that defines angle. 
        Returns true if successful.
        """
        return _fusion.CoilFeatureInput_setToRevolutionsAndPitch(self, revolutions, pitch, angle)

    def setToHeightAndPitchCoil(self, height: "ValueInput", pitch: "ValueInput", angle: "ValueInput") -> "bool":
        r"""
        Sets the coil type to HeightAndPitchCoilType. 
        height : A ValueInput object that defines the height. 
        pitch : A ValueInput object that defines the pitch. 
        angle : A ValueInput object that defines angle. 
        Returns true if successful.
        """
        return _fusion.CoilFeatureInput_setToHeightAndPitchCoil(self, height, pitch, angle)

    def setToSpiral(self, revolutions: "ValueInput", pitch: "ValueInput") -> "bool":
        r"""
        Sets the coil type to SpiralCoilType. 
        revolutions : A ValueInput object that defines the number of revolutions. 
        pitch : A ValueInput object that defines the pitch. 
        Returns true if successful.
        """
        return _fusion.CoilFeatureInput_setToSpiral(self, revolutions, pitch)

    def _get_isSolid(self) -> "bool":
        r"""
        Specifies if the coil should be created as a solid or surface. This is
        initialized to true so a solid will be created if it's not changed.
        It only can be set to false in non-parametric modeling.
        """
        return _fusion.CoilFeatureInput__get_isSolid(self)

    def _set_isSolid(self, value: "bool") -> "bool":
        r"""
        Specifies if the coil should be created as a solid or surface. This is
        initialized to true so a solid will be created if it's not changed.
        It only can be set to false in non-parametric modeling.
        """
        return _fusion.CoilFeatureInput__set_isSolid(self, value)

    def _get_revolutions(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets the revolutions number. Returns null in the case where the coilType property returns HeightAndPitchCoilType."""
        return _fusion.CoilFeatureInput__get_revolutions(self)

    def _get_height(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets the height. Returns null in the case where the coilType property returns RevolutionsAndPitchCoilType."""
        return _fusion.CoilFeatureInput__get_height(self)

    def _get_pitch(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets the pitch. Returns null in the case where the coilType property returns RevolutionsAndHeightCoilType or SpiralCoilType."""
        return _fusion.CoilFeatureInput__get_pitch(self)

    def _get_angle(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets the angle. Returns null in the case where the coilType property returns SpiralCoilType."""
        return _fusion.CoilFeatureInput__get_angle(self)

    def _get_coilType(self) -> "adsk::fusion::CoilFeatureTypes":
        r"""Gets the type of the coil."""
        return _fusion.CoilFeatureInput__get_coilType(self)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations":
        r"""Gets and sets the type of operation performed by the coil."""
        return _fusion.CoilFeatureInput__get_operation(self)

    def _set_operation(self, value: "FeatureOperations") -> "bool":
        r"""Gets and sets the type of operation performed by the coil."""
        return _fusion.CoilFeatureInput__set_operation(self, value)

    def _get_basePlane(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets and sets the base plane."""
        return _fusion.CoilFeatureInput__get_basePlane(self)

    def _set_basePlane(self, value: "Base") -> "bool":
        r"""Gets and sets the base plane."""
        return _fusion.CoilFeatureInput__set_basePlane(self, value)

    def _get_isClockwiseRotation(self) -> "bool":
        r"""
        Gets and sets whether the rotation is clockwise or counter-clockwise. A value of true indicates clockwise rotation.
        It defaults to true.
        """
        return _fusion.CoilFeatureInput__get_isClockwiseRotation(self)

    def _set_isClockwiseRotation(self, value: "bool") -> "bool":
        r"""
        Gets and sets whether the rotation is clockwise or counter-clockwise. A value of true indicates clockwise rotation.
        It defaults to true.
        """
        return _fusion.CoilFeatureInput__set_isClockwiseRotation(self, value)

    def _get_diameter(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets and sets the diameter."""
        return _fusion.CoilFeatureInput__get_diameter(self)

    def _set_diameter(self, value: "ValueInput") -> "bool":
        r"""Gets and sets the diameter."""
        return _fusion.CoilFeatureInput__set_diameter(self, value)

    def _get_coilSectionType(self) -> "adsk::fusion::CoilFeatureSectionTypes":
        r"""
        Gets the section type of the coil.
        It defaults to CircularCoilSectionType.
        """
        return _fusion.CoilFeatureInput__get_coilSectionType(self)

    def _set_coilSectionType(self, value: "CoilFeatureSectionTypes") -> "bool":
        r"""
        Gets the section type of the coil.
        It defaults to CircularCoilSectionType.
        """
        return _fusion.CoilFeatureInput__set_coilSectionType(self, value)

    def _get_coilSectionPosition(self) -> "adsk::fusion::CoilFeatureSectionPositions":
        r"""
        Gets the section position of the coil.
        It defaults to InsideCoilSectionPosition.
        """
        return _fusion.CoilFeatureInput__get_coilSectionPosition(self)

    def _set_coilSectionPosition(self, value: "CoilFeatureSectionPositions") -> "bool":
        r"""
        Gets the section position of the coil.
        It defaults to InsideCoilSectionPosition.
        """
        return _fusion.CoilFeatureInput__set_coilSectionPosition(self, value)

    def _get_sectionSize(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets and sets the section size."""
        return _fusion.CoilFeatureInput__get_sectionSize(self)

    def _set_sectionSize(self, value: "ValueInput") -> "bool":
        r"""Gets and sets the section size."""
        return _fusion.CoilFeatureInput__set_sectionSize(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.CoilFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.CoilFeatureInput__set_targetBaseFeature(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.CoilFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CoilFeatureInput__get_isValid(self)

# Register CoilFeatureInput in _fusion:
_fusion.CoilFeatureInput_swigregister(CoilFeatureInput)

def CoilFeatureInput_classType() -> "char const *":
    return _fusion.CoilFeatureInput_classType()


CoilFeatureInput.isSolid = property(CoilFeatureInput._get_isSolid, CoilFeatureInput._set_isSolid, doc="Specifies if the coil should be created as a solid or surface. This is\ninitialized to true so a solid will be created if it's not changed.\nIt only can be set to false in non-parametric modeling.")


CoilFeatureInput.revolutions = property(CoilFeatureInput._get_revolutions, doc="Gets the revolutions number. Returns null in the case where the coilType property returns HeightAndPitchCoilType.")


CoilFeatureInput.height = property(CoilFeatureInput._get_height, doc="Gets the height. Returns null in the case where the coilType property returns RevolutionsAndPitchCoilType.")


CoilFeatureInput.pitch = property(CoilFeatureInput._get_pitch, doc="Gets the pitch. Returns null in the case where the coilType property returns RevolutionsAndHeightCoilType or SpiralCoilType.")


CoilFeatureInput.angle = property(CoilFeatureInput._get_angle, doc="Gets the angle. Returns null in the case where the coilType property returns SpiralCoilType.")


CoilFeatureInput.coilType = property(CoilFeatureInput._get_coilType, doc="Gets the type of the coil.")


CoilFeatureInput.operation = property(CoilFeatureInput._get_operation, CoilFeatureInput._set_operation, doc="Gets and sets the type of operation performed by the coil.")


CoilFeatureInput.basePlane = property(CoilFeatureInput._get_basePlane, CoilFeatureInput._set_basePlane, doc="Gets and sets the base plane.")


CoilFeatureInput.isClockwiseRotation = property(CoilFeatureInput._get_isClockwiseRotation, CoilFeatureInput._set_isClockwiseRotation, doc="Gets and sets whether the rotation is clockwise or counter-clockwise. A value of true indicates clockwise rotation.\nIt defaults to true.")


CoilFeatureInput.diameter = property(CoilFeatureInput._get_diameter, CoilFeatureInput._set_diameter, doc="Gets and sets the diameter.")


CoilFeatureInput.coilSectionType = property(CoilFeatureInput._get_coilSectionType, CoilFeatureInput._set_coilSectionType, doc="Gets the section type of the coil.\nIt defaults to CircularCoilSectionType.")


CoilFeatureInput.coilSectionPosition = property(CoilFeatureInput._get_coilSectionPosition, CoilFeatureInput._set_coilSectionPosition, doc="Gets the section position of the coil.\nIt defaults to InsideCoilSectionPosition.")


CoilFeatureInput.sectionSize = property(CoilFeatureInput._get_sectionSize, CoilFeatureInput._set_sectionSize, doc="Gets and sets the section size.")


CoilFeatureInput.targetBaseFeature = property(CoilFeatureInput._get_targetBaseFeature, CoilFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


CoilFeatureInput.cast = lambda arg: arg if isinstance(arg, CoilFeatureInput) else None

class CoilFeatures(Base):
    r"""
    Collection that provides access to all of the existing coil features in a design
    and supports the ability to create new coil features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CoilFeatures *":
        return _fusion.CoilFeatures___deref__(self)

    def __eq__(self, rhs: "CoilFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CoilFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "CoilFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CoilFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.CoilFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::CoilFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.CoilFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CoilFeatures_classType()
    __swig_destroy__ = _fusion.delete_CoilFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::CoilFeature >":
        r"""
        Function that returns the specified coil feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.CoilFeatures_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::CoilFeature >":
        r"""
        Function that returns the specified coil feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.CoilFeatures_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of coil features in the collection."""
        return _fusion.CoilFeatures__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.CoilFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CoilFeatures__get_isValid(self)

# Register CoilFeatures in _fusion:
_fusion.CoilFeatures_swigregister(CoilFeatures)

def CoilFeatures_classType() -> "char const *":
    return _fusion.CoilFeatures_classType()


CoilFeatures.count = property(CoilFeatures._get_count, doc="The number of coil features in the collection.")


CoilFeatures.cast = lambda arg: arg if isinstance(arg, CoilFeatures) else None

class CombineFeatureInput(Base):
    r"""
    This class defines the methods and properties that pertain to the definition of a combine 
    feature.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CombineFeatureInput *":
        return _fusion.CombineFeatureInput___deref__(self)

    def __eq__(self, rhs: "CombineFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CombineFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "CombineFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CombineFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CombineFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_CombineFeatureInput

    def _get_targetBody(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""Gets and sets the BRep Body object that represents the blank body."""
        return _fusion.CombineFeatureInput__get_targetBody(self)

    def _set_targetBody(self, value: "BRepBody") -> "bool":
        r"""Gets and sets the BRep Body object that represents the blank body."""
        return _fusion.CombineFeatureInput__set_targetBody(self, value)

    def _get_toolBodies(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""Gets and sets the BRep Body objects that represent the tool bodies."""
        return _fusion.CombineFeatureInput__get_toolBodies(self)

    def _set_toolBodies(self, value: "ObjectCollection") -> "bool":
        r"""Gets and sets the BRep Body objects that represent the tool bodies."""
        return _fusion.CombineFeatureInput__set_toolBodies(self, value)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations":
        r"""
        Gets and sets the type of operation performed by the combine.
        The valid values are JoinFeatureOperation, CutFeatureOperation and IntersectFeatureOperation.
        The default value is JoinFeatureOperation.
        """
        return _fusion.CombineFeatureInput__get_operation(self)

    def _set_operation(self, value: "FeatureOperations") -> "bool":
        r"""
        Gets and sets the type of operation performed by the combine.
        The valid values are JoinFeatureOperation, CutFeatureOperation and IntersectFeatureOperation.
        The default value is JoinFeatureOperation.
        """
        return _fusion.CombineFeatureInput__set_operation(self, value)

    def _get_isNewComponent(self) -> "bool":
        r"""
        Gets and sets a boolean value for whether or not a new component will be created with the results. The default value is false.
        In Base feature environment NewComponent does not work.
        """
        return _fusion.CombineFeatureInput__get_isNewComponent(self)

    def _set_isNewComponent(self, value: "bool") -> "bool":
        r"""
        Gets and sets a boolean value for whether or not a new component will be created with the results. The default value is false.
        In Base feature environment NewComponent does not work.
        """
        return _fusion.CombineFeatureInput__set_isNewComponent(self, value)

    def _get_isKeepToolBodies(self) -> "bool":
        r"""Gets and sets a boolean value for whether or not the tool bodies are retrained after the combine results. The default value is false."""
        return _fusion.CombineFeatureInput__get_isKeepToolBodies(self)

    def _set_isKeepToolBodies(self, value: "bool") -> "bool":
        r"""Gets and sets a boolean value for whether or not the tool bodies are retrained after the combine results. The default value is false."""
        return _fusion.CombineFeatureInput__set_isKeepToolBodies(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.CombineFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.CombineFeatureInput__set_targetBaseFeature(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.CombineFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CombineFeatureInput__get_isValid(self)

# Register CombineFeatureInput in _fusion:
_fusion.CombineFeatureInput_swigregister(CombineFeatureInput)

def CombineFeatureInput_classType() -> "char const *":
    return _fusion.CombineFeatureInput_classType()


CombineFeatureInput.targetBody = property(CombineFeatureInput._get_targetBody, CombineFeatureInput._set_targetBody, doc="Gets and sets the BRep Body object that represents the blank body.")


CombineFeatureInput.toolBodies = property(CombineFeatureInput._get_toolBodies, CombineFeatureInput._set_toolBodies, doc="Gets and sets the BRep Body objects that represent the tool bodies.")


CombineFeatureInput.operation = property(CombineFeatureInput._get_operation, CombineFeatureInput._set_operation, doc="Gets and sets the type of operation performed by the combine.\nThe valid values are JoinFeatureOperation, CutFeatureOperation and IntersectFeatureOperation.\nThe default value is JoinFeatureOperation.")


CombineFeatureInput.isNewComponent = property(CombineFeatureInput._get_isNewComponent, CombineFeatureInput._set_isNewComponent, doc="Gets and sets a boolean value for whether or not a new component will be created with the results. The default value is false.\nIn Base feature environment NewComponent does not work.")


CombineFeatureInput.isKeepToolBodies = property(CombineFeatureInput._get_isKeepToolBodies, CombineFeatureInput._set_isKeepToolBodies, doc="Gets and sets a boolean value for whether or not the tool bodies are retrained after the combine results. The default value is false.")


CombineFeatureInput.targetBaseFeature = property(CombineFeatureInput._get_targetBaseFeature, CombineFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


CombineFeatureInput.cast = lambda arg: arg if isinstance(arg, CombineFeatureInput) else None

class CombineFeatures(Base):
    r"""
    Collection that provides access to all of the existing Combine features in a component
    and supports the ability to create new Combine features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CombineFeatures *":
        return _fusion.CombineFeatures___deref__(self)

    def __eq__(self, rhs: "CombineFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CombineFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "CombineFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CombineFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.CombineFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::CombineFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.CombineFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CombineFeatures_classType()
    __swig_destroy__ = _fusion.delete_CombineFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::CombineFeature >":
        r"""
        Function that returns the specified combine feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.CombineFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""
        The number of combine features in the collection. 
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.CombineFeatures__get_count(self)

    def createInput(self, targetBody: "BRepBody", toolBodies: "ObjectCollection") -> "adsk::core::Ptr< adsk::fusion::CombineFeatureInput >":
        r"""
        Creates a CombineFeatureInput object. Use properties and methods on this object
        to define the combine you want to create and then use the Add method, passing in 
        the CombineFeatureInput object. 
        targetBody : A BRep body that represents the blank body. 
        toolBodies : An ObjectCollection containing one or more BRep bodies that represent tool bodies. 
        Returns the newly created CombineFeatureInput object or null if the creation failed.
        """
        return _fusion.CombineFeatures_createInput(self, targetBody, toolBodies)

    def add(self, input: "CombineFeatureInput") -> "adsk::core::Ptr< adsk::fusion::CombineFeature >":
        r"""
        Creates a new combine feature. 
        input : A CombineFeatureInput object that defines the desired combine. Use the createInput 
        method to create a new CombineFeatureInput object and then use methods on it 
        (the CombineFeatureInput object) to define the combine. 
        Returns the newly created CombineFeature object or null if the creation failed.
        This function returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.CombineFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::CombineFeature >":
        r"""
        Function that returns the specified combine feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.CombineFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.CombineFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CombineFeatures__get_isValid(self)

# Register CombineFeatures in _fusion:
_fusion.CombineFeatures_swigregister(CombineFeatures)

def CombineFeatures_classType() -> "char const *":
    return _fusion.CombineFeatures_classType()


CombineFeatures.count = property(CombineFeatures._get_count, doc="The number of combine features in the collection.\nThis property returns nothing in the case where the feature is non-parametric.")


CombineFeatures.cast = lambda arg: arg if isinstance(arg, CombineFeatures) else None

class ComponentList(Base):
    r"""Provides a list of components."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ComponentList *":
        return _fusion.ComponentList___deref__(self)

    def __eq__(self, rhs: "ComponentList") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ComponentList___eq__(self, rhs)


    def __ne__(self, rhs: "ComponentList") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ComponentList___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.ComponentList___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::Component >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.ComponentList___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ComponentList_classType()
    __swig_destroy__ = _fusion.delete_ComponentList

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""
        Function that returns the specified component using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ComponentList_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of components in the collection."""
        return _fusion.ComponentList__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ComponentList__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ComponentList__get_isValid(self)

# Register ComponentList in _fusion:
_fusion.ComponentList_swigregister(ComponentList)

def ComponentList_classType() -> "char const *":
    return _fusion.ComponentList_classType()


ComponentList.count = property(ComponentList._get_count, doc="Returns the number of components in the collection.")


ComponentList.cast = lambda arg: arg if isinstance(arg, ComponentList) else None

class Components(Base):
    r"""The Components collection object provides access to existing components in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::Components *":
        return _fusion.Components___deref__(self)

    def __eq__(self, rhs: "Components") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.Components___eq__(self, rhs)


    def __ne__(self, rhs: "Components") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.Components___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.Components___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::Component >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.Components___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.Components_classType()
    __swig_destroy__ = _fusion.delete_Components

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""
        Function that returns the specified component using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.Components_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of components in the collection."""
        return _fusion.Components__get_count(self)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""
        Function that returns the specified component by name. 
        name : The name of the component within the collection to return. 
        Returns the specified component or null if the name is not found.
        """
        return _fusion.Components_itemByName(self, name)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""
        Returns the Component that has the specified ID. 
        id : The ID of the Component to get. This is the same id used by PIM (Product Information Model). 
        Returns the specified Component or null in the case where there isn't a Component with the specified ID in this Design.
        """
        return _fusion.Components_itemById(self, id)

    def _get_objectType(self) -> "char const *":
        return _fusion.Components__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.Components__get_isValid(self)

# Register Components in _fusion:
_fusion.Components_swigregister(Components)

def Components_classType() -> "char const *":
    return _fusion.Components_classType()


Components.count = property(Components._get_count, doc="The number of components in the collection.")


Components.cast = lambda arg: arg if isinstance(arg, Components) else None

class ConstructionAxes(Base):
    r"""
    Provides access to the construction axes within a component and provides 
    methods to create new construction axes.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionAxes *":
        return _fusion.ConstructionAxes___deref__(self)

    def __eq__(self, rhs: "ConstructionAxes") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionAxes___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionAxes") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionAxes___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.ConstructionAxes___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.ConstructionAxes___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionAxes_classType()
    __swig_destroy__ = _fusion.delete_ConstructionAxes

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >":
        r"""
        Function that returns the specified construction axis using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ConstructionAxes_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >":
        r"""
        Returns the specified construction axis using the name of the construction
        axis as it is displayed in the browser. 
        name : The name of the axis as it is displayed in the browser 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.ConstructionAxes_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of construction axes in the collection."""
        return _fusion.ConstructionAxes__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxisInput >":
        r"""
        Create a ConstructionAxisInput object that is in turn used to create a ConstructionAxis. 
        occurrenceForCreation : A creation occurrence is needed if the input is in another component AND the 
        construction axis is not in the root component. The occurrenceForCreation is analogous 
        to the active occurrence in the UI. 
        Returns a ConstructionAxisInput object
        """
        return _fusion.ConstructionAxes_createInput(self, *args)

    def add(self, input: "ConstructionAxisInput") -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >":
        r"""
        Creates and adds a new ConstructionAxis using the creation parameters in the ConstructionAxisInput.
        If the ConstructionAxisInput was defined using the setByLine method then
        the add will only work in a direct edit model (do not capture design history) and will fail in a parametric model. 
        input : A ConstructionAxisInput object 
        Returns the newly created construction axis or null if the creation failed.
        """
        return _fusion.ConstructionAxes_add(self, input)

    def _get_component(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""The component that owns this collection."""
        return _fusion.ConstructionAxes__get_component(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionAxes__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionAxes__get_isValid(self)

# Register ConstructionAxes in _fusion:
_fusion.ConstructionAxes_swigregister(ConstructionAxes)

def ConstructionAxes_classType() -> "char const *":
    return _fusion.ConstructionAxes_classType()


ConstructionAxes.count = property(ConstructionAxes._get_count, doc="The number of construction axes in the collection.")


ConstructionAxes.component = property(ConstructionAxes._get_component, doc="The component that owns this collection.")


ConstructionAxes.cast = lambda arg: arg if isinstance(arg, ConstructionAxes) else None

class ConstructionAxis(Base):
    r"""ConstructionAxis Object"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionAxis *":
        return _fusion.ConstructionAxis___deref__(self)

    def __eq__(self, rhs: "ConstructionAxis") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionAxis___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionAxis") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionAxis___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionAxis_classType()
    __swig_destroy__ = _fusion.delete_ConstructionAxis

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::InfiniteLine3D >":
        r"""
        Returns an infinite line that represents the position and orientation of the 
        construction axis. This geometry is defined in the AssemblyContext of this 
        ConstructionAxis.
        """
        return _fusion.ConstructionAxis__get_geometry(self)

    def _get_name(self) -> "std::string":
        r"""The name of the construction axis as it is shown in the browser."""
        return _fusion.ConstructionAxis__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""The name of the construction axis as it is shown in the browser."""
        return _fusion.ConstructionAxis__set_name(self, value)

    def _get_definition(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxisDefinition >":
        r"""
        Returns the construction axis definition object which provides access to the information
        defining the construction axis.
        """
        return _fusion.ConstructionAxis__get_definition(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the construction axis. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ConstructionAxis_deleteMe(self)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this construction axis is parametric or not."""
        return _fusion.ConstructionAxis__get_isParametric(self)

    def _get_isDeletable(self) -> "bool":
        r"""
        Indicates if this construction axis can be deleted. Base
        construction axes can not be deleted.
        """
        return _fusion.ConstructionAxis__get_isDeletable(self)

    def _get_isLightBulbOn(self) -> "bool":
        r"""
        Indicates if the light bulb (as displayed in the browser) is on.
        A construction axis will only be visible if it's light bulb, and that of it's
        containing folder and parent component/s are also on.
        """
        return _fusion.ConstructionAxis__get_isLightBulbOn(self)

    def _set_isLightBulbOn(self, value: "bool") -> "bool":
        r"""
        Indicates if the light bulb (as displayed in the browser) is on.
        A construction axis will only be visible if it's light bulb, and that of it's
        containing folder and parent component/s are also on.
        """
        return _fusion.ConstructionAxis__set_isLightBulbOn(self, value)

    def _get_isVisible(self) -> "bool":
        r"""
        Gets if the construction plane is visible.
        This property is affected by the AssemblyContext of the construction axis.
        """
        return _fusion.ConstructionAxis__get_isVisible(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the parent component or base feature. If both the design and the construction 
        axis are parametric, the parent will be a component. If the design is parametric and 
        the construction axis is not, the parent will be a base feature. If
        the design is not parametric the parent will be a component.
        """
        return _fusion.ConstructionAxis__get_parent(self)

    def _get_component(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the component this construction plane belongs to."""
        return _fusion.ConstructionAxis__get_component(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this construction axis."""
        return _fusion.ConstructionAxis__get_timelineObject(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ConstructionAxis__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ConstructionAxis__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ConstructionAxis_createForAssemblyContext(self, occurrence)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this construction axis is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ConstructionAxis__get_baseFeature(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this construction axis."""
        return _fusion.ConstructionAxis__get_attributes(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of this construction axis."""
        return _fusion.ConstructionAxis__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ConstructionAxis__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the ConstructionAxis object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same construction axis.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.ConstructionAxis__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionAxis__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionAxis__get_isValid(self)

# Register ConstructionAxis in _fusion:
_fusion.ConstructionAxis_swigregister(ConstructionAxis)

def ConstructionAxis_classType() -> "char const *":
    return _fusion.ConstructionAxis_classType()


ConstructionAxis.geometry = property(ConstructionAxis._get_geometry, doc="Returns an infinite line that represents the position and orientation of the\nconstruction axis. This geometry is defined in the AssemblyContext of this\nConstructionAxis.")


ConstructionAxis.name = property(ConstructionAxis._get_name, ConstructionAxis._set_name, doc="The name of the construction axis as it is shown in the browser.")


ConstructionAxis.definition = property(ConstructionAxis._get_definition, doc="Returns the construction axis definition object which provides access to the information\ndefining the construction axis.")


ConstructionAxis.isParametric = property(ConstructionAxis._get_isParametric, doc="Indicates if this construction axis is parametric or not.")


ConstructionAxis.isDeletable = property(ConstructionAxis._get_isDeletable, doc="Indicates if this construction axis can be deleted. Base\nconstruction axes can not be deleted.")


ConstructionAxis.isLightBulbOn = property(ConstructionAxis._get_isLightBulbOn, ConstructionAxis._set_isLightBulbOn, doc="Indicates if the light bulb (as displayed in the browser) is on.\nA construction axis will only be visible if it's light bulb, and that of it's\ncontaining folder and parent component/s are also on.")


ConstructionAxis.isVisible = property(ConstructionAxis._get_isVisible, doc="Gets if the construction plane is visible.\nThis property is affected by the AssemblyContext of the construction axis.")


ConstructionAxis.parent = property(ConstructionAxis._get_parent, doc="Returns the parent component or base feature. If both the design and the construction\naxis are parametric, the parent will be a component. If the design is parametric and\nthe construction axis is not, the parent will be a base feature. If\nthe design is not parametric the parent will be a component.")


ConstructionAxis.component = property(ConstructionAxis._get_component, doc="Returns the component this construction plane belongs to.")


ConstructionAxis.timelineObject = property(ConstructionAxis._get_timelineObject, doc="Returns the timeline object associated with this construction axis.")


ConstructionAxis.assemblyContext = property(ConstructionAxis._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")


ConstructionAxis.nativeObject = property(ConstructionAxis._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


ConstructionAxis.baseFeature = property(ConstructionAxis._get_baseFeature, doc="If this construction axis is associated with a base feature, this property will return that base feature.\nIf it's not associated with a base feature, this property will return null.")


ConstructionAxis.attributes = property(ConstructionAxis._get_attributes, doc="Returns the collection of attributes associated with this construction axis.")


ConstructionAxis.healthState = property(ConstructionAxis._get_healthState, doc="Returns the current health state of this construction axis.")


ConstructionAxis.errorOrWarningMessage = property(ConstructionAxis._get_errorOrWarningMessage, doc="Returns the error or warning message in the case where the healthState property returns either\nWarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.")


ConstructionAxis.entityToken = property(ConstructionAxis._get_entityToken, doc="Returns a token for the ConstructionAxis object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same construction axis.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.")


ConstructionAxis.cast = lambda arg: arg if isinstance(arg, ConstructionAxis) else None

class ConstructionAxisDefinition(Base):
    r"""
    A Base class to return the information (possibly parametric) used to 
    define a ConstructionAxis.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionAxisDefinition *":
        return _fusion.ConstructionAxisDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionAxisDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionAxisDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionAxisDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionAxisDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionAxisDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionAxisDefinition

    def _get_parentConstructionAxis(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >":
        r"""Returns the ConstructionAxis object"""
        return _fusion.ConstructionAxisDefinition__get_parentConstructionAxis(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionAxisDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionAxisDefinition__get_isValid(self)

# Register ConstructionAxisDefinition in _fusion:
_fusion.ConstructionAxisDefinition_swigregister(ConstructionAxisDefinition)

def ConstructionAxisDefinition_classType() -> "char const *":
    return _fusion.ConstructionAxisDefinition_classType()


ConstructionAxisDefinition.parentConstructionAxis = property(ConstructionAxisDefinition._get_parentConstructionAxis, doc="Returns the ConstructionAxis object")


ConstructionAxisDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionAxisDefinition) else None

class ConstructionAxisInput(Base):
    r"""
    A ConstructionAxisInput is a throwaway object used to create a ConstructionAxis
    The usage pattern is:
    a. create a ConstructionAxisInput (ConstructionAxes.CreateInput)
    b. call one of the member functions to specify how the ConstructionAxis is created
    c. create the ConstructionAxis (call ConstructionAxes.Add)
    d. stop referencing the ConstructionAxisInput (so it gets deleted).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionAxisInput *":
        return _fusion.ConstructionAxisInput___deref__(self)

    def __eq__(self, rhs: "ConstructionAxisInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionAxisInput___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionAxisInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionAxisInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionAxisInput_classType()
    __swig_destroy__ = _fusion.delete_ConstructionAxisInput

    def setByLine(self, line: "InfiniteLine3D") -> "bool":
        r"""
        This input method is for creating a non-parametric construction axis whose position
        in space is defined by an InfiniteLine3D object.
        This method of defining a construction axis is only valid when working in a direct edit model (do not capture design history).
        This is not valid when working in a parametric model and will fail. 
        line : An InFiniteLine3D object 
        Returns true if the creation of the ConstructionAxisInput is successful.
        """
        return _fusion.ConstructionAxisInput_setByLine(self, line)

    def setByCircularFace(self, circularFace: "BRepFace") -> "bool":
        r"""
        This input method is for creating an axis coincident with the axis of a 
        cylindrical, conical or torus face.
        This can result in a parametric or non-parametric construction axis depending 
        on whether the parent component is parametric or is a direct edit component. 
        circularFace : The face from a cylinder, cone, or torus. 
        Returns true if the creation of the ConstructionAxisInput is successful.
        """
        return _fusion.ConstructionAxisInput_setByCircularFace(self, circularFace)

    def setByPerpendicularAtPoint(self, face: "BRepFace", pointEntity: "Base") -> "bool":
        r"""
        This input method is for creating an axis that is normal to a face
        at a specified point. 
        face : A face (BRepFace object) to create the axis normal to. 
        pointEntity : A construction point, sketch point or vertex the axis is to pass thru 
        Returns true if the creation of the ConstructionAxisInput is successful.
        """
        return _fusion.ConstructionAxisInput_setByPerpendicularAtPoint(self, face, pointEntity)

    def setByTwoPlanes(self, planarEntityOne: "Base", planarEntityTwo: "Base") -> "bool":
        r"""
        This input method is for creating a construction axis coincident with the 
        intersection of two planes or planar faces.
        This will fail if the the two planes are parallel.
        This can result in a parametric or non-parametric construction axis depending 
        on whether the parent component is parametric or is a direct edit component. 
        planarEntityOne : The first planar face or construction plane to intersect 
        planarEntityTwo : The second planar face or construction plane to intersect 
        Returns true if the creation of the ConstructionAxisInput is successful.
        """
        return _fusion.ConstructionAxisInput_setByTwoPlanes(self, planarEntityOne, planarEntityTwo)

    def setByTwoPoints(self, pointEntityOne: "Base", pointEntityTwo: "Base") -> "bool":
        r"""
        This input method is for creating a construction axis that passes through the two points 
        (work points, sketch points or vertices).
        This will fail if the the two points are coincident.
        This can result in a parametric or non-parametric construction axis depending 
        on whether the parent component is parametric or is a direct edit component. 
        pointEntityOne : The first construction point, sketch point or vertex the axis passes through 
        pointEntityTwo : The second construction point, sketch point or vertex the axis passes through 
        Returns true if the creation of the ConstructionAxisInput is successful.
        """
        return _fusion.ConstructionAxisInput_setByTwoPoints(self, pointEntityOne, pointEntityTwo)

    def setByEdge(self, edgeEntity: "Base") -> "bool":
        r"""
        This input method is for creating a construction axis from a specified linear/circular edge
        or sketch curve.
        This can result in a parametric or non-parametric construction axis depending 
        on whether the parent component is parametric or is a direct edit component. 
        edgeEntity : A linear/circular edge, construction line, or sketch line 
        Returns true if the creation of the ConstructionAxisInput is successful.
        """
        return _fusion.ConstructionAxisInput_setByEdge(self, edgeEntity)

    def setByNormalToFaceAtPoint(self, face: "BRepFace", pointEntity: "Base") -> "bool":
        r"""
        This input method if for creating a construction axis normal to a specified face 
        or sketch profile and that passes through a specified point. 
        This can result in a parametric or non-parametric construction axis depending 
        on whether the parent component is parametric or is a direct edit component. 
        face : The face (BRepFace object) to create the axis normal to. 
        pointEntity : A construction point, sketch point or vertex the axis passes through.
        This point does not have to lie on the face. 
        Returns true if the creation of the ConstructionAxisInput is successful.
        """
        return _fusion.ConstructionAxisInput_setByNormalToFaceAtPoint(self, face, pointEntity)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        In order for geometry to be transformed correctly, an Occurrence for creation needs 
        to be specified when the ConstructionAxis is created based on geometry
        (e.g. a straight edge) in another component AND (the ConstructionAxis) is not in the 
        root component. The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.ConstructionAxisInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, value: "Occurrence") -> "bool":
        r"""
        In order for geometry to be transformed correctly, an Occurrence for creation needs 
        to be specified when the ConstructionAxis is created based on geometry
        (e.g. a straight edge) in another component AND (the ConstructionAxis) is not in the 
        root component. The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.ConstructionAxisInput__set_creationOccurrence(self, value)

    def _get_targetBaseOrFormFeature(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        When creating a construction axis that is owned by a base or form feature, set this property to the 
        base or form feature you want to associate the new construction plane with. By default, this is null,
        meaning it will not be associated with a base or form feature.
        Because of a current limitation, if you want to create a construction axis associated with a base
        or form feature, you must set this property AND call the edit method of the base or form feature,
        create the feature, and then call the finishEdit method of the base or form feature. The base or form
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ConstructionAxisInput__get_targetBaseOrFormFeature(self)

    def _set_targetBaseOrFormFeature(self, value: "Base") -> "bool":
        r"""
        When creating a construction axis that is owned by a base or form feature, set this property to the 
        base or form feature you want to associate the new construction plane with. By default, this is null,
        meaning it will not be associated with a base or form feature.
        Because of a current limitation, if you want to create a construction axis associated with a base
        or form feature, you must set this property AND call the edit method of the base or form feature,
        create the feature, and then call the finishEdit method of the base or form feature. The base or form
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ConstructionAxisInput__set_targetBaseOrFormFeature(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionAxisInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionAxisInput__get_isValid(self)

# Register ConstructionAxisInput in _fusion:
_fusion.ConstructionAxisInput_swigregister(ConstructionAxisInput)

def ConstructionAxisInput_classType() -> "char const *":
    return _fusion.ConstructionAxisInput_classType()


ConstructionAxisInput.creationOccurrence = property(ConstructionAxisInput._get_creationOccurrence, ConstructionAxisInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an Occurrence for creation needs\nto be specified when the ConstructionAxis is created based on geometry\n(e.g. a straight edge) in another component AND (the ConstructionAxis) is not in the\nroot component. The CreationOccurrence is analogous to the active occurrence in the UI")


ConstructionAxisInput.targetBaseOrFormFeature = property(ConstructionAxisInput._get_targetBaseOrFormFeature, ConstructionAxisInput._set_targetBaseOrFormFeature, doc="When creating a construction axis that is owned by a base or form feature, set this property to the\nbase or form feature you want to associate the new construction plane with. By default, this is null,\nmeaning it will not be associated with a base or form feature.\nBecause of a current limitation, if you want to create a construction axis associated with a base\nor form feature, you must set this property AND call the edit method of the base or form feature,\ncreate the feature, and then call the finishEdit method of the base or form feature. The base or form\nfeature must be in an 'edit' state to be able to add any additional items to it.")


ConstructionAxisInput.cast = lambda arg: arg if isinstance(arg, ConstructionAxisInput) else None

class ConstructionPlane(Base):
    r"""ConstructionPlane Object"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionPlane *":
        return _fusion.ConstructionPlane___deref__(self)

    def __eq__(self, rhs: "ConstructionPlane") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionPlane___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionPlane") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionPlane___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionPlane_classType()
    __swig_destroy__ = _fusion.delete_ConstructionPlane

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Plane >":
        r"""
        Returns a plane that represents the position and orientation of the construction plane.
        This geometry is defined in the AssemblyContext of this ConstructionPlane.
        """
        return _fusion.ConstructionPlane__get_geometry(self)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the construction plane as it is shown in the browser."""
        return _fusion.ConstructionPlane__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the construction plane as it is shown in the browser."""
        return _fusion.ConstructionPlane__set_name(self, value)

    def _get_definition(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlaneDefinition >":
        r"""
        Returns the ConstructionPlaneDefinition object which provides access to the information
        defining this ConstructionPlane.
        """
        return _fusion.ConstructionPlane__get_definition(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the construction plane. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ConstructionPlane_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""
        Indicates if this construction plane can be deleted. Base
        construction planes can not be deleted.
        """
        return _fusion.ConstructionPlane__get_isDeletable(self)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this construction plane is parametric or not."""
        return _fusion.ConstructionPlane__get_isParametric(self)

    def _get_isLightBulbOn(self) -> "bool":
        r"""
        Indicates if the light bulb (as displayed in the browser) is on.
        A construction plane will only be visible if it's light bulb, and that of it's
        containing folder and parent component/s are also on.
        """
        return _fusion.ConstructionPlane__get_isLightBulbOn(self)

    def _set_isLightBulbOn(self, value: "bool") -> "bool":
        r"""
        Indicates if the light bulb (as displayed in the browser) is on.
        A construction plane will only be visible if it's light bulb, and that of it's
        containing folder and parent component/s are also on.
        """
        return _fusion.ConstructionPlane__set_isLightBulbOn(self, value)

    def _get_isVisible(self) -> "bool":
        r"""
        Indicates if the construction plane is visible.
        This property is affected by the AssemblyContext of the construction plane.
        """
        return _fusion.ConstructionPlane__get_isVisible(self)

    def _get_displayBounds(self) -> "adsk::core::Ptr< adsk::core::BoundingBox2D >":
        r"""
        Gets and sets the display size of the construction plane. The bounding
        box defines the min and max corners of the plane as defined in the 
        2D space of the construction plane.
        """
        return _fusion.ConstructionPlane__get_displayBounds(self)

    def _set_displayBounds(self, value: "BoundingBox2D") -> "bool":
        r"""
        Gets and sets the display size of the construction plane. The bounding
        box defines the min and max corners of the plane as defined in the 
        2D space of the construction plane.
        """
        return _fusion.ConstructionPlane__set_displayBounds(self, value)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the parent component or base feature. If both the design and the construction 
        plane are parametric, the parent will be a component. If the design is parametric and 
        the construction plane is not, the parent will be a base feature. If
        the design is not parametric the parent will be a component.
        """
        return _fusion.ConstructionPlane__get_parent(self)

    def _get_component(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the component this construction plane belongs to."""
        return _fusion.ConstructionPlane__get_component(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this construction plane."""
        return _fusion.ConstructionPlane__get_timelineObject(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ConstructionPlane__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >":
        r"""
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ConstructionPlane__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ConstructionPlane_createForAssemblyContext(self, occurrence)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this construction plane is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ConstructionPlane__get_baseFeature(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this construction plane."""
        return _fusion.ConstructionPlane__get_attributes(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of this construction plane."""
        return _fusion.ConstructionPlane__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ConstructionPlane__get_errorOrWarningMessage(self)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >":
        r"""
        Returns the current position and orientation of the construction plane as a matrix.
        For a parametric construction plane, this property is read-only. For a construction
        plane in a direct modeling model or in a base feature, this is read-write and can be
        used to reposition the constructions plane.
        """
        return _fusion.ConstructionPlane__get_transform(self)

    def _set_transform(self, value: "Matrix3D") -> "bool":
        r"""
        Returns the current position and orientation of the construction plane as a matrix.
        For a parametric construction plane, this property is read-only. For a construction
        plane in a direct modeling model or in a base feature, this is read-write and can be
        used to reposition the constructions plane.
        """
        return _fusion.ConstructionPlane__set_transform(self, value)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the ConstructionPlane object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same construction plane.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.ConstructionPlane__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionPlane__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionPlane__get_isValid(self)

# Register ConstructionPlane in _fusion:
_fusion.ConstructionPlane_swigregister(ConstructionPlane)

def ConstructionPlane_classType() -> "char const *":
    return _fusion.ConstructionPlane_classType()


ConstructionPlane.geometry = property(ConstructionPlane._get_geometry, doc="Returns a plane that represents the position and orientation of the construction plane.\nThis geometry is defined in the AssemblyContext of this ConstructionPlane.")


ConstructionPlane.name = property(ConstructionPlane._get_name, ConstructionPlane._set_name, doc="Returns the name of the construction plane as it is shown in the browser.")


ConstructionPlane.definition = property(ConstructionPlane._get_definition, doc="Returns the ConstructionPlaneDefinition object which provides access to the information\ndefining this ConstructionPlane.")


ConstructionPlane.isDeletable = property(ConstructionPlane._get_isDeletable, doc="Indicates if this construction plane can be deleted. Base\nconstruction planes can not be deleted.")


ConstructionPlane.isParametric = property(ConstructionPlane._get_isParametric, doc="Indicates if this construction plane is parametric or not.")


ConstructionPlane.isLightBulbOn = property(ConstructionPlane._get_isLightBulbOn, ConstructionPlane._set_isLightBulbOn, doc="Indicates if the light bulb (as displayed in the browser) is on.\nA construction plane will only be visible if it's light bulb, and that of it's\ncontaining folder and parent component/s are also on.")


ConstructionPlane.isVisible = property(ConstructionPlane._get_isVisible, doc="Indicates if the construction plane is visible.\nThis property is affected by the AssemblyContext of the construction plane.")


ConstructionPlane.displayBounds = property(ConstructionPlane._get_displayBounds, ConstructionPlane._set_displayBounds, doc="Gets and sets the display size of the construction plane. The bounding\nbox defines the min and max corners of the plane as defined in the\n2D space of the construction plane.")


ConstructionPlane.parent = property(ConstructionPlane._get_parent, doc="Returns the parent component or base feature. If both the design and the construction\nplane are parametric, the parent will be a component. If the design is parametric and\nthe construction plane is not, the parent will be a base feature. If\nthe design is not parametric the parent will be a component.")


ConstructionPlane.component = property(ConstructionPlane._get_component, doc="Returns the component this construction plane belongs to.")


ConstructionPlane.timelineObject = property(ConstructionPlane._get_timelineObject, doc="Returns the timeline object associated with this construction plane.")


ConstructionPlane.assemblyContext = property(ConstructionPlane._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")


ConstructionPlane.nativeObject = property(ConstructionPlane._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


ConstructionPlane.baseFeature = property(ConstructionPlane._get_baseFeature, doc="If this construction plane is associated with a base feature, this property will return that base feature.\nIf it's not associated with a base feature, this property will return null.")


ConstructionPlane.attributes = property(ConstructionPlane._get_attributes, doc="Returns the collection of attributes associated with this construction plane.")


ConstructionPlane.healthState = property(ConstructionPlane._get_healthState, doc="Returns the current health state of this construction plane.")


ConstructionPlane.errorOrWarningMessage = property(ConstructionPlane._get_errorOrWarningMessage, doc="Returns the error or warning message in the case where the healthState property returns either\nWarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.")


ConstructionPlane.transform = property(ConstructionPlane._get_transform, ConstructionPlane._set_transform, doc="Returns the current position and orientation of the construction plane as a matrix.\nFor a parametric construction plane, this property is read-only. For a construction\nplane in a direct modeling model or in a base feature, this is read-write and can be\nused to reposition the constructions plane.")


ConstructionPlane.entityToken = property(ConstructionPlane._get_entityToken, doc="Returns a token for the ConstructionPlane object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same construction plane.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.")


ConstructionPlane.cast = lambda arg: arg if isinstance(arg, ConstructionPlane) else None

class ConstructionPlaneDefinition(Base):
    r"""A Base class to return the information, possibly parametric, used to define the ConstructionPlane."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionPlaneDefinition *":
        return _fusion.ConstructionPlaneDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionPlaneDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionPlaneDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionPlaneDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionPlaneDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionPlaneDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionPlaneDefinition

    def _get_parentConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >":
        r"""Returns the ConstructionPlane object"""
        return _fusion.ConstructionPlaneDefinition__get_parentConstructionPlane(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionPlaneDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionPlaneDefinition__get_isValid(self)

# Register ConstructionPlaneDefinition in _fusion:
_fusion.ConstructionPlaneDefinition_swigregister(ConstructionPlaneDefinition)

def ConstructionPlaneDefinition_classType() -> "char const *":
    return _fusion.ConstructionPlaneDefinition_classType()


ConstructionPlaneDefinition.parentConstructionPlane = property(ConstructionPlaneDefinition._get_parentConstructionPlane, doc="Returns the ConstructionPlane object")


ConstructionPlaneDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPlaneDefinition) else None

class ConstructionPlaneInput(Base):
    r"""
    A ConstructionPlaneInput is a throwaway object used to create a ConstructionPlane
    The usage pattern is:
    a. create a ConstructionPlaneInput (ConstructionPlanes.CreateInput)
    b. call one of the member functions to specify how the ConstructionPlane is created
    c. create the ConstructionPlane (call ConstructionPlanes.Add)
    d. stop referencing the ConstructionPlaneInput (so it gets deleted).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionPlaneInput *":
        return _fusion.ConstructionPlaneInput___deref__(self)

    def __eq__(self, rhs: "ConstructionPlaneInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionPlaneInput___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionPlaneInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionPlaneInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionPlaneInput_classType()
    __swig_destroy__ = _fusion.delete_ConstructionPlaneInput

    def setByPlane(self, plane: "Plane") -> "bool":
        r"""
        This input method is for creating a non-parametric construction plane positioned in 
        space as defined by the input Plane object.
        This method of defining a construction plane is only valid when working in a direct edit model (do not capture design history).
        This is not valid when working in a parametric model and will fail. 
        plane : A transient plane object 
        Returns true if the construction plane definition is successful.
        """
        return _fusion.ConstructionPlaneInput_setByPlane(self, plane)

    def setByOffset(self, planarEntity: "Base", offset: "ValueInput") -> "bool":
        r"""
        This input method is for creating a construction plane that is offset from a planar 
        face or construction plane at a specified distance. This can result in 
        a parametric or non-parametric construction plane depending on whether the parent 
        component is parametric or is a direct edit component. 
        planarEntity : A plane, planar face or construction plane from which to create the offset plane 
        offset : ValueInput object that specifies the offset distance for the plane 
        Returns true if the construction plane definition is successful.
        """
        return _fusion.ConstructionPlaneInput_setByOffset(self, planarEntity, offset)

    def setByAngle(self, linearEntity: "Base", angle: "ValueInput", planarEntity: "Base") -> "bool":
        r"""
        This input method is for creating a construction plane through an edge, axis or line
        at a specified angle. This can result in a parametric or non-parametric construction
        plane depending on whether the parent component is parametric or is a direct edit 
        component. 
        linearEntity : The axis about which to rotate the plane 
        angle : The angle at which to create the plane 
        planarEntity : The planar face or construction plane the angle is measured from. 
        Returns true if the construction plane definition is successful.
        """
        return _fusion.ConstructionPlaneInput_setByAngle(self, linearEntity, angle, planarEntity)

    def setByTangent(self, tangentFace: "BRepFace", angle: "ValueInput", planarEntity: "Base") -> "bool":
        r"""
        This input method is for creating a construction plane tangent to a cylindrical or 
        conical face at a specified point. This can result in a parametric or non-parametric construction
        plane depending on whether the parent component is parametric or is a direct edit 
        component. 
        tangentFace : A cylindrical or conical face to create the plane tangent to 
        angle : The angle relative to the planarEntity input at which to create the tangent plane 
        planarEntity : The planar face or construction plane the tangent is measured from. 
        Returns true if the construction plane definition is successful.
        """
        return _fusion.ConstructionPlaneInput_setByTangent(self, tangentFace, angle, planarEntity)

    def setByTwoPlanes(self, planarEntityOne: "Base", planarEntityTwo: "Base") -> "bool":
        r"""
        This input method is for creating a construction plane at the midpoint between
        two planar faces or construction planes. This can result in a parametric or 
        non-parametric construction plane depending on whether the parent component is 
        parametric or is a direct edit component. 
        planarEntityOne : The first planar face or construction plane to create a bisecting plane between 
        planarEntityTwo : The second planar face or construction plane to create a bisecting plane between 
        Returns true if the construction plane definition is successful. 
        This will fail if the two planes are co-planar.
        """
        return _fusion.ConstructionPlaneInput_setByTwoPlanes(self, planarEntityOne, planarEntityTwo)

    def setByTwoEdges(self, linearEntityOne: "Base", linearEntityTwo: "Base") -> "bool":
        r"""
        This input method is for creating a construction plane that passes through two
        coplanar linear entities or axes.
        Defines a plane by specifying two coplanar linear entities. This can result in a 
        parametric or non-parametric construction plane depending on whether the parent 
        component is parametric or is a direct edit component. 
        linearEntityOne : The first of two coplanar linear entities to define the plane 
        linearEntityTwo : The second of two coplanar linear entities to define the plane 
        Returns true if the construction plane definition is successful. 
        This will fail if the two linear entities are not coplanar.
        """
        return _fusion.ConstructionPlaneInput_setByTwoEdges(self, linearEntityOne, linearEntityTwo)

    def setByThreePoints(self, pointEntityOne: "Base", pointEntityTwo: "Base", pointEntityThree: "Base") -> "bool":
        r"""
        This input method is for creating a construction plane through three points that
        define a triangle. This can result in a parametric or non-parametric construction 
        plane depending on whether the parent component is parametric or is a direct edit 
        component. 
        pointEntityOne : The first construction point, sketch point or vertex in the triangle 
        pointEntityTwo : The second construction point, sketch point or vertex in the triangle 
        pointEntityThree : The third construction point, sketch point or vertex in the triangle 
        Returns true if the construction plane definition is successful. 
        This will fail if the points do not form a triangle (no two
        points can be coincident and all three cannot be collinear).
        """
        return _fusion.ConstructionPlaneInput_setByThreePoints(self, pointEntityOne, pointEntityTwo, pointEntityThree)

    def setByTangentAtPoint(self, tangentFace: "BRepFace", pointEntity: "Base") -> "bool":
        r"""
        This input method is for creating a construction plane tangent to a face 
        and aligned to a point. This can result in a parametric or non-parametric 
        construction plane depending on whether the parent component is parametric or is a 
        direct edit component. 
        tangentFace : A face to create the plane tangent to 
        pointEntity : A construction point, sketch point or vertex the tangent plane aligns to. 
        This point need not lie on the tangent face. 
        Returns true if the construction plane definition is successful.
        """
        return _fusion.ConstructionPlaneInput_setByTangentAtPoint(self, tangentFace, pointEntity)

    def setByDistanceOnPath(self, pathEntity: "Base", distance: "ValueInput") -> "bool":
        r"""
        This input method is for creating a construction plane normal to, and at 
        specified distance along, a path defined by an edge or sketch profile.
        This can result in a parametric or non-parametric 
        construction plane depending on whether the parent component is parametric or is a 
        direct edit component. 
        pathEntity : The path can be an edge, sketch curve, or a path of multiple entities. 
        distance : The distance is a value from 0 to 1 indicating the position along the path where 0
        is at the start and 1 is at the end. 
        Returns true if the construction plane definition is successful.
        """
        return _fusion.ConstructionPlaneInput_setByDistanceOnPath(self, pathEntity, distance)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the ConstructionPlane is created based on geometry (e.g. a planarEntity)
        in another component AND (the ConstructionPlane) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.ConstructionPlaneInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, value: "Occurrence") -> "bool":
        r"""
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the ConstructionPlane is created based on geometry (e.g. a planarEntity)
        in another component AND (the ConstructionPlane) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.ConstructionPlaneInput__set_creationOccurrence(self, value)

    def _get_targetBaseOrFormFeature(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        When creating a construction plane that is owned by a base or form feature, set this property to the 
        base or form feature you want to associate the new construction plane with. By default, this is null,
        meaning it will not be associated with a base or form feature.
        Because of a current limitation, if you want to create a construction plane associated with a base
        or form feature, you must set this property AND call the edit method of the base or form feature,
        create the feature, and then call the finishEdit method of the base or form feature. The base or form
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ConstructionPlaneInput__get_targetBaseOrFormFeature(self)

    def _set_targetBaseOrFormFeature(self, value: "Base") -> "bool":
        r"""
        When creating a construction plane that is owned by a base or form feature, set this property to the 
        base or form feature you want to associate the new construction plane with. By default, this is null,
        meaning it will not be associated with a base or form feature.
        Because of a current limitation, if you want to create a construction plane associated with a base
        or form feature, you must set this property AND call the edit method of the base or form feature,
        create the feature, and then call the finishEdit method of the base or form feature. The base or form
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ConstructionPlaneInput__set_targetBaseOrFormFeature(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionPlaneInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionPlaneInput__get_isValid(self)

# Register ConstructionPlaneInput in _fusion:
_fusion.ConstructionPlaneInput_swigregister(ConstructionPlaneInput)

def ConstructionPlaneInput_classType() -> "char const *":
    return _fusion.ConstructionPlaneInput_classType()


ConstructionPlaneInput.creationOccurrence = property(ConstructionPlaneInput._get_creationOccurrence, ConstructionPlaneInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an Occurrence for creation needs to be\nspecified when the ConstructionPlane is created based on geometry (e.g. a planarEntity)\nin another component AND (the ConstructionPlane) is not in the root component.\nThe CreationOccurrence is analogous to the active occurrence in the UI")


ConstructionPlaneInput.targetBaseOrFormFeature = property(ConstructionPlaneInput._get_targetBaseOrFormFeature, ConstructionPlaneInput._set_targetBaseOrFormFeature, doc="When creating a construction plane that is owned by a base or form feature, set this property to the\nbase or form feature you want to associate the new construction plane with. By default, this is null,\nmeaning it will not be associated with a base or form feature.\nBecause of a current limitation, if you want to create a construction plane associated with a base\nor form feature, you must set this property AND call the edit method of the base or form feature,\ncreate the feature, and then call the finishEdit method of the base or form feature. The base or form\nfeature must be in an 'edit' state to be able to add any additional items to it.")


ConstructionPlaneInput.cast = lambda arg: arg if isinstance(arg, ConstructionPlaneInput) else None

class ConstructionPlanes(Base):
    r"""
    Provides access to the construction planes within a component and provides 
    methods to create new construction planes.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionPlanes *":
        return _fusion.ConstructionPlanes___deref__(self)

    def __eq__(self, rhs: "ConstructionPlanes") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionPlanes___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionPlanes") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionPlanes___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.ConstructionPlanes___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.ConstructionPlanes___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionPlanes_classType()
    __swig_destroy__ = _fusion.delete_ConstructionPlanes

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >":
        r"""
        Function that returns the specified construction plane using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ConstructionPlanes_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >":
        r"""
        Returns the specified construction plane using the name of the construction
        plane as it is displayed in the browser. 
        name : The name of the construction plane as it is displayed in the browser 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.ConstructionPlanes_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""Returns the number of construction planes in the collection."""
        return _fusion.ConstructionPlanes__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlaneInput >":
        r"""
        Create a ConstructionPlaneInput object that is in turn used to create a ConstructionPlane. 
        occurrenceForCreation : A creation occurrence is needed if the input is in another component AND the 
        construction plane is not in the root component. The occurrenceForCreation is analogous 
        to the active occurrence in the UI. 
        Returns a ConstructionPlaneInput object
        """
        return _fusion.ConstructionPlanes_createInput(self, *args)

    def add(self, input: "ConstructionPlaneInput") -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >":
        r"""
        Creates and adds a new ConstructionPlane using the creation parameters in
        the ConstructionPlaneInput. 
        If the ConstructionPlaneInput was defined using the setByPlane method then
        the add will only work in a direct edit model (do not capture design history) and will fail in a parametric model. 
        input : A ConstructionPlaneInput object 
        Returns the newly created construction plane or null if the creation failed.
        """
        return _fusion.ConstructionPlanes_add(self, input)

    def _get_component(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the component that owns this collection."""
        return _fusion.ConstructionPlanes__get_component(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionPlanes__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionPlanes__get_isValid(self)

# Register ConstructionPlanes in _fusion:
_fusion.ConstructionPlanes_swigregister(ConstructionPlanes)

def ConstructionPlanes_classType() -> "char const *":
    return _fusion.ConstructionPlanes_classType()


ConstructionPlanes.count = property(ConstructionPlanes._get_count, doc="Returns the number of construction planes in the collection.")


ConstructionPlanes.component = property(ConstructionPlanes._get_component, doc="Returns the component that owns this collection.")


ConstructionPlanes.cast = lambda arg: arg if isinstance(arg, ConstructionPlanes) else None

class ConstructionPoint(Base):
    r"""ConstructionPoint Object"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionPoint *":
        return _fusion.ConstructionPoint___deref__(self)

    def __eq__(self, rhs: "ConstructionPoint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionPoint___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionPoint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionPoint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionPoint_classType()
    __swig_destroy__ = _fusion.delete_ConstructionPoint

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""
        Returns a Point3D object that represents the position of the construction point.
        The returned geometry is in the AssemblyContext of this ConstructionPoint.
        """
        return _fusion.ConstructionPoint__get_geometry(self)

    def _get_name(self) -> "std::string":
        r"""The name of the construction point as it is displayed in the browser."""
        return _fusion.ConstructionPoint__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""The name of the construction point as it is displayed in the browser."""
        return _fusion.ConstructionPoint__set_name(self, value)

    def _get_definition(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPointDefinition >":
        r"""
        Returns the construction point definition object which provides access to the 
        information defining the construction point.
        """
        return _fusion.ConstructionPoint__get_definition(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the construction point. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ConstructionPoint_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""
        Indicates if this construction point can be deleted. The base
        construction point cannot be deleted.
        """
        return _fusion.ConstructionPoint__get_isDeletable(self)

    def _get_isLightBulbOn(self) -> "bool":
        r"""
        Indicates if the light bulb (as displayed in the browser) is on.
        A construction point will only be visible if it's light bulb, and that of it's
        containing folder and parent component/s are also on.
        """
        return _fusion.ConstructionPoint__get_isLightBulbOn(self)

    def _set_isLightBulbOn(self, value: "bool") -> "bool":
        r"""
        Indicates if the light bulb (as displayed in the browser) is on.
        A construction point will only be visible if it's light bulb, and that of it's
        containing folder and parent component/s are also on.
        """
        return _fusion.ConstructionPoint__set_isLightBulbOn(self, value)

    def _get_isVisible(self) -> "bool":
        r"""
        Gets if the construction point is visible.
        This property is affected by the AssemblyContext of the construction point.
        """
        return _fusion.ConstructionPoint__get_isVisible(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the parent component or base feature. If both the design and the construction 
        point are parametric, the parent will be a component. If the design is parametric and 
        the construction point is not, the parent will be a base feature. If
        the design is not parametric the parent will be a component.
        """
        return _fusion.ConstructionPoint__get_parent(self)

    def _get_component(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the component this construction point belongs to."""
        return _fusion.ConstructionPoint__get_component(self)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if the construction point is parametric."""
        return _fusion.ConstructionPoint__get_isParametric(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this construction point."""
        return _fusion.ConstructionPoint__get_timelineObject(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ConstructionPoint__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >":
        r"""
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ConstructionPoint__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ConstructionPoint_createForAssemblyContext(self, occurrence)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this construction point is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ConstructionPoint__get_baseFeature(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this construction point."""
        return _fusion.ConstructionPoint__get_attributes(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of this construction point."""
        return _fusion.ConstructionPoint__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ConstructionPoint__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the ConstructionPoint object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same construction point.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.ConstructionPoint__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionPoint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionPoint__get_isValid(self)

# Register ConstructionPoint in _fusion:
_fusion.ConstructionPoint_swigregister(ConstructionPoint)

def ConstructionPoint_classType() -> "char const *":
    return _fusion.ConstructionPoint_classType()


ConstructionPoint.geometry = property(ConstructionPoint._get_geometry, doc="Returns a Point3D object that represents the position of the construction point.\nThe returned geometry is in the AssemblyContext of this ConstructionPoint.")


ConstructionPoint.name = property(ConstructionPoint._get_name, ConstructionPoint._set_name, doc="The name of the construction point as it is displayed in the browser.")


ConstructionPoint.definition = property(ConstructionPoint._get_definition, doc="Returns the construction point definition object which provides access to the\ninformation defining the construction point.")


ConstructionPoint.isDeletable = property(ConstructionPoint._get_isDeletable, doc="Indicates if this construction point can be deleted. The base\nconstruction point cannot be deleted.")


ConstructionPoint.isLightBulbOn = property(ConstructionPoint._get_isLightBulbOn, ConstructionPoint._set_isLightBulbOn, doc="Indicates if the light bulb (as displayed in the browser) is on.\nA construction point will only be visible if it's light bulb, and that of it's\ncontaining folder and parent component/s are also on.")


ConstructionPoint.isVisible = property(ConstructionPoint._get_isVisible, doc="Gets if the construction point is visible.\nThis property is affected by the AssemblyContext of the construction point.")


ConstructionPoint.parent = property(ConstructionPoint._get_parent, doc="Returns the parent component or base feature. If both the design and the construction\npoint are parametric, the parent will be a component. If the design is parametric and\nthe construction point is not, the parent will be a base feature. If\nthe design is not parametric the parent will be a component.")


ConstructionPoint.component = property(ConstructionPoint._get_component, doc="Returns the component this construction point belongs to.")


ConstructionPoint.isParametric = property(ConstructionPoint._get_isParametric, doc="Indicates if the construction point is parametric.")


ConstructionPoint.timelineObject = property(ConstructionPoint._get_timelineObject, doc="Returns the timeline object associated with this construction point.")


ConstructionPoint.assemblyContext = property(ConstructionPoint._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")


ConstructionPoint.nativeObject = property(ConstructionPoint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


ConstructionPoint.baseFeature = property(ConstructionPoint._get_baseFeature, doc="If this construction point is associated with a base feature, this property will return that base feature.\nIf it's not associated with a base feature, this property will return null.")


ConstructionPoint.attributes = property(ConstructionPoint._get_attributes, doc="Returns the collection of attributes associated with this construction point.")


ConstructionPoint.healthState = property(ConstructionPoint._get_healthState, doc="Returns the current health state of this construction point.")


ConstructionPoint.errorOrWarningMessage = property(ConstructionPoint._get_errorOrWarningMessage, doc="Returns the error or warning message in the case where the healthState property returns either\nWarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.")


ConstructionPoint.entityToken = property(ConstructionPoint._get_entityToken, doc="Returns a token for the ConstructionPoint object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same construction point.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.")


ConstructionPoint.cast = lambda arg: arg if isinstance(arg, ConstructionPoint) else None

class ConstructionPointDefinition(Base):
    r"""
    A Base class to return the information (possibly parametric) used to 
    define a ConstructionPoint.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionPointDefinition *":
        return _fusion.ConstructionPointDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionPointDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionPointDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionPointDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionPointDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionPointDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionPointDefinition

    def _get_parentConstructionPoint(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >":
        r"""Returns the ConstructionPoint object"""
        return _fusion.ConstructionPointDefinition__get_parentConstructionPoint(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionPointDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionPointDefinition__get_isValid(self)

# Register ConstructionPointDefinition in _fusion:
_fusion.ConstructionPointDefinition_swigregister(ConstructionPointDefinition)

def ConstructionPointDefinition_classType() -> "char const *":
    return _fusion.ConstructionPointDefinition_classType()


ConstructionPointDefinition.parentConstructionPoint = property(ConstructionPointDefinition._get_parentConstructionPoint, doc="Returns the ConstructionPoint object")


ConstructionPointDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPointDefinition) else None

class ConstructionPointInput(Base):
    r"""
    A ConstructionPointInput is a throwaway object used to create a ConstructionPoint
    The usage pattern is 
    a. create a ConstructionPointInput (ConstructionPoints.CreateInput)
    b. call one of the member functions to specify how the ConstructionPoint is created
    c. create the ConstructionPoint (call ConstructionPoints.Add)
    d. stop referencing the ConstructionPointInput (so it gets deleted).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionPointInput *":
        return _fusion.ConstructionPointInput___deref__(self)

    def __eq__(self, rhs: "ConstructionPointInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionPointInput___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionPointInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionPointInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionPointInput_classType()
    __swig_destroy__ = _fusion.delete_ConstructionPointInput

    def setByTwoEdges(self, edgeOne: "Base", edgeTwo: "Base") -> "bool":
        r"""
        This input method is for creating a construction point at the intersection of 
        the two linear edges or sketch lines.
        The edges can be B-Rep edges or sketch lines.
        This can result in a parametric or non-parametric construction point depending 
        on whether the parent component is parametric or is a direct edit component. 
        edgeOne : The first B-Rep edge or sketch line 
        edgeTwo : The second B-Rep edge or sketch line 
        Returns true if the creation of the ConstructionPointInput is successful.
        """
        return _fusion.ConstructionPointInput_setByTwoEdges(self, edgeOne, edgeTwo)

    def setByThreePlanes(self, planeOne: "Base", planeTwo: "Base", planeThree: "Base") -> "bool":
        r"""
        This input method is for creating a construction point at the intersection of the 
        three planes or planar faces.
        This can result in a parametric or non-parametric construction point depending 
        on whether the parent component is parametric or is a direct edit component. 
        planeOne : The first plane or planar face to intersect 
        planeTwo : The second plane or planar face to intersect 
        planeThree : The third plane or planar face to intersect 
        Returns true if the creation of the ConstructionPointInput is successful.
        """
        return _fusion.ConstructionPointInput_setByThreePlanes(self, planeOne, planeTwo, planeThree)

    def setByEdgePlane(self, edge: "Base", plane: "Base") -> "bool":
        r"""
        This input method is for creating a construction point at the intersection of a 
        construction plane, planar face or sketch profile and a linear edge, construction axis
        or sketch line. 
        This can result in a parametric or non-parametric construction point depending 
        on whether the parent component is parametric or is a direct edit component. 
        edge : A linear B-Rep edge, construction axis or sketch line. 
        plane : A plane, planar B-Rep face or construction plane. 
        Returns true if the creation of the ConstructionPointInput is successful.
        """
        return _fusion.ConstructionPointInput_setByEdgePlane(self, edge, plane)

    def setByCenter(self, circularEntity: "Base") -> "bool":
        r"""
        This input method is for creating a construction point at the center of a spherical
        face (sphere or torus), circular edge or sketch arc/circle
        This can result in a parametric or non-parametric construction point depending 
        on whether the parent component is parametric or is a direct edit component. 
        circularEntity : A spherical face (sphere or torus), circular edge or sketch arc/circle 
        Returns true if the creation of the ConstructionPointInput is successful.
        """
        return _fusion.ConstructionPointInput_setByCenter(self, circularEntity)

    def setByPoint(self, point: "Base") -> "bool":
        r"""
        This input method is for creating a construction point on the specified point
        or vertex. The point can be either a B-Rep vertex, SketchPoint, or a Point3D object. 
        Providing a Point3D object is only valid when working in a direct edit model (do not capture design history).
        This is not valid when working in a parametric model and will fail.
        Even when providing a B-Rep vertex, or SketchPoint the result will be non-parametric 
        if the parent component is a direct edit component. 
        point : A B-Rep vertex, SketchPoint, or Point object 
        Returns true if the creation of the ConstructionPointInput is successful.
        """
        return _fusion.ConstructionPointInput_setByPoint(self, point)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        In order for geometry to be transformed correctly, an occurrence for creation needs 
        to be specified when the ConstructionPoint is created based on geometry
        (e.g. a sketch point) in another component AND (the ConstructionPoint) is not in the 
        root component. The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.ConstructionPointInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, value: "Occurrence") -> "bool":
        r"""
        In order for geometry to be transformed correctly, an occurrence for creation needs 
        to be specified when the ConstructionPoint is created based on geometry
        (e.g. a sketch point) in another component AND (the ConstructionPoint) is not in the 
        root component. The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.ConstructionPointInput__set_creationOccurrence(self, value)

    def _get_targetBaseOrFormFeature(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        When creating a construction point that is owned by a base or form feature, set this property to the 
        base or form feature you want to associate the new construction point with. By default, this is null,
        meaning it will not be associated with a base or form feature.
        Because of a current limitation, if you want to create a construction point associated with a base
        or form feature, you must set this property AND call the edit method of the base or form feature,
        create the feature, and then call the finishEdit method of the base or form feature. The base or form
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ConstructionPointInput__get_targetBaseOrFormFeature(self)

    def _set_targetBaseOrFormFeature(self, value: "Base") -> "bool":
        r"""
        When creating a construction point that is owned by a base or form feature, set this property to the 
        base or form feature you want to associate the new construction point with. By default, this is null,
        meaning it will not be associated with a base or form feature.
        Because of a current limitation, if you want to create a construction point associated with a base
        or form feature, you must set this property AND call the edit method of the base or form feature,
        create the feature, and then call the finishEdit method of the base or form feature. The base or form
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ConstructionPointInput__set_targetBaseOrFormFeature(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionPointInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionPointInput__get_isValid(self)

# Register ConstructionPointInput in _fusion:
_fusion.ConstructionPointInput_swigregister(ConstructionPointInput)

def ConstructionPointInput_classType() -> "char const *":
    return _fusion.ConstructionPointInput_classType()


ConstructionPointInput.creationOccurrence = property(ConstructionPointInput._get_creationOccurrence, ConstructionPointInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an occurrence for creation needs\nto be specified when the ConstructionPoint is created based on geometry\n(e.g. a sketch point) in another component AND (the ConstructionPoint) is not in the\nroot component. The CreationOccurrence is analogous to the active occurrence in the UI")


ConstructionPointInput.targetBaseOrFormFeature = property(ConstructionPointInput._get_targetBaseOrFormFeature, ConstructionPointInput._set_targetBaseOrFormFeature, doc="When creating a construction point that is owned by a base or form feature, set this property to the\nbase or form feature you want to associate the new construction point with. By default, this is null,\nmeaning it will not be associated with a base or form feature.\nBecause of a current limitation, if you want to create a construction point associated with a base\nor form feature, you must set this property AND call the edit method of the base or form feature,\ncreate the feature, and then call the finishEdit method of the base or form feature. The base or form\nfeature must be in an 'edit' state to be able to add any additional items to it.")


ConstructionPointInput.cast = lambda arg: arg if isinstance(arg, ConstructionPointInput) else None

class ConstructionPoints(Base):
    r"""
    Provides access to the construction points within a component and provides 
    methods to create new construction points.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionPoints *":
        return _fusion.ConstructionPoints___deref__(self)

    def __eq__(self, rhs: "ConstructionPoints") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionPoints___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionPoints") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionPoints___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.ConstructionPoints___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.ConstructionPoints___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionPoints_classType()
    __swig_destroy__ = _fusion.delete_ConstructionPoints

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >":
        r"""
        Function that returns the specified construction point using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ConstructionPoints_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >":
        r"""
        Returns the specified construction point using the name of the construction
        point as it is displayed in the browser. 
        name : The name of the construction point as it is displayed in the browser. 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.ConstructionPoints_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of construction points in the collection."""
        return _fusion.ConstructionPoints__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConstructionPointInput >":
        r"""
        Create a ConstructionPointInput object that is in turn used
        to create a ConstructionPoint. 
        occurrenceForCreation : A creation occurrence is needed if the input is in another component AND the 
        construction point is not in the root component. The occurrenceForCreation is analogous 
        to the active occurrence in the UI. 
        Returns a ConstructionPointInput object
        """
        return _fusion.ConstructionPoints_createInput(self, *args)

    def add(self, input: "ConstructionPointInput") -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >":
        r"""
        Creates a new construction point.
        If the ConstructionPointInput was defined using the setByPoint method using a Point3D object then
        the add will only work in a direct edit model (do not capture design history) and will fail in a parametric model. 
        input : A ConstructionPointInput object 
        Returns the newly created construction point or null if the creation failed.
        """
        return _fusion.ConstructionPoints_add(self, input)

    def _get_component(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""The component that owns this collection."""
        return _fusion.ConstructionPoints__get_component(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionPoints__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionPoints__get_isValid(self)

# Register ConstructionPoints in _fusion:
_fusion.ConstructionPoints_swigregister(ConstructionPoints)

def ConstructionPoints_classType() -> "char const *":
    return _fusion.ConstructionPoints_classType()


ConstructionPoints.count = property(ConstructionPoints._get_count, doc="The number of construction points in the collection.")


ConstructionPoints.component = property(ConstructionPoints._get_component, doc="The component that owns this collection.")


ConstructionPoints.cast = lambda arg: arg if isinstance(arg, ConstructionPoints) else None

class ContactSet(Base):
    r"""Represents a contact set in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ContactSet *":
        return _fusion.ContactSet___deref__(self)

    def __eq__(self, rhs: "ContactSet") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ContactSet___eq__(self, rhs)


    def __ne__(self, rhs: "ContactSet") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ContactSet___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ContactSet_classType()
    __swig_destroy__ = _fusion.delete_ContactSet

    def _get_name(self) -> "std::string":
        r"""Gets and sets the name of the contact set."""
        return _fusion.ContactSet__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the name of the contact set."""
        return _fusion.ContactSet__set_name(self, value)

    def _get_occurencesAndBodies(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base >,std::allocator< adsk::core::Ptr< adsk::core::Base > > >":
        r"""Gets and sets the group of Occurrence and/or BRepBody objects that are part of this contact set."""
        return _fusion.ContactSet__get_occurencesAndBodies(self)

    def _set_occurencesAndBodies(self, value: "BaseVector") -> "bool":
        r"""Gets and sets the group of Occurrence and/or BRepBody objects that are part of this contact set."""
        return _fusion.ContactSet__set_occurencesAndBodies(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this contact set from the design. 
        Returns true if the delete was succcessful.
        """
        return _fusion.ContactSet_deleteMe(self)

    def _get_isSuppressed(self) -> "bool":
        r"""Gets and sets if this contact set is currently suppressed."""
        return _fusion.ContactSet__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""Gets and sets if this contact set is currently suppressed."""
        return _fusion.ContactSet__set_isSuppressed(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.ContactSet__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ContactSet__get_isValid(self)

# Register ContactSet in _fusion:
_fusion.ContactSet_swigregister(ContactSet)

def ContactSet_classType() -> "char const *":
    return _fusion.ContactSet_classType()


ContactSet.name = property(ContactSet._get_name, ContactSet._set_name, doc="Gets and sets the name of the contact set.")


ContactSet.occurencesAndBodies = property(ContactSet._get_occurencesAndBodies, ContactSet._set_occurencesAndBodies, doc="Gets and sets the group of Occurrence and/or BRepBody objects that are part of this contact set.")


ContactSet.isSuppressed = property(ContactSet._get_isSuppressed, ContactSet._set_isSuppressed, doc="Gets and sets if this contact set is currently suppressed.")


ContactSet.cast = lambda arg: arg if isinstance(arg, ContactSet) else None

class ContactSets(Base):
    r"""Provides access to the existing contact sets in a design and supports creating new contact sets."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ContactSets *":
        return _fusion.ContactSets___deref__(self)

    def __eq__(self, rhs: "ContactSets") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ContactSets___eq__(self, rhs)


    def __ne__(self, rhs: "ContactSets") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ContactSets___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.ContactSets___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::ContactSet >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.ContactSets___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ContactSets_classType()
    __swig_destroy__ = _fusion.delete_ContactSets

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::ContactSet >":
        r"""
        Returns the specified contact set using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ContactSets_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::ContactSet >":
        r"""name :"""
        return _fusion.ContactSets_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""Returns the number of contacts sets in the design."""
        return _fusion.ContactSets__get_count(self)

    def add(self, occurrencesAndBodies: "BaseVector") -> "adsk::core::Ptr< adsk::fusion::ContactSet >":
        r"""
        Creates a new contact set for the provided occurrences and/or bodies. 
        occurrencesAndBodies : An array of Occurrence or BRepBody objects that will be included in the contact set.
        All occurrences and bodies must be in the context of the root component. 
        Returns the newly created ContactSet or null in the case of failure.
        """
        return _fusion.ContactSets_add(self, occurrencesAndBodies)

    def _get_objectType(self) -> "char const *":
        return _fusion.ContactSets__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ContactSets__get_isValid(self)

# Register ContactSets in _fusion:
_fusion.ContactSets_swigregister(ContactSets)

def ContactSets_classType() -> "char const *":
    return _fusion.ContactSets_classType()


ContactSets.count = property(ContactSets._get_count, doc="Returns the number of contacts sets in the design.")


ContactSets.cast = lambda arg: arg if isinstance(arg, ContactSets) else None

class CopyPasteBodies(Base):
    r"""
    Collection that provides access to all of the existing copy-paste features in a design.
    These are created in the UI by copying and then pasting a B-Rep body.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CopyPasteBodies *":
        return _fusion.CopyPasteBodies___deref__(self)

    def __eq__(self, rhs: "CopyPasteBodies") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CopyPasteBodies___eq__(self, rhs)


    def __ne__(self, rhs: "CopyPasteBodies") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CopyPasteBodies___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.CopyPasteBodies___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::CopyPasteBody >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.CopyPasteBodies___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CopyPasteBodies_classType()
    __swig_destroy__ = _fusion.delete_CopyPasteBodies

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::CopyPasteBody >":
        r"""
        Function that returns the specified Copy/Paste Body feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.CopyPasteBodies_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::CopyPasteBody >":
        r"""
        Function that returns the specified Copy/Paste Body feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.CopyPasteBodies_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of Copy/Paste Body features in the collection."""
        return _fusion.CopyPasteBodies__get_count(self)

    def add(self, sourceBody: "Base") -> "adsk::core::Ptr< adsk::fusion::CopyPasteBody >":
        r"""
        Copies the specified body into the component that owns this CopyPasteBodies collection. 
        sourceBody : Either an ObjectCollection of BRepBodies or a single BRepBody object to copy. 
        Returns the newly created BRepBody object or null in the case of failure.
        """
        return _fusion.CopyPasteBodies_add(self, sourceBody)

    def _get_objectType(self) -> "char const *":
        return _fusion.CopyPasteBodies__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CopyPasteBodies__get_isValid(self)

# Register CopyPasteBodies in _fusion:
_fusion.CopyPasteBodies_swigregister(CopyPasteBodies)

def CopyPasteBodies_classType() -> "char const *":
    return _fusion.CopyPasteBodies_classType()


CopyPasteBodies.count = property(CopyPasteBodies._get_count, doc="The number of Copy/Paste Body features in the collection.")


CopyPasteBodies.cast = lambda arg: arg if isinstance(arg, CopyPasteBodies) else None

class CustomFeatureDefinition(Base):
    r"""
    The CustomFeatureDefinition object defines a specific type of custom feature. It contains
    the settings that apply to all custom features of that type and is used when creating new
    custom features of that type. It also supports the events used to handle changes to custom
    features of that type.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomFeatureDefinition *":
        return _fusion.CustomFeatureDefinition___deref__(self)

    def __eq__(self, rhs: "CustomFeatureDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomFeatureDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "CustomFeatureDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomFeatureDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomFeatureDefinition_classType()

    @staticmethod
    def create(id: "std::string const &", defaultName: "std::string const &", iconFolder: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::CustomFeatureDefinition >":
        return _fusion.CustomFeatureDefinition_create(id, defaultName, iconFolder)
    __swig_destroy__ = _fusion.delete_CustomFeatureDefinition

    def _get_id(self) -> "std::string":
        r"""Gets the unique ID used for this type of custom feature."""
        return _fusion.CustomFeatureDefinition__get_id(self)

    def _get_iconFolder(self) -> "std::string":
        r"""
        Gets and sets the folder that contains the images that are used for the icon in the timeline for 
        this custom feature. The folder should contain the image files named 16x16.png and 32x32.png 
        which should be images that are 16 and 32 pixels square.
        """
        return _fusion.CustomFeatureDefinition__get_iconFolder(self)

    def _set_iconFolder(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the folder that contains the images that are used for the icon in the timeline for 
        this custom feature. The folder should contain the image files named 16x16.png and 32x32.png 
        which should be images that are 16 and 32 pixels square.
        """
        return _fusion.CustomFeatureDefinition__set_iconFolder(self, value)

    def _get_defaultName(self) -> "std::string":
        r"""
        Gets and sets the default name of the feature. Fusion will use this name and append a number
        to each feature instance as it's created. For example, if this is 'Dovetail' the first 
        custom feature created will be named 'Dovetail1' and the second will be 'Dovetail2'.
        If you want to localize this name you can use the Application.Preferences.generalPreferences.userLanguage
        property to determine what language the user has chosen and use the corresponding name for that language.
        """
        return _fusion.CustomFeatureDefinition__get_defaultName(self)

    def _set_defaultName(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the default name of the feature. Fusion will use this name and append a number
        to each feature instance as it's created. For example, if this is 'Dovetail' the first 
        custom feature created will be named 'Dovetail1' and the second will be 'Dovetail2'.
        If you want to localize this name you can use the Application.Preferences.generalPreferences.userLanguage
        property to determine what language the user has chosen and use the corresponding name for that language.
        """
        return _fusion.CustomFeatureDefinition__set_defaultName(self, value)

    def _get_editCommandId(self) -> "std::string":
        r"""
        Gets and sets which command will be invoked when the feature is edited. This is the id of the 
        CommandDefinition object that you have created to do the edit of the feature.
        """
        return _fusion.CustomFeatureDefinition__get_editCommandId(self)

    def _set_editCommandId(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets which command will be invoked when the feature is edited. This is the id of the 
        CommandDefinition object that you have created to do the edit of the feature.
        """
        return _fusion.CustomFeatureDefinition__set_editCommandId(self, value)

    def _get_customFeatureCompute(self) -> "adsk::core::Ptr< adsk::fusion::CustomFeatureEvent >":
        r"""
        The customFeatureCompute event fires when Fusion is computing the timeline and reaches
        the custom feature. The event is fired if any of the dependencies of the custom feature 
        have changed. You can modify the results of your custom feature based on the dependencies.
        """
        return _fusion.CustomFeatureDefinition__get_customFeatureCompute(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomFeatureDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomFeatureDefinition__get_isValid(self)

# Register CustomFeatureDefinition in _fusion:
_fusion.CustomFeatureDefinition_swigregister(CustomFeatureDefinition)

def CustomFeatureDefinition_classType() -> "char const *":
    return _fusion.CustomFeatureDefinition_classType()

def CustomFeatureDefinition_create(id: "std::string const &", defaultName: "std::string const &", iconFolder: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::CustomFeatureDefinition >":
    return _fusion.CustomFeatureDefinition_create(id, defaultName, iconFolder)


CustomFeatureDefinition.id = property(CustomFeatureDefinition._get_id, doc="Gets the unique ID used for this type of custom feature.")


CustomFeatureDefinition.iconFolder = property(CustomFeatureDefinition._get_iconFolder, CustomFeatureDefinition._set_iconFolder, doc="Gets and sets the folder that contains the images that are used for the icon in the timeline for\nthis custom feature. The folder should contain the image files named 16x16.png and 32x32.png\nwhich should be images that are 16 and 32 pixels square.")


CustomFeatureDefinition.defaultName = property(CustomFeatureDefinition._get_defaultName, CustomFeatureDefinition._set_defaultName, doc="Gets and sets the default name of the feature. Fusion will use this name and append a number\nto each feature instance as it's created. For example, if this is 'Dovetail' the first\ncustom feature created will be named 'Dovetail1' and the second will be 'Dovetail2'.\nIf you want to localize this name you can use the Application.Preferences.generalPreferences.userLanguage\nproperty to determine what language the user has chosen and use the corresponding name for that language.")


CustomFeatureDefinition.editCommandId = property(CustomFeatureDefinition._get_editCommandId, CustomFeatureDefinition._set_editCommandId, doc="Gets and sets which command will be invoked when the feature is edited. This is the id of the\nCommandDefinition object that you have created to do the edit of the feature.")


CustomFeatureDefinition.customFeatureCompute = property(CustomFeatureDefinition._get_customFeatureCompute, doc="The customFeatureCompute event fires when Fusion is computing the timeline and reaches\nthe custom feature. The event is fired if any of the dependencies of the custom feature\nhave changed. You can modify the results of your custom feature based on the dependencies.")


CustomFeatureDefinition.cast = lambda arg: arg if isinstance(arg, CustomFeatureDefinition) else None

class CustomFeatureDependencies(Base):
    r"""
    A collection of dependencies associated with a particular custom feature. These
    are the entities that the custom feature is dependent on. If these entities are
    modified, it will cause the custom feature to recompute so it can be up to date.
    These dependencies are saved with the custom feature and can be accessed at a
    later time, typically during the compute, to access and use the entities.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomFeatureDependencies *":
        return _fusion.CustomFeatureDependencies___deref__(self)

    def __eq__(self, rhs: "CustomFeatureDependencies") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomFeatureDependencies___eq__(self, rhs)


    def __ne__(self, rhs: "CustomFeatureDependencies") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomFeatureDependencies___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.CustomFeatureDependencies___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::CustomFeatureDependency >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.CustomFeatureDependencies___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomFeatureDependencies_classType()
    __swig_destroy__ = _fusion.delete_CustomFeatureDependencies

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::CustomFeatureDependency >":
        r"""
        Function that returns the specified custom dependency using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.CustomFeatureDependencies_item(self, index)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::CustomFeatureDependency >":
        r"""
        Function that returns the specified custom dependency given its ID. 
        id : The ID of the dependency, which was assigned when the dependency was defined. 
        Returns the specified item or null if the specified ID was not found.
        """
        return _fusion.CustomFeatureDependencies_itemById(self, id)

    def _get_count(self) -> "size_t":
        r"""The number of CustomFeatureParameter objects in the collection."""
        return _fusion.CustomFeatureDependencies__get_count(self)

    def add(self, id: "std::string const &", entity: "Base") -> "adsk::core::Ptr< adsk::fusion::CustomFeatureDependency >":
        r"""
        Adds an entity or parameter that this feature is dependent on. This is used by Fusion to know
        when to recompute this feature and to control the behavior of the feature's node in the timeline. 
        id : An ID for this dependency. This is used to allow you to identify which dependency is which in the future.
        The ID must be unique with respect to the other dependencies of this custom feature. 
        entity : The entity or parameter you want to add as a dependency. This can be a BRepBody, BRepFace, BrepEdge,
        BRepVertex, a sketch, any sketch entities, a profile, any construction geometry, or any parameter. 
        Returns the created CustomFeatureDependency object and asserts if it failed.
        """
        return _fusion.CustomFeatureDependencies_add(self, id, entity)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomFeatureDependencies__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomFeatureDependencies__get_isValid(self)

# Register CustomFeatureDependencies in _fusion:
_fusion.CustomFeatureDependencies_swigregister(CustomFeatureDependencies)

def CustomFeatureDependencies_classType() -> "char const *":
    return _fusion.CustomFeatureDependencies_classType()


CustomFeatureDependencies.count = property(CustomFeatureDependencies._get_count, doc="The number of CustomFeatureParameter objects in the collection.")


CustomFeatureDependencies.cast = lambda arg: arg if isinstance(arg, CustomFeatureDependencies) else None

class CustomFeatureDependency(Base):
    r"""
    A custom feature dependency defines a dependency the custom feature has on an entity
    outside the custom feature. For example, a feature might be dependent on a face or a
    point and if those entities are modified the custom feature needs to recompute to be 
    up to date.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomFeatureDependency *":
        return _fusion.CustomFeatureDependency___deref__(self)

    def __eq__(self, rhs: "CustomFeatureDependency") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomFeatureDependency___eq__(self, rhs)


    def __ne__(self, rhs: "CustomFeatureDependency") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomFeatureDependency___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomFeatureDependency_classType()
    __swig_destroy__ = _fusion.delete_CustomFeatureDependency

    def _get_id(self) -> "std::string":
        r"""Returns the ID of this custom feature dependency."""
        return _fusion.CustomFeatureDependency__get_id(self)

    def _get_entity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets and sets the entity associated with this dependency."""
        return _fusion.CustomFeatureDependency__get_entity(self)

    def _set_entity(self, value: "Base") -> "bool":
        r"""Gets and sets the entity associated with this dependency."""
        return _fusion.CustomFeatureDependency__set_entity(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Delets this dependency from the custom feature. 
        Returns true if the delete was successful.
        """
        return _fusion.CustomFeatureDependency_deleteMe(self)

    def _get_parentCustomFeature(self) -> "adsk::core::Ptr< adsk::fusion::CustomFeature >":
        r"""Returns the custom feature this dependency is associated with."""
        return _fusion.CustomFeatureDependency__get_parentCustomFeature(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomFeatureDependency__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomFeatureDependency__get_isValid(self)

# Register CustomFeatureDependency in _fusion:
_fusion.CustomFeatureDependency_swigregister(CustomFeatureDependency)

def CustomFeatureDependency_classType() -> "char const *":
    return _fusion.CustomFeatureDependency_classType()


CustomFeatureDependency.id = property(CustomFeatureDependency._get_id, doc="Returns the ID of this custom feature dependency.")


CustomFeatureDependency.entity = property(CustomFeatureDependency._get_entity, CustomFeatureDependency._set_entity, doc="Gets and sets the entity associated with this dependency.")


CustomFeatureDependency.parentCustomFeature = property(CustomFeatureDependency._get_parentCustomFeature, doc="Returns the custom feature this dependency is associated with.")


CustomFeatureDependency.cast = lambda arg: arg if isinstance(arg, CustomFeatureDependency) else None

class CustomFeatureEvent(adsk.core.Event):
    r"""A CustomFeature event is an event associated with handling changes to a custom feature."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomFeatureEvent *":
        return _fusion.CustomFeatureEvent___deref__(self)

    def __eq__(self, rhs: "CustomFeatureEvent") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomFeatureEvent___eq__(self, rhs)


    def __ne__(self, rhs: "CustomFeatureEvent") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomFeatureEvent___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomFeatureEvent_classType()
    __swig_destroy__ = _fusion.delete_CustomFeatureEvent

    def add(self, handler: "CustomFeatureEventHandler") -> "bool":
        r"""
        Add a handler to be notified when the file event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _fusion.CustomFeatureEvent_add(self, handler)

    def remove(self, handler: "CustomFeatureEventHandler") -> "bool":
        r"""
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _fusion.CustomFeatureEvent_remove(self, handler)

    def _get_name(self) -> "std::string":
        r"""The name of the event - e.g. 'DocumentOpening'"""
        return _fusion.CustomFeatureEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _fusion.CustomFeatureEvent__get_sender(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomFeatureEvent__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomFeatureEvent__get_isValid(self)

# Register CustomFeatureEvent in _fusion:
_fusion.CustomFeatureEvent_swigregister(CustomFeatureEvent)

def CustomFeatureEvent_classType() -> "char const *":
    return _fusion.CustomFeatureEvent_classType()


CustomFeatureEvent.cast = lambda arg: arg if isinstance(arg, CustomFeatureEvent) else None

class CustomFeatureEventArgs(adsk.core.EventArgs):
    r"""The CustomFeatureEventArgs provides information associated with a custom feature event."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomFeatureEventArgs *":
        return _fusion.CustomFeatureEventArgs___deref__(self)

    def __eq__(self, rhs: "CustomFeatureEventArgs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomFeatureEventArgs___eq__(self, rhs)


    def __ne__(self, rhs: "CustomFeatureEventArgs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomFeatureEventArgs___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomFeatureEventArgs_classType()
    __swig_destroy__ = _fusion.delete_CustomFeatureEventArgs

    def _get_customFeature(self) -> "adsk::core::Ptr< adsk::fusion::CustomFeature >":
        r"""Provides access to the custom feature that is being recomputed."""
        return _fusion.CustomFeatureEventArgs__get_customFeature(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >":
        r"""The event that the firing is in response to."""
        return _fusion.CustomFeatureEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomFeatureEventArgs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomFeatureEventArgs__get_isValid(self)

# Register CustomFeatureEventArgs in _fusion:
_fusion.CustomFeatureEventArgs_swigregister(CustomFeatureEventArgs)

def CustomFeatureEventArgs_classType() -> "char const *":
    return _fusion.CustomFeatureEventArgs_classType()


CustomFeatureEventArgs.customFeature = property(CustomFeatureEventArgs._get_customFeature, doc="Provides access to the custom feature that is being recomputed.")


CustomFeatureEventArgs.cast = lambda arg: arg if isinstance(arg, CustomFeatureEventArgs) else None

class CustomFeatureEventHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notify(self, eventArgs: "CustomFeatureEventArgs") -> "void":
        return _fusion.CustomFeatureEventHandler_notify(self, eventArgs)

    def __init__(self):
        if self.__class__ == CustomFeatureEventHandler:
            _self = None
        else:
            _self = self
        _fusion.CustomFeatureEventHandler_swiginit(self, _fusion.new_CustomFeatureEventHandler(_self, ))
    __swig_destroy__ = _fusion.delete_CustomFeatureEventHandler
    def __disown__(self):
        self.this.disown()
        _fusion.disown_CustomFeatureEventHandler(self)
        return weakref.proxy(self)

# Register CustomFeatureEventHandler in _fusion:
_fusion.CustomFeatureEventHandler_swigregister(CustomFeatureEventHandler)


CustomFeatureEventHandler.cast = lambda arg: arg if isinstance(arg, CustomFeatureEventHandler) else None

class CustomFeatureInput(Base):
    r"""This class defines the methods and properties that pertain to the definition of a Ruled Surface feature."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomFeatureInput *":
        return _fusion.CustomFeatureInput___deref__(self)

    def __eq__(self, rhs: "CustomFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "CustomFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_CustomFeatureInput

    def addDependency(self, id: "std::string const &", entity: "Base") -> "bool":
        r"""
        Adds an entity or parameter this feature is dependent on. This is used by Fusion to know
        when to recompute this feature and to control the behavior of the feature's node in the timeline. 
        id : An ID for this dependency. This is used to allow you to identify which dependency is which in the future.
        The ID must be unique with respect to the other dependencies of this custom feature. 
        entity : The entity or parameter you want to add as a dependency. This can be a BRepBody, BRepFace, BrepEdge,
        BRepVertex, a sketch, any sketch entities, a profile, any construction geometry, or any parameter. 
        Returns true if the dependency was successfully added.
        """
        return _fusion.CustomFeatureInput_addDependency(self, id, entity)

    def addCustomParameter(self, id: "std::string const &", label: "std::string const &", value: "ValueInput", units: "std::string const &", isVisible: "bool"=True) -> "bool":
        r"""
        Defines the information needed to create a new custom parameter that will be associated with
        this feature. A custom parameter appears as a model parameter and will be listed as a child of the 
        custom feature in the parameter dialog. The custom feature will automatically have a dependency 
        on this parameter. 
        id : An id for this parameter. This is used to allow you to idenfity the parameter in the future. This
        must be unique with respect to all other parameters associated with this custom feature. It's needed
        because the label does not need to be unique and the Fusion auto-generated name can be edited by
        the user. 
        label : The label for this parameter as seen in the parameters dialog. This identifies to the user the purpose
        of this parameter. For example, when you create an extrusion with a specific distance, there are two
        parameters displayed in the parameters dialog with the labels 'AlongDistance' and 'TaperAngle'. This does
        not have to be unique because in the case of a fillet feature there can be multiple parameters all labeled 'Radius'. 
        value : ValueInput object that specifies the value of the parameter. If the ValueInput was created using a real, 
        the value will be interpreted using the internal unit for the unit type specified by the 'units' argument. 
        For example, if the ValueInput was created using the real value 5 and the input to the 'units' argument is 
        any valid length unit, the value will be interpreted as 5 centimeters since centimeters is the internal unit
        for lengths. If the 'units' argument is a valid angle unit the value will be interpreted as 5 radians.
        If the ValueInput was created using a string, the string is used as-is for the expression of the parameter.
        This means if there are units as part of the string it must evaluate to the same unit type as that specified 
        by the 'units' argument and if no units are specified it will use the current default units specified for 
        the current document. For example, if the ValueInput was created with the string '5 in', then the 'units' 
        argument must define any valid length so it is compatible. If the ValueInput was created with the string '5',
        any unit type can be used and the result will be 5 of that unit.
        When using a ValueInput created using a string, it's the same as creating a parameter in the user-interface.
        You can specify any valid expression, i.e. '5', '5 in', '5 in / 2', '5 + Length', etc. and you can choose 
        from many different types of units. The only requirement is that the units must match in type. For example, 
        they must both be lengths, or they must both be angles. 
        units : The units to use for the value of the parameter. Units specified must match the units specified (if any) 
        in the ValueInput object.
        To create a parameter with no units (unitless) you can specify either an empty string. 
        isVisible : Optional argument that specifies if the parameter will be visible in the parameters dialog or not. By
        default the parameter will be visible. 
        This can be useful in cases where the feature can be edited to be in different states where a parameter 
        is only valid in a certain state. You can change the visibility based on the current state of the feature 
        and if that parameter should be available for edit. This implies that you create all the parameters that
        might be needed and then change their visibility based on the current state of the feature. The parameters
        that are not visible will not be returned by the ModelParameters collection and are only available through
        the custom feature they're associated with. 
        Returns true if the definition of the model parameter was successfully added.
        """
        return _fusion.CustomFeatureInput_addCustomParameter(self, id, label, value, units, isVisible)

    def _get_startFeature(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the first feature in the timeline that will be part of the custom feature. This can be a
        any entity type that is represented by a node in the timeline. The most common are features, construction
        points, axes, and planes, and sketches.
        """
        return _fusion.CustomFeatureInput__get_startFeature(self)

    def _set_startFeature(self, value: "Base") -> "bool":
        r"""
        Gets and sets the first feature in the timeline that will be part of the custom feature. This can be a
        any entity type that is represented by a node in the timeline. The most common are features, construction
        points, axes, and planes, and sketches.
        """
        return _fusion.CustomFeatureInput__set_startFeature(self, value)

    def _get_endFeature(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the last feature in the timeline that will be part of the custom feature. This can be a
        any entity type that is represented by a node in the timeline. The most common are features, construction
        points, axes, and planes, and sketches.
        """
        return _fusion.CustomFeatureInput__get_endFeature(self)

    def _set_endFeature(self, value: "Base") -> "bool":
        r"""
        Gets and sets the last feature in the timeline that will be part of the custom feature. This can be a
        any entity type that is represented by a node in the timeline. The most common are features, construction
        points, axes, and planes, and sketches.
        """
        return _fusion.CustomFeatureInput__set_endFeature(self, value)

    def _get_features(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base >,std::allocator< adsk::core::Ptr< adsk::core::Base > > >":
        r"""
        Returns the features combined by this custom feature. The start and end features and all of
        the features between them in the timeline are returned. This includes all entities represented in
        the timeline including modeling features, construction geometry, sketches, etc.
        """
        return _fusion.CustomFeatureInput__get_features(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomFeatureInput__get_isValid(self)

# Register CustomFeatureInput in _fusion:
_fusion.CustomFeatureInput_swigregister(CustomFeatureInput)

def CustomFeatureInput_classType() -> "char const *":
    return _fusion.CustomFeatureInput_classType()


CustomFeatureInput.startFeature = property(CustomFeatureInput._get_startFeature, CustomFeatureInput._set_startFeature, doc="Gets and sets the first feature in the timeline that will be part of the custom feature. This can be a\nany entity type that is represented by a node in the timeline. The most common are features, construction\npoints, axes, and planes, and sketches.")


CustomFeatureInput.endFeature = property(CustomFeatureInput._get_endFeature, CustomFeatureInput._set_endFeature, doc="Gets and sets the last feature in the timeline that will be part of the custom feature. This can be a\nany entity type that is represented by a node in the timeline. The most common are features, construction\npoints, axes, and planes, and sketches.")


CustomFeatureInput.features = property(CustomFeatureInput._get_features, doc="Returns the features combined by this custom feature. The start and end features and all of\nthe features between them in the timeline are returned. This includes all entities represented in\nthe timeline including modeling features, construction geometry, sketches, etc.")


CustomFeatureInput.cast = lambda arg: arg if isinstance(arg, CustomFeatureInput) else None

class CustomFeatureParameters(Base):
    r"""A collection of custom parameters associated with a particular custom feature."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomFeatureParameters *":
        return _fusion.CustomFeatureParameters___deref__(self)

    def __eq__(self, rhs: "CustomFeatureParameters") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomFeatureParameters___eq__(self, rhs)


    def __ne__(self, rhs: "CustomFeatureParameters") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomFeatureParameters___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.CustomFeatureParameters___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::CustomFeatureParameter >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.CustomFeatureParameters___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomFeatureParameters_classType()
    __swig_destroy__ = _fusion.delete_CustomFeatureParameters

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::CustomFeatureParameter >":
        r"""
        Function that returns the specified custom parameter feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.CustomFeatureParameters_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of CustomFeatureParameter objects in the collection."""
        return _fusion.CustomFeatureParameters__get_count(self)

    def itemById(self, id: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::CustomFeatureParameter >":
        r"""
        Function that returns the specified CustomParameter object given its ID. 
        id : The ID of the custom parameter, which was assigned when the parameter was defined and the custom feature was created. 
        Returns the specified item or null if the specified ID was not found.
        """
        return _fusion.CustomFeatureParameters_itemById(self, id)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomFeatureParameters__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomFeatureParameters__get_isValid(self)

# Register CustomFeatureParameters in _fusion:
_fusion.CustomFeatureParameters_swigregister(CustomFeatureParameters)

def CustomFeatureParameters_classType() -> "char const *":
    return _fusion.CustomFeatureParameters_classType()


CustomFeatureParameters.count = property(CustomFeatureParameters._get_count, doc="The number of CustomFeatureParameter objects in the collection.")


CustomFeatureParameters.cast = lambda arg: arg if isinstance(arg, CustomFeatureParameters) else None

class CustomFeatures(Base):
    r"""
    Collection that provides access to all of the existing custom features in a component
    and supports the ability to create new custom features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomFeatures *":
        return _fusion.CustomFeatures___deref__(self)

    def __eq__(self, rhs: "CustomFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "CustomFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.CustomFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::CustomFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.CustomFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomFeatures_classType()
    __swig_destroy__ = _fusion.delete_CustomFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::CustomFeature >":
        r"""
        Function that returns the specified ruled surface feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.CustomFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of CustomFeature objects in the collection."""
        return _fusion.CustomFeatures__get_count(self)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::CustomFeature >":
        r"""
        Function that returns the specified CustomFeature feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.CustomFeatures_itemByName(self, name)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::CustomFeatureInput >":
        r"""
        Creates a new input object to fully define a custom feature. This doesn't create the feature but gathers
        all of the input that is needed to create a custom feature. This is passed to the add method to finally
        create the feature. 
        definition : The CustomFeatureDefinition that specifies the type of custom feature that will be created and other information
        associated with that specific custom feature type. 
        startFeature : The optional first feature in the timeline that defines the start of the group of features that make up the custom feature.
        This is not limited to standard modeling features but can be any of the objects that are represented by a node 
        in the timeline. 
        endFeature : The optional last feature in the timeline that defines the end of the group of features that make up the custom feature.
        This is not limited to standard modeling features but can be any of the objects that are represented by a node 
        in the timeline. 
        Returns the newly created CustomFeatureInput object or it will fail in the case of invalid input.
        """
        return _fusion.CustomFeatures_createInput(self, *args)

    def add(self, input: "CustomFeatureInput") -> "adsk::core::Ptr< adsk::fusion::CustomFeature >":
        r"""
        Creates a new custom feature. 
        input : The CustomFeatureInput object that defines the information needed to create a custom feature. 
        Returns the newly created CustomFeature.
        """
        return _fusion.CustomFeatures_add(self, input)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomFeatures__get_isValid(self)

# Register CustomFeatures in _fusion:
_fusion.CustomFeatures_swigregister(CustomFeatures)

def CustomFeatures_classType() -> "char const *":
    return _fusion.CustomFeatures_classType()


CustomFeatures.count = property(CustomFeatures._get_count, doc="The number of CustomFeature objects in the collection.")


CustomFeatures.cast = lambda arg: arg if isinstance(arg, CustomFeatures) else None

class CustomGraphicsBillBoard(Base):
    r"""
    Used to specify if the orientation of custom graphics are defined relative to the screen instead of model space.
    This is commonly used for legends and symbols that you want to always face the user, even as the
    camera is rotated.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomGraphicsBillBoard *":
        return _fusion.CustomGraphicsBillBoard___deref__(self)

    def __eq__(self, rhs: "CustomGraphicsBillBoard") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomGraphicsBillBoard___eq__(self, rhs)


    def __ne__(self, rhs: "CustomGraphicsBillBoard") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomGraphicsBillBoard___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomGraphicsBillBoard_classType()

    @staticmethod
    def create(anchorPoint: "Point3D") -> "adsk::core::Ptr< adsk::core::Point3D > const &":
        return _fusion.CustomGraphicsBillBoard_create(anchorPoint)
    __swig_destroy__ = _fusion.delete_CustomGraphicsBillBoard

    def _get_anchorPoint(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""
        Specifies the coordinate in model or view space that the graphics will anchor to. For graphics that
        represent a label, this will typically be the point where the label attaches to the model. A
        CustomGraphicsAnchorPoint can be created using the static create method on the CustomGraphicsAnchorPoint
        object.
        """
        return _fusion.CustomGraphicsBillBoard__get_anchorPoint(self)

    def _set_anchorPoint(self, value: "Point3D") -> "bool":
        r"""
        Specifies the coordinate in model or view space that the graphics will anchor to. For graphics that
        represent a label, this will typically be the point where the label attaches to the model. A
        CustomGraphicsAnchorPoint can be created using the static create method on the CustomGraphicsAnchorPoint
        object.
        """
        return _fusion.CustomGraphicsBillBoard__set_anchorPoint(self, value)

    def _get_billBoardStyle(self) -> "adsk::fusion::CustomGraphicsBillBoardStyles":
        r"""
        Specifies the type of billboarding to use. When a new CustomGraphicsBillBoard object is created
        this defaults to ScreenBillBoardStyle so the graphics will all be facing the view plane. It can also 
        be set to an arbitrary plane by setting this to AxialBillBoardStyle and can be defined so that it never
        appear backwards by setting it to RightReadingBillBoardStyle.
        """
        return _fusion.CustomGraphicsBillBoard__get_billBoardStyle(self)

    def _set_billBoardStyle(self, value: "CustomGraphicsBillBoardStyles") -> "bool":
        r"""
        Specifies the type of billboarding to use. When a new CustomGraphicsBillBoard object is created
        this defaults to ScreenBillBoardStyle so the graphics will all be facing the view plane. It can also 
        be set to an arbitrary plane by setting this to AxialBillBoardStyle and can be defined so that it never
        appear backwards by setting it to RightReadingBillBoardStyle.
        """
        return _fusion.CustomGraphicsBillBoard__set_billBoardStyle(self, value)

    def _get_axis(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        When the billBoardStyle property is set to AxialBillBoardStyle, this is used to control the direction
        of the graphics. Otherwise it uses the x axis of the view.
        """
        return _fusion.CustomGraphicsBillBoard__get_axis(self)

    def _set_axis(self, value: "Vector3D") -> "bool":
        r"""
        When the billBoardStyle property is set to AxialBillBoardStyle, this is used to control the direction
        of the graphics. Otherwise it uses the x axis of the view.
        """
        return _fusion.CustomGraphicsBillBoard__set_axis(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomGraphicsBillBoard__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomGraphicsBillBoard__get_isValid(self)

# Register CustomGraphicsBillBoard in _fusion:
_fusion.CustomGraphicsBillBoard_swigregister(CustomGraphicsBillBoard)

def CustomGraphicsBillBoard_classType() -> "char const *":
    return _fusion.CustomGraphicsBillBoard_classType()

def CustomGraphicsBillBoard_create(anchorPoint: "Point3D") -> "adsk::core::Ptr< adsk::core::Point3D > const &":
    return _fusion.CustomGraphicsBillBoard_create(anchorPoint)


CustomGraphicsBillBoard.anchorPoint = property(CustomGraphicsBillBoard._get_anchorPoint, CustomGraphicsBillBoard._set_anchorPoint, doc="Specifies the coordinate in model or view space that the graphics will anchor to. For graphics that\nrepresent a label, this will typically be the point where the label attaches to the model. A\nCustomGraphicsAnchorPoint can be created using the static create method on the CustomGraphicsAnchorPoint\nobject.")


CustomGraphicsBillBoard.billBoardStyle = property(CustomGraphicsBillBoard._get_billBoardStyle, CustomGraphicsBillBoard._set_billBoardStyle, doc="Specifies the type of billboarding to use. When a new CustomGraphicsBillBoard object is created\nthis defaults to ScreenBillBoardStyle so the graphics will all be facing the view plane. It can also\nbe set to an arbitrary plane by setting this to AxialBillBoardStyle and can be defined so that it never\nappear backwards by setting it to RightReadingBillBoardStyle.")


CustomGraphicsBillBoard.axis = property(CustomGraphicsBillBoard._get_axis, CustomGraphicsBillBoard._set_axis, doc="When the billBoardStyle property is set to AxialBillBoardStyle, this is used to control the direction\nof the graphics. Otherwise it uses the x axis of the view.")


CustomGraphicsBillBoard.cast = lambda arg: arg if isinstance(arg, CustomGraphicsBillBoard) else None

class CustomGraphicsBRepEdges(Base):
    r"""A collection of CustomGraphicsBRepEdge objects associated with a specific CustomGraphics body object."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomGraphicsBRepEdges *":
        return _fusion.CustomGraphicsBRepEdges___deref__(self)

    def __eq__(self, rhs: "CustomGraphicsBRepEdges") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomGraphicsBRepEdges___eq__(self, rhs)


    def __ne__(self, rhs: "CustomGraphicsBRepEdges") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomGraphicsBRepEdges___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomGraphicsBRepEdges_classType()
    __swig_destroy__ = _fusion.delete_CustomGraphicsBRepEdges

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomGraphicsBRepEdges__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomGraphicsBRepEdges__get_isValid(self)

# Register CustomGraphicsBRepEdges in _fusion:
_fusion.CustomGraphicsBRepEdges_swigregister(CustomGraphicsBRepEdges)

def CustomGraphicsBRepEdges_classType() -> "char const *":
    return _fusion.CustomGraphicsBRepEdges_classType()


CustomGraphicsBRepEdges.cast = lambda arg: arg if isinstance(arg, CustomGraphicsBRepEdges) else None

class CustomGraphicsBRepFaces(Base):
    r"""A collection of CustomGraphicsBRepFace objects associated with a specific CustomGraphicsBRepBody object."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomGraphicsBRepFaces *":
        return _fusion.CustomGraphicsBRepFaces___deref__(self)

    def __eq__(self, rhs: "CustomGraphicsBRepFaces") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomGraphicsBRepFaces___eq__(self, rhs)


    def __ne__(self, rhs: "CustomGraphicsBRepFaces") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomGraphicsBRepFaces___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomGraphicsBRepFaces_classType()
    __swig_destroy__ = _fusion.delete_CustomGraphicsBRepFaces

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomGraphicsBRepFaces__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomGraphicsBRepFaces__get_isValid(self)

# Register CustomGraphicsBRepFaces in _fusion:
_fusion.CustomGraphicsBRepFaces_swigregister(CustomGraphicsBRepFaces)

def CustomGraphicsBRepFaces_classType() -> "char const *":
    return _fusion.CustomGraphicsBRepFaces_classType()


CustomGraphicsBRepFaces.cast = lambda arg: arg if isinstance(arg, CustomGraphicsBRepFaces) else None

class CustomGraphicsBRepVertices(Base):
    r"""A collection of CustomGraphicsBRepVertex objects associated with a specific CustomGraphics body object."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomGraphicsBRepVertices *":
        return _fusion.CustomGraphicsBRepVertices___deref__(self)

    def __eq__(self, rhs: "CustomGraphicsBRepVertices") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomGraphicsBRepVertices___eq__(self, rhs)


    def __ne__(self, rhs: "CustomGraphicsBRepVertices") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomGraphicsBRepVertices___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomGraphicsBRepVertices_classType()
    __swig_destroy__ = _fusion.delete_CustomGraphicsBRepVertices

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomGraphicsBRepVertices__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomGraphicsBRepVertices__get_isValid(self)

# Register CustomGraphicsBRepVertices in _fusion:
_fusion.CustomGraphicsBRepVertices_swigregister(CustomGraphicsBRepVertices)

def CustomGraphicsBRepVertices_classType() -> "char const *":
    return _fusion.CustomGraphicsBRepVertices_classType()


CustomGraphicsBRepVertices.cast = lambda arg: arg if isinstance(arg, CustomGraphicsBRepVertices) else None

class CustomGraphicsColorEffect(Base):
    r"""The base class for all custom graphics color effects."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomGraphicsColorEffect *":
        return _fusion.CustomGraphicsColorEffect___deref__(self)

    def __eq__(self, rhs: "CustomGraphicsColorEffect") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomGraphicsColorEffect___eq__(self, rhs)


    def __ne__(self, rhs: "CustomGraphicsColorEffect") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomGraphicsColorEffect___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomGraphicsColorEffect_classType()
    __swig_destroy__ = _fusion.delete_CustomGraphicsColorEffect

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomGraphicsColorEffect__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomGraphicsColorEffect__get_isValid(self)

# Register CustomGraphicsColorEffect in _fusion:
_fusion.CustomGraphicsColorEffect_swigregister(CustomGraphicsColorEffect)

def CustomGraphicsColorEffect_classType() -> "char const *":
    return _fusion.CustomGraphicsColorEffect_classType()


CustomGraphicsColorEffect.cast = lambda arg: arg if isinstance(arg, CustomGraphicsColorEffect) else None

class CustomGraphicsCoordinates(Base):
    r"""Represents coordinates that are used to define vertices in custom graphics."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomGraphicsCoordinates *":
        return _fusion.CustomGraphicsCoordinates___deref__(self)

    def __eq__(self, rhs: "CustomGraphicsCoordinates") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomGraphicsCoordinates___eq__(self, rhs)


    def __ne__(self, rhs: "CustomGraphicsCoordinates") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomGraphicsCoordinates___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomGraphicsCoordinates_classType()

    @staticmethod
    def create(coordinates: "DoubleVector") -> "std::vector< double > const &":
        return _fusion.CustomGraphicsCoordinates_create(coordinates)
    __swig_destroy__ = _fusion.delete_CustomGraphicsCoordinates

    def _get_coordinates(self) -> "std::vector< double,std::allocator< double > >":
        r"""
        Gets and sets the coordinate data associated with this CustomGraphicsCoordinates object.
        This data represents the x, y, z components of the coordinates where the unit of measure is centimeters.
        """
        return _fusion.CustomGraphicsCoordinates__get_coordinates(self)

    def _set_coordinates(self, value: "DoubleVector") -> "bool":
        r"""
        Gets and sets the coordinate data associated with this CustomGraphicsCoordinates object.
        This data represents the x, y, z components of the coordinates where the unit of measure is centimeters.
        """
        return _fusion.CustomGraphicsCoordinates__set_coordinates(self, value)

    def _get_coordinateCount(self) -> "int":
        r"""Returns the number of coordinates defined in the CustomGraphicsCoordinates object."""
        return _fusion.CustomGraphicsCoordinates__get_coordinateCount(self)

    def getCoordinate(self, index: "int") -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""
        Gets the coordinate at the specified index. 
        index : The index of the coordinate to return. The first coordinate has an index of 0. 
        Returns the coordinate as a Point3D object.
        """
        return _fusion.CustomGraphicsCoordinates_getCoordinate(self, index)

    def setCoordinate(self, index: "int", coordinate: "Point3D") -> "bool":
        r"""
        Sets the coordinate at the specified index. 
        index : The index of the coordinate to set. The first coordinate has an index of 0. 
        coordinate : The coordinate value as a Point3D object. 
        Returns true if setting the coordinate was successful.
        """
        return _fusion.CustomGraphicsCoordinates_setCoordinate(self, index, coordinate)

    def _get_colors(self) -> "std::vector< short,std::allocator< short > >":
        r"""
        Gets and sets the colors assoicated with the coordinate data. This is used when a mesh is
        displayed using per-vertex coloring.
        The color at each vertex is represented by four values where they are the red, green, blue, 
        and alpha values. This should contain the same number of colors as vertices.
        """
        return _fusion.CustomGraphicsCoordinates__get_colors(self)

    def _set_colors(self, value: "ShortVector") -> "bool":
        r"""
        Gets and sets the colors assoicated with the coordinate data. This is used when a mesh is
        displayed using per-vertex coloring.
        The color at each vertex is represented by four values where they are the red, green, blue, 
        and alpha values. This should contain the same number of colors as vertices.
        """
        return _fusion.CustomGraphicsCoordinates__set_colors(self, value)

    def getColor(self, index: "int") -> "adsk::core::Ptr< adsk::core::Color >":
        r"""
        Gets the color assigned to the coordinate at the specified index. 
        index : The index of the color to return. The first color has an index of 0. 
        Returns the color associated with the index. Can also return null in the case
        where there is no color assigned.
        """
        return _fusion.CustomGraphicsCoordinates_getColor(self, index)

    def setColor(self, index: "int", color: "Color") -> "bool":
        r"""
        Sets the color of the coordinate at the specified index. 
        index : The index of the coordinate to set. The first coordinate has an index of 0. 
        color : The color value as a Color object. 
        Returns true if setting the color was successful.
        """
        return _fusion.CustomGraphicsCoordinates_setColor(self, index, color)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomGraphicsCoordinates__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomGraphicsCoordinates__get_isValid(self)

# Register CustomGraphicsCoordinates in _fusion:
_fusion.CustomGraphicsCoordinates_swigregister(CustomGraphicsCoordinates)

def CustomGraphicsCoordinates_classType() -> "char const *":
    return _fusion.CustomGraphicsCoordinates_classType()

def CustomGraphicsCoordinates_create(coordinates: "DoubleVector") -> "std::vector< double > const &":
    return _fusion.CustomGraphicsCoordinates_create(coordinates)


CustomGraphicsCoordinates.coordinates = property(CustomGraphicsCoordinates._get_coordinates, CustomGraphicsCoordinates._set_coordinates, doc="Gets and sets the coordinate data associated with this CustomGraphicsCoordinates object.\nThis data represents the x, y, z components of the coordinates where the unit of measure is centimeters.")


CustomGraphicsCoordinates.coordinateCount = property(CustomGraphicsCoordinates._get_coordinateCount, doc="Returns the number of coordinates defined in the CustomGraphicsCoordinates object.")


CustomGraphicsCoordinates.colors = property(CustomGraphicsCoordinates._get_colors, CustomGraphicsCoordinates._set_colors, doc="Gets and sets the colors assoicated with the coordinate data. This is used when a mesh is\ndisplayed using per-vertex coloring.\nThe color at each vertex is represented by four values where they are the red, green, blue,\nand alpha values. This should contain the same number of colors as vertices.")


CustomGraphicsCoordinates.cast = lambda arg: arg if isinstance(arg, CustomGraphicsCoordinates) else None

class CustomGraphicsEntity(Base):
    r"""The base class for all visible and selectable custom graphics objects."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomGraphicsEntity *":
        return _fusion.CustomGraphicsEntity___deref__(self)

    def __eq__(self, rhs: "CustomGraphicsEntity") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomGraphicsEntity___eq__(self, rhs)


    def __ne__(self, rhs: "CustomGraphicsEntity") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomGraphicsEntity___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomGraphicsEntity_classType()
    __swig_destroy__ = _fusion.delete_CustomGraphicsEntity

    def deleteMe(self) -> "bool":
        r"""
        Deletes the entity from the custom graphics group. 
        Returns true if the deletion was successful.
        """
        return _fusion.CustomGraphicsEntity_deleteMe(self)

    def _get_isVisible(self) -> "bool":
        r"""
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsEntity__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsEntity__set_isVisible(self, value)

    def _get_isSelectable(self) -> "bool":
        r"""
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsEntity__get_isSelectable(self)

    def _set_isSelectable(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsEntity__set_isSelectable(self, value)

    def setOpacity(self, opacity: "double", isOverride: "bool") -> "bool":
        r"""
        Sets the opacity of the graphics entity. By default, when a new entity is it is
        completely opaque and does not override the opacity defined by the material. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if setting the opacity information was successful.
        """
        return _fusion.CustomGraphicsEntity_setOpacity(self, opacity, isOverride)

    def getOpacity(self) -> "bool":
        r"""
        Gets the opacity of the graphics entity. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if getting the opacity information was successful.
        """
        return _fusion.CustomGraphicsEntity_getOpacity(self)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >":
        r"""
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsEntity__get_transform(self)

    def _set_transform(self, value: "Matrix3D") -> "bool":
        r"""
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsEntity__set_transform(self, value)

    def _get_depthPriority(self) -> "int":
        r"""
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsEntity__get_depthPriority(self)

    def _set_depthPriority(self, value: "int") -> "bool":
        r"""
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsEntity__set_depthPriority(self, value)

    def _get_cullMode(self) -> "adsk::fusion::CustomGraphicsCullModes":
        r"""
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsEntity__get_cullMode(self)

    def _set_cullMode(self, value: "CustomGraphicsCullModes") -> "bool":
        r"""
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsEntity__set_cullMode(self, value)

    def _get_color(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsColorEffect >":
        r"""
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsEntity__get_color(self)

    def _set_color(self, value: "CustomGraphicsColorEffect") -> "bool":
        r"""
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsEntity__set_color(self, value)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the parent Component for a top-level group or the CustomGraphicsGroup object for 
        graphics entities and child groups.
        """
        return _fusion.CustomGraphicsEntity__get_parent(self)

    def _get_id(self) -> "std::string":
        r"""
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsEntity__get_id(self)

    def _set_id(self, value: "std::string const &") -> "bool":
        r"""
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsEntity__set_id(self, value)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""
        Returns a box oriented parallel to the world x-y-x axes that contains the graphics entity.
        Depending on whether the graphics are drawn in model space or screen space this will return
        the bounding box in either centimeters (model) or pixels (screen). In the case where it
        returns the bounding box in pixel space, the Z coordinates of the box will be 0 and can be ignored.
        """
        return _fusion.CustomGraphicsEntity__get_boundingBox(self)

    def _get_billBoarding(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBillBoard >":
        r"""
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsEntity__get_billBoarding(self)

    def _set_billBoarding(self, value: "CustomGraphicsBillBoard") -> "bool":
        r"""
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsEntity__set_billBoarding(self, value)

    def _get_viewPlacement(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewPlacement >":
        r"""
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsEntity__get_viewPlacement(self)

    def _set_viewPlacement(self, value: "CustomGraphicsViewPlacement") -> "bool":
        r"""
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsEntity__set_viewPlacement(self, value)

    def _get_viewScale(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewScale >":
        r"""
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsEntity__get_viewScale(self)

    def _set_viewScale(self, value: "CustomGraphicsViewScale") -> "bool":
        r"""
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsEntity__set_viewScale(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomGraphicsEntity__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomGraphicsEntity__get_isValid(self)

# Register CustomGraphicsEntity in _fusion:
_fusion.CustomGraphicsEntity_swigregister(CustomGraphicsEntity)

def CustomGraphicsEntity_classType() -> "char const *":
    return _fusion.CustomGraphicsEntity_classType()


CustomGraphicsEntity.isVisible = property(CustomGraphicsEntity._get_isVisible, CustomGraphicsEntity._set_isVisible, doc="Gets and sets if the graphics entity is visible in the graphics window. By\ndefault, when a new entity is created it is visible.")


CustomGraphicsEntity.isSelectable = property(CustomGraphicsEntity._get_isSelectable, CustomGraphicsEntity._set_isSelectable, doc="Gets and sets if the graphics entity is selectable within the graphics window. By\ndefault, when a new entity is created it is selectable.")


CustomGraphicsEntity.transform = property(CustomGraphicsEntity._get_transform, CustomGraphicsEntity._set_transform, doc="Gets and sets the transform associated with the graphics entity. When a new graphics\nentity is created its default transform is an identity matrix which results in the graphics entity\nbeing displayed in model space using the original coordinate data used to define the entity.")


CustomGraphicsEntity.depthPriority = property(CustomGraphicsEntity._get_depthPriority, CustomGraphicsEntity._set_depthPriority, doc="Gets and sets the depth priority associated with the graphics entity. The depth priority defines\nhow one graphics entity will be drawn with respect to another entity. This is useful when there\nare entities that lie in the same space so it's ambiguous which should be drawn on the other. For\nexample, if you draw a curve on a planar mesh and want the curve to be completely visible. You can\nset the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh\nand will remain visible.\nWhen a new graphics entity is created it's default depth priority is 0.")


CustomGraphicsEntity.cullMode = property(CustomGraphicsEntity._get_cullMode, CustomGraphicsEntity._set_cullMode, doc="Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains\na mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used\nfor a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never\nvisible to the user.\nWhen a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize\nthe rendering of 'solid' meshes so the inside is not rendered.")


CustomGraphicsEntity.color = property(CustomGraphicsEntity._get_color, CustomGraphicsEntity._set_color, doc="Gets and sets the current color definition for this entity. The color of custom graphics can\nbe defined in many ways; solid color, simple material, and appearance.")


CustomGraphicsEntity.parent = property(CustomGraphicsEntity._get_parent, doc="Returns the parent Component for a top-level group or the CustomGraphicsGroup object for\ngraphics entities and child groups.")


CustomGraphicsEntity.id = property(CustomGraphicsEntity._get_id, CustomGraphicsEntity._set_id, doc="An id you can specify for the entity. By default, all new graphics entities do not have an id and\nthis property will return an empty string. But in cases where entities will be selected, assigning\nan id can make understanding what was selected much easier.")


CustomGraphicsEntity.boundingBox = property(CustomGraphicsEntity._get_boundingBox, doc="Returns a box oriented parallel to the world x-y-x axes that contains the graphics entity.\nDepending on whether the graphics are drawn in model space or screen space this will return\nthe bounding box in either centimeters (model) or pixels (screen). In the case where it\nreturns the bounding box in pixel space, the Z coordinates of the box will be 0 and can be ignored.")


CustomGraphicsEntity.billBoarding = property(CustomGraphicsEntity._get_billBoarding, CustomGraphicsEntity._set_billBoarding, doc="Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding\nyou can set this property using a CustomGraphicsBillBoard objects that you statically create using\nthe create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity\nyou can set this property to null.\nBillboarding is used to specify that the orientation of custom graphics is defined relative to the\nscreen instead of model space. This is commonly used for legends and symbols that you want to\nalways face the user, even as the camera is rotated.")


CustomGraphicsEntity.viewPlacement = property(CustomGraphicsEntity._get_viewPlacement, CustomGraphicsEntity._set_viewPlacement, doc="Gets and sets the graphics view placement being applied to this graphics entity. A\nCustomGraphicsViewPlacement object can be created using the static create method of the\nclass. When assigned to a graphics entity the position of the graphics is defined\nrelative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).")


CustomGraphicsEntity.viewScale = property(CustomGraphicsEntity._get_viewScale, CustomGraphicsEntity._set_viewScale, doc="Gets and sets the graphics view scale being applied to this graphics entity. A\nCustomGraphicsViewScale object can be created using the static create method of the\nclass. When assigned to a graphics entity the size of the graphics entity is defined\nin view space (pixels) instead of model space (centimeters).")


CustomGraphicsEntity.cast = lambda arg: arg if isinstance(arg, CustomGraphicsEntity) else None

class CustomGraphicsGroups(Base):
    r"""
    Provides access to a set of graphics groups that are either associated with a component or owned by another
    CustomGraphicsGroup object. This object also supports the creation of new custom graphics groups.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomGraphicsGroups *":
        return _fusion.CustomGraphicsGroups___deref__(self)

    def __eq__(self, rhs: "CustomGraphicsGroups") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomGraphicsGroups___eq__(self, rhs)


    def __ne__(self, rhs: "CustomGraphicsGroups") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomGraphicsGroups___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.CustomGraphicsGroups___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsGroup >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.CustomGraphicsGroups___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomGraphicsGroups_classType()
    __swig_destroy__ = _fusion.delete_CustomGraphicsGroups

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsGroup >":
        r"""
        Function that returns the specified graphics group using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.CustomGraphicsGroups_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of graphics groups in the collection."""
        return _fusion.CustomGraphicsGroups__get_count(self)

    def add(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsGroup >":
        r"""
        Creates a new, empty CustomGraphicsGroup. 
        Returns the new CustomGraphicsGroup object or null in the case of a failure.
        """
        return _fusion.CustomGraphicsGroups_add(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomGraphicsGroups__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomGraphicsGroups__get_isValid(self)

# Register CustomGraphicsGroups in _fusion:
_fusion.CustomGraphicsGroups_swigregister(CustomGraphicsGroups)

def CustomGraphicsGroups_classType() -> "char const *":
    return _fusion.CustomGraphicsGroups_classType()


CustomGraphicsGroups.count = property(CustomGraphicsGroups._get_count, doc="Returns the number of graphics groups in the collection.")


CustomGraphicsGroups.cast = lambda arg: arg if isinstance(arg, CustomGraphicsGroups) else None

class CustomGraphicsViewPlacement(Base):
    r"""
    Positions custom graphics relative to one of the four corners of the view. Graphics positioned
    this way will always appear on top of the model graphics. This is typically used to display
    legends are small interactive tools.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomGraphicsViewPlacement *":
        return _fusion.CustomGraphicsViewPlacement___deref__(self)

    def __eq__(self, rhs: "CustomGraphicsViewPlacement") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomGraphicsViewPlacement___eq__(self, rhs)


    def __ne__(self, rhs: "CustomGraphicsViewPlacement") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomGraphicsViewPlacement___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomGraphicsViewPlacement_classType()

    @staticmethod
    def create(anchorPoint: "Point3D", viewCorner: "ViewCorners", viewPoint: "Point2D") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Point2D > const &":
        return _fusion.CustomGraphicsViewPlacement_create(anchorPoint, viewCorner, viewPoint)
    __swig_destroy__ = _fusion.delete_CustomGraphicsViewPlacement

    def _get_anchorPoint(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""
        Gets and sets the position within the defined graphics that serves as the anchor. This is the location
        on the graphics that is positioned at the specified view point.
        """
        return _fusion.CustomGraphicsViewPlacement__get_anchorPoint(self)

    def _set_anchorPoint(self, value: "Point3D") -> "bool":
        r"""
        Gets and sets the position within the defined graphics that serves as the anchor. This is the location
        on the graphics that is positioned at the specified view point.
        """
        return _fusion.CustomGraphicsViewPlacement__set_anchorPoint(self, value)

    def _get_viewPoint(self) -> "adsk::core::Ptr< adsk::core::Point2D >":
        r"""
        A 2D point in the view that defines the position of the graphics. This is relative to the corner
        and is in pixels. The x and y directions vary for each of the corners. These directions are only
        used to position the 2D point and do not affect the standard coordinate system the graphics were
        drawn in.
        upperLeftViewCorner - The x direction is to the right and y is down.
        upperRightViewCorner - The x direction is to the left and y is down.
        lowerLeftViewCorner - The x direction is to the right and y is up.
        lowerRightViewCorner - The x direction is to the left and y is up.
        """
        return _fusion.CustomGraphicsViewPlacement__get_viewPoint(self)

    def _set_viewPoint(self, value: "Point2D") -> "bool":
        r"""
        A 2D point in the view that defines the position of the graphics. This is relative to the corner
        and is in pixels. The x and y directions vary for each of the corners. These directions are only
        used to position the 2D point and do not affect the standard coordinate system the graphics were
        drawn in.
        upperLeftViewCorner - The x direction is to the right and y is down.
        upperRightViewCorner - The x direction is to the left and y is down.
        lowerLeftViewCorner - The x direction is to the right and y is up.
        lowerRightViewCorner - The x direction is to the left and y is up.
        """
        return _fusion.CustomGraphicsViewPlacement__set_viewPoint(self, value)

    def _get_viewCorner(self) -> "adsk::fusion::ViewCorners":
        r"""Gets and sets which corner the graphics are positioned relative to."""
        return _fusion.CustomGraphicsViewPlacement__get_viewCorner(self)

    def _set_viewCorner(self, value: "ViewCorners") -> "bool":
        r"""Gets and sets which corner the graphics are positioned relative to."""
        return _fusion.CustomGraphicsViewPlacement__set_viewCorner(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomGraphicsViewPlacement__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomGraphicsViewPlacement__get_isValid(self)

# Register CustomGraphicsViewPlacement in _fusion:
_fusion.CustomGraphicsViewPlacement_swigregister(CustomGraphicsViewPlacement)

def CustomGraphicsViewPlacement_classType() -> "char const *":
    return _fusion.CustomGraphicsViewPlacement_classType()

def CustomGraphicsViewPlacement_create(anchorPoint: "Point3D", viewCorner: "ViewCorners", viewPoint: "Point2D") -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Point2D > const &":
    return _fusion.CustomGraphicsViewPlacement_create(anchorPoint, viewCorner, viewPoint)


CustomGraphicsViewPlacement.anchorPoint = property(CustomGraphicsViewPlacement._get_anchorPoint, CustomGraphicsViewPlacement._set_anchorPoint, doc="Gets and sets the position within the defined graphics that serves as the anchor. This is the location\non the graphics that is positioned at the specified view point.")


CustomGraphicsViewPlacement.viewPoint = property(CustomGraphicsViewPlacement._get_viewPoint, CustomGraphicsViewPlacement._set_viewPoint, doc="A 2D point in the view that defines the position of the graphics. This is relative to the corner\nand is in pixels. The x and y directions vary for each of the corners. These directions are only\nused to position the 2D point and do not affect the standard coordinate system the graphics were\ndrawn in.\nupperLeftViewCorner - The x direction is to the right and y is down.\nupperRightViewCorner - The x direction is to the left and y is down.\nlowerLeftViewCorner - The x direction is to the right and y is up.\nlowerRightViewCorner - The x direction is to the left and y is up.")


CustomGraphicsViewPlacement.viewCorner = property(CustomGraphicsViewPlacement._get_viewCorner, CustomGraphicsViewPlacement._set_viewCorner, doc="Gets and sets which corner the graphics are positioned relative to.")


CustomGraphicsViewPlacement.cast = lambda arg: arg if isinstance(arg, CustomGraphicsViewPlacement) else None

class CustomGraphicsViewScale(Base):
    r"""
    Specifies that custom graphics are to be scaled relative to the view (pixels) and not model space.
    If this is applied to some custom graphics then they will stat the same size on the screen regardless
    of the user zooming in or out. This is commonly used for glyphs and other interactive widgets so they don't
    don't get too large or too small.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomGraphicsViewScale *":
        return _fusion.CustomGraphicsViewScale___deref__(self)

    def __eq__(self, rhs: "CustomGraphicsViewScale") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomGraphicsViewScale___eq__(self, rhs)


    def __ne__(self, rhs: "CustomGraphicsViewScale") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomGraphicsViewScale___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomGraphicsViewScale_classType()

    @staticmethod
    def create(pixelScale: "double", anchorPoint: "Point3D") -> "adsk::core::Ptr< adsk::core::Point3D > const &":
        return _fusion.CustomGraphicsViewScale_create(pixelScale, anchorPoint)
    __swig_destroy__ = _fusion.delete_CustomGraphicsViewScale

    def _get_pixelScale(self) -> "double":
        r"""
        Gets and sets the scale of the custom graphics relative to the view. If a custom graphics line is defined
        to be 100 units long it would usually display as 100 cm long. When it is view scaled with a pixel scale of
        1 it will display as 100 pixels long.
        """
        return _fusion.CustomGraphicsViewScale__get_pixelScale(self)

    def _set_pixelScale(self, value: "double") -> "bool":
        r"""
        Gets and sets the scale of the custom graphics relative to the view. If a custom graphics line is defined
        to be 100 units long it would usually display as 100 cm long. When it is view scaled with a pixel scale of
        1 it will display as 100 pixels long.
        """
        return _fusion.CustomGraphicsViewScale__set_pixelScale(self, value)

    def _get_anchorPoint(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""
        Gets and sets the point in the graphics that defines the origin of the scaling. The graphics will be scaled
        up or down relative to that point.
        """
        return _fusion.CustomGraphicsViewScale__get_anchorPoint(self)

    def _set_anchorPoint(self, value: "Point3D") -> "bool":
        r"""
        Gets and sets the point in the graphics that defines the origin of the scaling. The graphics will be scaled
        up or down relative to that point.
        """
        return _fusion.CustomGraphicsViewScale__set_anchorPoint(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomGraphicsViewScale__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomGraphicsViewScale__get_isValid(self)

# Register CustomGraphicsViewScale in _fusion:
_fusion.CustomGraphicsViewScale_swigregister(CustomGraphicsViewScale)

def CustomGraphicsViewScale_classType() -> "char const *":
    return _fusion.CustomGraphicsViewScale_classType()

def CustomGraphicsViewScale_create(pixelScale: "double", anchorPoint: "Point3D") -> "adsk::core::Ptr< adsk::core::Point3D > const &":
    return _fusion.CustomGraphicsViewScale_create(pixelScale, anchorPoint)


CustomGraphicsViewScale.pixelScale = property(CustomGraphicsViewScale._get_pixelScale, CustomGraphicsViewScale._set_pixelScale, doc="Gets and sets the scale of the custom graphics relative to the view. If a custom graphics line is defined\nto be 100 units long it would usually display as 100 cm long. When it is view scaled with a pixel scale of\n1 it will display as 100 pixels long.")


CustomGraphicsViewScale.anchorPoint = property(CustomGraphicsViewScale._get_anchorPoint, CustomGraphicsViewScale._set_anchorPoint, doc="Gets and sets the point in the graphics that defines the origin of the scaling. The graphics will be scaled\nup or down relative to that point.")


CustomGraphicsViewScale.cast = lambda arg: arg if isinstance(arg, CustomGraphicsViewScale) else None

class CutPasteBodies(Base):
    r"""
    Collection that provides access to all of the existing cut-paste features in a design.
    These are created in the UI by cutting and then pasting a B-Rep body.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CutPasteBodies *":
        return _fusion.CutPasteBodies___deref__(self)

    def __eq__(self, rhs: "CutPasteBodies") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CutPasteBodies___eq__(self, rhs)


    def __ne__(self, rhs: "CutPasteBodies") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CutPasteBodies___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.CutPasteBodies___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::CutPasteBody >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.CutPasteBodies___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CutPasteBodies_classType()
    __swig_destroy__ = _fusion.delete_CutPasteBodies

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::CutPasteBody >":
        r"""
        Function that returns the specified Cut/Paste Body feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.CutPasteBodies_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::CutPasteBody >":
        r"""
        Function that returns the specified Cut/Paste Body feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.CutPasteBodies_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of Cut/Paste Body features in the collection."""
        return _fusion.CutPasteBodies__get_count(self)

    def add(self, sourceBody: "Base") -> "adsk::core::Ptr< adsk::fusion::CutPasteBody >":
        r"""
        Cuts and copies the specififed body into the component that owns this CutPasteBodies collection. 
        This is effectively the equivalent of moving a body. 
        sourceBody : Either an ObjectCollection of BRepBodies or a single BRepBody object to cut. 
        Returns the newly created BRepBody object or null in the case of failure.
        """
        return _fusion.CutPasteBodies_add(self, sourceBody)

    def _get_objectType(self) -> "char const *":
        return _fusion.CutPasteBodies__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CutPasteBodies__get_isValid(self)

# Register CutPasteBodies in _fusion:
_fusion.CutPasteBodies_swigregister(CutPasteBodies)

def CutPasteBodies_classType() -> "char const *":
    return _fusion.CutPasteBodies_classType()


CutPasteBodies.count = property(CutPasteBodies._get_count, doc="The number of Cut/Paste Body features in the collection.")


CutPasteBodies.cast = lambda arg: arg if isinstance(arg, CutPasteBodies) else None

class CylinderFeatures(Base):
    r"""Collection that provides access to all of the existing cylinder features in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CylinderFeatures *":
        return _fusion.CylinderFeatures___deref__(self)

    def __eq__(self, rhs: "CylinderFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CylinderFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "CylinderFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CylinderFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.CylinderFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::CylinderFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.CylinderFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CylinderFeatures_classType()
    __swig_destroy__ = _fusion.delete_CylinderFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::CylinderFeature >":
        r"""
        Function that returns the specified cylinder feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.CylinderFeatures_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::CylinderFeature >":
        r"""
        Function that returns the specified cylinder feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.CylinderFeatures_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of cylinder features in the collection."""
        return _fusion.CylinderFeatures__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.CylinderFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CylinderFeatures__get_isValid(self)

# Register CylinderFeatures in _fusion:
_fusion.CylinderFeatures_swigregister(CylinderFeatures)

def CylinderFeatures_classType() -> "char const *":
    return _fusion.CylinderFeatures_classType()


CylinderFeatures.count = property(CylinderFeatures._get_count, doc="The number of cylinder features in the collection.")


CylinderFeatures.cast = lambda arg: arg if isinstance(arg, CylinderFeatures) else None

class DeleteFaceFeatures(Base):
    r"""
    Collection that provides access to all of the existing DeleteFaceFeature features in a component
    and supports the ability to create new DeleteFaceFeature features.
    The SurfaceDeleteFaceFeature and DeleteFaceFeature differ in that the SurfaceDeleteFaceFeature
    can delete any face without any restrictions. If the body is a solid, it will become a surface
    when the first face is deleted. The specified face is deleted without any other changes being
    made to the body. The DeleteFaceFeature deletes the specified face and also modifies the other faces
    in the body to heal or fill in the area of the deleted face. This means that a solid body will
    remain solid.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::DeleteFaceFeatures *":
        return _fusion.DeleteFaceFeatures___deref__(self)

    def __eq__(self, rhs: "DeleteFaceFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.DeleteFaceFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "DeleteFaceFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.DeleteFaceFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.DeleteFaceFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::DeleteFaceFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.DeleteFaceFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.DeleteFaceFeatures_classType()
    __swig_destroy__ = _fusion.delete_DeleteFaceFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::DeleteFaceFeature >":
        r"""
        Function that returns the specified DeleteFaceFeature object using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.DeleteFaceFeatures_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::DeleteFaceFeature >":
        r"""
        Function that returns the specified DeleteFaceFeature object using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.DeleteFaceFeatures_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of DeleteFaceFeature objects in the collection."""
        return _fusion.DeleteFaceFeatures__get_count(self)

    def add(self, facesToDelete: "Base") -> "adsk::core::Ptr< adsk::fusion::DeleteFaceFeature >":
        r"""
        Creates a new SurfaceDeleteFace feature. This deletes the specified faces
        from their bodies and attempts to heal the body. The method will fail if
        the body cannot be healed. This is equivalent to selecting and deleting
        faces when in the Patch workspace. 
        facesToDelete : A single BRepFace or an ObjectCollection containing multiple BRepFace objects. 
        Returns the newly created DeleteFaceFeature object or null if the creation failed.
        """
        return _fusion.DeleteFaceFeatures_add(self, facesToDelete)

    def _get_objectType(self) -> "char const *":
        return _fusion.DeleteFaceFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.DeleteFaceFeatures__get_isValid(self)

# Register DeleteFaceFeatures in _fusion:
_fusion.DeleteFaceFeatures_swigregister(DeleteFaceFeatures)

def DeleteFaceFeatures_classType() -> "char const *":
    return _fusion.DeleteFaceFeatures_classType()


DeleteFaceFeatures.count = property(DeleteFaceFeatures._get_count, doc="The number of DeleteFaceFeature objects in the collection.")


DeleteFaceFeatures.cast = lambda arg: arg if isinstance(arg, DeleteFaceFeatures) else None

class Design(adsk.core.Product):
    r"""
    Object that represents an open Fusion 360 design. This derives from the
    Design base class and adds the Fusion 360 specific functionality.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::Design *":
        return _fusion.Design___deref__(self)

    def __eq__(self, rhs: "Design") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.Design___eq__(self, rhs)


    def __ne__(self, rhs: "Design") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.Design___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.Design_classType()
    __swig_destroy__ = _fusion.delete_Design

    def _get_designType(self) -> "adsk::fusion::DesignTypes":
        r"""
        Gets and sets the current design type (DirectDesignType or ParametricDesignType)
        Changing an exising design from ParametricDesignType to DirectDesignType will result in the timeline and all design
        history being removed and further operations will not be captured in the timeline.
        """
        return _fusion.Design__get_designType(self)

    def _set_designType(self, value: "DesignTypes") -> "bool":
        r"""
        Gets and sets the current design type (DirectDesignType or ParametricDesignType)
        Changing an exising design from ParametricDesignType to DirectDesignType will result in the timeline and all design
        history being removed and further operations will not be captured in the timeline.
        """
        return _fusion.Design__set_designType(self, value)

    def _get_rootComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the root Component"""
        return _fusion.Design__get_rootComponent(self)

    def _get_allComponents(self) -> "adsk::core::Ptr< adsk::fusion::Components >":
        r"""
        Returns the Components collection that provides access to existing components 
        in a design
        """
        return _fusion.Design__get_allComponents(self)

    def _get_activeEditObject(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the current edit target as seen in the user interface. This edit target
        is defined as the container object that will be added to if something is created.
        For example, a component can be an edit target so that when new bodies are created they
        are added to that component. A sketch can also be an edit target.
        """
        return _fusion.Design__get_activeEditObject(self)

    def _get_activeComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""
        Returns the component that is current being edited. This can return the root component
        or another component within the design.
        """
        return _fusion.Design__get_activeComponent(self)

    def _get_snapshots(self) -> "adsk::core::Ptr< adsk::fusion::Snapshots >":
        r"""
        Returns the Snapshots object associated with this design which provides access to the 
        existing snapshots and the creation of new snapshots.
        """
        return _fusion.Design__get_snapshots(self)

    def _get_timeline(self) -> "adsk::core::Ptr< adsk::fusion::Timeline >":
        r"""Returns the timeline associated with this design."""
        return _fusion.Design__get_timeline(self)

    def _get_userParameters(self) -> "adsk::core::Ptr< adsk::fusion::UserParameters >":
        r"""Returns the collection of User Parameters in a design"""
        return _fusion.Design__get_userParameters(self)

    def _get_allParameters(self) -> "adsk::core::Ptr< adsk::fusion::ParameterList >":
        r"""
        Returns a read only list of all parameters in the design. This includes
        the user parameters and model parameters from all components in this design. The parameters from Externally Referenced components
        are NOT included because they are in actuality, separate designs.
        """
        return _fusion.Design__get_allParameters(self)

    def _get_fusionUnitsManager(self) -> "adsk::core::Ptr< adsk::fusion::FusionUnitsManager >":
        r"""
        Returns a specialized UnitsManager that can set the default length units and work 
        with parameters.
        """
        return _fusion.Design__get_fusionUnitsManager(self)

    def _get_exportManager(self) -> "adsk::core::Ptr< adsk::fusion::ExportManager >":
        r"""
        Returns the ExportManager for this design. You use the ExportManager
        to export the current design in various formats.
        """
        return _fusion.Design__get_exportManager(self)

    def _get_isRootComponentActive(self) -> "bool":
        r"""
        Gets whether the root component is the active edit target in the user interface.
        This is the same as checking the state of the radio button next to the root compoonent in the browser.
        To activate the root component use the ActivateRootComponent method.
        """
        return _fusion.Design__get_isRootComponentActive(self)

    def activateRootComponent(self) -> "bool":
        r"""
        Makes the root component the active component in the user interface. This is the same
        as enabling the radio button next to the root component in the browser. 
        Returns true if the activation was successful.
        """
        return _fusion.Design_activateRootComponent(self)

    def _get_materials(self) -> "adsk::core::Ptr< adsk::core::Materials >":
        r"""Returns the materials contained in this document."""
        return _fusion.Design__get_materials(self)

    def _get_appearances(self) -> "adsk::core::Ptr< adsk::core::Appearances >":
        r"""Returns the appearances contained in this document."""
        return _fusion.Design__get_appearances(self)

    def createInterferenceInput(self, entities: "ObjectCollection") -> "adsk::core::Ptr< adsk::fusion::InterferenceInput >":
        r"""
        Creates an InterferenceInput object. This object collects the entities and options that are
        used when calculating interference. To analyze interference you first create an InterferenceInput
        supplying the entities and set any other settings and then provide this object as input to the 
        analyzeInterference method. 
        entities : An ObjectCollection containing the BRepBody and/or Occurrence entities that will be used in the
        interference calculation. All entities must be in the context of the root component of the top-level design. 
        Returns an InterferenceInput object which you can use to set any other interference settings and then
        use as input to the analyzeInterference method to calculate the interference. Returns null if the
        creation failed.
        """
        return _fusion.Design_createInterferenceInput(self, entities)

    def analyzeInterference(self, input: "InterferenceInput") -> "adsk::core::Ptr< adsk::fusion::InterferenceResults >":
        r"""
        Calculates the interference between the input bodies and/or occurrences. 
        input : An InterferenceInput that defines all of the necessary input needed to calculate the interference.
        An InterferenceInput object is created using the createInterferenceInput method. 
        Returns an InterferenceResults object that can be used to examine the interference results.
        """
        return _fusion.Design_analyzeInterference(self, input)

    def _get_activeOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the occurrence that is currently activated, if any. This can return null in the case
        where no occurrence is activated and the root component is active.
        """
        return _fusion.Design__get_activeOccurrence(self)

    def areaProperties(self, *args) -> "adsk::core::Ptr< adsk::fusion::AreaProperties >":
        r"""
        Returns the AreaProperties object that has properties for getting the area, perimeter, centroid, etc 
        for a collection of 2D sketch profiles and/or planar surfaces that all lie on the same plane. 
        inputs : A collection of one or more 2D sketch profile and/or planar surface input objects to perform the calculations on. 
        Supported input object types are 2D closed sketch profiles and planar surfaces. Object must all lie on the same plane.
        Calculation results reflect the sums of the input objects (i.e. total area of multiple sketch profiles) 
        accuracy : Specifies the desired level of computational accuracy of the property calculations.
        The default value of 'LowCalculationAccuracy' returns results within a +/- 1% error margin. 
        Returns an AreaProperties object that can be used to examine the area results.
        """
        return _fusion.Design_areaProperties(self, *args)

    def physicalProperties(self, *args) -> "adsk::core::Ptr< adsk::fusion::PhysicalProperties >":
        r"""
        Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc 
        for a collection of 3D solid objects. 
        inputs : A collection of one or more 3D solid input objects to perform the calculations on. 
        Supported input object types are Components, Occurrences and BRepBodies.
        Calculation results reflect the sums of the input objects (i.e. total volume of multiple bodies) 
        accuracy : Specifies the desired level of computational accuracy of the property calculations.
        The default value of 'LowCalculationAccuracy' returns results within a +/- 1% error margin.
        """
        return _fusion.Design_physicalProperties(self, *args)

    def _get_contactSets(self) -> "adsk::core::Ptr< adsk::fusion::ContactSets >":
        r"""Returns the contact sets associated with this design."""
        return _fusion.Design__get_contactSets(self)

    def _get_isContactAnalysisEnabled(self) -> "bool":
        r"""
        Gets and sets whether contact analysis is enabled for all components. This
        is the equivalent of the 'Disable Contact / Enable Contact' command. If this
        if True then any contact analysis defined (either all or contact sets) is enabled.
        if False, then no contact analysis is performed.
        """
        return _fusion.Design__get_isContactAnalysisEnabled(self)

    def _set_isContactAnalysisEnabled(self, value: "bool") -> "bool":
        r"""
        Gets and sets whether contact analysis is enabled for all components. This
        is the equivalent of the 'Disable Contact / Enable Contact' command. If this
        if True then any contact analysis defined (either all or contact sets) is enabled.
        if False, then no contact analysis is performed.
        """
        return _fusion.Design__set_isContactAnalysisEnabled(self, value)

    def _get_isContactSetAnalysis(self) -> "bool":
        r"""
        Gets and sets whether contact analysis is done using contact sets
        or between all bodies, independent of any contact sets. If True and
        the isContactAnalysisEnabled property is True then contact analysis
        is performed using contact sets. If False and isContactAnalysisEnabled
        is True, then contact analysis is performed between all bodies. If
        isContactAnalysisEnabled is False then no contact analysis is performed.
        """
        return _fusion.Design__get_isContactSetAnalysis(self)

    def _set_isContactSetAnalysis(self, value: "bool") -> "bool":
        r"""
        Gets and sets whether contact analysis is done using contact sets
        or between all bodies, independent of any contact sets. If True and
        the isContactAnalysisEnabled property is True then contact analysis
        is performed using contact sets. If False and isContactAnalysisEnabled
        is True, then contact analysis is performed between all bodies. If
        isContactAnalysisEnabled is False then no contact analysis is performed.
        """
        return _fusion.Design__set_isContactSetAnalysis(self, value)

    def findEntityByToken(self, entityToken: "std::string const &") -> "std::vector< adsk::core::Ptr< adsk::core::Base >,std::allocator< adsk::core::Ptr< adsk::core::Base > > >":
        r"""
        Returns the entity associated with the provided token. If there isn't an
        entity that matches the provided token, null is returned. 
        In most cases an array containing a single entity will be returned but 
        there are cases where more than one enity will be returned. An example of this
        is where a token is obtained from a face and subsequent modeling operations cause
        the face to be split into two or more pieces. All of the pieces will be returned
        with the first face being the most logical match to the original face. 
        entityToken : The input entity token you want to find the matching entity for. 
        Returns the entity associated with the provided token, or null in the case
        there isn't a match.
        """
        return _fusion.Design_findEntityByToken(self, entityToken)

    def computeAll(self) -> "bool":
        r"""
        Forces a recompute of the entire design. This is the equivalent of the 'Compute All'
        command. 
        Returns true if the compute completed. This doesn't indicate if all the items in the
        timeline successfully computed or not. You need to check the health state of each item
        in the timeline to determine if everything successfully computed or not.
        """
        return _fusion.Design_computeAll(self)

    def _get_parentDocument(self) -> "adsk::core::Ptr< adsk::core::Document >":
        r"""Returns the parent Document object."""
        return _fusion.Design__get_parentDocument(self)

    def _get_unitsManager(self) -> "adsk::core::Ptr< adsk::core::UnitsManager >":
        r"""Returns the UnitsManager object associated with this product."""
        return _fusion.Design__get_unitsManager(self)

    def _get_workspaces(self) -> "adsk::core::Ptr< adsk::core::WorkspaceList >":
        r"""Returns the workspaces associated with this product."""
        return _fusion.Design__get_workspaces(self)

    def _get_productType(self) -> "std::string":
        r"""
        Returns the product type name of this product. A list of all of
        the possible product types can be obtained by using the 
        Application.supportedProductTypes property.
        """
        return _fusion.Design__get_productType(self)

    def findAttributes(self, groupName: "std::string const &", attributeName: "std::string const &") -> "std::vector< adsk::core::Ptr< adsk::core::Attribute >,std::allocator< adsk::core::Ptr< adsk::core::Attribute > > >":
        r"""
        Find attributes attached to objects in this product that match the group and or attribute name.
        This does not find attributes attached directly to the Product or Document objects but finds the
        attributes attached to entities within the product.
        The search string for both the groupName and attributeName arguments can be either an absolute 
        name value, or a regular expression. With an absolute name, the search string must match the
        entire groupName or attributeName, including case. An empty string will match everything.
        For example if you have an attribute group named 'MyStuff' that contains the attribute 'Length1', 
        using the search string 'MyStuff' as the group name and 'Length1' as the attribute name will 
        find the attributes with those names. Searching for 'MyStuff' as the group name and '' as the
        attribute name will find all attributes that have 'MyStuff' as the group name.
        Regular expressions provide a more flexible way of searching. To use a regular expression, 
        prefix the input string for the groupName or attributeName arguments with 're:'. The regular
        expression much match the entire group or attribute name. For example if you have a group that
        contains attributes named 'Length1', 'Length2', 'Width1', and 'Width2' and want to find any 
        of the length attributes you can use a regular expression using the string 're:Length.*'. For more
        information on attributes see the Attributes topic in the user manual. 
        groupName : The search string for the group name. See above for more details. 
        attributeName : The search string for the attribute name. See above for more details. 
        An array of Attribute objects that were found. An empty array is returned if no attributes were found.
        """
        return _fusion.Design_findAttributes(self, groupName, attributeName)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this product."""
        return _fusion.Design__get_attributes(self)

    def deleteEntities(self, entities: "ObjectCollection") -> "bool":
        r"""
        Deletes the specified set of entities that are associated with this product. 
        entities : An ObjectCollection containing the list of entities to delete. 
        Returns True if any of the entities provided in the list were deleted. If
        entities were specified that can't be deleted or aren't owned by this product,
        they are ignored.
        """
        return _fusion.Design_deleteEntities(self, entities)

    def _get_objectType(self) -> "char const *":
        return _fusion.Design__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.Design__get_isValid(self)

# Register Design in _fusion:
_fusion.Design_swigregister(Design)

def Design_classType() -> "char const *":
    return _fusion.Design_classType()


Design.designType = property(Design._get_designType, Design._set_designType, doc="Gets and sets the current design type (DirectDesignType or ParametricDesignType)\nChanging an exising design from ParametricDesignType to DirectDesignType will result in the timeline and all design\nhistory being removed and further operations will not be captured in the timeline.")


Design.rootComponent = property(Design._get_rootComponent, doc="Returns the root Component")


Design.allComponents = property(Design._get_allComponents, doc="Returns the Components collection that provides access to existing components\nin a design")


Design.activeEditObject = property(Design._get_activeEditObject, doc="Returns the current edit target as seen in the user interface. This edit target\nis defined as the container object that will be added to if something is created.\nFor example, a component can be an edit target so that when new bodies are created they\nare added to that component. A sketch can also be an edit target.")


Design.activeComponent = property(Design._get_activeComponent, doc="Returns the component that is current being edited. This can return the root component\nor another component within the design.")


Design.snapshots = property(Design._get_snapshots, doc="Returns the Snapshots object associated with this design which provides access to the\nexisting snapshots and the creation of new snapshots.")


Design.timeline = property(Design._get_timeline, doc="Returns the timeline associated with this design.")


Design.userParameters = property(Design._get_userParameters, doc="Returns the collection of User Parameters in a design")


Design.allParameters = property(Design._get_allParameters, doc="Returns a read only list of all parameters in the design. This includes\nthe user parameters and model parameters from all components in this design. The parameters from Externally Referenced components\nare NOT included because they are in actuality, separate designs.")


Design.fusionUnitsManager = property(Design._get_fusionUnitsManager, doc="Returns a specialized UnitsManager that can set the default length units and work\nwith parameters.")


Design.exportManager = property(Design._get_exportManager, doc="Returns the ExportManager for this design. You use the ExportManager\nto export the current design in various formats.")


Design.isRootComponentActive = property(Design._get_isRootComponentActive, doc="Gets whether the root component is the active edit target in the user interface.\nThis is the same as checking the state of the radio button next to the root compoonent in the browser.\nTo activate the root component use the ActivateRootComponent method.")


Design.materials = property(Design._get_materials, doc="Returns the materials contained in this document.")


Design.appearances = property(Design._get_appearances, doc="Returns the appearances contained in this document.")


Design.activeOccurrence = property(Design._get_activeOccurrence, doc="Returns the occurrence that is currently activated, if any. This can return null in the case\nwhere no occurrence is activated and the root component is active.")


Design.contactSets = property(Design._get_contactSets, doc="Returns the contact sets associated with this design.")


Design.isContactAnalysisEnabled = property(Design._get_isContactAnalysisEnabled, Design._set_isContactAnalysisEnabled, doc="Gets and sets whether contact analysis is enabled for all components. This\nis the equivalent of the 'Disable Contact / Enable Contact' command. If this\nif True then any contact analysis defined (either all or contact sets) is enabled.\nif False, then no contact analysis is performed.")


Design.isContactSetAnalysis = property(Design._get_isContactSetAnalysis, Design._set_isContactSetAnalysis, doc="Gets and sets whether contact analysis is done using contact sets\nor between all bodies, independent of any contact sets. If True and\nthe isContactAnalysisEnabled property is True then contact analysis\nis performed using contact sets. If False and isContactAnalysisEnabled\nis True, then contact analysis is performed between all bodies. If\nisContactAnalysisEnabled is False then no contact analysis is performed.")


Design.cast = lambda arg: arg if isinstance(arg, Design) else None

class DraftFeatureInput(Base):
    r"""
    This class defines the methods and properties that pertain to the definition of a draft 
    feature.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::DraftFeatureInput *":
        return _fusion.DraftFeatureInput___deref__(self)

    def __eq__(self, rhs: "DraftFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.DraftFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "DraftFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.DraftFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.DraftFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_DraftFeatureInput

    def _get_inputFaces(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepFace > > >":
        r"""
        Gets and sets the input faces.
        If IsTangentChain is true, all the faces that are tangentially connected to the input faces (if any) will also be included.
        """
        return _fusion.DraftFeatureInput__get_inputFaces(self)

    def _set_inputFaces(self, value: "BRepFaceVector") -> "bool":
        r"""
        Gets and sets the input faces.
        If IsTangentChain is true, all the faces that are tangentially connected to the input faces (if any) will also be included.
        """
        return _fusion.DraftFeatureInput__set_inputFaces(self, value)

    def _get_plane(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets and sets the plane that defines the direction in which the draft is applied. This can be a planar BrepFace, or a ConstructionPlane."""
        return _fusion.DraftFeatureInput__get_plane(self)

    def _set_plane(self, value: "Base") -> "bool":
        r"""Gets and sets the plane that defines the direction in which the draft is applied. This can be a planar BrepFace, or a ConstructionPlane."""
        return _fusion.DraftFeatureInput__set_plane(self, value)

    def _get_isTangentChain(self) -> "bool":
        r"""
        Gets and sets if any faces that are tangentially connected to any of 
        the input faces will also be included in setting InputEntities. It defaults to true.
        """
        return _fusion.DraftFeatureInput__get_isTangentChain(self)

    def _set_isTangentChain(self, value: "bool") -> "bool":
        r"""
        Gets and sets if any faces that are tangentially connected to any of 
        the input faces will also be included in setting InputEntities. It defaults to true.
        """
        return _fusion.DraftFeatureInput__set_isTangentChain(self, value)

    def _get_isDirectionFlipped(self) -> "bool":
        r"""Gets and sets if the direction of the draft is flipped."""
        return _fusion.DraftFeatureInput__get_isDirectionFlipped(self)

    def _set_isDirectionFlipped(self, value: "bool") -> "bool":
        r"""Gets and sets if the direction of the draft is flipped."""
        return _fusion.DraftFeatureInput__set_isDirectionFlipped(self, value)

    def setSingleAngle(self, isSymmetric: "bool", angle: "ValueInput") -> "bool":
        r"""
        Defines the draft to be defined so that a single angle is used for all drafts.
        If the isSymmetric is true then the faces are split along the parting plane and drafted
        independently using the same angle. 
        isSymmetric : Set to 'true' if the faces are to be split along the plane and drafted symmetrically. This 
        will have the side effect of setting the isSymmetric property to the same value. 
        angle : The ValueInput object that defines the angle of the draft. This can be a positive or negative
        value which will affect the direction of the draft along with the isDirectionFlipped property. 
        Returns true if successful
        """
        return _fusion.DraftFeatureInput_setSingleAngle(self, isSymmetric, angle)

    def setTwoAngles(self, angleOne: "ValueInput", angleTwo: "ValueInput") -> "bool":
        r"""
        Defines both angles to use when the surfaces are split along the draft plane and
        the faces on each side of the plane are drafted independently from the other side. 
        angleOne : The ValueInput object that defines the angle for the faces on the first side of the draft plane. 
        angleTwo : The ValueInput object that defines the angle for the faces on the second side of the draft plane. 
        Returns true if successful
        """
        return _fusion.DraftFeatureInput_setTwoAngles(self, angleOne, angleTwo)

    def _get_angleOne(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets the first, or the only angle in the case of a single angle definition."""
        return _fusion.DraftFeatureInput__get_angleOne(self)

    def _get_angleTwo(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets the second angle. This can be null in the case where a single angle definition is used."""
        return _fusion.DraftFeatureInput__get_angleTwo(self)

    def _get_isSymmetric(self) -> "bool":
        r"""
        Gets if the draft is symmetric from the draft plane. This only applies in the case where two
        angles have been specified and should be ignored otherwise.
        """
        return _fusion.DraftFeatureInput__get_isSymmetric(self)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.DraftFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.DraftFeatureInput__set_targetBaseFeature(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.DraftFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.DraftFeatureInput__get_isValid(self)

# Register DraftFeatureInput in _fusion:
_fusion.DraftFeatureInput_swigregister(DraftFeatureInput)

def DraftFeatureInput_classType() -> "char const *":
    return _fusion.DraftFeatureInput_classType()


DraftFeatureInput.inputFaces = property(DraftFeatureInput._get_inputFaces, DraftFeatureInput._set_inputFaces, doc="Gets and sets the input faces.\nIf IsTangentChain is true, all the faces that are tangentially connected to the input faces (if any) will also be included.")


DraftFeatureInput.plane = property(DraftFeatureInput._get_plane, DraftFeatureInput._set_plane, doc="Gets and sets the plane that defines the direction in which the draft is applied. This can be a planar BrepFace, or a ConstructionPlane.")


DraftFeatureInput.isTangentChain = property(DraftFeatureInput._get_isTangentChain, DraftFeatureInput._set_isTangentChain, doc="Gets and sets if any faces that are tangentially connected to any of\nthe input faces will also be included in setting InputEntities. It defaults to true.")


DraftFeatureInput.isDirectionFlipped = property(DraftFeatureInput._get_isDirectionFlipped, DraftFeatureInput._set_isDirectionFlipped, doc="Gets and sets if the direction of the draft is flipped.")


DraftFeatureInput.angleOne = property(DraftFeatureInput._get_angleOne, doc="Gets the first, or the only angle in the case of a single angle definition.")


DraftFeatureInput.angleTwo = property(DraftFeatureInput._get_angleTwo, doc="Gets the second angle. This can be null in the case where a single angle definition is used.")


DraftFeatureInput.isSymmetric = property(DraftFeatureInput._get_isSymmetric, doc="Gets if the draft is symmetric from the draft plane. This only applies in the case where two\nangles have been specified and should be ignored otherwise.")


DraftFeatureInput.targetBaseFeature = property(DraftFeatureInput._get_targetBaseFeature, DraftFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


DraftFeatureInput.cast = lambda arg: arg if isinstance(arg, DraftFeatureInput) else None

class DraftFeatures(Base):
    r"""
    Collection that provides access to all of the existing draft features in a component
    and supports the ability to create new draft features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::DraftFeatures *":
        return _fusion.DraftFeatures___deref__(self)

    def __eq__(self, rhs: "DraftFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.DraftFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "DraftFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.DraftFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.DraftFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::DraftFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.DraftFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.DraftFeatures_classType()
    __swig_destroy__ = _fusion.delete_DraftFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::DraftFeature >":
        r"""
        Function that returns the specified draft feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.DraftFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of draft features in the collection."""
        return _fusion.DraftFeatures__get_count(self)

    def createInput(self, inputFaces: "BRepFaceVector", plane: "Base", isTangentChain: "bool"=True) -> "adsk::core::Ptr< adsk::fusion::DraftFeatureInput >":
        r"""
        Creates a DraftFeatureInput object. Use properties and methods on this object
        to define the draft you want to create and then use the Add method, passing in 
        the DraftFeatureInput object. 
        inputFaces : BRepFace array that contains the faces to which draft will be applied.
        The picked point on face is always the point returned from pointOnFace property of the first BRepFace in this collection. 
        plane : Input object that defines the direction in which the draft is applied. This can be a planar BrepFace, or a ConstructionPlane. 
        isTangentChain : A boolean value for setting whether or not faces that are tangentially connected to 
        any of the input faces (if any) will also be included. It defaults to true. 
        Returns the newly created DraftFeatureInput object or null if the creation failed.
        """
        return _fusion.DraftFeatures_createInput(self, inputFaces, plane, isTangentChain)

    def add(self, input: "DraftFeatureInput") -> "adsk::core::Ptr< adsk::fusion::DraftFeature >":
        r"""
        Creates a new draft feature. 
        input : A DraftFeatureInput object that defines the desired draft. Use the createInput 
        method to create a new DraftFeatureInput object and then use methods on it 
        (the DraftFeatureInput object) to define the draft. 
        Returns the newly created DraftFeature object or null if the creation failed.
        """
        return _fusion.DraftFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::DraftFeature >":
        r"""
        Function that returns the specified draft feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.DraftFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.DraftFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.DraftFeatures__get_isValid(self)

# Register DraftFeatures in _fusion:
_fusion.DraftFeatures_swigregister(DraftFeatures)

def DraftFeatures_classType() -> "char const *":
    return _fusion.DraftFeatures_classType()


DraftFeatures.count = property(DraftFeatures._get_count, doc="The number of draft features in the collection.")


DraftFeatures.cast = lambda arg: arg if isinstance(arg, DraftFeatures) else None

class ExportManager(Base):
    r"""Provides support for exporting model data to various formats."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ExportManager *":
        return _fusion.ExportManager___deref__(self)

    def __eq__(self, rhs: "ExportManager") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ExportManager___eq__(self, rhs)


    def __ne__(self, rhs: "ExportManager") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ExportManager___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ExportManager_classType()
    __swig_destroy__ = _fusion.delete_ExportManager

    def createIGESExportOptions(self, *args) -> "adsk::core::Ptr< adsk::fusion::IGESExportOptions >":
        r"""
        Creates an IGESExportOptions object that's used to export a design in IGES format. Creation
        of the IGESExportOptions object does not perform the export. You must pass this object to the
        ExportManager.execute method to perform the export. The IGESExportOptions supports any available
        options when exporting to IGES format. 
        filename : The filename of the IGES file to be created. 
        geometry : The geometry to export. Valid geometry for this is currently a Component object. This argument is optional
        and if not specified, it results in the root component and it entire contents being exported. 
        The created IGESExportOptions object or null if the creation failed.
        """
        return _fusion.ExportManager_createIGESExportOptions(self, *args)

    def createSTEPExportOptions(self, *args) -> "adsk::core::Ptr< adsk::fusion::STEPExportOptions >":
        r"""
        Creates an STEPExportOptions object that's used to export a design in STEP format. Creation
        of the STEPExportOptions object does not perform the export. You must pass this object to the
        ExportManager.execute method to perform the export. The STEPExportOptions supports any available
        options when exporting to STEP format. 
        filename : The filename of the STEP file to be created. 
        geometry : The geometry to export. Valid geometry for this is currently a Component object. This argument is optional
        and if not specified, it results in the root component and it entire contents being exported. 
        The created STEPExportOptions object or null if the creation failed.
        """
        return _fusion.ExportManager_createSTEPExportOptions(self, *args)

    def createSATExportOptions(self, *args) -> "adsk::core::Ptr< adsk::fusion::SATExportOptions >":
        r"""
        Creates an SATExportOptions object that's used to export a design in SAT format. Creation
        of the SATExportOptions object does not perform the export. You must pass this object to the
        ExportManager.execute method to perform the export. The SATExportOptions supports any available
        options when exporting to SAT format. 
        filename : The filename of the SAT file to be created. 
        geometry : The geometry to export. Valid geometry for this is currently a Component object. This argument is optional
        and if not specified, it results in the root component and it entire contents being exported. 
        The created SATExportOptions object or null if the creation failed.
        """
        return _fusion.ExportManager_createSATExportOptions(self, *args)

    def createSMTExportOptions(self, *args) -> "adsk::core::Ptr< adsk::fusion::SMTExportOptions >":
        r"""
        Creates an SMTExportOptions object that's used to export a design in SMT format. Creation
        of the SMTExportOptions object does not perform the export. You must pass this object to the
        ExportManager.execute method to perform the export. The SMTExportOptions supports any available
        options when exporting to SMT format. 
        filename : The filename of the SMT file to be created. 
        geometry : The geometry to export. Valid geometry for this is currently a Component object. This argument is optional
        and if not specified, it results in the root component and it entire contents being exported. 
        The created SMTExportOptions object or null if the creation failed.
        """
        return _fusion.ExportManager_createSMTExportOptions(self, *args)

    def createFusionArchiveExportOptions(self, *args) -> "adsk::core::Ptr< adsk::fusion::FusionArchiveExportOptions >":
        r"""
        Creates an FusionArchiveExportOptions object that's used to export a design in Fusion 360 archive format. Creation
        of the FusionArchiveExportOptions object does not perform the export. You must pass this object to the
        ExportManager.execute method to perform the export. The FusionArchiveExportOptions supports any available
        options when exporting to Fusion 360 archive format. 
        filename : The filename of the Fusion 360 archive file to be created. 
        geometry : The geometry to export. Valid geometry for this is currently a Component object. This argument is optional
        and if not specified, it results in the root component and it entire contents being exported. 
        The created FusionArchiveExportOptions object or null if the creation failed.
        """
        return _fusion.ExportManager_createFusionArchiveExportOptions(self, *args)

    def createSTLExportOptions(self, *args) -> "adsk::core::Ptr< adsk::fusion::STLExportOptions >":
        r"""
        Creates an STLExportOptions object that's used to export a design in STL format. Creation
        of the STLExportOptions object does not perform the export. You must pass this object to the
        ExportManager.execute method to perform the export. 
        geometry : The geometry to export. This can be a BRepBody, Occurrence, or the root Component object. 
        filename : The filename of the STL file to be created. This is optional and can be left out if the mesh will be opened in a mesh editor. 
        The created createSTLExportOptions object or null if the creation failed.
        """
        return _fusion.ExportManager_createSTLExportOptions(self, *args)

    def execute(self, exportOptions: "ExportOptions") -> "bool":
        r"""
        Executes the export operation to create the file in the format specified by the input ExportOptions object. 
        exportOptions : An ExportOptions object that is created using one of the create methods on the ExportManager object. This
        defines the type of file and any available options supported for that file type. 
        Returns true if the export was successful.
        """
        return _fusion.ExportManager_execute(self, exportOptions)

    def _get_objectType(self) -> "char const *":
        return _fusion.ExportManager__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ExportManager__get_isValid(self)

# Register ExportManager in _fusion:
_fusion.ExportManager_swigregister(ExportManager)

def ExportManager_classType() -> "char const *":
    return _fusion.ExportManager_classType()


ExportManager.cast = lambda arg: arg if isinstance(arg, ExportManager) else None

class ExportOptions(Base):
    r"""
    The base class for the different export types. This class is never directly used
    in an export because you need the specific export type to specify the type of
    export to be performed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ExportOptions *":
        return _fusion.ExportOptions___deref__(self)

    def __eq__(self, rhs: "ExportOptions") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ExportOptions___eq__(self, rhs)


    def __ne__(self, rhs: "ExportOptions") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ExportOptions___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ExportOptions_classType()
    __swig_destroy__ = _fusion.delete_ExportOptions

    def _get_filename(self) -> "std::string":
        r"""
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.ExportOptions__get_filename(self)

    def _set_filename(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.ExportOptions__set_filename(self, value)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Specifies the geometry to export. This can be an Occurrence, or the root Component. 
        For STL export, it can also be a BRepBody. For DXF export, it can be a sketch of flat pattern.
        """
        return _fusion.ExportOptions__get_geometry(self)

    def _set_geometry(self, value: "Base") -> "bool":
        r"""
        Specifies the geometry to export. This can be an Occurrence, or the root Component. 
        For STL export, it can also be a BRepBody. For DXF export, it can be a sketch of flat pattern.
        """
        return _fusion.ExportOptions__set_geometry(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.ExportOptions__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ExportOptions__get_isValid(self)

# Register ExportOptions in _fusion:
_fusion.ExportOptions_swigregister(ExportOptions)

def ExportOptions_classType() -> "char const *":
    return _fusion.ExportOptions_classType()


ExportOptions.filename = property(ExportOptions._get_filename, ExportOptions._set_filename, doc="Gets and sets the filename that the exported file will be written to. This can\nbe empty in the case of STL export and sending the result to the mesh editor.")


ExportOptions.geometry = property(ExportOptions._get_geometry, ExportOptions._set_geometry, doc="Specifies the geometry to export. This can be an Occurrence, or the root Component.\nFor STL export, it can also be a BRepBody. For DXF export, it can be a sketch of flat pattern.")


ExportOptions.cast = lambda arg: arg if isinstance(arg, ExportOptions) else None

class ExtendFeatureInput(Base):
    r"""This class defines the methods and properties that pertain to the definition of a extend feature."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ExtendFeatureInput *":
        return _fusion.ExtendFeatureInput___deref__(self)

    def __eq__(self, rhs: "ExtendFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ExtendFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "ExtendFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ExtendFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ExtendFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_ExtendFeatureInput

    def _get_edges(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""Gets and sets the edges to extend"""
        return _fusion.ExtendFeatureInput__get_edges(self)

    def _set_edges(self, value: "ObjectCollection") -> "bool":
        r"""Gets and sets the edges to extend"""
        return _fusion.ExtendFeatureInput__set_edges(self, value)

    def _get_distance(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets and sets the ValueInput object that defines the extend distance"""
        return _fusion.ExtendFeatureInput__get_distance(self)

    def _set_distance(self, value: "ValueInput") -> "bool":
        r"""Gets and sets the ValueInput object that defines the extend distance"""
        return _fusion.ExtendFeatureInput__set_distance(self, value)

    def _get_extendType(self) -> "adsk::fusion::SurfaceExtendTypes":
        r"""Gets and sets surface extend type to use"""
        return _fusion.ExtendFeatureInput__get_extendType(self)

    def _set_extendType(self, value: "SurfaceExtendTypes") -> "bool":
        r"""Gets and sets surface extend type to use"""
        return _fusion.ExtendFeatureInput__set_extendType(self, value)

    def _get_isChainingEnabled(self) -> "bool":
        r"""
        Gets and sets if all edges that are tangent or curvature continuous, and end point connected, will be found 
        automatically and extended.
        """
        return _fusion.ExtendFeatureInput__get_isChainingEnabled(self)

    def _set_isChainingEnabled(self, value: "bool") -> "bool":
        r"""
        Gets and sets if all edges that are tangent or curvature continuous, and end point connected, will be found 
        automatically and extended.
        """
        return _fusion.ExtendFeatureInput__set_isChainingEnabled(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ExtendFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ExtendFeatureInput__set_targetBaseFeature(self, value)

    def _get_extendAlignment(self) -> "adsk::fusion::SurfaceExtendAlignment":
        r"""Gets and sets surface extend alignment to use."""
        return _fusion.ExtendFeatureInput__get_extendAlignment(self)

    def _set_extendAlignment(self, value: "SurfaceExtendAlignment") -> "bool":
        r"""Gets and sets surface extend alignment to use."""
        return _fusion.ExtendFeatureInput__set_extendAlignment(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.ExtendFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ExtendFeatureInput__get_isValid(self)

# Register ExtendFeatureInput in _fusion:
_fusion.ExtendFeatureInput_swigregister(ExtendFeatureInput)

def ExtendFeatureInput_classType() -> "char const *":
    return _fusion.ExtendFeatureInput_classType()


ExtendFeatureInput.edges = property(ExtendFeatureInput._get_edges, ExtendFeatureInput._set_edges, doc="Gets and sets the edges to extend")


ExtendFeatureInput.distance = property(ExtendFeatureInput._get_distance, ExtendFeatureInput._set_distance, doc="Gets and sets the ValueInput object that defines the extend distance")


ExtendFeatureInput.extendType = property(ExtendFeatureInput._get_extendType, ExtendFeatureInput._set_extendType, doc="Gets and sets surface extend type to use")


ExtendFeatureInput.isChainingEnabled = property(ExtendFeatureInput._get_isChainingEnabled, ExtendFeatureInput._set_isChainingEnabled, doc="Gets and sets if all edges that are tangent or curvature continuous, and end point connected, will be found\nautomatically and extended.")


ExtendFeatureInput.targetBaseFeature = property(ExtendFeatureInput._get_targetBaseFeature, ExtendFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


ExtendFeatureInput.extendAlignment = property(ExtendFeatureInput._get_extendAlignment, ExtendFeatureInput._set_extendAlignment, doc="Gets and sets surface extend alignment to use.")


ExtendFeatureInput.cast = lambda arg: arg if isinstance(arg, ExtendFeatureInput) else None

class ExtendFeatures(Base):
    r"""
    Collection that provides access to all of the existing Extend features in a component
    and supports the ability to create new Extend features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ExtendFeatures *":
        return _fusion.ExtendFeatures___deref__(self)

    def __eq__(self, rhs: "ExtendFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ExtendFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "ExtendFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ExtendFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.ExtendFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::ExtendFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.ExtendFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ExtendFeatures_classType()
    __swig_destroy__ = _fusion.delete_ExtendFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::ExtendFeature >":
        r"""
        Function that returns the specified extend feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ExtendFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of Extend features in the collection."""
        return _fusion.ExtendFeatures__get_count(self)

    def createInput(self, edges: "ObjectCollection", distance: "ValueInput", extendType: "SurfaceExtendTypes", isChainingEnabled: "bool"=True) -> "adsk::core::Ptr< adsk::fusion::ExtendFeatureInput >":
        r"""
        Creates a ExtendFeatureInput object. Use properties and methods on this object
        to define the extend feature you want to create and then use the Add method, passing in 
        the ExtendFeatureInput object. 
        edges : The surface edges to extend.
        Only the outer edges from an open body can be extended. The edges must all be from the same body.
        Depending on the extend type there can also be some limitations on the edges being input as described below
        for the extendType argument. 
        distance : ValueInput object that defines the distance to extend the face/s.
        Natural and Tangent Extend types require a positive distance value.
        Perpendicular Extend Type supports either a positive or negative value to
        control the direction of the extend. A positive number results in the
        perpendicular extension being in the same direction as the positive normal
        of the connected faces. 
        extendType : The extension type to use when extending the face(s).
        Input edges must be connected at endpoints when Tangent or Perpendicular Extend Types are used. 
        Input edges need not be connected when Natural Extend type is used. 
        isChainingEnabled : An optional boolean argument whose default is true. If this argument is true, all edges that are 
        tangent or curvature continuous, and end point connected, will be found automatically and include
        in the set of edges to extend. 
        Returns the newly created ExtendFeatureInput object or null if the creation failed.
        """
        return _fusion.ExtendFeatures_createInput(self, edges, distance, extendType, isChainingEnabled)

    def add(self, input: "ExtendFeatureInput") -> "adsk::core::Ptr< adsk::fusion::ExtendFeature >":
        r"""
        Creates a new extend feature. 
        input : An ExtendFeatureInput object that defines the desired extend feature. Use the createInput 
        method to create a new ExtendFeatureInput object and then use methods on it 
        (the ExtendFeatureInput object) to define the desired options for the extent feature. 
        Returns the newly created ExtendFeature object or null if the creation failed.
        """
        return _fusion.ExtendFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::ExtendFeature >":
        r"""
        Function that returns the specified extend feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.ExtendFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.ExtendFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ExtendFeatures__get_isValid(self)

# Register ExtendFeatures in _fusion:
_fusion.ExtendFeatures_swigregister(ExtendFeatures)

def ExtendFeatures_classType() -> "char const *":
    return _fusion.ExtendFeatures_classType()


ExtendFeatures.count = property(ExtendFeatures._get_count, doc="The number of Extend features in the collection.")


ExtendFeatures.cast = lambda arg: arg if isinstance(arg, ExtendFeatures) else None

class ExtentDefinition(Base):
    r"""The base class for the various definition objects used to define the extent of a feature."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ExtentDefinition *":
        return _fusion.ExtentDefinition___deref__(self)

    def __eq__(self, rhs: "ExtentDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ExtentDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ExtentDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ExtentDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ExtentDefinition_classType()
    __swig_destroy__ = _fusion.delete_ExtentDefinition

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >":
        r"""
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.ExtentDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ExtentDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ExtentDefinition__get_isValid(self)

# Register ExtentDefinition in _fusion:
_fusion.ExtentDefinition_swigregister(ExtentDefinition)

def ExtentDefinition_classType() -> "char const *":
    return _fusion.ExtentDefinition_classType()


ExtentDefinition.parentFeature = property(ExtentDefinition._get_parentFeature, doc="Returns the parent feature that this definition is associated with. If this definition has been created\nstatically and is not associated with a feature this property will return null.")


ExtentDefinition.cast = lambda arg: arg if isinstance(arg, ExtentDefinition) else None

class ExtrudeFeatureInput(Base):
    r"""
    This class defines the methods and properties that pertain to the definition of an extrude 
    feature. This class also provides properties for setting/getting the Profile and Operation 
    of the extrude. The Profile and Operation are defined when the ExtrudeFeatures.createInput 
    method is called so they do not exist as properties on this class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ExtrudeFeatureInput *":
        return _fusion.ExtrudeFeatureInput___deref__(self)

    def __eq__(self, rhs: "ExtrudeFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ExtrudeFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "ExtrudeFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ExtrudeFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ExtrudeFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_ExtrudeFeatureInput

    def _get_profile(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the profiles or planar faces used to define the shape of the extrude.
        This property can return or be set with a single profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        To create a surface (non-solid) extrusion, you can use the createOpenProfile and createBRepEdgeProfile
        methods of the Component object to create an open profile. The isSolid property of the
        ExtrudeFeatureInput property must also be False.
        """
        return _fusion.ExtrudeFeatureInput__get_profile(self)

    def _set_profile(self, value: "Base") -> "bool":
        r"""
        Gets and sets the profiles or planar faces used to define the shape of the extrude.
        This property can return or be set with a single profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        To create a surface (non-solid) extrusion, you can use the createOpenProfile and createBRepEdgeProfile
        methods of the Component object to create an open profile. The isSolid property of the
        ExtrudeFeatureInput property must also be False.
        """
        return _fusion.ExtrudeFeatureInput__set_profile(self, value)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations":
        r"""Gets and sets the type of operation performed by the extrusion."""
        return _fusion.ExtrudeFeatureInput__get_operation(self)

    def _set_operation(self, value: "FeatureOperations") -> "bool":
        r"""Gets and sets the type of operation performed by the extrusion."""
        return _fusion.ExtrudeFeatureInput__set_operation(self, value)

    def _get_taperAngle(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Gets and sets the taper angle of the extrusion. This is used to define the
        taper angle for a single sided and symmetric and defines the angle for side one
        of a two sided extrusion. This property is initialized with a taper angle of zero.
        A negative angle will taper the extrusion inward while a positive value will taper
        the extrusion outward. This property is valid for both parametric and non-parametric extrusions.
        """
        return _fusion.ExtrudeFeatureInput__get_taperAngle(self)

    def _set_taperAngle(self, value: "ValueInput") -> "bool":
        r"""
        Gets and sets the taper angle of the extrusion. This is used to define the
        taper angle for a single sided and symmetric and defines the angle for side one
        of a two sided extrusion. This property is initialized with a taper angle of zero.
        A negative angle will taper the extrusion inward while a positive value will taper
        the extrusion outward. This property is valid for both parametric and non-parametric extrusions.
        """
        return _fusion.ExtrudeFeatureInput__set_taperAngle(self, value)

    def setDistanceExtent(self, isSymmetric: "bool", distance: "ValueInput") -> "bool":
        r"""
        Sets the extrusion extents option to 'Distance'. 
        isSymmetric : Set to 'true' for an extrusion symmetrical about the profile plane 
        distance : ValueInput object that defines the extrude distance.
        If the isSymmetric argument is 'false', a positive or negative distance can be used to control the direction. 
        Returns true if successful
        """
        return _fusion.ExtrudeFeatureInput_setDistanceExtent(self, isSymmetric, distance)

    def setTwoSidesDistanceExtent(self, distanceOne: "ValueInput", distanceTwo: "ValueInput") -> "bool":
        r"""
        Sets the extrusion extents option to 'Two Side'.
        This method will fail in the case of a non-parametric extrusion. 
        distanceOne : ValueInput object that defines the extrude distance for the first side. 
        distanceTwo : ValueInput object that defines the extrude distance for the second side. 
        Returns true if successful
        """
        return _fusion.ExtrudeFeatureInput_setTwoSidesDistanceExtent(self, distanceOne, distanceTwo)

    def setAllExtent(self, direction: "ExtentDirections") -> "bool":
        r"""
        Sets the extrusion extents option to 'All' (i.e. the extrusion is through-all, in both directions.)
        This method will fail in the case of a non-parametric extrusion. 
        direction : The direction can be either positive, negative, or symmetric. 
        Returns true if successful
        """
        return _fusion.ExtrudeFeatureInput_setAllExtent(self, direction)

    def setOneSideToExtent(self, *args) -> "bool":
        r"""
        Sets the extrusion Direction option to 'One Side' and the Extents option to 'To' (a specified face) 
        toEntity : The entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For an extrude it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        matchShape : If the matchShape argument is 'true', the toEntity is extended to fully intersect the extrusion. 
        directionHint : Specifies the direction of the extrusion. This is only used in the case where there are two possible solutions and the extrusion can
        hit the toEntity in either direction. An example is if the profile of the extrusion is within a hole.
        The extrusion will intersect the cylinder of the hole in either direction.
        Typically there is only a single solution and the direction is determined automatically. 
        Returns true if successful.
        """
        return _fusion.ExtrudeFeatureInput_setOneSideToExtent(self, *args)

    def setTwoSidesToExtent(self, toEntityOne: "Base", toEntityTwo: "Base", matchShape: "bool") -> "bool":
        r"""
        Set the extrusion Direction option to 'Two Side'
        This method will fail in the case of a non-parametric extrusion. 
        toEntityOne : The first entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For an extrude it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        toEntityTwo : The second entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For an extrude it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        matchShape : If the matchShape argument is 'true', the toEntity is extended to fully intersect the extrusion. 
        Returns true if successful.
        """
        return _fusion.ExtrudeFeatureInput_setTwoSidesToExtent(self, toEntityOne, toEntityTwo, matchShape)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the Extrusion is created based on geometry (e.g. a profile and/or face(s))
        in another component AND (the Extrusion) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.ExtrudeFeatureInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, value: "Occurrence") -> "bool":
        r"""
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the Extrusion is created based on geometry (e.g. a profile and/or face(s))
        in another component AND (the Extrusion) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.ExtrudeFeatureInput__set_creationOccurrence(self, value)

    def _get_isSolid(self) -> "bool":
        r"""
        Specifies if the extrusion should be created as a solid or surface. If
        it's a surface then there aren't any end caps and it's open. When a ExtrudeFeature
        input is created, this is initialized to true so a solid will be created if it's not changed.
        """
        return _fusion.ExtrudeFeatureInput__get_isSolid(self)

    def _set_isSolid(self, value: "bool") -> "bool":
        r"""
        Specifies if the extrusion should be created as a solid or surface. If
        it's a surface then there aren't any end caps and it's open. When a ExtrudeFeature
        input is created, this is initialized to true so a solid will be created if it's not changed.
        """
        return _fusion.ExtrudeFeatureInput__set_isSolid(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ExtrudeFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ExtrudeFeatureInput__set_targetBaseFeature(self, value)

    def _get_startExtent(self) -> "adsk::core::Ptr< adsk::fusion::ExtentDefinition >":
        r"""
        Gets and sets the extent used to define the start of the extrusion. When a new ExtrudeFeatureInput
        object is created the start extent is initialized to be the profile plane but you can change it
        to a profile plane with offset or from an object by setting this property with either a 
        ProfilePlaneWithOffsetStartDefinition or a EntityStartDefinition object. You can get either one
        of those objects by using the static create method on the class.
        """
        return _fusion.ExtrudeFeatureInput__get_startExtent(self)

    def _set_startExtent(self, value: "ExtentDefinition") -> "bool":
        r"""
        Gets and sets the extent used to define the start of the extrusion. When a new ExtrudeFeatureInput
        object is created the start extent is initialized to be the profile plane but you can change it
        to a profile plane with offset or from an object by setting this property with either a 
        ProfilePlaneWithOffsetStartDefinition or a EntityStartDefinition object. You can get either one
        of those objects by using the static create method on the class.
        """
        return _fusion.ExtrudeFeatureInput__set_startExtent(self, value)

    def setOneSideExtent(self, *args) -> "bool":
        r"""
        Defines the extrusion to go in one direction from the profile. The extent of the extrusion is 
        defined by the extent argument. 
        extent : An ExtentDefinition object that defines how the extent of the extrusion is defined. This can be
        a specified distance (DistanceExtentDefinition), to an entity (ToEntityExtent), or through-all (AllExtentDefinition).
        These objects can be obtained by using the static create method on the appropriate class. 
        direction : Specifies the direction of the extrusion. PositiveExtentDirection and NegativeExtentDirection
        are valid values. PositiveExtentDirection is in the same direction as the normal of the profile's
        parent sketch plane. 
        taperAngle : Optional argument that specifies the taper angle. If omitted a taper angle of 0 is used. 
        Returns true is setting the input to a one sided extent was successful.
        """
        return _fusion.ExtrudeFeatureInput_setOneSideExtent(self, *args)

    def setTwoSidesExtent(self, *args) -> "bool":
        r"""
        Defines the extrusion to go in both directions from the profile. The extent is defined independently
        for each direction using the input arguments. 
        sideOneExtent : An ExtentDefinition object that defines how the extent of the extrusion towards side one is defined. This can be
        a specified distance (DistanceExtentDefinition), to an entity (ToEntityExtent), or through-all (AllExtentDefinition).
        These objects can be obtained by using the static create method on the appropriate class. 
        sideTwoExtent : An ExtentDefinition object that defines how the extent of the extrusion towards side two is defined. This can be
        a specified distance (DistanceExtentDefinition), to an entity (ToEntityExtent), or through-all (AllExtentDefinition).
        These objects can be obtained by using the static create method on the appropriate class. 
        sideOneTaperAngle : Optional argument that specifies the taper angle for side one. If omitted a taper angle of 0 is used. 
        sideTwoTaperAngle : Optional argument that specifies the taper angle for side two. If omitted a taper angle of 0 is used. 
        Returns true is setting the extent was successful.
        """
        return _fusion.ExtrudeFeatureInput_setTwoSidesExtent(self, *args)

    def setSymmetricExtent(self, *args) -> "bool":
        r"""
        Defines the extrusion to go symmetrically in both directions from the profile. 
        distance : The distance of the extrusions. This is either the full length of half of the length of the final extrusion
        depending on the value of the isFullLength property. 
        isFullLength : Defines if the value defines the full length of the extrusion or half of the length. A value of true indicates
        it defines the full length. 
        taperAngle : Optional argument that specifies the taper angle. The same taper angle is used for both sides for a symmetric 
        extrusion. If omitted a taper angle of 0 is used. 
        Returns true is setting the extent was successful.
        """
        return _fusion.ExtrudeFeatureInput_setSymmetricExtent(self, *args)

    def _get_extentOne(self) -> "adsk::core::Ptr< adsk::fusion::ExtentDefinition >":
        r"""
        Gets the extent assigned for a single sided extrude or side one of a two-sided extrusion. To set the extent, use
        one of the set methods on the ExtrudeFeatureInput object.
        """
        return _fusion.ExtrudeFeatureInput__get_extentOne(self)

    def _get_extentTwo(self) -> "adsk::core::Ptr< adsk::fusion::ExtentDefinition >":
        r"""
        Gets the extent assigned for side two of the extrusion. If the extrude is single sided extrude this
        property will return null. The hasTwoExtents property can be used to determine if there
        are two sides or not. To set the extent, use one of the set methods on the ExtrudeFeatureInput object.
        """
        return _fusion.ExtrudeFeatureInput__get_extentTwo(self)

    def _get_taperAngleOne(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Gets the value that will be used as the taper angle for a single sided extrusion or side one of a two-sided
        extrusion. To set the taper angle, use one of the set methods on the ExtrudeFeatureInput object.
        """
        return _fusion.ExtrudeFeatureInput__get_taperAngleOne(self)

    def _get_taperAngleTwo(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Gets the value that will be used as the taper angle for side two of a two-sided extrusion. If the extrusion is 
        single-sided, this property will return null. The hasTwoExtents property can be used to determine if there
        are two sides or not. To set the taper angle, use one of the set methods on the ExtrudeFeatureInput object.
        """
        return _fusion.ExtrudeFeatureInput__get_taperAngleTwo(self)

    def _get_hasTwoExtents(self) -> "bool":
        r"""
        Property that indicates if the extrusion is a single or two-sided extrusion. If false, the extentTwo
        and taperAngleTwo properties should not be used.
        """
        return _fusion.ExtrudeFeatureInput__get_hasTwoExtents(self)

    def _get_participantBodies(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepBody > > >":
        r"""
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        If this property has not been set, the default behavior is that all bodies that are intersected by the 
        feature will participate.
        This property can return null in the case where the feature has not been fully defined so that
        possible intersecting bodies can be computed.
        """
        return _fusion.ExtrudeFeatureInput__get_participantBodies(self)

    def _set_participantBodies(self, value: "BRepBodyVector") -> "bool":
        r"""
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        If this property has not been set, the default behavior is that all bodies that are intersected by the 
        feature will participate.
        This property can return null in the case where the feature has not been fully defined so that
        possible intersecting bodies can be computed.
        """
        return _fusion.ExtrudeFeatureInput__set_participantBodies(self, value)

    def _get_isThinExtrude(self) -> "bool":
        r"""
        Sets or returns whether the extrude is a thin extrude.
        Setting it as false will make it a regular extrude.
        """
        return _fusion.ExtrudeFeatureInput__get_isThinExtrude(self)

    def _set_isThinExtrude(self, value: "bool") -> "bool":
        r"""
        Sets or returns whether the extrude is a thin extrude.
        Setting it as false will make it a regular extrude.
        """
        return _fusion.ExtrudeFeatureInput__set_isThinExtrude(self, value)

    def setThinExtrude(self, *args) -> "bool":
        r"""
        Changes the extrude feature to be a thin extrude. This is only valid if the isThinExtrude property
        is False. If the extrusion is already a thin extrude, you can use the properties on the ExtrudeFeature
        to modify the thin extrude specific values. 
        thinExtrudeWallLocationOne : Specifies the position of the thin wall extrude with respect to the profile being extruded. This defines
        the direction for a single sided thin extrude or side one of a two-sided extrusion. 
        thinExtrudeWallThicknessOne : A ValueInput object that defines the thickness for a single sided thin extrude or side one of a two-sided
        extrusion . 
        thinExtrudeWallLocationTwo : Optional argument that specifys the position of side two of a two-sided extrusion. This argument is ignored
        for a single sided thin extrude. 
        thinExtrudeWallThicknessTwo : Optional argument that is a ValueInput object that defines the thickness for side two of a
        two-sided extrusion extrusion. This argument is ignored for a single sided thin extrude. 
        Returns true if successful.
        """
        return _fusion.ExtrudeFeatureInput_setThinExtrude(self, *args)

    def _get_thinExtrudeWallLocationOne(self) -> "adsk::fusion::ThinExtrudeWallLocation":
        r"""Gets and sets the wall location for a one sided thin extrude or side one of a two sided thin extrude"""
        return _fusion.ExtrudeFeatureInput__get_thinExtrudeWallLocationOne(self)

    def _set_thinExtrudeWallLocationOne(self, value: "ThinExtrudeWallLocation") -> "bool":
        r"""Gets and sets the wall location for a one sided thin extrude or side one of a two sided thin extrude"""
        return _fusion.ExtrudeFeatureInput__set_thinExtrudeWallLocationOne(self, value)

    def _get_thinExtrudeWallLocationTwo(self) -> "adsk::fusion::ThinExtrudeWallLocation":
        r"""Gets and sets the wall location for side two of a two sided thin extrude"""
        return _fusion.ExtrudeFeatureInput__get_thinExtrudeWallLocationTwo(self)

    def _set_thinExtrudeWallLocationTwo(self, value: "ThinExtrudeWallLocation") -> "bool":
        r"""Gets and sets the wall location for side two of a two sided thin extrude"""
        return _fusion.ExtrudeFeatureInput__set_thinExtrudeWallLocationTwo(self, value)

    def _get_thinExtrudeWallThicknessOne(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets and sets the wall thickness for a one sided thin extrude or side one of a two sided thin extrude"""
        return _fusion.ExtrudeFeatureInput__get_thinExtrudeWallThicknessOne(self)

    def _set_thinExtrudeWallThicknessOne(self, value: "ValueInput") -> "bool":
        r"""Gets and sets the wall thickness for a one sided thin extrude or side one of a two sided thin extrude"""
        return _fusion.ExtrudeFeatureInput__set_thinExtrudeWallThicknessOne(self, value)

    def _get_thinExtrudeWallThicknessTwo(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets and sets the wall thickness for side two of a two sided thin extrude"""
        return _fusion.ExtrudeFeatureInput__get_thinExtrudeWallThicknessTwo(self)

    def _set_thinExtrudeWallThicknessTwo(self, value: "ValueInput") -> "bool":
        r"""Gets and sets the wall thickness for side two of a two sided thin extrude"""
        return _fusion.ExtrudeFeatureInput__set_thinExtrudeWallThicknessTwo(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.ExtrudeFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ExtrudeFeatureInput__get_isValid(self)

# Register ExtrudeFeatureInput in _fusion:
_fusion.ExtrudeFeatureInput_swigregister(ExtrudeFeatureInput)

def ExtrudeFeatureInput_classType() -> "char const *":
    return _fusion.ExtrudeFeatureInput_classType()


ExtrudeFeatureInput.profile = property(ExtrudeFeatureInput._get_profile, ExtrudeFeatureInput._set_profile, doc="Gets and sets the profiles or planar faces used to define the shape of the extrude.\nThis property can return or be set with a single profile, a single planar face, or\nan ObjectCollection consisting of multiple profiles and planar faces. When an\nObjectCollection is used all of the profiles and faces must be co-planar.\nTo create a surface (non-solid) extrusion, you can use the createOpenProfile and createBRepEdgeProfile\nmethods of the Component object to create an open profile. The isSolid property of the\nExtrudeFeatureInput property must also be False.")


ExtrudeFeatureInput.operation = property(ExtrudeFeatureInput._get_operation, ExtrudeFeatureInput._set_operation, doc="Gets and sets the type of operation performed by the extrusion.")


ExtrudeFeatureInput.taperAngle = property(ExtrudeFeatureInput._get_taperAngle, ExtrudeFeatureInput._set_taperAngle, doc="Gets and sets the taper angle of the extrusion. This is used to define the\ntaper angle for a single sided and symmetric and defines the angle for side one\nof a two sided extrusion. This property is initialized with a taper angle of zero.\nA negative angle will taper the extrusion inward while a positive value will taper\nthe extrusion outward. This property is valid for both parametric and non-parametric extrusions.")


ExtrudeFeatureInput.creationOccurrence = property(ExtrudeFeatureInput._get_creationOccurrence, ExtrudeFeatureInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an Occurrence for creation needs to be\nspecified when the Extrusion is created based on geometry (e.g. a profile and/or face(s))\nin another component AND (the Extrusion) is not in the root component.\nThe CreationOccurrence is analogous to the active occurrence in the UI")


ExtrudeFeatureInput.isSolid = property(ExtrudeFeatureInput._get_isSolid, ExtrudeFeatureInput._set_isSolid, doc="Specifies if the extrusion should be created as a solid or surface. If\nit's a surface then there aren't any end caps and it's open. When a ExtrudeFeature\ninput is created, this is initialized to true so a solid will be created if it's not changed.")


ExtrudeFeatureInput.targetBaseFeature = property(ExtrudeFeatureInput._get_targetBaseFeature, ExtrudeFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


ExtrudeFeatureInput.startExtent = property(ExtrudeFeatureInput._get_startExtent, ExtrudeFeatureInput._set_startExtent, doc="Gets and sets the extent used to define the start of the extrusion. When a new ExtrudeFeatureInput\nobject is created the start extent is initialized to be the profile plane but you can change it\nto a profile plane with offset or from an object by setting this property with either a\nProfilePlaneWithOffsetStartDefinition or a EntityStartDefinition object. You can get either one\nof those objects by using the static create method on the class.")


ExtrudeFeatureInput.extentOne = property(ExtrudeFeatureInput._get_extentOne, doc="Gets the extent assigned for a single sided extrude or side one of a two-sided extrusion. To set the extent, use\none of the set methods on the ExtrudeFeatureInput object.")


ExtrudeFeatureInput.extentTwo = property(ExtrudeFeatureInput._get_extentTwo, doc="Gets the extent assigned for side two of the extrusion. If the extrude is single sided extrude this\nproperty will return null. The hasTwoExtents property can be used to determine if there\nare two sides or not. To set the extent, use one of the set methods on the ExtrudeFeatureInput object.")


ExtrudeFeatureInput.taperAngleOne = property(ExtrudeFeatureInput._get_taperAngleOne, doc="Gets the value that will be used as the taper angle for a single sided extrusion or side one of a two-sided\nextrusion. To set the taper angle, use one of the set methods on the ExtrudeFeatureInput object.")


ExtrudeFeatureInput.taperAngleTwo = property(ExtrudeFeatureInput._get_taperAngleTwo, doc="Gets the value that will be used as the taper angle for side two of a two-sided extrusion. If the extrusion is\nsingle-sided, this property will return null. The hasTwoExtents property can be used to determine if there\nare two sides or not. To set the taper angle, use one of the set methods on the ExtrudeFeatureInput object.")


ExtrudeFeatureInput.hasTwoExtents = property(ExtrudeFeatureInput._get_hasTwoExtents, doc="Property that indicates if the extrusion is a single or two-sided extrusion. If false, the extentTwo\nand taperAngleTwo properties should not be used.")


ExtrudeFeatureInput.participantBodies = property(ExtrudeFeatureInput._get_participantBodies, ExtrudeFeatureInput._set_participantBodies, doc="Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.\nIf this property has not been set, the default behavior is that all bodies that are intersected by the\nfeature will participate.\nThis property can return null in the case where the feature has not been fully defined so that\npossible intersecting bodies can be computed.")


ExtrudeFeatureInput.isThinExtrude = property(ExtrudeFeatureInput._get_isThinExtrude, ExtrudeFeatureInput._set_isThinExtrude, doc="Sets or returns whether the extrude is a thin extrude.\nSetting it as false will make it a regular extrude.")


ExtrudeFeatureInput.thinExtrudeWallLocationOne = property(ExtrudeFeatureInput._get_thinExtrudeWallLocationOne, ExtrudeFeatureInput._set_thinExtrudeWallLocationOne, doc="Gets and sets the wall location for a one sided thin extrude or side one of a two sided thin extrude")


ExtrudeFeatureInput.thinExtrudeWallLocationTwo = property(ExtrudeFeatureInput._get_thinExtrudeWallLocationTwo, ExtrudeFeatureInput._set_thinExtrudeWallLocationTwo, doc="Gets and sets the wall location for side two of a two sided thin extrude")


ExtrudeFeatureInput.thinExtrudeWallThicknessOne = property(ExtrudeFeatureInput._get_thinExtrudeWallThicknessOne, ExtrudeFeatureInput._set_thinExtrudeWallThicknessOne, doc="Gets and sets the wall thickness for a one sided thin extrude or side one of a two sided thin extrude")


ExtrudeFeatureInput.thinExtrudeWallThicknessTwo = property(ExtrudeFeatureInput._get_thinExtrudeWallThicknessTwo, ExtrudeFeatureInput._set_thinExtrudeWallThicknessTwo, doc="Gets and sets the wall thickness for side two of a two sided thin extrude")


ExtrudeFeatureInput.cast = lambda arg: arg if isinstance(arg, ExtrudeFeatureInput) else None

class ExtrudeFeatures(Base):
    r"""
    Collection that provides access to all of the existing extrude features in a design
    and supports the ability to create new extrude features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ExtrudeFeatures *":
        return _fusion.ExtrudeFeatures___deref__(self)

    def __eq__(self, rhs: "ExtrudeFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ExtrudeFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "ExtrudeFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ExtrudeFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.ExtrudeFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::ExtrudeFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.ExtrudeFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ExtrudeFeatures_classType()
    __swig_destroy__ = _fusion.delete_ExtrudeFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::ExtrudeFeature >":
        r"""
        Function that returns the specified extrude feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ExtrudeFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of extrude features in the collection."""
        return _fusion.ExtrudeFeatures__get_count(self)

    def createInput(self, profile: "Base", operation: "FeatureOperations") -> "adsk::core::Ptr< adsk::fusion::ExtrudeFeatureInput >":
        r"""
        Creates a new ExtrudeFeatureInput object that is used to specify the input needed
        to create a new extrude feature. 
        profile : The profile argument can be a single Profile, a single planar face, a single SketchText object,
        or an ObjectCollection consisting of multiple profiles, planar faces, and sketch texts.
        When an ObjectCollection is used all of the profiles, faces, and sketch texts must be co-planar.
        To create a surface (non-solid) extrusion, you can use the createOpenProfile and createBRepEdgeProfile
        methods of the Component object to create an open profile. You also need to set the isSolid property
        of the returned ExtrudeFeatureInput property to False. 
        operation : The feature operation to perform. 
        Returns the newly created ExtrudeFeatureInput object or null if the creation failed.
        """
        return _fusion.ExtrudeFeatures_createInput(self, profile, operation)

    def add(self, input: "ExtrudeFeatureInput") -> "adsk::core::Ptr< adsk::fusion::ExtrudeFeature >":
        r"""
        Creates a new extrude feature based on the information defined by the provided ExtrudeFeatureInput object.
        To create a new extrusion use the createInput function to create a new input object and use the methods and 
        properties on that object to define the required input for an extrusion. Once the information is defined on the
        input object you can pass it to the Add method to create the extrusion. 
        input : The ExtrudeFeatureInput object that specifies the input needed to create a new extrude 
        feature. 
        Returns the newly created ExtrudeFeature or null if the creation failed.
        """
        return _fusion.ExtrudeFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::ExtrudeFeature >":
        r"""
        Function that returns the specified extrude feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.ExtrudeFeatures_itemByName(self, name)

    def addSimple(self, profile: "Base", distance: "ValueInput", operation: "FeatureOperations") -> "adsk::core::Ptr< adsk::fusion::ExtrudeFeature >":
        r"""
        Creates a basic extrusion that goes from the profile plane the specified distance. 
        profile : The profile argument can be a single Profile, a single planar face, a single SketchText object,
        or an ObjectCollection consisting of multiple profiles, planar faces, and sketch texts.
        When an ObjectCollection is used all of the profiles, faces, and sketch texts must be co-planar.
        To create a surface (non-solid) extrusion, you can use the createOpenProfile and createBRepEdgeProfile
        methods of the Component object to create an open profile. You also need to set the isSolid property
        of the returned ExtrudeFeatureInput property to False. 
        distance : ValueInput object that defines the extrude distance. A positive value extrudes in the positive direction
        of the sketch plane and negative value is in the opposite direction. 
        operation : The feature operation to perform. 
        Returns the newly created ExtrudeFeature or null if the creation failed.
        """
        return _fusion.ExtrudeFeatures_addSimple(self, profile, distance, operation)

    def _get_objectType(self) -> "char const *":
        return _fusion.ExtrudeFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ExtrudeFeatures__get_isValid(self)

# Register ExtrudeFeatures in _fusion:
_fusion.ExtrudeFeatures_swigregister(ExtrudeFeatures)

def ExtrudeFeatures_classType() -> "char const *":
    return _fusion.ExtrudeFeatures_classType()


ExtrudeFeatures.count = property(ExtrudeFeatures._get_count, doc="The number of extrude features in the collection.")


ExtrudeFeatures.cast = lambda arg: arg if isinstance(arg, ExtrudeFeatures) else None

class Feature(Base):
    r"""Base class object representing all features."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::Feature *":
        return _fusion.Feature___deref__(self)

    def __eq__(self, rhs: "Feature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.Feature___eq__(self, rhs)


    def __ne__(self, rhs: "Feature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.Feature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.Feature_classType()
    __swig_destroy__ = _fusion.delete_Feature

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.Feature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.Feature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.Feature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.Feature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.Feature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.Feature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.Feature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.Feature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.Feature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.Feature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.Feature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.Feature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.Feature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.Feature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.Feature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.Feature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.Feature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.Feature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.Feature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.Feature__get_isValid(self)

# Register Feature in _fusion:
_fusion.Feature_swigregister(Feature)

def Feature_classType() -> "char const *":
    return _fusion.Feature_classType()


Feature.name = property(Feature._get_name, Feature._set_name, doc="Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric).")


Feature.isSuppressed = property(Feature._get_isSuppressed, Feature._set_isSuppressed, doc="Gets and sets if this feature is suppressed. This is only valid\nfor parametric features.")


Feature.isParametric = property(Feature._get_isParametric, doc="Indicates if this feature is parametric or not.")


Feature.faces = property(Feature._get_faces, doc="Returns the faces that were created by this feature.\nThis works for both parametric and non-parametric features.")


Feature.parentComponent = property(Feature._get_parentComponent, doc="Returns the parent component that owns this feature.")


Feature.linkedFeatures = property(Feature._get_linkedFeatures, doc="Returns the set of features that are linked to this feature. The set of linked features\nare all of the features that were created in various components as the result of a\nsingle feature being created in the user interface.")


Feature.assemblyContext = property(Feature._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")


Feature.timelineObject = property(Feature._get_timelineObject, doc="Returns the timeline object associated with this feature.")


Feature.bodies = property(Feature._get_bodies, doc="Returns the bodies that were modified or created by this feature.\nThis works for both parametric and non-parametric features. For a BaseFeature\nthis returns the bodies that are owned by the base feature.")


Feature.attributes = property(Feature._get_attributes, doc="Returns the collection of attributes associated with this face.")


Feature.baseFeature = property(Feature._get_baseFeature, doc="If this feature is associated with a base feature, this property will return that base feature.\nIf it's not associated with a base feature, this property will return null.")


Feature.healthState = property(Feature._get_healthState, doc="Returns the current health state of the feature.")


Feature.errorOrWarningMessage = property(Feature._get_errorOrWarningMessage, doc="Returns the error or warning message in the case where the healthState property returns either\nWarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.")


Feature.entityToken = property(Feature._get_entityToken, doc="Returns a token for the Feature object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same feature.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.")


Feature.cast = lambda arg: arg if isinstance(arg, Feature) else None

class FeatureList(Base):
    r"""
    Provides access to a list of features. This is used in the API to return
    a list of features from an API call.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::FeatureList *":
        return _fusion.FeatureList___deref__(self)

    def __eq__(self, rhs: "FeatureList") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.FeatureList___eq__(self, rhs)


    def __ne__(self, rhs: "FeatureList") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.FeatureList___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.FeatureList___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::Feature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.FeatureList___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.FeatureList_classType()
    __swig_destroy__ = _fusion.delete_FeatureList

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::Feature >":
        r"""
        Returns the specified folder. 
        index : The index of the feature to return. The first feature in the list has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.FeatureList_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of features in this collection."""
        return _fusion.FeatureList__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.FeatureList__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.FeatureList__get_isValid(self)

# Register FeatureList in _fusion:
_fusion.FeatureList_swigregister(FeatureList)

def FeatureList_classType() -> "char const *":
    return _fusion.FeatureList_classType()


FeatureList.count = property(FeatureList._get_count, doc="The number of features in this collection.")


FeatureList.cast = lambda arg: arg if isinstance(arg, FeatureList) else None

class Features(Base):
    r"""
    The features collection which provides access to all existing features. This collection
    provides direct access to all features regardless of type. It also provides access
    to type specific collections where you can get features of a specific type and also create
    new features of that type.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::Features *":
        return _fusion.Features___deref__(self)

    def __eq__(self, rhs: "Features") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.Features___eq__(self, rhs)


    def __ne__(self, rhs: "Features") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.Features___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.Features___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::Feature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.Features___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.Features_classType()
    __swig_destroy__ = _fusion.delete_Features

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::Feature >":
        r"""
        Function that returns the specified feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.Features_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of bodies in the collection."""
        return _fusion.Features__get_count(self)

    def _get_extrudeFeatures(self) -> "adsk::core::Ptr< adsk::fusion::ExtrudeFeatures >":
        r"""
        Returns the collection that provides access to the extrude features within the component 
        and supports the creation of new extrude features.
        """
        return _fusion.Features__get_extrudeFeatures(self)

    def _get_revolveFeatures(self) -> "adsk::core::Ptr< adsk::fusion::RevolveFeatures >":
        r"""
        Returns the collection that provides access to the revolve features within the component 
        and supports the creation of new revolved features.
        """
        return _fusion.Features__get_revolveFeatures(self)

    def _get_holeFeatures(self) -> "adsk::core::Ptr< adsk::fusion::HoleFeatures >":
        r"""
        Returns the collection that provides access to the hole features within the component
        and supports the creation of new hole features.
        """
        return _fusion.Features__get_holeFeatures(self)

    def _get_filletFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FilletFeatures >":
        r"""
        Returns the collection that provides access to the fillet features within the component
        and supports the creation of new fillet features.
        """
        return _fusion.Features__get_filletFeatures(self)

    def _get_sweepFeatures(self) -> "adsk::core::Ptr< adsk::fusion::SweepFeatures >":
        r"""
        Returns the collection that provides access to the sweep features within the component
        and supports the creation of new sweep features.
        """
        return _fusion.Features__get_sweepFeatures(self)

    def _get_chamferFeatures(self) -> "adsk::core::Ptr< adsk::fusion::ChamferFeatures >":
        r"""
        Returns the collection that provides access to the chamfer features within the component
        and supports the creation of new chamfer features.
        """
        return _fusion.Features__get_chamferFeatures(self)

    def _get_shellFeatures(self) -> "adsk::core::Ptr< adsk::fusion::ShellFeatures >":
        r"""
        Returns the collection that provides access to the shell features within the component
        and supports the creation of new shell features.
        """
        return _fusion.Features__get_shellFeatures(self)

    def _get_mirrorFeatures(self) -> "adsk::core::Ptr< adsk::fusion::MirrorFeatures >":
        r"""
        Returns the collection that provides access to the mirror features within the component
        and supports the creation of new mirror features.
        """
        return _fusion.Features__get_mirrorFeatures(self)

    def _get_circularPatternFeatures(self) -> "adsk::core::Ptr< adsk::fusion::CircularPatternFeatures >":
        r"""
        Returns the collection that provides access to the circular pattern features within the component
        and supports the creation of new circular pattern features.
        """
        return _fusion.Features__get_circularPatternFeatures(self)

    def _get_rectangularPatternFeatures(self) -> "adsk::core::Ptr< adsk::fusion::RectangularPatternFeatures >":
        r"""
        Returns the collection that provides access to the rectangular pattern features within the component
        and supports the creation of new rectangular pattern features.
        """
        return _fusion.Features__get_rectangularPatternFeatures(self)

    def _get_pathPatternFeatures(self) -> "adsk::core::Ptr< adsk::fusion::PathPatternFeatures >":
        r"""
        Returns the collection that provides access to the path pattern features within the component
        and supports the creation of new path pattern features.
        """
        return _fusion.Features__get_pathPatternFeatures(self)

    def _get_combineFeatures(self) -> "adsk::core::Ptr< adsk::fusion::CombineFeatures >":
        r"""
        Returns the collection that provides access to the combine features within the component
        and supports the creation of new combine features.
        """
        return _fusion.Features__get_combineFeatures(self)

    def _get_threadFeatures(self) -> "adsk::core::Ptr< adsk::fusion::ThreadFeatures >":
        r"""
        Returns the collection that provides access to the thread features within the component
        and supports the creation of new thread features.
        """
        return _fusion.Features__get_threadFeatures(self)

    def _get_draftFeatures(self) -> "adsk::core::Ptr< adsk::fusion::DraftFeatures >":
        r"""
        Returns the collection that provides access to the draft features within the component
        and supports the creation of new draft features.
        """
        return _fusion.Features__get_draftFeatures(self)

    def _get_scaleFeatures(self) -> "adsk::core::Ptr< adsk::fusion::ScaleFeatures >":
        r"""
        Returns the collection that provides access to the scale features within the component
        and supports the creation of new scale features.
        """
        return _fusion.Features__get_scaleFeatures(self)

    def createPath(self, curve: "Base", isChain: "bool"=True) -> "adsk::core::Ptr< adsk::fusion::Path >":
        r"""
        Method that creates a Path used to define the shape of a Sweep feature. A Path is a contiguous
        set of curves that can be a combination of sketch curves and model edges. 
        curve : A SketchCurve or an ObjectCollection containing multiple sketch entities and/or BRepEdge objects. If a single sketch curve
        or edge is input the isChain argument is checked to determine if connected curves (they do not need to be tangent)
        should be automatically found. If multiple curves are provided the isChain argument is always
        treated as false so you must provide all of the curves in the object collection that you want included in the path.
        The provided curves must all connect together in a single path.
        The input curves can be from multiple sketches and bodies and they need to geometrically connect for
        a valid path to be created. 
        isChain : Optional argument, that defaults to true. If this argument is set to true, all curves and edges that are end point 
        connected to the single input curve will be found and used to create the path.
        This argument is only used when the first argument is a single SketchCurve/BRepEdge object. 
        Returns the newly created Path.
        """
        return _fusion.Features_createPath(self, curve, isChain)

    def _get_replaceFaceFeatures(self) -> "adsk::core::Ptr< adsk::fusion::ReplaceFaceFeatures >":
        r"""
        Returns the collection that provides access to the replaceFace features within the component
        and supports the creation of new replaceFace features.
        """
        return _fusion.Features__get_replaceFaceFeatures(self)

    def _get_moveFeatures(self) -> "adsk::core::Ptr< adsk::fusion::MoveFeatures >":
        r"""
        Returns the collection that provides access to the Move features within the component
        and supports the creation of new Move features.
        """
        return _fusion.Features__get_moveFeatures(self)

    def _get_splitFaceFeatures(self) -> "adsk::core::Ptr< adsk::fusion::SplitFaceFeatures >":
        r"""
        Returns the collection that provides access to the SplitFace features within the component and supports the creation
        of new SplitFace features
        """
        return _fusion.Features__get_splitFaceFeatures(self)

    def _get_splitBodyFeatures(self) -> "adsk::core::Ptr< adsk::fusion::SplitBodyFeatures >":
        r"""
        Returns the collection that provides access to the SplitBody features within the component and supports the creation
        of new SplitBody features
        """
        return _fusion.Features__get_splitBodyFeatures(self)

    def _get_silhouetteSplitFeatures(self) -> "adsk::core::Ptr< adsk::fusion::SilhouetteSplitFeatures >":
        r"""
        Returns the collection that provides access to the Parting Line Split features within the component and supports 
        the creation of new Parting Line Split features
        """
        return _fusion.Features__get_silhouetteSplitFeatures(self)

    def _get_offsetFeatures(self) -> "adsk::core::Ptr< adsk::fusion::OffsetFeatures >":
        r"""
        Returns the collection that provides access to the Offset features within the component
        and supports the creation of new Offset features.
        """
        return _fusion.Features__get_offsetFeatures(self)

    def _get_extendFeatures(self) -> "adsk::core::Ptr< adsk::fusion::ExtendFeatures >":
        r"""
        Returns the collection that provides access to the Extend features within the component
        and supports the creation of new Extend features.
        """
        return _fusion.Features__get_extendFeatures(self)

    def _get_stitchFeatures(self) -> "adsk::core::Ptr< adsk::fusion::StitchFeatures >":
        r"""
        Returns the collection that provides access to the Stitch features within the component
        and supports the creation of new Stitch features.
        """
        return _fusion.Features__get_stitchFeatures(self)

    def _get_boundaryFillFeatures(self) -> "adsk::core::Ptr< adsk::fusion::BoundaryFillFeatures >":
        r"""
        Returns the collection that provides access to the Boundary Fill features within the component
        and supports the creation of new Boundary Fill features.
        """
        return _fusion.Features__get_boundaryFillFeatures(self)

    def _get_trimFeatures(self) -> "adsk::core::Ptr< adsk::fusion::TrimFeatures >":
        r"""
        Returns the collection that provides access to the Trim features within the component
        and supports the creation of new Trim features.
        """
        return _fusion.Features__get_trimFeatures(self)

    def _get_thickenFeatures(self) -> "adsk::core::Ptr< adsk::fusion::ThickenFeatures >":
        r"""
        Returns the collection that provides access to the Thicken features within the component
        and supports the creation of new Thicken features.
        """
        return _fusion.Features__get_thickenFeatures(self)

    def _get_unstitchFeatures(self) -> "adsk::core::Ptr< adsk::fusion::UnstitchFeatures >":
        r"""
        Returns the collection that provides access to the Unstitch features within the component
        and supports the creation of new Unstitch features.
        """
        return _fusion.Features__get_unstitchFeatures(self)

    def _get_removeFeatures(self) -> "adsk::core::Ptr< adsk::fusion::RemoveFeatures >":
        r"""
        Returns the collection that provides access to the Remove features within the component
        and supports the creation of new Remove features.
        """
        return _fusion.Features__get_removeFeatures(self)

    def _get_baseFeatures(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeatures >":
        r"""
        Returns the collection that provides access to the existing base features 
        and supports the creation of new base features. A base feature represents
        a body that is non-parametric.
        """
        return _fusion.Features__get_baseFeatures(self)

    def _get_coilFeatures(self) -> "adsk::core::Ptr< adsk::fusion::CoilFeatures >":
        r"""Returns the collection that provides access to the Coil Primitive features within the component."""
        return _fusion.Features__get_coilFeatures(self)

    def _get_boxFeatures(self) -> "adsk::core::Ptr< adsk::fusion::BoxFeatures >":
        r"""Returns the collection that provides access to the existing box features."""
        return _fusion.Features__get_boxFeatures(self)

    def _get_cylinderFeatures(self) -> "adsk::core::Ptr< adsk::fusion::CylinderFeatures >":
        r"""Returns the collection that provides access to the existing cylinder features."""
        return _fusion.Features__get_cylinderFeatures(self)

    def _get_sphereFeatures(self) -> "adsk::core::Ptr< adsk::fusion::SphereFeatures >":
        r"""Returns the collection that provides access to the existing sphere features."""
        return _fusion.Features__get_sphereFeatures(self)

    def _get_torusFeatures(self) -> "adsk::core::Ptr< adsk::fusion::TorusFeatures >":
        r"""Returns the collection that provides access to the existing torus features."""
        return _fusion.Features__get_torusFeatures(self)

    def _get_pipeFeatues(self) -> "adsk::core::Ptr< adsk::fusion::PipeFeatures >":
        r"""Returns the collection that provides access to the existing pipe features."""
        return _fusion.Features__get_pipeFeatues(self)

    def _get_ribFeatures(self) -> "adsk::core::Ptr< adsk::fusion::RibFeatures >":
        r"""Returns the collection that provides access to the existing rib features."""
        return _fusion.Features__get_ribFeatures(self)

    def _get_webFeatures(self) -> "adsk::core::Ptr< adsk::fusion::WebFeatures >":
        r"""Returns the collection that provides access to the existing web features."""
        return _fusion.Features__get_webFeatures(self)

    def _get_formFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FormFeatures >":
        r"""Returns the collection that provides access to the existing form features."""
        return _fusion.Features__get_formFeatures(self)

    def _get_reverseNormalFeatures(self) -> "adsk::core::Ptr< adsk::fusion::ReverseNormalFeatures >":
        r"""
        Returns the collection that provides access to the Reverse Normal features within the component
        and supports the creation of new Reverse Normal features.
        """
        return _fusion.Features__get_reverseNormalFeatures(self)

    def _get_patchFeatures(self) -> "adsk::core::Ptr< adsk::fusion::PatchFeatures >":
        r"""
        Returns the collection that provides access to the Patch features within the component
        and supports the creation of new Patch features.
        """
        return _fusion.Features__get_patchFeatures(self)

    def _get_loftFeatures(self) -> "adsk::core::Ptr< adsk::fusion::LoftFeatures >":
        r"""
        Returns the collection that provides access to the existing loft features and
        supports the creation of new loft features.
        """
        return _fusion.Features__get_loftFeatures(self)

    def _get_ruleFilletFeatures(self) -> "adsk::core::Ptr< adsk::fusion::RuleFilletFeatures >":
        r"""Returns the collection that provides access to the existing form features."""
        return _fusion.Features__get_ruleFilletFeatures(self)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::Feature >":
        r"""
        Function that returns the specified feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the same name seen in the timeline. 
        Returns the specified item or null if a feature matching the name was not found.
        """
        return _fusion.Features_itemByName(self, name)

    def _get_surfaceDeleteFaceFeatures(self) -> "adsk::core::Ptr< adsk::fusion::SurfaceDeleteFaceFeatures >":
        r"""Returns the collection that provides access to the existing Surface Delete Face features."""
        return _fusion.Features__get_surfaceDeleteFaceFeatures(self)

    def _get_deleteFaceFeatures(self) -> "adsk::core::Ptr< adsk::fusion::DeleteFaceFeatures >":
        r"""Returns the collection that provides access to the existing Delete Face features."""
        return _fusion.Features__get_deleteFaceFeatures(self)

    def _get_offsetFacesFeatures(self) -> "adsk::core::Ptr< adsk::fusion::OffsetFacesFeatures >":
        r"""Returns the collection that provides access to the existing Offset Face features."""
        return _fusion.Features__get_offsetFacesFeatures(self)

    def _get_copyPasteBodies(self) -> "adsk::core::Ptr< adsk::fusion::CopyPasteBodies >":
        r"""
        Returns the collection that provides access to the existing copy-paste features
        and supports the creation of new copy-paste features.
        """
        return _fusion.Features__get_copyPasteBodies(self)

    def _get_cutPasteBodies(self) -> "adsk::core::Ptr< adsk::fusion::CutPasteBodies >":
        r"""
        Returns the collection that provides access to the existing cut-paste features
        and supports the creation of new cut-paste features.
        """
        return _fusion.Features__get_cutPasteBodies(self)

    def _get_flangeFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FlangeFeatures >":
        r"""Returns the collection that provides access to the existing flange features."""
        return _fusion.Features__get_flangeFeatures(self)

    def _get_unfoldFeatures(self) -> "adsk::core::Ptr< adsk::fusion::UnfoldFeatures >":
        r"""Returns the collection that provides access to the existing unfold features."""
        return _fusion.Features__get_unfoldFeatures(self)

    def _get_refoldFeatures(self) -> "adsk::core::Ptr< adsk::fusion::RefoldFeatures >":
        r"""Returns the collection that provides access to the existing refold features."""
        return _fusion.Features__get_refoldFeatures(self)

    def _get_ruledSurfaceFeatures(self) -> "adsk::core::Ptr< adsk::fusion::RuledSurfaceFeatures >":
        r"""
        Returns the collection that provides access to the Ruled Surface features within the component
        and supports the creation of new Ruled Surface features.
        """
        return _fusion.Features__get_ruledSurfaceFeatures(self)

    def _get_customFeatures(self) -> "adsk::core::Ptr< adsk::fusion::CustomFeatures >":
        r"""
        Returns the collection that provides access to the custom features within the component
        and supports the creation of new custom features.
        """
        return _fusion.Features__get_customFeatures(self)

    def _get_untrimFeatures(self) -> "adsk::core::Ptr< adsk::fusion::UntrimFeatures >":
        r"""
        Returns the collection that provides access to the Untrim features within the component
        and supports the creation of new Untrim features.
        """
        return _fusion.Features__get_untrimFeatures(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.Features__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.Features__get_isValid(self)

# Register Features in _fusion:
_fusion.Features_swigregister(Features)

def Features_classType() -> "char const *":
    return _fusion.Features_classType()


Features.count = property(Features._get_count, doc="Returns the number of bodies in the collection.")


Features.extrudeFeatures = property(Features._get_extrudeFeatures, doc="Returns the collection that provides access to the extrude features within the component\nand supports the creation of new extrude features.")


Features.revolveFeatures = property(Features._get_revolveFeatures, doc="Returns the collection that provides access to the revolve features within the component\nand supports the creation of new revolved features.")


Features.holeFeatures = property(Features._get_holeFeatures, doc="Returns the collection that provides access to the hole features within the component\nand supports the creation of new hole features.")


Features.filletFeatures = property(Features._get_filletFeatures, doc="Returns the collection that provides access to the fillet features within the component\nand supports the creation of new fillet features.")


Features.sweepFeatures = property(Features._get_sweepFeatures, doc="Returns the collection that provides access to the sweep features within the component\nand supports the creation of new sweep features.")


Features.chamferFeatures = property(Features._get_chamferFeatures, doc="Returns the collection that provides access to the chamfer features within the component\nand supports the creation of new chamfer features.")


Features.shellFeatures = property(Features._get_shellFeatures, doc="Returns the collection that provides access to the shell features within the component\nand supports the creation of new shell features.")


Features.mirrorFeatures = property(Features._get_mirrorFeatures, doc="Returns the collection that provides access to the mirror features within the component\nand supports the creation of new mirror features.")


Features.circularPatternFeatures = property(Features._get_circularPatternFeatures, doc="Returns the collection that provides access to the circular pattern features within the component\nand supports the creation of new circular pattern features.")


Features.rectangularPatternFeatures = property(Features._get_rectangularPatternFeatures, doc="Returns the collection that provides access to the rectangular pattern features within the component\nand supports the creation of new rectangular pattern features.")


Features.pathPatternFeatures = property(Features._get_pathPatternFeatures, doc="Returns the collection that provides access to the path pattern features within the component\nand supports the creation of new path pattern features.")


Features.combineFeatures = property(Features._get_combineFeatures, doc="Returns the collection that provides access to the combine features within the component\nand supports the creation of new combine features.")


Features.threadFeatures = property(Features._get_threadFeatures, doc="Returns the collection that provides access to the thread features within the component\nand supports the creation of new thread features.")


Features.draftFeatures = property(Features._get_draftFeatures, doc="Returns the collection that provides access to the draft features within the component\nand supports the creation of new draft features.")


Features.scaleFeatures = property(Features._get_scaleFeatures, doc="Returns the collection that provides access to the scale features within the component\nand supports the creation of new scale features.")


Features.replaceFaceFeatures = property(Features._get_replaceFaceFeatures, doc="Returns the collection that provides access to the replaceFace features within the component\nand supports the creation of new replaceFace features.")


Features.moveFeatures = property(Features._get_moveFeatures, doc="Returns the collection that provides access to the Move features within the component\nand supports the creation of new Move features.")


Features.splitFaceFeatures = property(Features._get_splitFaceFeatures, doc="Returns the collection that provides access to the SplitFace features within the component and supports the creation\nof new SplitFace features")


Features.splitBodyFeatures = property(Features._get_splitBodyFeatures, doc="Returns the collection that provides access to the SplitBody features within the component and supports the creation\nof new SplitBody features")


Features.silhouetteSplitFeatures = property(Features._get_silhouetteSplitFeatures, doc="Returns the collection that provides access to the Parting Line Split features within the component and supports\nthe creation of new Parting Line Split features")


Features.offsetFeatures = property(Features._get_offsetFeatures, doc="Returns the collection that provides access to the Offset features within the component\nand supports the creation of new Offset features.")


Features.extendFeatures = property(Features._get_extendFeatures, doc="Returns the collection that provides access to the Extend features within the component\nand supports the creation of new Extend features.")


Features.stitchFeatures = property(Features._get_stitchFeatures, doc="Returns the collection that provides access to the Stitch features within the component\nand supports the creation of new Stitch features.")


Features.boundaryFillFeatures = property(Features._get_boundaryFillFeatures, doc="Returns the collection that provides access to the Boundary Fill features within the component\nand supports the creation of new Boundary Fill features.")


Features.trimFeatures = property(Features._get_trimFeatures, doc="Returns the collection that provides access to the Trim features within the component\nand supports the creation of new Trim features.")


Features.thickenFeatures = property(Features._get_thickenFeatures, doc="Returns the collection that provides access to the Thicken features within the component\nand supports the creation of new Thicken features.")


Features.unstitchFeatures = property(Features._get_unstitchFeatures, doc="Returns the collection that provides access to the Unstitch features within the component\nand supports the creation of new Unstitch features.")


Features.removeFeatures = property(Features._get_removeFeatures, doc="Returns the collection that provides access to the Remove features within the component\nand supports the creation of new Remove features.")


Features.baseFeatures = property(Features._get_baseFeatures, doc="Returns the collection that provides access to the existing base features\nand supports the creation of new base features. A base feature represents\na body that is non-parametric.")


Features.coilFeatures = property(Features._get_coilFeatures, doc="Returns the collection that provides access to the Coil Primitive features within the component.")


Features.boxFeatures = property(Features._get_boxFeatures, doc="Returns the collection that provides access to the existing box features.")


Features.cylinderFeatures = property(Features._get_cylinderFeatures, doc="Returns the collection that provides access to the existing cylinder features.")


Features.sphereFeatures = property(Features._get_sphereFeatures, doc="Returns the collection that provides access to the existing sphere features.")


Features.torusFeatures = property(Features._get_torusFeatures, doc="Returns the collection that provides access to the existing torus features.")


Features.pipeFeatues = property(Features._get_pipeFeatues, doc="Returns the collection that provides access to the existing pipe features.")


Features.ribFeatures = property(Features._get_ribFeatures, doc="Returns the collection that provides access to the existing rib features.")


Features.webFeatures = property(Features._get_webFeatures, doc="Returns the collection that provides access to the existing web features.")


Features.formFeatures = property(Features._get_formFeatures, doc="Returns the collection that provides access to the existing form features.")


Features.reverseNormalFeatures = property(Features._get_reverseNormalFeatures, doc="Returns the collection that provides access to the Reverse Normal features within the component\nand supports the creation of new Reverse Normal features.")


Features.patchFeatures = property(Features._get_patchFeatures, doc="Returns the collection that provides access to the Patch features within the component\nand supports the creation of new Patch features.")


Features.loftFeatures = property(Features._get_loftFeatures, doc="Returns the collection that provides access to the existing loft features and\nsupports the creation of new loft features.")


Features.ruleFilletFeatures = property(Features._get_ruleFilletFeatures, doc="Returns the collection that provides access to the existing form features.")


Features.surfaceDeleteFaceFeatures = property(Features._get_surfaceDeleteFaceFeatures, doc="Returns the collection that provides access to the existing Surface Delete Face features.")


Features.deleteFaceFeatures = property(Features._get_deleteFaceFeatures, doc="Returns the collection that provides access to the existing Delete Face features.")


Features.offsetFacesFeatures = property(Features._get_offsetFacesFeatures, doc="Returns the collection that provides access to the existing Offset Face features.")


Features.copyPasteBodies = property(Features._get_copyPasteBodies, doc="Returns the collection that provides access to the existing copy-paste features\nand supports the creation of new copy-paste features.")


Features.cutPasteBodies = property(Features._get_cutPasteBodies, doc="Returns the collection that provides access to the existing cut-paste features\nand supports the creation of new cut-paste features.")


Features.flangeFeatures = property(Features._get_flangeFeatures, doc="Returns the collection that provides access to the existing flange features.")


Features.unfoldFeatures = property(Features._get_unfoldFeatures, doc="Returns the collection that provides access to the existing unfold features.")


Features.refoldFeatures = property(Features._get_refoldFeatures, doc="Returns the collection that provides access to the existing refold features.")


Features.ruledSurfaceFeatures = property(Features._get_ruledSurfaceFeatures, doc="Returns the collection that provides access to the Ruled Surface features within the component\nand supports the creation of new Ruled Surface features.")


Features.customFeatures = property(Features._get_customFeatures, doc="Returns the collection that provides access to the custom features within the component\nand supports the creation of new custom features.")


Features.untrimFeatures = property(Features._get_untrimFeatures, doc="Returns the collection that provides access to the Untrim features within the component\nand supports the creation of new Untrim features.")


Features.cast = lambda arg: arg if isinstance(arg, Features) else None

class FilletEdgeSet(Base):
    r"""The base class for the classes that define the different types of fillet edge sets."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::FilletEdgeSet *":
        return _fusion.FilletEdgeSet___deref__(self)

    def __eq__(self, rhs: "FilletEdgeSet") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.FilletEdgeSet___eq__(self, rhs)


    def __ne__(self, rhs: "FilletEdgeSet") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.FilletEdgeSet___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.FilletEdgeSet_classType()
    __swig_destroy__ = _fusion.delete_FilletEdgeSet

    def _get_isTangentChain(self) -> "bool":
        r"""Gets and sets the Tangent chain for fillet. This enables tangent chain option for fillet."""
        return _fusion.FilletEdgeSet__get_isTangentChain(self)

    def _set_isTangentChain(self, value: "bool") -> "bool":
        r"""Gets and sets the Tangent chain for fillet. This enables tangent chain option for fillet."""
        return _fusion.FilletEdgeSet__set_isTangentChain(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.FilletEdgeSet__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.FilletEdgeSet__get_isValid(self)

# Register FilletEdgeSet in _fusion:
_fusion.FilletEdgeSet_swigregister(FilletEdgeSet)

def FilletEdgeSet_classType() -> "char const *":
    return _fusion.FilletEdgeSet_classType()


FilletEdgeSet.isTangentChain = property(FilletEdgeSet._get_isTangentChain, FilletEdgeSet._set_isTangentChain, doc="Gets and sets the Tangent chain for fillet. This enables tangent chain option for fillet.")


FilletEdgeSet.cast = lambda arg: arg if isinstance(arg, FilletEdgeSet) else None

class FilletEdgeSets(Base):
    r"""Collection that provides access to all of the existing fillet edge sets associated with a fillet feature."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::FilletEdgeSets *":
        return _fusion.FilletEdgeSets___deref__(self)

    def __eq__(self, rhs: "FilletEdgeSets") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.FilletEdgeSets___eq__(self, rhs)


    def __ne__(self, rhs: "FilletEdgeSets") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.FilletEdgeSets___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.FilletEdgeSets___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::FilletEdgeSet >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.FilletEdgeSets___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.FilletEdgeSets_classType()
    __swig_destroy__ = _fusion.delete_FilletEdgeSets

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::FilletEdgeSet >":
        r"""
        Function that returns the specified fillet edge set using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.FilletEdgeSets_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of fillet edge sets in the collection."""
        return _fusion.FilletEdgeSets__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.FilletEdgeSets__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.FilletEdgeSets__get_isValid(self)

# Register FilletEdgeSets in _fusion:
_fusion.FilletEdgeSets_swigregister(FilletEdgeSets)

def FilletEdgeSets_classType() -> "char const *":
    return _fusion.FilletEdgeSets_classType()


FilletEdgeSets.count = property(FilletEdgeSets._get_count, doc="The number of fillet edge sets in the collection.")


FilletEdgeSets.cast = lambda arg: arg if isinstance(arg, FilletEdgeSets) else None

class FilletFeatureInput(Base):
    r"""
    This class defines the methods and properties that pertain to the definition of a fillet 
    feature.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::FilletFeatureInput *":
        return _fusion.FilletFeatureInput___deref__(self)

    def __eq__(self, rhs: "FilletFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.FilletFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "FilletFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.FilletFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.FilletFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_FilletFeatureInput

    def addConstantRadiusEdgeSet(self, edges: "ObjectCollection", radius: "ValueInput", isTangentChain: "bool") -> "bool":
        r"""
        Adds a set of edges with a constant radius to this input. 
        edges : An ObjectCollection containing the edges to be filleted. If the isTangentChain argument is true
        additional edges may also get filleted if they are tangentially connected to any of the 
        input edges. 
        radius : A ValueInput object that defines the radius of the fillet. If the ValueInput uses
        a real then it is interpreted as centimeters. If it is a string then the units
        can be defined as part of the string (i.e. '2 in') or if no units are specified
        it is interpreted using the current default units for length. 
        isTangentChain : A boolean value for setting whether or not edges that are tangentially connected to 
        the input edges (if any) will also be filleted. 
        Returns true if the set of edges was successfully added to the FilletFeatureInput.
        """
        return _fusion.FilletFeatureInput_addConstantRadiusEdgeSet(self, edges, radius, isTangentChain)

    def addVariableRadiusEdgeSet(self, tangentEdges: "ObjectCollection", startRadius: "ValueInput", endRadius: "ValueInput", positions: "ValueInputVector", radii: "ValueInputVector") -> "bool":
        r"""
        Adds a single edge or set of tangent edges along with variable radius information to this input. 
        tangentEdges : An object collection containing a single edge or multiple edges. Multiple edges 
        must be tangentially connected and added to the collection in order. 
        startRadius : A ValueInput object that defines the starting radius of the fillet. If a single edge is
        being filleted, the start radius is at the start end of the edge. If multiple tangent
        edges are being filleted the start radius is the open end of the first edge in the
        collection.
        If the ValueInput uses a real then it is interpreted as centimeters. If it is a string then 
        the units can be defined as part of the string (i.e. '2 in') or if no units are specified
        it is interpreted using the current default units for length. 
        endRadius : A ValueInput object that defines the ending radius of the fillet. If a single edge is
        being filleted, the end radius is at the end of the edge. If multiple tangent
        edges are being filleted the end radius is the open end of the last edge in the
        collection.
        If the ValueInput uses a real then it is interpreted as centimeters. If it is a string then 
        the units can be defined as part of the string (i.e. '2 in') or if no units are specified
        it is interpreted using the current default units for length. 
        positions : An array of ValueInput objects that defines the positions of any additonal radii
        along the edge(s). The value must be between 0 and 1 and defines the percentage along the 
        curve where a radius is defined. The value is unitless. This array must have the same 
        number of values as the array passed in for the radii argument. 
        radii : An array of ValueInput objects that define the radii at positions along the edge(s).
        This array must have the same number of values as the array passed in for
        the positions argument. If the ValueInput uses a real then it is interpreted as centimeters.
        If it is a string then the units can be defined as part of the string (i.e. '2 in'). 
        If no units are specified it will be interpreted using the current default units for length. 
        Returns true if the edge set was successfully added to the FilletFeatureInput.
        """
        return _fusion.FilletFeatureInput_addVariableRadiusEdgeSet(self, tangentEdges, startRadius, endRadius, positions, radii)

    def _get_isG2(self) -> "bool":
        r"""Gets and sets if the fillet uses the G2 (curvature-continuity) surface quality option ."""
        return _fusion.FilletFeatureInput__get_isG2(self)

    def _set_isG2(self, value: "bool") -> "bool":
        r"""Gets and sets if the fillet uses the G2 (curvature-continuity) surface quality option ."""
        return _fusion.FilletFeatureInput__set_isG2(self, value)

    def _get_isRollingBallCorner(self) -> "bool":
        r"""Gets and sets if a rolling ball or setback solution is to be used in any corners."""
        return _fusion.FilletFeatureInput__get_isRollingBallCorner(self)

    def _set_isRollingBallCorner(self, value: "bool") -> "bool":
        r"""Gets and sets if a rolling ball or setback solution is to be used in any corners."""
        return _fusion.FilletFeatureInput__set_isRollingBallCorner(self, value)

    def _get_isTangentChain(self) -> "bool":
        r"""
        Gets and sets if any edges that are tangentially connected to any of filleted
        edges will also be included in the fillet.
        """
        return _fusion.FilletFeatureInput__get_isTangentChain(self)

    def _set_isTangentChain(self, value: "bool") -> "bool":
        r"""
        Gets and sets if any edges that are tangentially connected to any of filleted
        edges will also be included in the fillet.
        """
        return _fusion.FilletFeatureInput__set_isTangentChain(self, value)

    def addChordLengthEdgeSet(self, edges: "ObjectCollection", chordLength: "ValueInput", isTangentChain: "bool") -> "bool":
        r"""
        Adds a set of edges with a chord length to this input. 
        edges : An ObjectCollection containing the edges to be filleted. If the isTangentChain argument is true
        additional edges may also get filleted if they are tangentially connected to any of the 
        input edges. 
        chordLength : A ValueInput object that defines the chord length of the fillet. If the ValueInput uses
        a real then it is interpreted as centimeters. If it is a string then the units
        can be defined as part of the string (i.e. '2 in') or if no units are specified
        it is interpreted using the current default units for length. 
        isTangentChain : A boolean value for setting whether or not edges that are tangentially connected to 
        the input edges (if any) will also be filleted. 
        Returns true if the set of edges was successfully added to the FilletFeatureInput.
        """
        return _fusion.FilletFeatureInput_addChordLengthEdgeSet(self, edges, chordLength, isTangentChain)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.FilletFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.FilletFeatureInput__set_targetBaseFeature(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.FilletFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.FilletFeatureInput__get_isValid(self)

# Register FilletFeatureInput in _fusion:
_fusion.FilletFeatureInput_swigregister(FilletFeatureInput)

def FilletFeatureInput_classType() -> "char const *":
    return _fusion.FilletFeatureInput_classType()


FilletFeatureInput.isG2 = property(FilletFeatureInput._get_isG2, FilletFeatureInput._set_isG2, doc="Gets and sets if the fillet uses the G2 (curvature-continuity) surface quality option .")


FilletFeatureInput.isRollingBallCorner = property(FilletFeatureInput._get_isRollingBallCorner, FilletFeatureInput._set_isRollingBallCorner, doc="Gets and sets if a rolling ball or setback solution is to be used in any corners.")


FilletFeatureInput.isTangentChain = property(FilletFeatureInput._get_isTangentChain, FilletFeatureInput._set_isTangentChain, doc="Gets and sets if any edges that are tangentially connected to any of filleted\nedges will also be included in the fillet.")


FilletFeatureInput.targetBaseFeature = property(FilletFeatureInput._get_targetBaseFeature, FilletFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


FilletFeatureInput.cast = lambda arg: arg if isinstance(arg, FilletFeatureInput) else None

class FilletFeatures(Base):
    r"""
    Collection that provides access to all of the existing fillet features in a component
    and supports the ability to create new fillet features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::FilletFeatures *":
        return _fusion.FilletFeatures___deref__(self)

    def __eq__(self, rhs: "FilletFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.FilletFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "FilletFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.FilletFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.FilletFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::FilletFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.FilletFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.FilletFeatures_classType()
    __swig_destroy__ = _fusion.delete_FilletFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::FilletFeature >":
        r"""
        Function that returns the specified fillet feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.FilletFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of fillet features in the collection."""
        return _fusion.FilletFeatures__get_count(self)

    def createInput(self) -> "adsk::core::Ptr< adsk::fusion::FilletFeatureInput >":
        r"""
        Creates a FilletFeatureInput object. Use properties and methods on this object
        to define the fillet you want to create and then use the Add method, passing in 
        the FilletFeatureInput object. 
        Returns the newly created FilletFeatureInput object or null if the creation failed.
        """
        return _fusion.FilletFeatures_createInput(self)

    def add(self, input: "FilletFeatureInput") -> "adsk::core::Ptr< adsk::fusion::FilletFeature >":
        r"""
        Creates a new fillet feature. 
        input : A FilletFeatureInput object that defines the desired fillet. Use the createInput 
        method to create a new FilletFeatureInput object and then use methods on it 
        (the FilletFeatureInput object) to define the fillet. 
        Returns the newly created FilletFeature object or null if the creation failed.
        """
        return _fusion.FilletFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::FilletFeature >":
        r"""
        Function that returns the specified fillet feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.FilletFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.FilletFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.FilletFeatures__get_isValid(self)

# Register FilletFeatures in _fusion:
_fusion.FilletFeatures_swigregister(FilletFeatures)

def FilletFeatures_classType() -> "char const *":
    return _fusion.FilletFeatures_classType()


FilletFeatures.count = property(FilletFeatures._get_count, doc="The number of fillet features in the collection.")


FilletFeatures.cast = lambda arg: arg if isinstance(arg, FilletFeatures) else None

class FlangeFeatures(Base):
    r"""Collection that provides access to all of the existing flange features in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::FlangeFeatures *":
        return _fusion.FlangeFeatures___deref__(self)

    def __eq__(self, rhs: "FlangeFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.FlangeFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "FlangeFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.FlangeFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.FlangeFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::FlangeFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.FlangeFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.FlangeFeatures_classType()
    __swig_destroy__ = _fusion.delete_FlangeFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::FlangeFeature >":
        r"""
        Function that returns the specified flange feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.FlangeFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of flange features in the collection."""
        return _fusion.FlangeFeatures__get_count(self)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::FlangeFeature >":
        r"""
        Function that returns the specified flange feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.FlangeFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.FlangeFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.FlangeFeatures__get_isValid(self)

# Register FlangeFeatures in _fusion:
_fusion.FlangeFeatures_swigregister(FlangeFeatures)

def FlangeFeatures_classType() -> "char const *":
    return _fusion.FlangeFeatures_classType()


FlangeFeatures.count = property(FlangeFeatures._get_count, doc="The number of flange features in the collection.")


FlangeFeatures.cast = lambda arg: arg if isinstance(arg, FlangeFeatures) else None

class FormFeatures(Base):
    r"""Collection that provides access to all of the existing Form features in a component."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::FormFeatures *":
        return _fusion.FormFeatures___deref__(self)

    def __eq__(self, rhs: "FormFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.FormFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "FormFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.FormFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.FormFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::FormFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.FormFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.FormFeatures_classType()
    __swig_destroy__ = _fusion.delete_FormFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::FormFeature >":
        r"""
        Function that returns the specified Form feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.FormFeatures_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::FormFeature >":
        r"""
        Function that returns the specified form feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.FormFeatures_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of Form features in the collection."""
        return _fusion.FormFeatures__get_count(self)

    def add(self) -> "adsk::core::Ptr< adsk::fusion::FormFeature >":
        r"""
        Creates a new empty form feature in the parent component. 
        Returns the new FormFeature or null in the case of an error.
        """
        return _fusion.FormFeatures_add(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.FormFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.FormFeatures__get_isValid(self)

# Register FormFeatures in _fusion:
_fusion.FormFeatures_swigregister(FormFeatures)

def FormFeatures_classType() -> "char const *":
    return _fusion.FormFeatures_classType()


FormFeatures.count = property(FormFeatures._get_count, doc="The number of Form features in the collection.")


FormFeatures.cast = lambda arg: arg if isinstance(arg, FormFeatures) else None

class FusionDefaultUnitsPreferences(adsk.core.DefaultUnitsPreferences):
    r"""Fusion 360 Default Units for Design Preferences"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::FusionDefaultUnitsPreferences *":
        return _fusion.FusionDefaultUnitsPreferences___deref__(self)

    def __eq__(self, rhs: "FusionDefaultUnitsPreferences") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.FusionDefaultUnitsPreferences___eq__(self, rhs)


    def __ne__(self, rhs: "FusionDefaultUnitsPreferences") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.FusionDefaultUnitsPreferences___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.FusionDefaultUnitsPreferences_classType()
    __swig_destroy__ = _fusion.delete_FusionDefaultUnitsPreferences

    def _get_distanceDisplayUnits(self) -> "adsk::fusion::DistanceUnits":
        r"""Gets and sets the default units for length when creating a new Fusion 360 file."""
        return _fusion.FusionDefaultUnitsPreferences__get_distanceDisplayUnits(self)

    def _set_distanceDisplayUnits(self, value: "DistanceUnits") -> "bool":
        r"""Gets and sets the default units for length when creating a new Fusion 360 file."""
        return _fusion.FusionDefaultUnitsPreferences__set_distanceDisplayUnits(self, value)

    def _get_name(self) -> "std::string":
        r"""Returns the name of this DefaultUnitPreferences object."""
        return _fusion.FusionDefaultUnitsPreferences__get_name(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.FusionDefaultUnitsPreferences__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.FusionDefaultUnitsPreferences__get_isValid(self)

# Register FusionDefaultUnitsPreferences in _fusion:
_fusion.FusionDefaultUnitsPreferences_swigregister(FusionDefaultUnitsPreferences)

def FusionDefaultUnitsPreferences_classType() -> "char const *":
    return _fusion.FusionDefaultUnitsPreferences_classType()


FusionDefaultUnitsPreferences.distanceDisplayUnits = property(FusionDefaultUnitsPreferences._get_distanceDisplayUnits, FusionDefaultUnitsPreferences._set_distanceDisplayUnits, doc="Gets and sets the default units for length when creating a new Fusion 360 file.")


FusionDefaultUnitsPreferences.cast = lambda arg: arg if isinstance(arg, FusionDefaultUnitsPreferences) else None

class FusionDocument(adsk.core.Document):
    r"""Object that represents a Fusion 360 specific document."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::FusionDocument *":
        return _fusion.FusionDocument___deref__(self)

    def __eq__(self, rhs: "FusionDocument") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.FusionDocument___eq__(self, rhs)


    def __ne__(self, rhs: "FusionDocument") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.FusionDocument___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.FusionDocument_classType()
    __swig_destroy__ = _fusion.delete_FusionDocument

    def _get_design(self) -> "adsk::core::Ptr< adsk::fusion::Design >":
        r"""Returns the design associated with this Fusion 360 document."""
        return _fusion.FusionDocument__get_design(self)

    def activate(self) -> "bool":
        r"""
        Causes this document to become the active document in the user interface. 
        Returns true if the activation was successful.
        """
        return _fusion.FusionDocument_activate(self)

    def _get_name(self) -> "std::string":
        r"""Gets and sets the name of the document."""
        return _fusion.FusionDocument__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the name of the document."""
        return _fusion.FusionDocument__set_name(self, value)

    def close(self, saveChanges: "bool") -> "bool":
        r"""
        Closes this document. 
        saveChanges : This argument defines what the behavior of the close is when the document
        has been modified. If the document hasn't been modified then this argument
        is ignored and the document is closed. If the document has been modified
        and this argument is false then Fusion 360 will close the document and lose
        any changes. If the document has been modified and this argument is true then
        it will prompt the user if they want to save the changes or not, just the same
        as if the user was to interactively close the document. 
        Returns true if closing the document was successful.
        """
        return _fusion.FusionDocument_close(self, saveChanges)

    def _get_isModified(self) -> "bool":
        r"""Property that indicates if the document has been modified since it was last saved."""
        return _fusion.FusionDocument__get_isModified(self)

    def _get_isSaved(self) -> "bool":
        r"""
        Property that indicates if this document has been saved or not. The initial save of
        a document requires that the name and location be specified and requires the saveAs method
        to be used. If the document has been saved then the save method can be used to save changes made.
        """
        return _fusion.FusionDocument__get_isSaved(self)

    def save(self, description: "std::string const &") -> "bool":
        r"""
        Saves a version of the current document. You must use the SaveAs method the first
        time a document is saved. You can determine if a document has been saved by checking
        the value of the isSaved property. 
        description : The version description for this document 
        Returns true if saving the document was successful.
        """
        return _fusion.FusionDocument_save(self, description)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Application >":
        r"""Returns the parent Application object."""
        return _fusion.FusionDocument__get_parent(self)

    def saveAs(self, name: "std::string const &", dataFolder: "DataFolder", description: "std::string const &", tag: "std::string const &") -> "bool":
        r"""
        Performs a Save As on this document. This saves the currently open document to the specified
        location and this document becomes the saved document. If this is a new document that has 
        never been saved you must use the SaveAs method in order to specify the location and name. You
        can determine if the document has been saved by checking the value of the isSaved property. 
        name : The name to use for this document. If this is an empty string, Fusion 360 will use the default name
        assigned when the document was created. 
        dataFolder : The data folder to save this document to. 
        description : The description string of the document. This can be an empty string. 
        tag : The tag string of the document. This can be an empty string. 
        Returns true if the save as was successful.
        """
        return _fusion.FusionDocument_saveAs(self, name, dataFolder, description, tag)

    def _get_products(self) -> "adsk::core::Ptr< adsk::core::Products >":
        r"""Returns the products associated with this document."""
        return _fusion.FusionDocument__get_products(self)

    def _get_isActive(self) -> "bool":
        r"""Gets if this document is the active document in the user interface."""
        return _fusion.FusionDocument__get_isActive(self)

    def _get_isVisible(self) -> "bool":
        r"""Gets if a currently open document is open as visible."""
        return _fusion.FusionDocument__get_isVisible(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this document."""
        return _fusion.FusionDocument__get_attributes(self)

    def _get_dataFile(self) -> "adsk::core::Ptr< adsk::core::DataFile >":
        r"""Gets the DataFile that represents this document in A360."""
        return _fusion.FusionDocument__get_dataFile(self)

    def _get_version(self) -> "std::string":
        r"""Returns the Fusion 360 version this document was last saved with."""
        return _fusion.FusionDocument__get_version(self)

    def _get_documentReferences(self) -> "adsk::core::Ptr< adsk::core::DocumentReferences >":
        r"""
        Returns a collection containing the documents directly referenced
        by this document.
        """
        return _fusion.FusionDocument__get_documentReferences(self)

    def _get_isUpToDate(self) -> "bool":
        r"""
        Indicates if any references in the assembly are out of date. This is the API 
        equivalent to the 'Out of Date' notification displayed in the Quick Access Toolbar.
        """
        return _fusion.FusionDocument__get_isUpToDate(self)

    def _get_allDocumentReferences(self) -> "adsk::core::Ptr< adsk::core::DocumentReferences >":
        r"""
        Returns a collection containing all of the documents referenced directly
        by this document and those referenced by all sub-assemblies.
        """
        return _fusion.FusionDocument__get_allDocumentReferences(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.FusionDocument__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.FusionDocument__get_isValid(self)

# Register FusionDocument in _fusion:
_fusion.FusionDocument_swigregister(FusionDocument)

def FusionDocument_classType() -> "char const *":
    return _fusion.FusionDocument_classType()


FusionDocument.design = property(FusionDocument._get_design, doc="Returns the design associated with this Fusion 360 document.")


FusionDocument.cast = lambda arg: arg if isinstance(arg, FusionDocument) else None

class FusionProductPreferences(adsk.core.ProductPreferences):
    r"""Fusion 360 General Design Preferences"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::FusionProductPreferences *":
        return _fusion.FusionProductPreferences___deref__(self)

    def __eq__(self, rhs: "FusionProductPreferences") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.FusionProductPreferences___eq__(self, rhs)


    def __ne__(self, rhs: "FusionProductPreferences") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.FusionProductPreferences___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.FusionProductPreferences_classType()
    __swig_destroy__ = _fusion.delete_FusionProductPreferences

    def _get_isActiveComponentVisibilityUsed(self) -> "bool":
        r"""Gets and sets the Active Component Visibility option"""
        return _fusion.FusionProductPreferences__get_isActiveComponentVisibilityUsed(self)

    def _set_isActiveComponentVisibilityUsed(self, value: "bool") -> "bool":
        r"""Gets and sets the Active Component Visibility option"""
        return _fusion.FusionProductPreferences__set_isActiveComponentVisibilityUsed(self, value)

    def _get_defaultDesignType(self) -> "adsk::fusion::DefaultDesignTypeOptions":
        r"""Gets and sets the Design History (default design type) setting"""
        return _fusion.FusionProductPreferences__get_defaultDesignType(self)

    def _set_defaultDesignType(self, value: "DefaultDesignTypeOptions") -> "bool":
        r"""Gets and sets the Design History (default design type) setting"""
        return _fusion.FusionProductPreferences__set_defaultDesignType(self, value)

    def _get_defaultWorkspace(self) -> "adsk::fusion::DefaultWorkspaces":
        r"""Gets and sets the Default workspace setting. (Model, Sculpt or Patch)"""
        return _fusion.FusionProductPreferences__get_defaultWorkspace(self)

    def _set_defaultWorkspace(self, value: "DefaultWorkspaces") -> "bool":
        r"""Gets and sets the Default workspace setting. (Model, Sculpt or Patch)"""
        return _fusion.FusionProductPreferences__set_defaultWorkspace(self, value)

    def _get_isJointPreviewAnimated(self) -> "bool":
        r"""Gets and sets the Animate joint preview option"""
        return _fusion.FusionProductPreferences__get_isJointPreviewAnimated(self)

    def _set_isJointPreviewAnimated(self, value: "bool") -> "bool":
        r"""Gets and sets the Animate joint preview option"""
        return _fusion.FusionProductPreferences__set_isJointPreviewAnimated(self, value)

    def _get_is3DSketchingAllowed(self) -> "bool":
        r"""
        Gets and sets the Allow 3D sketching of lines and splines option
        which controls if 3D sketching is allowed or if sketching is forced to
        be on the x-y plane of the sketch.
        """
        return _fusion.FusionProductPreferences__get_is3DSketchingAllowed(self)

    def _set_is3DSketchingAllowed(self, value: "bool") -> "bool":
        r"""
        Gets and sets the Allow 3D sketching of lines and splines option
        which controls if 3D sketching is allowed or if sketching is forced to
        be on the x-y plane of the sketch.
        """
        return _fusion.FusionProductPreferences__set_is3DSketchingAllowed(self, value)

    def _get_isGhostedResultBodyShown(self) -> "bool":
        r"""Gets and sets the Show ghosted result body option"""
        return _fusion.FusionProductPreferences__get_isGhostedResultBodyShown(self)

    def _set_isGhostedResultBodyShown(self, value: "bool") -> "bool":
        r"""Gets and sets the Show ghosted result body option"""
        return _fusion.FusionProductPreferences__set_isGhostedResultBodyShown(self, value)

    def _get_isDimensionEditedWhenCreated(self) -> "bool":
        r"""Gets and sets if dimension value is edited when the dimension is created."""
        return _fusion.FusionProductPreferences__get_isDimensionEditedWhenCreated(self)

    def _set_isDimensionEditedWhenCreated(self, value: "bool") -> "bool":
        r"""Gets and sets if dimension value is edited when the dimension is created."""
        return _fusion.FusionProductPreferences__set_isDimensionEditedWhenCreated(self, value)

    def _get_isAutoLookAtSketch(self) -> "bool":
        r"""Gets and sets if the view is re-oriented to view the newly created sketch."""
        return _fusion.FusionProductPreferences__get_isAutoLookAtSketch(self)

    def _set_isAutoLookAtSketch(self, value: "bool") -> "bool":
        r"""Gets and sets if the view is re-oriented to view the newly created sketch."""
        return _fusion.FusionProductPreferences__set_isAutoLookAtSketch(self, value)

    def _get_isAutoProjectGeometry(self) -> "bool":
        r"""Gets and Sets if geometry, not in the active sketch plane, is to be automatically projected."""
        return _fusion.FusionProductPreferences__get_isAutoProjectGeometry(self)

    def _set_isAutoProjectGeometry(self, value: "bool") -> "bool":
        r"""Gets and Sets if geometry, not in the active sketch plane, is to be automatically projected."""
        return _fusion.FusionProductPreferences__set_isAutoProjectGeometry(self, value)

    def _get_name(self) -> "std::string":
        r"""Returns the name of this ProductPreferences object."""
        return _fusion.FusionProductPreferences__get_name(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.FusionProductPreferences__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.FusionProductPreferences__get_isValid(self)

# Register FusionProductPreferences in _fusion:
_fusion.FusionProductPreferences_swigregister(FusionProductPreferences)

def FusionProductPreferences_classType() -> "char const *":
    return _fusion.FusionProductPreferences_classType()


FusionProductPreferences.isActiveComponentVisibilityUsed = property(FusionProductPreferences._get_isActiveComponentVisibilityUsed, FusionProductPreferences._set_isActiveComponentVisibilityUsed, doc="Gets and sets the Active Component Visibility option")


FusionProductPreferences.defaultDesignType = property(FusionProductPreferences._get_defaultDesignType, FusionProductPreferences._set_defaultDesignType, doc="Gets and sets the Design History (default design type) setting")


FusionProductPreferences.defaultWorkspace = property(FusionProductPreferences._get_defaultWorkspace, FusionProductPreferences._set_defaultWorkspace, doc="Gets and sets the Default workspace setting. (Model, Sculpt or Patch)")


FusionProductPreferences.isJointPreviewAnimated = property(FusionProductPreferences._get_isJointPreviewAnimated, FusionProductPreferences._set_isJointPreviewAnimated, doc="Gets and sets the Animate joint preview option")


FusionProductPreferences.is3DSketchingAllowed = property(FusionProductPreferences._get_is3DSketchingAllowed, FusionProductPreferences._set_is3DSketchingAllowed, doc="Gets and sets the Allow 3D sketching of lines and splines option\nwhich controls if 3D sketching is allowed or if sketching is forced to\nbe on the x-y plane of the sketch.")


FusionProductPreferences.isGhostedResultBodyShown = property(FusionProductPreferences._get_isGhostedResultBodyShown, FusionProductPreferences._set_isGhostedResultBodyShown, doc="Gets and sets the Show ghosted result body option")


FusionProductPreferences.isDimensionEditedWhenCreated = property(FusionProductPreferences._get_isDimensionEditedWhenCreated, FusionProductPreferences._set_isDimensionEditedWhenCreated, doc="Gets and sets if dimension value is edited when the dimension is created.")


FusionProductPreferences.isAutoLookAtSketch = property(FusionProductPreferences._get_isAutoLookAtSketch, FusionProductPreferences._set_isAutoLookAtSketch, doc="Gets and sets if the view is re-oriented to view the newly created sketch.")


FusionProductPreferences.isAutoProjectGeometry = property(FusionProductPreferences._get_isAutoProjectGeometry, FusionProductPreferences._set_isAutoProjectGeometry, doc="Gets and Sets if geometry, not in the active sketch plane, is to be automatically projected.")


FusionProductPreferences.cast = lambda arg: arg if isinstance(arg, FusionProductPreferences) else None

class FusionUnitsManager(adsk.core.UnitsManager):
    r"""
    Utility class used to work with Values and control default units. 
    Internal values are held in SI units (e.g. seconds, radians, kg for time, angle, mass) 
    with the exception that all lengths are in cm rather than meter and this affects derived 
    units (e.g. velocity is cm/s, volume is cm^3). Units are specified flexibly via strings 
    (e.g. 'cm', 'in', 'inch', 'cm^3', 'cm*cm*cm', 'mph', 'mps' 'm/s').
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::FusionUnitsManager *":
        return _fusion.FusionUnitsManager___deref__(self)

    def __eq__(self, rhs: "FusionUnitsManager") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.FusionUnitsManager___eq__(self, rhs)


    def __ne__(self, rhs: "FusionUnitsManager") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.FusionUnitsManager___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.FusionUnitsManager_classType()
    __swig_destroy__ = _fusion.delete_FusionUnitsManager

    def _get_design(self) -> "adsk::core::Ptr< adsk::fusion::Design >":
        r"""Returns the the parent design"""
        return _fusion.FusionUnitsManager__get_design(self)

    def _get_distanceDisplayUnits(self) -> "adsk::fusion::DistanceUnits":
        r"""Gets and sets the default distance units for this design."""
        return _fusion.FusionUnitsManager__get_distanceDisplayUnits(self)

    def _set_distanceDisplayUnits(self, value: "DistanceUnits") -> "bool":
        r"""Gets and sets the default distance units for this design."""
        return _fusion.FusionUnitsManager__set_distanceDisplayUnits(self, value)

    def _get_product(self) -> "adsk::core::Ptr< adsk::core::Product >":
        r"""Returns the parent Product."""
        return _fusion.FusionUnitsManager__get_product(self)

    def isValidExpression(self, expression: "std::string const &", units: "std::string const &") -> "bool":
        r"""
        Checks to see if the given expression is valid. 
        expression : 
        units : The units to use when validating the expression. 
        Returns True if it is a valid expression.
        """
        return _fusion.FusionUnitsManager_isValidExpression(self, expression, units)

    def evaluateExpression(self, *args) -> "double":
        r"""
        Gets the value (in internal units) of the expression. 
        expression : EvaluateExpression('1cm + 1in') -> 3.54
        EvaluateExpression('1') -> -> depends on the DistanceUnits, with 'mm' it gives 0.1 
        units : If not supplied the units will default to the default length specified in the preferences. 
        Returns -1 AND GetLastError will return ExpressionError in the event of an error.
        """
        return _fusion.FusionUnitsManager_evaluateExpression(self, *args)

    def convert(self, valueInInputUnits: "double", inputUnits: "std::string const &", outputUnits: "std::string const &") -> "double":
        r"""
        Converts a value from one unit to another. The input and output unit specifiers must be compatible.
        For example, 'in' (inches) and 'cm' (centimeters) will work because they both define length. 
        So Convert(1.5, 'in', 'ft') -> 0.125
        Convert(1.5, unitsManager.defaultLengthUnits, 'cm') -> depends on the current default distance units, with 'mm' it gives 0.15
        So Convert(1.5, 'in', 'kg') -> -1 and GetLastError returns ExpressionError (to denote error)
        So Convert(1, 'in', 'internalUnits') -> 2.54
        So Convert(1, 'internalUnits', 'in') -> 0.3937... 
        valueInInputUnits : The value to convert 
        inputUnits : The units of the value to convert 
        outputUnits : The units to convert the value to 
        Returns -1 AND GetLastError returns ExpressionError in the event of an error.
        """
        return _fusion.FusionUnitsManager_convert(self, valueInInputUnits, inputUnits, outputUnits)

    def formatInternalValue(self, *args) -> "std::string":
        r"""
        Formats the internal value as a string. The output string is formatted using the current 
        unit settings in preferences. The preferences control the number of decimal places, whether 
        units are abbreviated and several other things.
        FormatInternalValue(1.5, 'in') -> '0.591 in'
        FormatInternalValue(1.5, 'in', false) -> '0.591'
        FormatInternalValue(1.5, 'mm', true) -> '15.00 mm'
        FormatInternalValue(1.5) -> depends on DistanceUnits, might be '15.0 mm' 
        internalValue : The internal value to format. 
        displayUnits : The units to display the value in. If not supplied the units will default to the default length specified in the preferences. 
        showUnits : Specify false to exclude units from the format. The default is true. 
        Returns an empty string if the units are incorrectly specified.
        """
        return _fusion.FusionUnitsManager_formatInternalValue(self, *args)

    def formatUnits(self, units: "std::string const &") -> "std::string":
        r"""
        Formats the unit according to the user preferences
        'centimeter' -> 'cm'
        'inch' -> 'in'
        'cm* cm *cm / s' -> , 'cm^3 / s' 
        units : The unit to use when converting the value into a string. 
        Returns an empty string and GetLastError returns ExpressionError in the event of an error.
        """
        return _fusion.FusionUnitsManager_formatUnits(self, units)

    def standardizeExpression(self, *args) -> "std::string":
        r"""
        Standardizes the expression in terms of spacing and user preferences. 
        StandardizeExpression('1.5') -> depends on distance units, but with mmight be '1.5 mm'
        StandardizeExpression('1.5', 'in') -> '1.5 in'
        StandardizeExpression('1.5 cm + 1.50001 centimeter') -> '1.5 cm + 1.50001 cm'
        StandardizeExpression('1.5', 'm * m * m / s') -> '1.5 m^3 /s' 
        expression : The expression to standardize 
        units : The units to apply to the standardized expression. If not supplied the units will default to the default length specified in the preferences. 
        Returns an empty string AND GetLastError returns ExpressionError in the event of an error.
        """
        return _fusion.FusionUnitsManager_standardizeExpression(self, *args)

    def _get_internalUnits(self) -> "std::string":
        r"""
        Returns a string that represents internal units - i.e. 'internalUnits'. 
        This can be used when performing conversions via Convert.
        """
        return _fusion.FusionUnitsManager__get_internalUnits(self)

    def _get_defaultLengthUnits(self) -> "std::string":
        r"""
        Returns the unit strings for the current default length unit as specified in preferences. - e.g. 'cm' or 'in'
        This is the string that is being used by Fusion 360 to represent the current length unit and is affected
        by the preference settings that let the user choose whether abbrevations and symbols can be used. This means
        that inch length units can be returned as inch, in, or '. If you need a consistent way of determing the current
        length unit, the distanceDisplayUnits of the FusionUnitsManager object returns an enum value.
        """
        return _fusion.FusionUnitsManager__get_defaultLengthUnits(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.FusionUnitsManager__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.FusionUnitsManager__get_isValid(self)

# Register FusionUnitsManager in _fusion:
_fusion.FusionUnitsManager_swigregister(FusionUnitsManager)

def FusionUnitsManager_classType() -> "char const *":
    return _fusion.FusionUnitsManager_classType()


FusionUnitsManager.design = property(FusionUnitsManager._get_design, doc="Returns the the parent design")


FusionUnitsManager.distanceDisplayUnits = property(FusionUnitsManager._get_distanceDisplayUnits, FusionUnitsManager._set_distanceDisplayUnits, doc="Gets and sets the default distance units for this design.")


FusionUnitsManager.cast = lambda arg: arg if isinstance(arg, FusionUnitsManager) else None

class GeometricConstraint(Base):
    r"""The base class for all geometric constraints."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::GeometricConstraint *":
        return _fusion.GeometricConstraint___deref__(self)

    def __eq__(self, rhs: "GeometricConstraint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.GeometricConstraint___eq__(self, rhs)


    def __ne__(self, rhs: "GeometricConstraint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.GeometricConstraint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.GeometricConstraint_classType()
    __swig_destroy__ = _fusion.delete_GeometricConstraint

    def deleteMe(self) -> "bool":
        r"""
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.GeometricConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this constraint is deletable."""
        return _fusion.GeometricConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.GeometricConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.GeometricConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.GeometricConstraint__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the GeometricConstraint object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same geometric constraint.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.GeometricConstraint__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.GeometricConstraint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.GeometricConstraint__get_isValid(self)

# Register GeometricConstraint in _fusion:
_fusion.GeometricConstraint_swigregister(GeometricConstraint)

def GeometricConstraint_classType() -> "char const *":
    return _fusion.GeometricConstraint_classType()


GeometricConstraint.isDeletable = property(GeometricConstraint._get_isDeletable, doc="Indicates if this constraint is deletable.")


GeometricConstraint.parentSketch = property(GeometricConstraint._get_parentSketch, doc="Returns the parent sketch object.")


GeometricConstraint.assemblyContext = property(GeometricConstraint._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")


GeometricConstraint.attributes = property(GeometricConstraint._get_attributes, doc="Returns the collection of attributes associated with this geometric constraint.")


GeometricConstraint.entityToken = property(GeometricConstraint._get_entityToken, doc="Returns a token for the GeometricConstraint object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same geometric constraint.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.")


GeometricConstraint.cast = lambda arg: arg if isinstance(arg, GeometricConstraint) else None

class GeometricConstraintList(Base):
    r"""A list of geometric constraints."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::GeometricConstraintList *":
        return _fusion.GeometricConstraintList___deref__(self)

    def __eq__(self, rhs: "GeometricConstraintList") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.GeometricConstraintList___eq__(self, rhs)


    def __ne__(self, rhs: "GeometricConstraintList") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.GeometricConstraintList___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.GeometricConstraintList___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::GeometricConstraint >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.GeometricConstraintList___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.GeometricConstraintList_classType()
    __swig_destroy__ = _fusion.delete_GeometricConstraintList

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::GeometricConstraint >":
        r"""
        Function that returns the specified geometry constraint using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.GeometricConstraintList_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of constraints in the sketch."""
        return _fusion.GeometricConstraintList__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.GeometricConstraintList__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.GeometricConstraintList__get_isValid(self)

# Register GeometricConstraintList in _fusion:
_fusion.GeometricConstraintList_swigregister(GeometricConstraintList)

def GeometricConstraintList_classType() -> "char const *":
    return _fusion.GeometricConstraintList_classType()


GeometricConstraintList.count = property(GeometricConstraintList._get_count, doc="Returns the number of constraints in the sketch.")


GeometricConstraintList.cast = lambda arg: arg if isinstance(arg, GeometricConstraintList) else None

class GeometricConstraints(Base):
    r"""
    A collection of all of the geometric constraints in a sketch. This object
    also supports the methods to create new geometric constraints.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::GeometricConstraints *":
        return _fusion.GeometricConstraints___deref__(self)

    def __eq__(self, rhs: "GeometricConstraints") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.GeometricConstraints___eq__(self, rhs)


    def __ne__(self, rhs: "GeometricConstraints") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.GeometricConstraints___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.GeometricConstraints___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::GeometricConstraint >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.GeometricConstraints___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.GeometricConstraints_classType()
    __swig_destroy__ = _fusion.delete_GeometricConstraints

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::GeometricConstraint >":
        r"""
        Function that returns the specified sketch constraint using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.GeometricConstraints_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of constraints in the sketch."""
        return _fusion.GeometricConstraints__get_count(self)

    def addCoincident(self, point: "SketchPoint", entity: "SketchEntity") -> "adsk::core::Ptr< adsk::fusion::CoincidentConstraint >":
        r"""
        Creates a new coincident constraint between two entities. The first argument
        is a sketch point. The second argument is a sketch curve or point. 
        point : The SketchPoint that will be made coincident. 
        entity : The SketchPoint or sketch curve that the point will be made coincident to. 
        Returns the newly created CoincidentConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addCoincident(self, point, entity)

    def addCollinear(self, lineOne: "SketchLine", lineTwo: "SketchLine") -> "adsk::core::Ptr< adsk::fusion::CollinearConstraint >":
        r"""
        Creates a new collinear constraint between two lines. 
        lineOne : The first line to create the constraint on. 
        lineTwo : The second line to create the constraint on. 
        Returns the newly created CollinearConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addCollinear(self, lineOne, lineTwo)

    def addConcentric(self, entityOne: "SketchCurve", entityTwo: "SketchCurve") -> "adsk::core::Ptr< adsk::fusion::ConcentricConstraint >":
        r"""
        Creates a new concentric constraint between two circles, arcs, ellipses, or elliptical arcs. 
        entityOne : The first circle, arc, ellipse or elliptical arc. 
        entityTwo : The second circle, arc, ellipse or elliptical arc. 
        Returns the newly created ConcentricConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addConcentric(self, entityOne, entityTwo)

    def addMidPoint(self, point: "SketchPoint", midPointCurve: "SketchCurve") -> "adsk::core::Ptr< adsk::fusion::MidPointConstraint >":
        r"""
        Creates a new midpoint constraint between a point and a curve. 
        point : The point to constrain to the midpoint of a curve. 
        midPointCurve : The curve that defines the midpoint to constraint to. 
        Returns the newly created MidPointConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addMidPoint(self, point, midPointCurve)

    def addParallel(self, lineOne: "SketchLine", lineTwo: "SketchLine") -> "adsk::core::Ptr< adsk::fusion::ParallelConstraint >":
        r"""
        Creates a new parallel constraint between two lines. 
        lineOne : The first SketchLine. 
        lineTwo : The second SketchLine. 
        Returns the newly created ParallelConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addParallel(self, lineOne, lineTwo)

    def addPerpendicular(self, lineOne: "SketchLine", lineTwo: "SketchLine") -> "adsk::core::Ptr< adsk::fusion::PerpendicularConstraint >":
        r"""
        Creates a new perpendicular constraint between two lines. 
        lineOne : The first SketchLine. 
        lineTwo : The second SketchLine. 
        Returns the newly created PerpendicularConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addPerpendicular(self, lineOne, lineTwo)

    def addHorizontal(self, line: "SketchLine") -> "adsk::core::Ptr< adsk::fusion::HorizontalConstraint >":
        r"""
        Creates a new horizontal constraint on a line. 
        line : The line to constrain horizontally. 
        Returns the newly created HorizontalConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addHorizontal(self, line)

    def addHorizontalPoints(self, pointOne: "SketchPoint", pointTwo: "SketchPoint") -> "adsk::core::Ptr< adsk::fusion::HorizontalPointsConstraint >":
        r"""
        Creates a new horizontal constraint between two points. 
        pointOne : The first SketchPoint to constrain horizontally. 
        pointTwo : The second SketchPoint to constrain horizontally. 
        Returns the newly created HorizontalPointsConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addHorizontalPoints(self, pointOne, pointTwo)

    def addVertical(self, line: "SketchLine") -> "adsk::core::Ptr< adsk::fusion::VerticalConstraint >":
        r"""
        Creates a new vertical constraint on a line. 
        line : The line to constrain vertically. 
        Returns the newly created VerticalConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addVertical(self, line)

    def addVerticalPoints(self, pointOne: "SketchPoint", pointTwo: "SketchPoint") -> "adsk::core::Ptr< adsk::fusion::VerticalPointsConstraint >":
        r"""
        Creates a new vertical constraint between two points. 
        pointOne : The first SketchPoint to constrain vertically. 
        pointTwo : The second SketchPoint to constrain vertically. 
        Returns the newly created VerticalPointsConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addVerticalPoints(self, pointOne, pointTwo)

    def addTangent(self, curveOne: "SketchCurve", curveTwo: "SketchCurve") -> "adsk::core::Ptr< adsk::fusion::TangentConstraint >":
        r"""
        Creates a new tangent constraint between two curves. 
        curveOne : The first curve to be tangent. 
        curveTwo : The second curve to be tangent. 
        Returns the newly created TangentConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addTangent(self, curveOne, curveTwo)

    def addSmooth(self, curveOne: "SketchCurve", curveTwo: "SketchCurve") -> "adsk::core::Ptr< adsk::fusion::SmoothConstraint >":
        r"""
        Creates a new smooth constraint between two curves. One of the curves
        must be a spline. The other curve can be a spline or an arc. 
        curveOne : The first curve to be smooth. 
        curveTwo : The first curve to be smooth. 
        Returns the newly created SmoothConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addSmooth(self, curveOne, curveTwo)

    def addEqual(self, curveOne: "SketchCurve", curveTwo: "SketchCurve") -> "adsk::core::Ptr< adsk::fusion::EqualConstraint >":
        r"""
        Creates a new equal constraint between two lines, or between arcs and circles. 
        curveOne : The first line, arc, or circle. 
        curveTwo : The second line, arc, or circle. 
        Returns the newly created EqualConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addEqual(self, curveOne, curveTwo)

    def addSymmetry(self, entityOne: "SketchEntity", entityTwo: "SketchEntity", symmetryLine: "SketchLine") -> "adsk::core::Ptr< adsk::fusion::SymmetryConstraint >":
        r"""
        Creates a new symmetry constraint. 
        entityOne : The first sketch entity to be symmetric. 
        entityTwo : The second sketch entity to be symmetric. It must be the same type as the first entity. 
        symmetryLine : The SketchLine that defines the axis of symmetry. 
        Returns the newly created SymmetryConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addSymmetry(self, entityOne, entityTwo, symmetryLine)

    def _get_objectType(self) -> "char const *":
        return _fusion.GeometricConstraints__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.GeometricConstraints__get_isValid(self)

# Register GeometricConstraints in _fusion:
_fusion.GeometricConstraints_swigregister(GeometricConstraints)

def GeometricConstraints_classType() -> "char const *":
    return _fusion.GeometricConstraints_classType()


GeometricConstraints.count = property(GeometricConstraints._get_count, doc="Returns the number of constraints in the sketch.")


GeometricConstraints.cast = lambda arg: arg if isinstance(arg, GeometricConstraints) else None

class HoleFeatureInput(Base):
    r"""
    This class defines the methods and properties that pertain to the definition of a hole 
    feature.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::HoleFeatureInput *":
        return _fusion.HoleFeatureInput___deref__(self)

    def __eq__(self, rhs: "HoleFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.HoleFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "HoleFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.HoleFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.HoleFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_HoleFeatureInput

    def setPositionByPoint(self, planarEntity: "Base", point: "Base") -> "bool":
        r"""
        Defines the position of a the hole using a point. The point can be a vertex on the face
        or it can be a Point3D object to define any location on the face. If a Point3D object is 
        provided it will be projected onto the plane along the planes normal. The orientation of the
        hole is defined by the planar face or construction plane. If a vertex is used, the position of 
        the hole is associative to that vertex. If a Point3D object is used the position of the hole 
        is not associative. 
        planarEntity : The planar BRepFace or ConstructionPlane object that defines the orientation of the hole.
        The natural direction of the hole will be opposite the normal of the face or construction plane. 
        point : A Point3D object or vertex that defines the position of the hole. The point will be projected 
        onto the plane along the normal of the plane. 
        Returns true if successful.
        """
        return _fusion.HoleFeatureInput_setPositionByPoint(self, planarEntity, point)

    def setPositionAtCenter(self, planarEntity: "Base", centerEdge: "BRepEdge") -> "bool":
        r"""
        Defines the position of the hole at the center of a circular or elliptical edge of the face. 
        planarEntity : The planar BRepFace or ConstructionPlane object that defines the orientation of the hole.
        The natural direction of the hole will be opposite the normal of the face or construction plane. 
        centerEdge : A circular or elliptical edge whose center point will be the position of the hole. 
        Returns true if successful.
        """
        return _fusion.HoleFeatureInput_setPositionAtCenter(self, planarEntity, centerEdge)

    def setPositionBySketchPoint(self, sketchPoint: "SketchPoint") -> "bool":
        r"""
        Defines the position and orientation of the hole using a sketch point. 
        sketchPoint : The sketch point that defines the position of the hole. The orientation is
        inferred from the normal of the point's parent sketch. The natural direction will be 
        opposite the normal of the sketch. 
        Returns true if successful.
        """
        return _fusion.HoleFeatureInput_setPositionBySketchPoint(self, sketchPoint)

    def setPositionByPlaneAndOffsets(self, *args) -> "bool":
        r"""
        Defines the orientation of the hole using a planar face or construction plane. 
        The position of the hole is defined by the distance from one or two edges. 
        planarEntity : The planar BRepFace or ConstructionPlane object that defines the orientation of the hole.
        The natural direction of the hole will be opposite the normal of the face or construction plane. 
        point : A Point3D object that defines the approximate initial position of the hole. The point will be 
        projected onto the plane. This point should be close to the final position of the hole and 
        is used to determine which solution out of several possible solutions should be chosen 
        for the hole location. 
        edgeOne : A linear BRepEdge object that the position of the hole will be measured from. The position 
        of the hole will be measured along a perpendicular from this edge. 
        offsetOne : A ValueInput object that defines the offset distance from edgeOne. If the ValueInput uses
        a real then it is interpreted as centimeters. If it is a string then the units
        can be defined as part of the string (i.e. '3 in'). If no units are specified
        it is interpreted using the current default units for length. 
        edgeTwo : You can optionally define a second edge and offset to specify the position of the hole. If you use a
        second edge it has the same requirements as the edgeOne argument. If you provide a second edge you 
        must also provide the offsetTwo argument. 
        offsetTwo : If edgeTwo is defined, you must provide this argument which is a ValueInput object that 
        defines the offset from the edgeTwo. If the ValueInput uses a real then it is interpreted 
        as centimeters. If it is a string then the units can be defined as part of the string 
        (i.e. '3 in'). If no units are specified it is interpreted using the current default units 
        for length. 
        Returns true if successful.
        """
        return _fusion.HoleFeatureInput_setPositionByPlaneAndOffsets(self, *args)

    def setPositionOnEdge(self, planarEntity: "Base", edge: "BRepEdge", position: "HoleEdgePositions") -> "bool":
        r"""
        Defines the position and orientation of the hole to be on the start, end or center of an edge. 
        planarEntity : The planar BRepFace or ConstructionPlane object that defines the orientation of the hole
        and start of the hole. The natural direction of the hole will be opposite the normal of 
        the face or construction plane. 
        edge : The edge to position the hole on. 
        position : The position along the edge to place the hole. 
        Returns true if successful.
        """
        return _fusion.HoleFeatureInput_setPositionOnEdge(self, planarEntity, edge, position)

    def _get_tipAngle(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Gets the ValueInput object that defines the angle of the tip of the hole. The default 
        is '118.0 deg' but can be modified by setting it using another Value object.
        """
        return _fusion.HoleFeatureInput__get_tipAngle(self)

    def _set_tipAngle(self, value: "ValueInput") -> "bool":
        r"""
        Gets the ValueInput object that defines the angle of the tip of the hole. The default 
        is '118.0 deg' but can be modified by setting it using another Value object.
        """
        return _fusion.HoleFeatureInput__set_tipAngle(self, value)

    def _get_isDefaultDirection(self) -> "bool":
        r"""Gets or sets if the hole goes in the default direction or is reversed."""
        return _fusion.HoleFeatureInput__get_isDefaultDirection(self)

    def _set_isDefaultDirection(self, value: "bool") -> "bool":
        r"""Gets or sets if the hole goes in the default direction or is reversed."""
        return _fusion.HoleFeatureInput__set_isDefaultDirection(self, value)

    def setDistanceExtent(self, distance: "ValueInput") -> "bool":
        r"""
        Defines the depth of the hole using a specified distance. 
        distance : The depth of the hole. If a real is specified the value is in centimeters. 
        If a string is specified the units are derived from the string. If no units are specified, 
        the default units of the document are used. 
        Returns true if setting the extent was successful.
        """
        return _fusion.HoleFeatureInput_setDistanceExtent(self, distance)

    def setAllExtent(self, direction: "ExtentDirections") -> "bool":
        r"""
        Defines the extent of the hole to be through-all. The direction can be
        either positive, negative. 
        direction : The direction of the hole relative to the normal of the sketch plane. 
        Returns true if successful.
        """
        return _fusion.HoleFeatureInput_setAllExtent(self, direction)

    def setOneSideToExtent(self, *args) -> "bool":
        r"""
        Sets the extent of the hole to be from the sketch plane to the specified 'to' face. 
        toEntity : The entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For a hole it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        matchShape : Indicates if the hole is not contained on the face that the hole should match
        the shape of the entity as if it extended beyond it's current boundaries. 
        directionHint : Specifies the direction of the hole. This is only used in the case where there are two possible solutions and the hole can
        hit the toEntity in either direction.
        Typically there is only a single solution and the direction is determined automatically. 
        Returns true if successful.
        """
        return _fusion.HoleFeatureInput_setOneSideToExtent(self, *args)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the Hole is created based on geometry (e.g. a face or point)
        in another component AND (the Hole) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        A value of null indicates that everything is in the context of a single component.
        """
        return _fusion.HoleFeatureInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, value: "Occurrence") -> "bool":
        r"""
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the Hole is created based on geometry (e.g. a face or point)
        in another component AND (the Hole) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        A value of null indicates that everything is in the context of a single component.
        """
        return _fusion.HoleFeatureInput__set_creationOccurrence(self, value)

    def setPositionBySketchPoints(self, sketchPoints: "ObjectCollection") -> "bool":
        r"""
        Defines the position and orientation of the hole using a set of sketch points. 
        sketchPoints : A collection of sketch points that defines the positions of the holes. The orientation is
        inferred from the normal of the point's parent sketch. The natural direction will be 
        opposite the normal of the sketch. The points can be from multiple sketches but they
        must all be co-planar. 
        Returns true if successful.
        """
        return _fusion.HoleFeatureInput_setPositionBySketchPoints(self, sketchPoints)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.HoleFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.HoleFeatureInput__set_targetBaseFeature(self, value)

    def _get_participantBodies(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepBody > > >":
        r"""
        Gets and sets the list of bodies that will participate in the hole.
        If this property has not been set, the default behavior is that all bodies that are intersected by the 
        hole will participate.
        This property can return null in the case where the feature has not been fully defined so that
        possible intersecting bodies can be computed.
        """
        return _fusion.HoleFeatureInput__get_participantBodies(self)

    def _set_participantBodies(self, value: "BRepBodyVector") -> "bool":
        r"""
        Gets and sets the list of bodies that will participate in the hole.
        If this property has not been set, the default behavior is that all bodies that are intersected by the 
        hole will participate.
        This property can return null in the case where the feature has not been fully defined so that
        possible intersecting bodies can be computed.
        """
        return _fusion.HoleFeatureInput__set_participantBodies(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.HoleFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.HoleFeatureInput__get_isValid(self)

# Register HoleFeatureInput in _fusion:
_fusion.HoleFeatureInput_swigregister(HoleFeatureInput)

def HoleFeatureInput_classType() -> "char const *":
    return _fusion.HoleFeatureInput_classType()


HoleFeatureInput.tipAngle = property(HoleFeatureInput._get_tipAngle, HoleFeatureInput._set_tipAngle, doc="Gets the ValueInput object that defines the angle of the tip of the hole. The default\nis '118.0 deg' but can be modified by setting it using another Value object.")


HoleFeatureInput.isDefaultDirection = property(HoleFeatureInput._get_isDefaultDirection, HoleFeatureInput._set_isDefaultDirection, doc="Gets or sets if the hole goes in the default direction or is reversed.")


HoleFeatureInput.creationOccurrence = property(HoleFeatureInput._get_creationOccurrence, HoleFeatureInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an Occurrence for creation needs to be\nspecified when the Hole is created based on geometry (e.g. a face or point)\nin another component AND (the Hole) is not in the root component.\nThe CreationOccurrence is analogous to the active occurrence in the UI\nA value of null indicates that everything is in the context of a single component.")


HoleFeatureInput.targetBaseFeature = property(HoleFeatureInput._get_targetBaseFeature, HoleFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


HoleFeatureInput.participantBodies = property(HoleFeatureInput._get_participantBodies, HoleFeatureInput._set_participantBodies, doc="Gets and sets the list of bodies that will participate in the hole.\nIf this property has not been set, the default behavior is that all bodies that are intersected by the\nhole will participate.\nThis property can return null in the case where the feature has not been fully defined so that\npossible intersecting bodies can be computed.")


HoleFeatureInput.cast = lambda arg: arg if isinstance(arg, HoleFeatureInput) else None

class HoleFeatures(Base):
    r"""
    Collection that provides access to all of the existing hole features in a component
    and supports the ability to create new hole features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::HoleFeatures *":
        return _fusion.HoleFeatures___deref__(self)

    def __eq__(self, rhs: "HoleFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.HoleFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "HoleFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.HoleFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.HoleFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::HoleFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.HoleFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.HoleFeatures_classType()
    __swig_destroy__ = _fusion.delete_HoleFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::HoleFeature >":
        r"""
        Function that returns the specified hole feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.HoleFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of hole features in the collection."""
        return _fusion.HoleFeatures__get_count(self)

    def createSimpleInput(self, holeDiameter: "ValueInput") -> "adsk::core::Ptr< adsk::fusion::HoleFeatureInput >":
        r"""
        Creates a HoleFeatureInput object that defines a simple hole (a single diameter). 
        This is not a hole feature, but an object used to create a hole feature. Functionality
        on the returned HoleFeatureInput object is used to define the position and extent 
        of the hole. 
        holeDiameter : A ValueInput object that defines the diameter of the hole. If the ValueInput uses
        a real, it is interpreted as centimeters. If it is a string, the units
        can be defined as part of the string (i.e. '3 in') If no units are specified,
        it is interpreted using the current default units for length. 
        Returns the newly created HoleFeatureInput object or null if the creation failed.
        """
        return _fusion.HoleFeatures_createSimpleInput(self, holeDiameter)

    def createCounterboreInput(self, holeDiameter: "ValueInput", counterboreDiameter: "ValueInput", counterboreDepth: "ValueInput") -> "adsk::core::Ptr< adsk::fusion::HoleFeatureInput >":
        r"""
        Creates a HoleFeatureInput object that defines a counterbore hole. This is not
        a hole feature but an object used to create a hole feature. Functionality
        on the returned HoleFeatureInput object is used to define the position and extent 
        of the hole. 
        holeDiameter : A ValueInput object that defines the diameter of the hole. If the ValueInput uses
        a real, it is interpreted as centimeters. If it is a string, the units
        can be defined as part of the string (i.e. '3 in') If no units are specified,
        it is interpreted using the current default units for length. 
        counterboreDiameter : A ValueInput object that defines the counterbore diameter of the hole. If the ValueInput uses
        a real, it is interpreted as centimeters. If it is a string, the units
        can be defined as part of the string (i.e. '3 in') If no units are specified,
        it is interpreted using the current default units for length. 
        counterboreDepth : A ValueInput object that defines the counterbore depth of the hole. If the ValueInput uses
        a real, it is interpreted as centimeters. If it is a string, the units
        can be defined as part of the string (i.e. '3 in') If no units are specified,
        it is interpreted using the current default units for length. 
        Returns the newly created HoleFeatureInput object or null if the creation failed.
        """
        return _fusion.HoleFeatures_createCounterboreInput(self, holeDiameter, counterboreDiameter, counterboreDepth)

    def createCountersinkInput(self, holeDiameter: "ValueInput", countersinkDiameter: "ValueInput", countersinkAngle: "ValueInput") -> "adsk::core::Ptr< adsk::fusion::HoleFeatureInput >":
        r"""
        Creates a HoleFeatureInput object that defines a countersink hole. This is not
        a hole feature but an object used to create a hole feature. Functionality
        on the returned HoleFeatureInput object is used to define the position and extent of the hole. 
        holeDiameter : A ValueInput object that defines the diameter of the hole. If the ValueInput uses
        a real, it is interpreted as centimeters. If it is a string, the units
        can be defined as part of the string (i.e. '3 in') If no units are specified,
        it is interpreted using the current default units for length. 
        countersinkDiameter : A ValueInput object that defines the diameter of the countersink. If the ValueInput uses
        a real, it is interpreted as centimeters. If it is a string, the units
        can be defined as part of the string (i.e. '3 in') If no units are specified,
        it is interpreted using the current default units for length. 
        countersinkAngle : A ValueInput object that defines the angle of the countersink. If the ValueInput uses
        a real then it is interpreted as radians. If it is a string then the units
        can be defined as part of the string (i.e. '120 deg'). If no units are specified
        it is interpreted using the current default units for angles. 
        Returns the newly created HoleFeatureInput object or null if the creation failed.
        """
        return _fusion.HoleFeatures_createCountersinkInput(self, holeDiameter, countersinkDiameter, countersinkAngle)

    def add(self, input: "HoleFeatureInput") -> "adsk::core::Ptr< adsk::fusion::HoleFeature >":
        r"""
        Creates a new hole feature based on the information provided by a HoleFeatureInput object.
        To create a new hole, use one of the createInput functions to define a new input object for 
        the type of hole you want to create. Use the methods and properties on the input object 
        to define any additional input. Once the information is defined on the input object, you 
        can pass it to the Add method to create the hole. 
        input : The HoleFeatureInput object that defines the hole you want to create. 
        Returns the newly created HoleFeature or null if the creation failed.
        """
        return _fusion.HoleFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::HoleFeature >":
        r"""
        Function that returns the specified hole feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.HoleFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.HoleFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.HoleFeatures__get_isValid(self)

# Register HoleFeatures in _fusion:
_fusion.HoleFeatures_swigregister(HoleFeatures)

def HoleFeatures_classType() -> "char const *":
    return _fusion.HoleFeatures_classType()


HoleFeatures.count = property(HoleFeatures._get_count, doc="The number of hole features in the collection.")


HoleFeatures.cast = lambda arg: arg if isinstance(arg, HoleFeatures) else None

class HolePositionDefinition(Base):
    r"""The base class for the classes that define how a hole can be positioned."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::HolePositionDefinition *":
        return _fusion.HolePositionDefinition___deref__(self)

    def __eq__(self, rhs: "HolePositionDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.HolePositionDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "HolePositionDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.HolePositionDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.HolePositionDefinition_classType()
    __swig_destroy__ = _fusion.delete_HolePositionDefinition

    def _get_objectType(self) -> "char const *":
        return _fusion.HolePositionDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.HolePositionDefinition__get_isValid(self)

# Register HolePositionDefinition in _fusion:
_fusion.HolePositionDefinition_swigregister(HolePositionDefinition)

def HolePositionDefinition_classType() -> "char const *":
    return _fusion.HolePositionDefinition_classType()


HolePositionDefinition.cast = lambda arg: arg if isinstance(arg, HolePositionDefinition) else None

class InterferenceInput(Base):
    r"""
    Used to gather and define the various inputs and settings needed to calculate interference. This
    object is created using the Design.createInterferenceInput method.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::InterferenceInput *":
        return _fusion.InterferenceInput___deref__(self)

    def __eq__(self, rhs: "InterferenceInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.InterferenceInput___eq__(self, rhs)


    def __ne__(self, rhs: "InterferenceInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.InterferenceInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.InterferenceInput_classType()
    __swig_destroy__ = _fusion.delete_InterferenceInput

    def _get_entities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and set an ObjectCollection containing BRepBody and/or Occurrence entities that
        will be used when checking for interference. All entities must be in the context of 
        the root component of the top-level design.
        """
        return _fusion.InterferenceInput__get_entities(self)

    def _set_entities(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and set an ObjectCollection containing BRepBody and/or Occurrence entities that
        will be used when checking for interference. All entities must be in the context of 
        the root component of the top-level design.
        """
        return _fusion.InterferenceInput__set_entities(self, value)

    def _get_areCoincidentFacesIncluded(self) -> "bool":
        r"""
        Gets and sets whether any coincident faces in the input bodies are considered as interference
        or not. This property defaults to False for a newly created InterferenceInput object.
        """
        return _fusion.InterferenceInput__get_areCoincidentFacesIncluded(self)

    def _set_areCoincidentFacesIncluded(self, value: "bool") -> "bool":
        r"""
        Gets and sets whether any coincident faces in the input bodies are considered as interference
        or not. This property defaults to False for a newly created InterferenceInput object.
        """
        return _fusion.InterferenceInput__set_areCoincidentFacesIncluded(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.InterferenceInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.InterferenceInput__get_isValid(self)

# Register InterferenceInput in _fusion:
_fusion.InterferenceInput_swigregister(InterferenceInput)

def InterferenceInput_classType() -> "char const *":
    return _fusion.InterferenceInput_classType()


InterferenceInput.entities = property(InterferenceInput._get_entities, InterferenceInput._set_entities, doc="Gets and set an ObjectCollection containing BRepBody and/or Occurrence entities that\nwill be used when checking for interference. All entities must be in the context of\nthe root component of the top-level design.")


InterferenceInput.areCoincidentFacesIncluded = property(InterferenceInput._get_areCoincidentFacesIncluded, InterferenceInput._set_areCoincidentFacesIncluded, doc="Gets and sets whether any coincident faces in the input bodies are considered as interference\nor not. This property defaults to False for a newly created InterferenceInput object.")


InterferenceInput.cast = lambda arg: arg if isinstance(arg, InterferenceInput) else None

class InterferenceResult(Base):
    r"""Represents the interference between bodies and/or occurrences in an interference analysis."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::InterferenceResult *":
        return _fusion.InterferenceResult___deref__(self)

    def __eq__(self, rhs: "InterferenceResult") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.InterferenceResult___eq__(self, rhs)


    def __ne__(self, rhs: "InterferenceResult") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.InterferenceResult___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.InterferenceResult_classType()
    __swig_destroy__ = _fusion.delete_InterferenceResult

    def _get_entityOne(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the first entity involved in the interference"""
        return _fusion.InterferenceResult__get_entityOne(self)

    def _get_entityTwo(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the second entity involved in the interference"""
        return _fusion.InterferenceResult__get_entityTwo(self)

    def _get_interferenceBody(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""Returns a transient BRepBody that represents the volume of interference."""
        return _fusion.InterferenceResult__get_interferenceBody(self)

    def _get_isCreateBody(self) -> "bool":
        r"""
        Gets and sets if this interference volume should be created as a model body. Setting
        this to true doesn't create the body just indicates that a body is desired. Calling
        the createBodies method on the interferenceResults object will result in the creation
        of the model body if this property is true.
        """
        return _fusion.InterferenceResult__get_isCreateBody(self)

    def _set_isCreateBody(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this interference volume should be created as a model body. Setting
        this to true doesn't create the body just indicates that a body is desired. Calling
        the createBodies method on the interferenceResults object will result in the creation
        of the model body if this property is true.
        """
        return _fusion.InterferenceResult__set_isCreateBody(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.InterferenceResult__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.InterferenceResult__get_isValid(self)

# Register InterferenceResult in _fusion:
_fusion.InterferenceResult_swigregister(InterferenceResult)

def InterferenceResult_classType() -> "char const *":
    return _fusion.InterferenceResult_classType()


InterferenceResult.entityOne = property(InterferenceResult._get_entityOne, doc="Returns the first entity involved in the interference")


InterferenceResult.entityTwo = property(InterferenceResult._get_entityTwo, doc="Returns the second entity involved in the interference")


InterferenceResult.interferenceBody = property(InterferenceResult._get_interferenceBody, doc="Returns a transient BRepBody that represents the volume of interference.")


InterferenceResult.isCreateBody = property(InterferenceResult._get_isCreateBody, InterferenceResult._set_isCreateBody, doc="Gets and sets if this interference volume should be created as a model body. Setting\nthis to true doesn't create the body just indicates that a body is desired. Calling\nthe createBodies method on the interferenceResults object will result in the creation\nof the model body if this property is true.")


InterferenceResult.cast = lambda arg: arg if isinstance(arg, InterferenceResult) else None

class InterferenceResults(Base):
    r"""Transient object used to return the result of an interference analysis."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::InterferenceResults *":
        return _fusion.InterferenceResults___deref__(self)

    def __eq__(self, rhs: "InterferenceResults") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.InterferenceResults___eq__(self, rhs)


    def __ne__(self, rhs: "InterferenceResults") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.InterferenceResults___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.InterferenceResults___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::InterferenceResult >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.InterferenceResults___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.InterferenceResults_classType()
    __swig_destroy__ = _fusion.delete_InterferenceResults

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::InterferenceResult >":
        r"""
        Function that returns the specified interference result using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.InterferenceResults_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of interference results in the collection."""
        return _fusion.InterferenceResults__get_count(self)

    def createBodies(self, allInterferenceBodies: "bool") -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Creates bodies in the model that represent the interference volumes.
        This is not supported in parametric modelling. 
        allInterferenceBodies : Sets if all bodies or only individual bodies will be created as bodies in the model.
        If False, then only interferenceResult objects whose isCreateBody property is true
        will be created as a model body. If true, all interface volumes will be created as
        a body regardless of the value of the isCreateBody property.
        """
        return _fusion.InterferenceResults_createBodies(self, allInterferenceBodies)

    def _get_objectType(self) -> "char const *":
        return _fusion.InterferenceResults__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.InterferenceResults__get_isValid(self)

# Register InterferenceResults in _fusion:
_fusion.InterferenceResults_swigregister(InterferenceResults)

def InterferenceResults_classType() -> "char const *":
    return _fusion.InterferenceResults_classType()


InterferenceResults.count = property(InterferenceResults._get_count, doc="Returns the number of interference results in the collection.")


InterferenceResults.cast = lambda arg: arg if isinstance(arg, InterferenceResults) else None

class Joint(Base):
    r"""A joint in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::Joint *":
        return _fusion.Joint___deref__(self)

    def __eq__(self, rhs: "Joint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.Joint___eq__(self, rhs)


    def __ne__(self, rhs: "Joint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.Joint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.Joint_classType()
    __swig_destroy__ = _fusion.delete_Joint

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this joint."""
        return _fusion.Joint__get_parentComponent(self)

    def _get_name(self) -> "std::string":
        r"""Gets and sets the name of the joint."""
        return _fusion.Joint__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the name of the joint."""
        return _fusion.Joint__set_name(self, value)

    def _get_geometryOrOriginOne(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets and sets the first JointGeometry or JointOrigin for this joint."""
        return _fusion.Joint__get_geometryOrOriginOne(self)

    def _set_geometryOrOriginOne(self, value: "Base") -> "bool":
        r"""Gets and sets the first JointGeometry or JointOrigin for this joint."""
        return _fusion.Joint__set_geometryOrOriginOne(self, value)

    def _get_geometryOrOriginTwo(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets and sets the second JointGeometry or JointOrigin for this joint."""
        return _fusion.Joint__get_geometryOrOriginTwo(self)

    def _set_geometryOrOriginTwo(self, value: "Base") -> "bool":
        r"""Gets and sets the second JointGeometry or JointOrigin for this joint."""
        return _fusion.Joint__set_geometryOrOriginTwo(self, value)

    def _get_angle(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the parameter controlling the angle between the two input geometries. This is effectively the
        angle between the two primary axes of the two joint geometries.
        """
        return _fusion.Joint__get_angle(self)

    def _get_offset(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the parameter controlling the offset between the two input geometries. This is effectively the
        offset distance between the two planes defined by the primary and secondary axes
        of the input geometries or the offset along the tertiary axis (z axis) of the joint.
        """
        return _fusion.Joint__get_offset(self)

    def _get_isFlipped(self) -> "bool":
        r"""
        Gets and sets if the joint direction is flipped or not. This is effectively
        specifying if the third axis of the two input geometries is facing (false) or
        opposed (true).
        """
        return _fusion.Joint__get_isFlipped(self)

    def _set_isFlipped(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the joint direction is flipped or not. This is effectively
        specifying if the third axis of the two input geometries is facing (false) or
        opposed (true).
        """
        return _fusion.Joint__set_isFlipped(self, value)

    def _get_jointMotion(self) -> "adsk::core::Ptr< adsk::fusion::JointMotion >":
        r"""Returns a JointMotion object that defines the motion relationship between the two geometries."""
        return _fusion.Joint__get_jointMotion(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this joint. 
        Returns true if the delete is successful.
        """
        return _fusion.Joint_deleteMe(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this joint."""
        return _fusion.Joint__get_timelineObject(self)

    def setAsRigidJointMotion(self) -> "bool":
        r"""
        Redefines the relationship between the two joint geometries as a rigid joint. 
        Returns true if successful.
        """
        return _fusion.Joint_setAsRigidJointMotion(self)

    def setAsRevoluteJointMotion(self, *args) -> "bool":
        r"""
        Redefines the relationship between the two joint geometries as a revolute joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived
        from. 
        Returns true if the operation was successful.
        """
        return _fusion.Joint_setAsRevoluteJointMotion(self, *args)

    def setAsSliderJointMotion(self, *args) -> "bool":
        r"""
        Redefines the relationship between the two joint geometries as a slider joint. 
        sliderDirection : Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the 
        customSliderDirectionEntity argument must also be provided. 
        customSliderDirectionEntity : If the sliderDirection is CustomJointDirection this argument is used to specify the entity that defines
        the custom slider direction. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.Joint_setAsSliderJointMotion(self, *args)

    def setAsCylindricalJointMotion(self, *args) -> "bool":
        r"""
        Redefines the relationship between the two joint geometries as a cylindrical joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived
        from. 
        Returns true if the operation was successful.
        """
        return _fusion.Joint_setAsCylindricalJointMotion(self, *args)

    def setAsPinSlotJointMotion(self, *args) -> "bool":
        r"""
        Redefines the relationship between the two joint geometries as a pin-slot joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        slideDirection : Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the 
        customSlideDirectionEntity argument must also be provided. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived 
        customSlideDirectionEntity : If the slideDirection is CustomJointDirection this argument is used to specify the entity that defines
        the custom slide direction. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.Joint_setAsPinSlotJointMotion(self, *args)

    def setAsPlanarJointMotion(self, *args) -> "bool":
        r"""
        Redefines the relationship between the two joint geometries as a planar joint. 
        normalDirection : Defines the direction of the normal of the single degree of rotation.
        This can be set to XAxisJointDirection, YAxisJointDirection, ZAxisJointDirection, 
        or CustomJointDirection. If set to CustomJointDirection then the customNormalDirectionEntity
        argument must also be provided. 
        customNormalDirectionEntity : If the normalDirection is CustomJointDirection this argument is used to specify the entity that defines
        the direction of the normal. This can be several types of entities that can define a direction. 
        customPrimarySlideDirection : This arguments defines the direction of the primary slide direction. A default primary slide direction 
        is automatically chosen and will be used if this argument is not provided or is null. The secondar slide
        direction is automatically inferred from the normal and primary slide directions. 
        Returns true if the operation was successful.
        """
        return _fusion.Joint_setAsPlanarJointMotion(self, *args)

    def setAsBallJointMotion(self, *args) -> "bool":
        r"""
        Redefines the relationship between the two joint geometries as a ball joint. 
        pitchDirection : Defines the direction the pitch angle is measured from. This can be ZAxisJointDirection or CustomJointDirection. If
        CustomJointDirection is specified then you must also provide a value for the customPitchDirection argument. 
        yawDirection : Defines the direction the yaw is measured from. This can be XAxisJointDirection or CustomJointDirection. If
        CustomJointDirection is specified then you must also provide a value for the customYawDirection argument. 
        customPitchDirection : If the pitchDirection argument is customPitchDirection this argument is used to define the direction the pitch
        angel is measured from. This can be several types of entities that can define a direction. 
        customYawDirection : If the yawDirection argument is customPitchDirection this argument is used to define the direction the yaw
        angel is measured from. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.Joint_setAsBallJointMotion(self, *args)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::Joint >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.Joint__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::Joint >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.Joint_createForAssemblyContext(self, occurrence)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.Joint__get_assemblyContext(self)

    def _get_isSuppressed(self) -> "bool":
        r"""Gets and sets if this joint is suppressed."""
        return _fusion.Joint__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""Gets and sets if this joint is suppressed."""
        return _fusion.Joint__set_isSuppressed(self, value)

    def _get_isLightBulbOn(self) -> "bool":
        r"""
        Gets and sets if the light bulb of this joint as displayed in the browser is on or off.
        A joint will only be visible if the light bulb is switched on. However,
        the light bulb can be on and the joint still invisible if a higher level occurrence 
        in the assembly context is not visible because its light bulb is off or the joints folder
        is light bulb is off.
        """
        return _fusion.Joint__get_isLightBulbOn(self)

    def _set_isLightBulbOn(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the light bulb of this joint as displayed in the browser is on or off.
        A joint will only be visible if the light bulb is switched on. However,
        the light bulb can be on and the joint still invisible if a higher level occurrence 
        in the assembly context is not visible because its light bulb is off or the joints folder
        is light bulb is off.
        """
        return _fusion.Joint__set_isLightBulbOn(self, value)

    def _get_isVisible(self) -> "bool":
        r"""
        Gets whether the joint is visible. To change the visibility see the isLightBulbOn property.
        This property is affected by the assembly context.
        """
        return _fusion.Joint__get_isVisible(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this joint."""
        return _fusion.Joint__get_attributes(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the joint."""
        return _fusion.Joint__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.Joint__get_errorOrWarningMessage(self)

    def _get_occurrenceOne(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the first of two occurrences that this joint defines a relationship between. This is the occurrence
        that can also be found through the geometryOrOriginOne property.
        """
        return _fusion.Joint__get_occurrenceOne(self)

    def _get_occurrenceTwo(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the first of two occurrences that this joint defines a relationship between. This is the occurrence
        that can also be found through the geometryOrOriginTwo property.
        """
        return _fusion.Joint__get_occurrenceTwo(self)

    def _get_isLocked(self) -> "bool":
        r"""Gets and sets if the joint is locked."""
        return _fusion.Joint__get_isLocked(self)

    def _set_isLocked(self, value: "bool") -> "bool":
        r"""Gets and sets if the joint is locked."""
        return _fusion.Joint__set_isLocked(self, value)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Joint object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same joint.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.Joint__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.Joint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.Joint__get_isValid(self)

# Register Joint in _fusion:
_fusion.Joint_swigregister(Joint)

def Joint_classType() -> "char const *":
    return _fusion.Joint_classType()


Joint.parentComponent = property(Joint._get_parentComponent, doc="Returns the parent component that owns this joint.")


Joint.name = property(Joint._get_name, Joint._set_name, doc="Gets and sets the name of the joint.")


Joint.geometryOrOriginOne = property(Joint._get_geometryOrOriginOne, Joint._set_geometryOrOriginOne, doc="Gets and sets the first JointGeometry or JointOrigin for this joint.")


Joint.geometryOrOriginTwo = property(Joint._get_geometryOrOriginTwo, Joint._set_geometryOrOriginTwo, doc="Gets and sets the second JointGeometry or JointOrigin for this joint.")


Joint.angle = property(Joint._get_angle, doc="Returns the parameter controlling the angle between the two input geometries. This is effectively the\nangle between the two primary axes of the two joint geometries.")


Joint.offset = property(Joint._get_offset, doc="Returns the parameter controlling the offset between the two input geometries. This is effectively the\noffset distance between the two planes defined by the primary and secondary axes\nof the input geometries or the offset along the tertiary axis (z axis) of the joint.")


Joint.isFlipped = property(Joint._get_isFlipped, Joint._set_isFlipped, doc="Gets and sets if the joint direction is flipped or not. This is effectively\nspecifying if the third axis of the two input geometries is facing (false) or\nopposed (true).")


Joint.jointMotion = property(Joint._get_jointMotion, doc="Returns a JointMotion object that defines the motion relationship between the two geometries.")


Joint.timelineObject = property(Joint._get_timelineObject, doc="Returns the timeline object associated with this joint.")


Joint.nativeObject = property(Joint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


Joint.assemblyContext = property(Joint._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")


Joint.isSuppressed = property(Joint._get_isSuppressed, Joint._set_isSuppressed, doc="Gets and sets if this joint is suppressed.")


Joint.isLightBulbOn = property(Joint._get_isLightBulbOn, Joint._set_isLightBulbOn, doc="Gets and sets if the light bulb of this joint as displayed in the browser is on or off.\nA joint will only be visible if the light bulb is switched on. However,\nthe light bulb can be on and the joint still invisible if a higher level occurrence\nin the assembly context is not visible because its light bulb is off or the joints folder\nis light bulb is off.")


Joint.isVisible = property(Joint._get_isVisible, doc="Gets whether the joint is visible. To change the visibility see the isLightBulbOn property.\nThis property is affected by the assembly context.")


Joint.attributes = property(Joint._get_attributes, doc="Returns the collection of attributes associated with this joint.")


Joint.healthState = property(Joint._get_healthState, doc="Returns the current health state of the joint.")


Joint.errorOrWarningMessage = property(Joint._get_errorOrWarningMessage, doc="Returns the error or warning message in the case where the healthState property returns either\nWarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.")


Joint.occurrenceOne = property(Joint._get_occurrenceOne, doc="Returns the first of two occurrences that this joint defines a relationship between. This is the occurrence\nthat can also be found through the geometryOrOriginOne property.")


Joint.occurrenceTwo = property(Joint._get_occurrenceTwo, doc="Returns the first of two occurrences that this joint defines a relationship between. This is the occurrence\nthat can also be found through the geometryOrOriginTwo property.")


Joint.isLocked = property(Joint._get_isLocked, Joint._set_isLocked, doc="Gets and sets if the joint is locked.")


Joint.entityToken = property(Joint._get_entityToken, doc="Returns a token for the Joint object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same joint.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.")


Joint.cast = lambda arg: arg if isinstance(arg, Joint) else None

class JointGeometry(Base):
    r"""
    A transient object used to define and query the geometric input of a joint and the resulting coordinate
    system it defines. New JointGeometry objects are created using its various static create methods and 
    are then used as input to the Joints.createInput method.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::JointGeometry *":
        return _fusion.JointGeometry___deref__(self)

    def __eq__(self, rhs: "JointGeometry") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.JointGeometry___eq__(self, rhs)


    def __ne__(self, rhs: "JointGeometry") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.JointGeometry___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.JointGeometry_classType()

    @staticmethod
    def createByPlanarFace(face: "BRepFace", edge: "BRepEdge", keyPointType: "JointKeyPointTypes") -> "adsk::core::Ptr< adsk::fusion::BRepFace > const &, adsk::core::Ptr< adsk::fusion::BRepEdge > const &":
        return _fusion.JointGeometry_createByPlanarFace(face, edge, keyPointType)

    @staticmethod
    def createByNonPlanarFace(face: "BRepFace", keyPointType: "JointKeyPointTypes") -> "adsk::core::Ptr< adsk::fusion::BRepFace > const &":
        return _fusion.JointGeometry_createByNonPlanarFace(face, keyPointType)

    @staticmethod
    def createByProfile(profile: "Profile", sketchCurve: "SketchCurve", keyPointType: "JointKeyPointTypes") -> "adsk::core::Ptr< adsk::fusion::Profile > const &, adsk::core::Ptr< adsk::fusion::SketchCurve > const &":
        return _fusion.JointGeometry_createByProfile(profile, sketchCurve, keyPointType)

    @staticmethod
    def createByCurve(curve: "Base", keyPointType: "JointKeyPointTypes") -> "adsk::core::Ptr< adsk::fusion::JointGeometry >":
        return _fusion.JointGeometry_createByCurve(curve, keyPointType)

    @staticmethod
    def createByPoint(point: "Base") -> "adsk::core::Ptr< adsk::fusion::JointGeometry >":
        return _fusion.JointGeometry_createByPoint(point)

    @staticmethod
    def createByBetweenTwoPlanes(planeOne: "Base", planeTwo: "Base", entityOne: "Base", entityTwo: "Base", keyPointType: "JointKeyPointTypes") -> "adsk::core::Ptr< adsk::fusion::JointGeometry >":
        return _fusion.JointGeometry_createByBetweenTwoPlanes(planeOne, planeTwo, entityOne, entityTwo, keyPointType)
    __swig_destroy__ = _fusion.delete_JointGeometry

    def _get_geometryType(self) -> "adsk::fusion::JointGeometryTypes":
        r"""Returns the type of geometry this JointGeometry object represents."""
        return _fusion.JointGeometry__get_geometryType(self)

    def _get_keyPointType(self) -> "adsk::fusion::JointKeyPointTypes":
        r"""Returns the keypoint type this JointGeometry is using."""
        return _fusion.JointGeometry__get_keyPointType(self)

    def _get_entityOne(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        The first entity that's defining this joint geometry. This can be various types of geometry depending
        on how this joint geometry is defined. The geometryType property indicates how this joint geometry is
        defined a provides a clue about the type of geometry to expect back from this property.
        """
        return _fusion.JointGeometry__get_entityOne(self)

    def _get_entityTwo(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        This is the second entity that defines this joint geometry. This isn't used for all joint geometry types
        and will return null in the cases where it's not used. A second geometry is used in the case where the geometryType
        property returns JointProfileGeometry, JointPlanarBRepFaceGeometry, JointBetweenTwoFacesGeometry or JointByTwoEdgeIntersectionGeometry.
        """
        return _fusion.JointGeometry__get_entityTwo(self)

    def _get_origin(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Returns the origin point that's been calculated for this joint geometry."""
        return _fusion.JointGeometry__get_origin(self)

    def _get_primaryAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Returns the direction of the primary axis that's been calculated for this joint geometry.
        Conceptually, this is the X-axis of the computed coordinate system.
        """
        return _fusion.JointGeometry__get_primaryAxisVector(self)

    def _get_secondaryAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Returns the direction of the secondary axis that's been calculated for this joint geometry.
        Conceptually, this is the Y-axis of the computed coordinate system.
        """
        return _fusion.JointGeometry__get_secondaryAxisVector(self)

    def _get_thirdAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Returns the direction of the third axis that's been calculated for this joint geometry.
        Conceptually, this is the Z-axis of the computed coordinate system.
        """
        return _fusion.JointGeometry__get_thirdAxisVector(self)

    def _get_planeOne(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the first plane for joint geometry that is defined between two planes. Returns null in all other cases."""
        return _fusion.JointGeometry__get_planeOne(self)

    def _get_planeTwo(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the second plane for joint geometry that is defined between two planes. Returns null in all other cases."""
        return _fusion.JointGeometry__get_planeTwo(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.JointGeometry__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.JointGeometry__get_isValid(self)

# Register JointGeometry in _fusion:
_fusion.JointGeometry_swigregister(JointGeometry)

def JointGeometry_classType() -> "char const *":
    return _fusion.JointGeometry_classType()

def JointGeometry_createByPlanarFace(face: "BRepFace", edge: "BRepEdge", keyPointType: "JointKeyPointTypes") -> "adsk::core::Ptr< adsk::fusion::BRepFace > const &, adsk::core::Ptr< adsk::fusion::BRepEdge > const &":
    return _fusion.JointGeometry_createByPlanarFace(face, edge, keyPointType)

def JointGeometry_createByNonPlanarFace(face: "BRepFace", keyPointType: "JointKeyPointTypes") -> "adsk::core::Ptr< adsk::fusion::BRepFace > const &":
    return _fusion.JointGeometry_createByNonPlanarFace(face, keyPointType)

def JointGeometry_createByProfile(profile: "Profile", sketchCurve: "SketchCurve", keyPointType: "JointKeyPointTypes") -> "adsk::core::Ptr< adsk::fusion::Profile > const &, adsk::core::Ptr< adsk::fusion::SketchCurve > const &":
    return _fusion.JointGeometry_createByProfile(profile, sketchCurve, keyPointType)

def JointGeometry_createByCurve(curve: "Base", keyPointType: "JointKeyPointTypes") -> "adsk::core::Ptr< adsk::fusion::JointGeometry >":
    return _fusion.JointGeometry_createByCurve(curve, keyPointType)

def JointGeometry_createByPoint(point: "Base") -> "adsk::core::Ptr< adsk::fusion::JointGeometry >":
    return _fusion.JointGeometry_createByPoint(point)

def JointGeometry_createByBetweenTwoPlanes(planeOne: "Base", planeTwo: "Base", entityOne: "Base", entityTwo: "Base", keyPointType: "JointKeyPointTypes") -> "adsk::core::Ptr< adsk::fusion::JointGeometry >":
    return _fusion.JointGeometry_createByBetweenTwoPlanes(planeOne, planeTwo, entityOne, entityTwo, keyPointType)


JointGeometry.geometryType = property(JointGeometry._get_geometryType, doc="Returns the type of geometry this JointGeometry object represents.")


JointGeometry.keyPointType = property(JointGeometry._get_keyPointType, doc="Returns the keypoint type this JointGeometry is using.")


JointGeometry.entityOne = property(JointGeometry._get_entityOne, doc="The first entity that's defining this joint geometry. This can be various types of geometry depending\non how this joint geometry is defined. The geometryType property indicates how this joint geometry is\ndefined a provides a clue about the type of geometry to expect back from this property.")


JointGeometry.entityTwo = property(JointGeometry._get_entityTwo, doc="This is the second entity that defines this joint geometry. This isn't used for all joint geometry types\nand will return null in the cases where it's not used. A second geometry is used in the case where the geometryType\nproperty returns JointProfileGeometry, JointPlanarBRepFaceGeometry, JointBetweenTwoFacesGeometry or JointByTwoEdgeIntersectionGeometry.")


JointGeometry.origin = property(JointGeometry._get_origin, doc="Returns the origin point that's been calculated for this joint geometry.")


JointGeometry.primaryAxisVector = property(JointGeometry._get_primaryAxisVector, doc="Returns the direction of the primary axis that's been calculated for this joint geometry.\nConceptually, this is the X-axis of the computed coordinate system.")


JointGeometry.secondaryAxisVector = property(JointGeometry._get_secondaryAxisVector, doc="Returns the direction of the secondary axis that's been calculated for this joint geometry.\nConceptually, this is the Y-axis of the computed coordinate system.")


JointGeometry.thirdAxisVector = property(JointGeometry._get_thirdAxisVector, doc="Returns the direction of the third axis that's been calculated for this joint geometry.\nConceptually, this is the Z-axis of the computed coordinate system.")


JointGeometry.planeOne = property(JointGeometry._get_planeOne, doc="Returns the first plane for joint geometry that is defined between two planes. Returns null in all other cases.")


JointGeometry.planeTwo = property(JointGeometry._get_planeTwo, doc="Returns the second plane for joint geometry that is defined between two planes. Returns null in all other cases.")


JointGeometry.cast = lambda arg: arg if isinstance(arg, JointGeometry) else None

class JointInput(Base):
    r"""
    Defines all of the information required to create a new joint. This object provides
    equivalent functionality to the Joint command dialog in that it gathers the required
    information to create a joint.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::JointInput *":
        return _fusion.JointInput___deref__(self)

    def __eq__(self, rhs: "JointInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.JointInput___eq__(self, rhs)


    def __ne__(self, rhs: "JointInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.JointInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.JointInput_classType()
    __swig_destroy__ = _fusion.delete_JointInput

    def _get_geometryOrOriginOne(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets and sets the first JointGeometry or JointOrigin for this joint."""
        return _fusion.JointInput__get_geometryOrOriginOne(self)

    def _set_geometryOrOriginOne(self, value: "Base") -> "bool":
        r"""Gets and sets the first JointGeometry or JointOrigin for this joint."""
        return _fusion.JointInput__set_geometryOrOriginOne(self, value)

    def _get_geometryOrOriginTwo(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets and sets the second JointGeometry or JointOrigin for this joint."""
        return _fusion.JointInput__get_geometryOrOriginTwo(self)

    def _set_geometryOrOriginTwo(self, value: "Base") -> "bool":
        r"""Gets and sets the second JointGeometry or JointOrigin for this joint."""
        return _fusion.JointInput__set_geometryOrOriginTwo(self, value)

    def _get_angle(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Specifies the angle between two input geometries. This is effectively the
        angle between the two primary axes of the input geometries. When a new
        JointInput object is created, this value defaults to zero. When the joint
        is created this will become the value of the parameter that controls the joint angle.
        When using a real value to define the angle, the value is in radians. When
        using a string the expression is evaluated using the document default units for angles.
        """
        return _fusion.JointInput__get_angle(self)

    def _set_angle(self, value: "ValueInput") -> "bool":
        r"""
        Specifies the angle between two input geometries. This is effectively the
        angle between the two primary axes of the input geometries. When a new
        JointInput object is created, this value defaults to zero. When the joint
        is created this will become the value of the parameter that controls the joint angle.
        When using a real value to define the angle, the value is in radians. When
        using a string the expression is evaluated using the document default units for angles.
        """
        return _fusion.JointInput__set_angle(self, value)

    def _get_offset(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Specifies the offset between two input geometries. This is effectively the
        offset distance between the two planes defined by the primary and secondary axes
        of the input geometries. When a new JointInput object is created, this value defaults to zero. 
        When the joint is created this will become the value of the parameter that controls the joint offset.
        When using a real value to define the offset, the value is in centimeters. When
        using a string the expression is evaluated using the document default units for distance.
        """
        return _fusion.JointInput__get_offset(self)

    def _set_offset(self, value: "ValueInput") -> "bool":
        r"""
        Specifies the offset between two input geometries. This is effectively the
        offset distance between the two planes defined by the primary and secondary axes
        of the input geometries. When a new JointInput object is created, this value defaults to zero. 
        When the joint is created this will become the value of the parameter that controls the joint offset.
        When using a real value to define the offset, the value is in centimeters. When
        using a string the expression is evaluated using the document default units for distance.
        """
        return _fusion.JointInput__set_offset(self, value)

    def _get_isFlipped(self) -> "bool":
        r"""
        Gets and sets if the joint direction is flipped or not. This is effectively
        specifying if the third axis of the two input geometries is facing (false) or
        opposed (true).
        """
        return _fusion.JointInput__get_isFlipped(self)

    def _set_isFlipped(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the joint direction is flipped or not. This is effectively
        specifying if the third axis of the two input geometries is facing (false) or
        opposed (true).
        """
        return _fusion.JointInput__set_isFlipped(self, value)

    def setAsRigidJointMotion(self) -> "bool":
        r"""
        Defines the relationship between the two joint geometries as a rigid joint. 
        Returns true if successful.
        """
        return _fusion.JointInput_setAsRigidJointMotion(self)

    def setAsRevoluteJointMotion(self, *args) -> "bool":
        r"""
        Defines the relationship between the two joint geometries as a revolute joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived
        from. 
        Returns true if the operation was successful.
        """
        return _fusion.JointInput_setAsRevoluteJointMotion(self, *args)

    def setAsSliderJointMotion(self, *args) -> "bool":
        r"""
        Defines the relationship between the two joint geometries as a slider joint. 
        sliderDirection : Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the 
        customSliderDirectionEntity argument must also be provided. 
        customSliderDirectionEntity : If the sliderDirection is CustomJointDirection this argument is used to specify the entity that defines
        the custom slider direction. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.JointInput_setAsSliderJointMotion(self, *args)

    def setAsCylindricalJointMotion(self, *args) -> "bool":
        r"""
        Defines the relationship between the two joint geometries as a cylindrical joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived
        from. 
        Returns true if the operation was successful.
        """
        return _fusion.JointInput_setAsCylindricalJointMotion(self, *args)

    def setAsPinSlotJointMotion(self, *args) -> "bool":
        r"""
        Defines the relationship between the two joint geometries as a pin-slot joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        slideDirection : Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the 
        customSlideDirectionEntity argument must also be provided. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived 
        customSlideDirectionEntity : If the slideDirection is CustomJointDirection this argument is used to specify the entity that defines
        the custom slide direction. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.JointInput_setAsPinSlotJointMotion(self, *args)

    def setAsPlanarJointMotion(self, *args) -> "bool":
        r"""
        Defines the relationship between the two joint geometries as a planar joint. 
        normalDirection : Defines the direction of the normal of the single degree of rotation.
        This can be set to XAxisJointDirection, YAxisJointDirection, ZAxisJointDirection, 
        or CustomJointDirection. If set to CustomJointDirection then the customNormalDirectionEntity
        argument must also be provided. 
        customNormalDirectionEntity : If the normalDirection is CustomJointDirection this argument is used to specify the entity that defines
        the direction of the normal. This can be several types of entities that can define a direction. 
        customPrimarySlideDirection : This arguments defines the direction of the primary slide direction. A default primary slide direction 
        is automatically chosen and will be used if this argument is not provided or is null. The secondary slide
        direction is automatically inferred from the normal and primary slide directions. 
        Returns true if the operation was successful.
        """
        return _fusion.JointInput_setAsPlanarJointMotion(self, *args)

    def setAsBallJointMotion(self, *args) -> "bool":
        r"""
        Defines the relationship between the two joint geometries as a ball joint. 
        pitchDirection : Defines the direction the pitch angle is measured from. This can be ZAxisJointDirection or CustomJointDirection. If
        CustomJointDirection is specified then you must also provide a value for the customPitchDirection argument. 
        yawDirection : Defines the direction the yaw is measured from. This can be XAxisJointDirection or CustomJointDirection. If
        CustomJointDirection is specified then you must also provide a value for the customYawDirection argument. 
        customPitchDirection : If the pitchDirection argument is customPitchDirection this argument is used to define the direction the pitch
        angel is measured from. This can be several types of entities that can define a direction. 
        customYawDirection : If the yawDirection argument is customPitchDirection this argument is used to define the direction the yaw
        angel is measured from. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.JointInput_setAsBallJointMotion(self, *args)

    def _get_jointMotion(self) -> "adsk::core::Ptr< adsk::fusion::JointMotion >":
        r"""Returns an object derived from JointMotion that defines how the motion between the two joint geometries is defined."""
        return _fusion.JointInput__get_jointMotion(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.JointInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.JointInput__get_isValid(self)

# Register JointInput in _fusion:
_fusion.JointInput_swigregister(JointInput)

def JointInput_classType() -> "char const *":
    return _fusion.JointInput_classType()


JointInput.geometryOrOriginOne = property(JointInput._get_geometryOrOriginOne, JointInput._set_geometryOrOriginOne, doc="Gets and sets the first JointGeometry or JointOrigin for this joint.")


JointInput.geometryOrOriginTwo = property(JointInput._get_geometryOrOriginTwo, JointInput._set_geometryOrOriginTwo, doc="Gets and sets the second JointGeometry or JointOrigin for this joint.")


JointInput.angle = property(JointInput._get_angle, JointInput._set_angle, doc="Specifies the angle between two input geometries. This is effectively the\nangle between the two primary axes of the input geometries. When a new\nJointInput object is created, this value defaults to zero. When the joint\nis created this will become the value of the parameter that controls the joint angle.\nWhen using a real value to define the angle, the value is in radians. When\nusing a string the expression is evaluated using the document default units for angles.")


JointInput.offset = property(JointInput._get_offset, JointInput._set_offset, doc="Specifies the offset between two input geometries. This is effectively the\noffset distance between the two planes defined by the primary and secondary axes\nof the input geometries. When a new JointInput object is created, this value defaults to zero.\nWhen the joint is created this will become the value of the parameter that controls the joint offset.\nWhen using a real value to define the offset, the value is in centimeters. When\nusing a string the expression is evaluated using the document default units for distance.")


JointInput.isFlipped = property(JointInput._get_isFlipped, JointInput._set_isFlipped, doc="Gets and sets if the joint direction is flipped or not. This is effectively\nspecifying if the third axis of the two input geometries is facing (false) or\nopposed (true).")


JointInput.jointMotion = property(JointInput._get_jointMotion, doc="Returns an object derived from JointMotion that defines how the motion between the two joint geometries is defined.")


JointInput.cast = lambda arg: arg if isinstance(arg, JointInput) else None

class JointLimits(Base):
    r"""Used to define limits for the range of motion of a joint."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::JointLimits *":
        return _fusion.JointLimits___deref__(self)

    def __eq__(self, rhs: "JointLimits") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.JointLimits___eq__(self, rhs)


    def __ne__(self, rhs: "JointLimits") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.JointLimits___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.JointLimits_classType()
    __swig_destroy__ = _fusion.delete_JointLimits

    def _get_minimumValue(self) -> "double":
        r"""
        The minimum value of the value. This is in either centimeters
        or radians depending on if the joint value this is associated with
        defines a distance or an angle.
        """
        return _fusion.JointLimits__get_minimumValue(self)

    def _set_minimumValue(self, value: "double") -> "bool":
        r"""
        The minimum value of the value. This is in either centimeters
        or radians depending on if the joint value this is associated with
        defines a distance or an angle.
        """
        return _fusion.JointLimits__set_minimumValue(self, value)

    def _get_maximumValue(self) -> "double":
        r"""
        The maximum value of the value. This is in either centimeters
        or radians depending on if the joint value this is associated with
        defines a distance or an angle.
        """
        return _fusion.JointLimits__get_maximumValue(self)

    def _set_maximumValue(self, value: "double") -> "bool":
        r"""
        The maximum value of the value. This is in either centimeters
        or radians depending on if the joint value this is associated with
        defines a distance or an angle.
        """
        return _fusion.JointLimits__set_maximumValue(self, value)

    def _get_restValue(self) -> "double":
        r"""
        The resting state value. This is in either centimeters
        or radians depending on if the joint value this is associated with
        defines a distance or an angle.
        """
        return _fusion.JointLimits__get_restValue(self)

    def _set_restValue(self, value: "double") -> "bool":
        r"""
        The resting state value. This is in either centimeters
        or radians depending on if the joint value this is associated with
        defines a distance or an angle.
        """
        return _fusion.JointLimits__set_restValue(self, value)

    def _get_isMinimumValueEnabled(self) -> "bool":
        r"""Gets and sets whether the minimum joint limit is enabled or not."""
        return _fusion.JointLimits__get_isMinimumValueEnabled(self)

    def _set_isMinimumValueEnabled(self, value: "bool") -> "bool":
        r"""Gets and sets whether the minimum joint limit is enabled or not."""
        return _fusion.JointLimits__set_isMinimumValueEnabled(self, value)

    def _get_isMaximumValueEnabled(self) -> "bool":
        r"""Gets and sets whether the maximum joint limit is enabled or not."""
        return _fusion.JointLimits__get_isMaximumValueEnabled(self)

    def _set_isMaximumValueEnabled(self, value: "bool") -> "bool":
        r"""Gets and sets whether the maximum joint limit is enabled or not."""
        return _fusion.JointLimits__set_isMaximumValueEnabled(self, value)

    def _get_isRestValueEnabled(self) -> "bool":
        r"""Gets and sets whether the resting joint value is enabled or not."""
        return _fusion.JointLimits__get_isRestValueEnabled(self)

    def _set_isRestValueEnabled(self, value: "bool") -> "bool":
        r"""Gets and sets whether the resting joint value is enabled or not."""
        return _fusion.JointLimits__set_isRestValueEnabled(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.JointLimits__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.JointLimits__get_isValid(self)

# Register JointLimits in _fusion:
_fusion.JointLimits_swigregister(JointLimits)

def JointLimits_classType() -> "char const *":
    return _fusion.JointLimits_classType()


JointLimits.minimumValue = property(JointLimits._get_minimumValue, JointLimits._set_minimumValue, doc="The minimum value of the value. This is in either centimeters\nor radians depending on if the joint value this is associated with\ndefines a distance or an angle.")


JointLimits.maximumValue = property(JointLimits._get_maximumValue, JointLimits._set_maximumValue, doc="The maximum value of the value. This is in either centimeters\nor radians depending on if the joint value this is associated with\ndefines a distance or an angle.")


JointLimits.restValue = property(JointLimits._get_restValue, JointLimits._set_restValue, doc="The resting state value. This is in either centimeters\nor radians depending on if the joint value this is associated with\ndefines a distance or an angle.")


JointLimits.isMinimumValueEnabled = property(JointLimits._get_isMinimumValueEnabled, JointLimits._set_isMinimumValueEnabled, doc="Gets and sets whether the minimum joint limit is enabled or not.")


JointLimits.isMaximumValueEnabled = property(JointLimits._get_isMaximumValueEnabled, JointLimits._set_isMaximumValueEnabled, doc="Gets and sets whether the maximum joint limit is enabled or not.")


JointLimits.isRestValueEnabled = property(JointLimits._get_isRestValueEnabled, JointLimits._set_isRestValueEnabled, doc="Gets and sets whether the resting joint value is enabled or not.")


JointLimits.cast = lambda arg: arg if isinstance(arg, JointLimits) else None

class JointList(Base):
    r"""A list of joints."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::JointList *":
        return _fusion.JointList___deref__(self)

    def __eq__(self, rhs: "JointList") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.JointList___eq__(self, rhs)


    def __ne__(self, rhs: "JointList") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.JointList___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.JointList___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::Joint >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.JointList___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.JointList_classType()
    __swig_destroy__ = _fusion.delete_JointList

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::Joint >":
        r"""
        Function that returns the specified joint using an index into the list. 
        index : The index of the item within the list to return. The first item in the list has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.JointList_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::Joint >":
        r"""
        Function that returns the specified joint using a name. 
        name : The name of the item within the list to return. 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.JointList_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""Returns number of joints in the list."""
        return _fusion.JointList__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.JointList__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.JointList__get_isValid(self)

# Register JointList in _fusion:
_fusion.JointList_swigregister(JointList)

def JointList_classType() -> "char const *":
    return _fusion.JointList_classType()


JointList.count = property(JointList._get_count, doc="Returns number of joints in the list.")


JointList.cast = lambda arg: arg if isinstance(arg, JointList) else None

class JointMotion(Base):
    r"""
    The base class for the classes that represent all of the
    various joint types.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::JointMotion *":
        return _fusion.JointMotion___deref__(self)

    def __eq__(self, rhs: "JointMotion") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.JointMotion___eq__(self, rhs)


    def __ne__(self, rhs: "JointMotion") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.JointMotion___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.JointMotion_classType()
    __swig_destroy__ = _fusion.delete_JointMotion

    def _get_jointType(self) -> "adsk::fusion::JointTypes":
        r"""Returns an enum value indicating the type of joint this joint represents."""
        return _fusion.JointMotion__get_jointType(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.JointMotion__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.JointMotion__get_isValid(self)

# Register JointMotion in _fusion:
_fusion.JointMotion_swigregister(JointMotion)

def JointMotion_classType() -> "char const *":
    return _fusion.JointMotion_classType()


JointMotion.jointType = property(JointMotion._get_jointType, doc="Returns an enum value indicating the type of joint this joint represents.")


JointMotion.cast = lambda arg: arg if isinstance(arg, JointMotion) else None

class JointOrigin(Base):
    r"""Represents an existing joint origin in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::JointOrigin *":
        return _fusion.JointOrigin___deref__(self)

    def __eq__(self, rhs: "JointOrigin") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.JointOrigin___eq__(self, rhs)


    def __ne__(self, rhs: "JointOrigin") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.JointOrigin___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.JointOrigin_classType()
    __swig_destroy__ = _fusion.delete_JointOrigin

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this joint origin."""
        return _fusion.JointOrigin__get_parentComponent(self)

    def _get_name(self) -> "std::string":
        r"""Gets and sets the name of this joint origin. This is the name seen by the user in the timeline."""
        return _fusion.JointOrigin__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the name of this joint origin. This is the name seen by the user in the timeline."""
        return _fusion.JointOrigin__set_name(self, value)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::fusion::JointGeometry >":
        r"""
        Gets and sets the joint geometry for this joint origin input. This
        defines the location of the joint origin.
        """
        return _fusion.JointOrigin__get_geometry(self)

    def _set_geometry(self, value: "JointGeometry") -> "bool":
        r"""
        Gets and sets the joint geometry for this joint origin input. This
        defines the location of the joint origin.
        """
        return _fusion.JointOrigin__set_geometry(self, value)

    def _get_Angle(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the parameter that controls the angle. The value can be changed
        using the functionality of the returned ModelParameter object.
        """
        return _fusion.JointOrigin__get_Angle(self)

    def _get_OffsetX(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the parameter that controls the X offset direction. The value can be changed
        using the functionality of the returned ModelParameter object.
        """
        return _fusion.JointOrigin__get_OffsetX(self)

    def _get_OffsetY(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the parameter that controls the Y offset direction. The value can be changed
        using the functionality of the returned ModelParameter object.
        """
        return _fusion.JointOrigin__get_OffsetY(self)

    def _get_OffsetZ(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the parameter that controls the Z offset direction. The value can be changed
        using the functionality of the returned ModelParameter object.
        """
        return _fusion.JointOrigin__get_OffsetZ(self)

    def _get_isFlipped(self) -> "bool":
        r"""Gets and sets if the joint origin direction is flipped or not."""
        return _fusion.JointOrigin__get_isFlipped(self)

    def _set_isFlipped(self, value: "bool") -> "bool":
        r"""Gets and sets if the joint origin direction is flipped or not."""
        return _fusion.JointOrigin__set_isFlipped(self, value)

    def _get_XAxisEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the entity that defines the X axis direction. This defaults
        to null meaning the X axis is inferred from the input geometry.
        """
        return _fusion.JointOrigin__get_XAxisEntity(self)

    def _set_XAxisEntity(self, value: "Base") -> "bool":
        r"""
        Gets and sets the entity that defines the X axis direction. This defaults
        to null meaning the X axis is inferred from the input geometry.
        """
        return _fusion.JointOrigin__set_XAxisEntity(self, value)

    def _get_ZAxisEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the entity that defines the Z axis direction. This defaults
        to null meaning the Z axis is inferred from the input geometry.
        """
        return _fusion.JointOrigin__get_ZAxisEntity(self)

    def _set_ZAxisEntity(self, value: "Base") -> "bool":
        r"""
        Gets and sets the entity that defines the Z axis direction. This defaults
        to null meaning the Z axis is inferred from the input geometry.
        """
        return _fusion.JointOrigin__set_ZAxisEntity(self, value)

    def _get_primaryAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Returns the direction of the primary axis that's been calculated for this joint origin."""
        return _fusion.JointOrigin__get_primaryAxisVector(self)

    def _get_secondaryAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Returns the direction of the secondary axis that's been calculated for this joint origin."""
        return _fusion.JointOrigin__get_secondaryAxisVector(self)

    def _get_thirdAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Returns the direction of the third axis that's been calculated for this joint origin."""
        return _fusion.JointOrigin__get_thirdAxisVector(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this joint origin. 
        Returns true if successful.
        """
        return _fusion.JointOrigin_deleteMe(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this joint origin."""
        return _fusion.JointOrigin__get_timelineObject(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::JointOrigin >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.JointOrigin__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::JointOrigin >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.JointOrigin_createForAssemblyContext(self, occurrence)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.JointOrigin__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this joint origin."""
        return _fusion.JointOrigin__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the JointOrigin object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same joint origin.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.JointOrigin__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.JointOrigin__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.JointOrigin__get_isValid(self)

# Register JointOrigin in _fusion:
_fusion.JointOrigin_swigregister(JointOrigin)

def JointOrigin_classType() -> "char const *":
    return _fusion.JointOrigin_classType()


JointOrigin.parentComponent = property(JointOrigin._get_parentComponent, doc="Returns the parent component that owns this joint origin.")


JointOrigin.name = property(JointOrigin._get_name, JointOrigin._set_name, doc="Gets and sets the name of this joint origin. This is the name seen by the user in the timeline.")


JointOrigin.geometry = property(JointOrigin._get_geometry, JointOrigin._set_geometry, doc="Gets and sets the joint geometry for this joint origin input. This\ndefines the location of the joint origin.")


JointOrigin.angle = property(JointOrigin._get_Angle, doc="Gets the parameter that controls the angle. The value can be changed\nusing the functionality of the returned ModelParameter object.")


JointOrigin.offsetX = property(JointOrigin._get_OffsetX, doc="Gets the parameter that controls the X offset direction. The value can be changed\nusing the functionality of the returned ModelParameter object.")


JointOrigin.offsetY = property(JointOrigin._get_OffsetY, doc="Gets the parameter that controls the Y offset direction. The value can be changed\nusing the functionality of the returned ModelParameter object.")


JointOrigin.offsetZ = property(JointOrigin._get_OffsetZ, doc="Gets the parameter that controls the Z offset direction. The value can be changed\nusing the functionality of the returned ModelParameter object.")


JointOrigin.isFlipped = property(JointOrigin._get_isFlipped, JointOrigin._set_isFlipped, doc="Gets and sets if the joint origin direction is flipped or not.")


JointOrigin.xAxisEntity = property(JointOrigin._get_XAxisEntity, JointOrigin._set_XAxisEntity, doc="Gets and sets the entity that defines the X axis direction. This defaults\nto null meaning the X axis is inferred from the input geometry.")


JointOrigin.zAxisEntity = property(JointOrigin._get_ZAxisEntity, JointOrigin._set_ZAxisEntity, doc="Gets and sets the entity that defines the Z axis direction. This defaults\nto null meaning the Z axis is inferred from the input geometry.")


JointOrigin.primaryAxisVector = property(JointOrigin._get_primaryAxisVector, doc="Returns the direction of the primary axis that's been calculated for this joint origin.")


JointOrigin.secondaryAxisVector = property(JointOrigin._get_secondaryAxisVector, doc="Returns the direction of the secondary axis that's been calculated for this joint origin.")


JointOrigin.thirdAxisVector = property(JointOrigin._get_thirdAxisVector, doc="Returns the direction of the third axis that's been calculated for this joint origin.")


JointOrigin.timelineObject = property(JointOrigin._get_timelineObject, doc="Returns the timeline object associated with this joint origin.")


JointOrigin.nativeObject = property(JointOrigin._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


JointOrigin.assemblyContext = property(JointOrigin._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")


JointOrigin.attributes = property(JointOrigin._get_attributes, doc="Returns the collection of attributes associated with this joint origin.")


JointOrigin.entityToken = property(JointOrigin._get_entityToken, doc="Returns a token for the JointOrigin object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same joint origin.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.")


JointOrigin.cast = lambda arg: arg if isinstance(arg, JointOrigin) else None

class JointOriginInput(Base):
    r"""
    Defines all of the information required to create a new joint origin. This object provides
    equivalent functionality to the Joint Origin command dialog in that it gathers the required
    information to create a joint origin.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::JointOriginInput *":
        return _fusion.JointOriginInput___deref__(self)

    def __eq__(self, rhs: "JointOriginInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.JointOriginInput___eq__(self, rhs)


    def __ne__(self, rhs: "JointOriginInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.JointOriginInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.JointOriginInput_classType()
    __swig_destroy__ = _fusion.delete_JointOriginInput

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::fusion::JointGeometry >":
        r"""
        Gets and sets the joint geometry for this joint origin input. This
        defines the location of the joint origin.
        """
        return _fusion.JointOriginInput__get_geometry(self)

    def _set_geometry(self, value: "JointGeometry") -> "bool":
        r"""
        Gets and sets the joint geometry for this joint origin input. This
        defines the location of the joint origin.
        """
        return _fusion.JointOriginInput__set_geometry(self, value)

    def _get_Angle(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Gets and sets the value that defines the angle for the joint origin. This defaults to zero
        if it's not specified. The value defines an angle and if the ValueInput is defined using
        the createByReal method the value is assumed to be radians.
        """
        return _fusion.JointOriginInput__get_Angle(self)

    def _set_Angle(self, value: "ValueInput") -> "bool":
        r"""
        Gets and sets the value that defines the angle for the joint origin. This defaults to zero
        if it's not specified. The value defines an angle and if the ValueInput is defined using
        the createByReal method the value is assumed to be radians.
        """
        return _fusion.JointOriginInput__set_Angle(self, value)

    def _get_OffsetX(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Gets and sets the value that defines the X offset direction. This defaults to zero
        if it's not specified. The value defines a distance and if the ValueInput is defined using
        the createByReal method the value is assumed to be centimeters.
        """
        return _fusion.JointOriginInput__get_OffsetX(self)

    def _set_OffsetX(self, value: "ValueInput") -> "bool":
        r"""
        Gets and sets the value that defines the X offset direction. This defaults to zero
        if it's not specified. The value defines a distance and if the ValueInput is defined using
        the createByReal method the value is assumed to be centimeters.
        """
        return _fusion.JointOriginInput__set_OffsetX(self, value)

    def _get_OffsetY(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Gets and sets the value that defines the Y offset direction. This defaults to zero
        if it's not specified. The value defines a distance and if the ValueInput is defined using
        the createByReal method the value is assumed to be centimeters.
        """
        return _fusion.JointOriginInput__get_OffsetY(self)

    def _set_OffsetY(self, value: "ValueInput") -> "bool":
        r"""
        Gets and sets the value that defines the Y offset direction. This defaults to zero
        if it's not specified. The value defines a distance and if the ValueInput is defined using
        the createByReal method the value is assumed to be centimeters.
        """
        return _fusion.JointOriginInput__set_OffsetY(self, value)

    def _get_OffsetZ(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Gets and sets the value that defines the Z offset direction. This defaults to zero
        if it's not specified. The value defines a distance and if the ValueInput is defined using
        the createByReal method the value is assumed to be centimeters.
        """
        return _fusion.JointOriginInput__get_OffsetZ(self)

    def _set_OffsetZ(self, value: "ValueInput") -> "bool":
        r"""
        Gets and sets the value that defines the Z offset direction. This defaults to zero
        if it's not specified. The value defines a distance and if the ValueInput is defined using
        the createByReal method the value is assumed to be centimeters.
        """
        return _fusion.JointOriginInput__set_OffsetZ(self, value)

    def _get_isFlipped(self) -> "bool":
        r"""Gets and sets if the joint origin direction is flipped or not."""
        return _fusion.JointOriginInput__get_isFlipped(self)

    def _set_isFlipped(self, value: "bool") -> "bool":
        r"""Gets and sets if the joint origin direction is flipped or not."""
        return _fusion.JointOriginInput__set_isFlipped(self, value)

    def _get_XAxisEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the entity that defines the X axis direction. This defaults
        to null meaning the X axis is inferred from the input geometry.
        """
        return _fusion.JointOriginInput__get_XAxisEntity(self)

    def _set_XAxisEntity(self, value: "Base") -> "bool":
        r"""
        Gets and sets the entity that defines the X axis direction. This defaults
        to null meaning the X axis is inferred from the input geometry.
        """
        return _fusion.JointOriginInput__set_XAxisEntity(self, value)

    def _get_ZAxisEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the entity that defines the Z axis direction. This defaults
        to null meaning the Z axis is inferred from the input geometry.
        """
        return _fusion.JointOriginInput__get_ZAxisEntity(self)

    def _set_ZAxisEntity(self, value: "Base") -> "bool":
        r"""
        Gets and sets the entity that defines the Z axis direction. This defaults
        to null meaning the Z axis is inferred from the input geometry.
        """
        return _fusion.JointOriginInput__set_ZAxisEntity(self, value)

    def _get_primaryAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Returns the direction of the primary axis that's been calculated for this joint origin."""
        return _fusion.JointOriginInput__get_primaryAxisVector(self)

    def _get_secondaryAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Returns the direction of the secondary axis that's been calculated for this joint origin."""
        return _fusion.JointOriginInput__get_secondaryAxisVector(self)

    def _get_thirdAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Returns the direction of the third axis that's been calculated for this joint origin."""
        return _fusion.JointOriginInput__get_thirdAxisVector(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.JointOriginInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.JointOriginInput__get_isValid(self)

# Register JointOriginInput in _fusion:
_fusion.JointOriginInput_swigregister(JointOriginInput)

def JointOriginInput_classType() -> "char const *":
    return _fusion.JointOriginInput_classType()


JointOriginInput.geometry = property(JointOriginInput._get_geometry, JointOriginInput._set_geometry, doc="Gets and sets the joint geometry for this joint origin input. This\ndefines the location of the joint origin.")


JointOriginInput.angle = property(JointOriginInput._get_Angle, JointOriginInput._set_Angle, doc="Gets and sets the value that defines the angle for the joint origin. This defaults to zero\nif it's not specified. The value defines an angle and if the ValueInput is defined using\nthe createByReal method the value is assumed to be radians.")


JointOriginInput.offsetX = property(JointOriginInput._get_OffsetX, JointOriginInput._set_OffsetX, doc="Gets and sets the value that defines the X offset direction. This defaults to zero\nif it's not specified. The value defines a distance and if the ValueInput is defined using\nthe createByReal method the value is assumed to be centimeters.")


JointOriginInput.offsetY = property(JointOriginInput._get_OffsetY, JointOriginInput._set_OffsetY, doc="Gets and sets the value that defines the Y offset direction. This defaults to zero\nif it's not specified. The value defines a distance and if the ValueInput is defined using\nthe createByReal method the value is assumed to be centimeters.")


JointOriginInput.offsetZ = property(JointOriginInput._get_OffsetZ, JointOriginInput._set_OffsetZ, doc="Gets and sets the value that defines the Z offset direction. This defaults to zero\nif it's not specified. The value defines a distance and if the ValueInput is defined using\nthe createByReal method the value is assumed to be centimeters.")


JointOriginInput.isFlipped = property(JointOriginInput._get_isFlipped, JointOriginInput._set_isFlipped, doc="Gets and sets if the joint origin direction is flipped or not.")


JointOriginInput.xAxisEntity = property(JointOriginInput._get_XAxisEntity, JointOriginInput._set_XAxisEntity, doc="Gets and sets the entity that defines the X axis direction. This defaults\nto null meaning the X axis is inferred from the input geometry.")


JointOriginInput.zAxisEntity = property(JointOriginInput._get_ZAxisEntity, JointOriginInput._set_ZAxisEntity, doc="Gets and sets the entity that defines the Z axis direction. This defaults\nto null meaning the Z axis is inferred from the input geometry.")


JointOriginInput.primaryAxisVector = property(JointOriginInput._get_primaryAxisVector, doc="Returns the direction of the primary axis that's been calculated for this joint origin.")


JointOriginInput.secondaryAxisVector = property(JointOriginInput._get_secondaryAxisVector, doc="Returns the direction of the secondary axis that's been calculated for this joint origin.")


JointOriginInput.thirdAxisVector = property(JointOriginInput._get_thirdAxisVector, doc="Returns the direction of the third axis that's been calculated for this joint origin.")


JointOriginInput.cast = lambda arg: arg if isinstance(arg, JointOriginInput) else None

class JointOriginList(Base):
    r"""A list of joint origins."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::JointOriginList *":
        return _fusion.JointOriginList___deref__(self)

    def __eq__(self, rhs: "JointOriginList") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.JointOriginList___eq__(self, rhs)


    def __ne__(self, rhs: "JointOriginList") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.JointOriginList___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.JointOriginList___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::JointOrigin >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.JointOriginList___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.JointOriginList_classType()
    __swig_destroy__ = _fusion.delete_JointOriginList

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::JointOrigin >":
        r"""
        Function that returns the specified joint origin using an index into the list. 
        index : The index of the item within the list to return. The first item in the list has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.JointOriginList_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::JointOrigin >":
        r"""
        Function that returns the specified joint origin using a name. 
        name : The name of the item within the list to return. 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.JointOriginList_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""Returns number of joint origins in the list."""
        return _fusion.JointOriginList__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.JointOriginList__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.JointOriginList__get_isValid(self)

# Register JointOriginList in _fusion:
_fusion.JointOriginList_swigregister(JointOriginList)

def JointOriginList_classType() -> "char const *":
    return _fusion.JointOriginList_classType()


JointOriginList.count = property(JointOriginList._get_count, doc="Returns number of joint origins in the list.")


JointOriginList.cast = lambda arg: arg if isinstance(arg, JointOriginList) else None

class JointOrigins(Base):
    r"""
    The collection of joint origins in this component. This provides access to all existing 
    joint origins and supports the ability to create new joint origins.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::JointOrigins *":
        return _fusion.JointOrigins___deref__(self)

    def __eq__(self, rhs: "JointOrigins") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.JointOrigins___eq__(self, rhs)


    def __ne__(self, rhs: "JointOrigins") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.JointOrigins___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.JointOrigins___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::JointOrigin >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.JointOrigins___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.JointOrigins_classType()
    __swig_destroy__ = _fusion.delete_JointOrigins

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::JointOrigin >":
        r"""
        Function that returns the specified joint origin using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.JointOrigins_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::JointOrigin >":
        r"""
        Function that returns the specified joint origin using a name. 
        name : The name of the item within the collection to return. 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.JointOrigins_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""Returns number of joint origins in the collection."""
        return _fusion.JointOrigins__get_count(self)

    def createInput(self, geometry: "JointGeometry") -> "adsk::core::Ptr< adsk::fusion::JointOriginInput >":
        r"""
        Creates a JointOriginInput object which is used to collect all of the information 
        needed to create a simple joint origin. The creation of the input object takes the required
        input as the geometry argument and you can optionally use methods and properties on the created
        JointOriginInput to set other optional settings. The JointOrigin is created by calling the add 
        method of the JointOrigins object and passing it the JointOriginInput object. 
        geometry : A JointGeometry object that defines the geometry the joint origin will be created on. 
        Returns a JointOriginInput object if successfully created and null if it fails.
        """
        return _fusion.JointOrigins_createInput(self, geometry)

    def add(self, input: "JointOriginInput") -> "adsk::core::Ptr< adsk::fusion::JointOrigin >":
        r"""
        Create a new joint origin. 
        input : A JointOriginInput object that full defines all of the information needed to create a joint origin.
        You create a JointOriginInput by using the createInput method of the JointOrigins object. 
        Returns a JointOrigin object if successfully created and null if it fails.
        """
        return _fusion.JointOrigins_add(self, input)

    def _get_objectType(self) -> "char const *":
        return _fusion.JointOrigins__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.JointOrigins__get_isValid(self)

# Register JointOrigins in _fusion:
_fusion.JointOrigins_swigregister(JointOrigins)

def JointOrigins_classType() -> "char const *":
    return _fusion.JointOrigins_classType()


JointOrigins.count = property(JointOrigins._get_count, doc="Returns number of joint origins in the collection.")


JointOrigins.cast = lambda arg: arg if isinstance(arg, JointOrigins) else None

class Joints(Base):
    r"""
    The collection of joints in this component. This provides access to all existing joints
    and supports the ability to create new joints.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::Joints *":
        return _fusion.Joints___deref__(self)

    def __eq__(self, rhs: "Joints") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.Joints___eq__(self, rhs)


    def __ne__(self, rhs: "Joints") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.Joints___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.Joints___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::Joint >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.Joints___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.Joints_classType()
    __swig_destroy__ = _fusion.delete_Joints

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::Joint >":
        r"""
        Function that returns the specified joint using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.Joints_item(self, index)

    def createInput(self, geometryOrOriginOne: "Base", geometryOrOriginTwo: "Base") -> "adsk::core::Ptr< adsk::fusion::JointInput >":
        r"""
        Creates a JointInput object, which is the API equivalent to the Joint command dialog. You
        you use methods and properties on the returned class to set the desired options, similar to
        providing input and setting options in the Joint command dialog. Once the settings are defined
        you call the Joints.add method passing in the JointInput object to create the actual joint. 
        geometryOrOriginOne : A JointGeometry or JointOrigin object that defines the first set of geometry of the joint. 
        JointGeometry objects are created by using the various static methods on the JointGeometry class
        and JointOrigin objects are created through the JointOrigins object. 
        geometryOrOriginTwo : A JointGeometry or JointOrigin object that defines the second set of geometry of the joint. 
        JointGeometry objects are created by using the various static methods on the JointGeometry class
        and JointOrigin objects are created through the JointOrigins object. 
        Returns the JointInput object or null if the creation failed.
        """
        return _fusion.Joints_createInput(self, geometryOrOriginOne, geometryOrOriginTwo)

    def add(self, input: "JointInput") -> "adsk::core::Ptr< adsk::fusion::Joint >":
        r"""
        Creates a new joint. 
        input : The JointInput object that defines the geometry and various inputs that fully define a joint.
        A JointInput object is created using the Joints.createInput method. 
        Returns the newly created Joint or null in the case of failure.
        """
        return _fusion.Joints_add(self, input)

    def _get_count(self) -> "size_t":
        r"""Returns number of joints in the collection."""
        return _fusion.Joints__get_count(self)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::Joint >":
        r"""
        Function that returns the specified joint using a name. 
        name : The name of the item within the collection to return. 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.Joints_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.Joints__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.Joints__get_isValid(self)

# Register Joints in _fusion:
_fusion.Joints_swigregister(Joints)

def Joints_classType() -> "char const *":
    return _fusion.Joints_classType()


Joints.count = property(Joints._get_count, doc="Returns number of joints in the collection.")


Joints.cast = lambda arg: arg if isinstance(arg, Joints) else None

class LoftCenterLineOrRail(Base):
    r"""Represent a centerline or a single rail used by a loft feature."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::LoftCenterLineOrRail *":
        return _fusion.LoftCenterLineOrRail___deref__(self)

    def __eq__(self, rhs: "LoftCenterLineOrRail") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.LoftCenterLineOrRail___eq__(self, rhs)


    def __ne__(self, rhs: "LoftCenterLineOrRail") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.LoftCenterLineOrRail___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.LoftCenterLineOrRail_classType()
    __swig_destroy__ = _fusion.delete_LoftCenterLineOrRail

    def _get_isCenterLine(self) -> "bool":
        r"""Indicates if this object is a loft centerline (true) or a rail (false)."""
        return _fusion.LoftCenterLineOrRail__get_isCenterLine(self)

    def _get_entity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the entity that defines the centerline or rail. This can be a single sketch entity,
        a single BRepEdge, a Path, or a Profile.
        If this LoftCenterLineOrRail object is associated with a created feature, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.LoftCenterLineOrRail__get_entity(self)

    def _set_entity(self, value: "Base") -> "bool":
        r"""
        Gets and sets the entity that defines the centerline or rail. This can be a single sketch entity,
        a single BRepEdge, a Path, or a Profile.
        If this LoftCenterLineOrRail object is associated with a created feature, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.LoftCenterLineOrRail__set_entity(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the centerline or rail.
        If this LoftCenterLineOrRail object is associated with a created feature, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        Returns true if the operation was successful.
        """
        return _fusion.LoftCenterLineOrRail_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.LoftCenterLineOrRail__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.LoftCenterLineOrRail__get_isValid(self)

# Register LoftCenterLineOrRail in _fusion:
_fusion.LoftCenterLineOrRail_swigregister(LoftCenterLineOrRail)

def LoftCenterLineOrRail_classType() -> "char const *":
    return _fusion.LoftCenterLineOrRail_classType()


LoftCenterLineOrRail.isCenterLine = property(LoftCenterLineOrRail._get_isCenterLine, doc="Indicates if this object is a loft centerline (true) or a rail (false).")


LoftCenterLineOrRail.entity = property(LoftCenterLineOrRail._get_entity, LoftCenterLineOrRail._set_entity, doc="Gets and sets the entity that defines the centerline or rail. This can be a single sketch entity,\na single BRepEdge, a Path, or a Profile.\nIf this LoftCenterLineOrRail object is associated with a created feature, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


LoftCenterLineOrRail.cast = lambda arg: arg if isinstance(arg, LoftCenterLineOrRail) else None

class LoftCenterLineOrRails(Base):
    r"""Defines a single centerline or one or more rails for a loft feature."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::LoftCenterLineOrRails *":
        return _fusion.LoftCenterLineOrRails___deref__(self)

    def __eq__(self, rhs: "LoftCenterLineOrRails") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.LoftCenterLineOrRails___eq__(self, rhs)


    def __ne__(self, rhs: "LoftCenterLineOrRails") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.LoftCenterLineOrRails___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.LoftCenterLineOrRails___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::LoftCenterLineOrRail >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.LoftCenterLineOrRails___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.LoftCenterLineOrRails_classType()
    __swig_destroy__ = _fusion.delete_LoftCenterLineOrRails

    def _get_count(self) -> "size_t":
        r"""The number of centerlines or rails in the collection."""
        return _fusion.LoftCenterLineOrRails__get_count(self)

    def item(self, index: "int") -> "adsk::core::Ptr< adsk::fusion::LoftCenterLineOrRail >":
        r"""
        Function that returns the specified LoftCenterLineOrRail using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.LoftCenterLineOrRails_item(self, index)

    def _get_isCenterLine(self) -> "bool":
        r"""Indicates if a centerline or rails are currently defined."""
        return _fusion.LoftCenterLineOrRails__get_isCenterLine(self)

    def addCenterLine(self, entity: "Base") -> "adsk::core::Ptr< adsk::fusion::LoftCenterLineOrRail >":
        r"""
        Adds a centerline. A single centerline can be defined for a loft. If a centerline or rails have already
        been defined, they will be removed and the input will become the new single centerline.
        If this LoftCenterLineOrRails object is associated with a created feature, 
        entity : The entity that defines the center line. This can be a single sketch curve, a single BRepEdge, a Path consisting of
        connected B-Rep edges or sketch curves. 
        Returns the new LoftCenterLineOrRail object or null in the case of a failure.
        """
        return _fusion.LoftCenterLineOrRails_addCenterLine(self, entity)

    def addRail(self, entity: "Base") -> "adsk::core::Ptr< adsk::fusion::LoftCenterLineOrRail >":
        r"""
        Add a rail to the loft definition. Multiple rails can be defined, so each call of this
        method adds a new rail.
        If this LoftCenterLineOrRails object is associated with a created feature, you need to position the timeline 
        marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        entity : The entity that defines the rail. This can be a single sketch curve, a single BRepEdge, or a Path consisting of
        connected B-Rep edges or sketch curves. 
        Returns the new LoftCenterLineOrRail object or null in the case of a failure.
        """
        return _fusion.LoftCenterLineOrRails_addRail(self, entity)

    def _get_objectType(self) -> "char const *":
        return _fusion.LoftCenterLineOrRails__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.LoftCenterLineOrRails__get_isValid(self)

# Register LoftCenterLineOrRails in _fusion:
_fusion.LoftCenterLineOrRails_swigregister(LoftCenterLineOrRails)

def LoftCenterLineOrRails_classType() -> "char const *":
    return _fusion.LoftCenterLineOrRails_classType()


LoftCenterLineOrRails.count = property(LoftCenterLineOrRails._get_count, doc="The number of centerlines or rails in the collection.")


LoftCenterLineOrRails.isCenterLine = property(LoftCenterLineOrRails._get_isCenterLine, doc="Indicates if a centerline or rails are currently defined.")


LoftCenterLineOrRails.cast = lambda arg: arg if isinstance(arg, LoftCenterLineOrRails) else None

class LoftEndCondition(Base):
    r"""The base class for all loft end conditions."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::LoftEndCondition *":
        return _fusion.LoftEndCondition___deref__(self)

    def __eq__(self, rhs: "LoftEndCondition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.LoftEndCondition___eq__(self, rhs)


    def __ne__(self, rhs: "LoftEndCondition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.LoftEndCondition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.LoftEndCondition_classType()
    __swig_destroy__ = _fusion.delete_LoftEndCondition

    def _get_parentLoftSection(self) -> "adsk::core::Ptr< adsk::fusion::LoftSection >":
        r"""Returns the parent loft section."""
        return _fusion.LoftEndCondition__get_parentLoftSection(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.LoftEndCondition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.LoftEndCondition__get_isValid(self)

# Register LoftEndCondition in _fusion:
_fusion.LoftEndCondition_swigregister(LoftEndCondition)

def LoftEndCondition_classType() -> "char const *":
    return _fusion.LoftEndCondition_classType()


LoftEndCondition.parentLoftSection = property(LoftEndCondition._get_parentLoftSection, doc="Returns the parent loft section.")


LoftEndCondition.cast = lambda arg: arg if isinstance(arg, LoftEndCondition) else None

class LoftFeatureInput(Base):
    r"""
    This object defines the all of the input necessary to create a loft feature. It is the 
    programming equivalent to the Loft command dialog. Through this object you provide
    the input needed to fully define a loft. To create the loft feature you pass 
    this object the LoftFeatures.add method.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::LoftFeatureInput *":
        return _fusion.LoftFeatureInput___deref__(self)

    def __eq__(self, rhs: "LoftFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.LoftFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "LoftFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.LoftFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.LoftFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_LoftFeatureInput

    def _get_loftSections(self) -> "adsk::core::Ptr< adsk::fusion::LoftSections >":
        r"""
        The set of sections, (or profiles as they're referred to in the user-interface), that the loft will pass through. Use the add method on the LoftSections
        object to specify new sections.
        """
        return _fusion.LoftFeatureInput__get_loftSections(self)

    def _get_centerLineOrRails(self) -> "adsk::core::Ptr< adsk::fusion::LoftCenterLineOrRails >":
        r"""
        The single centerline or set of rails that define the shape of the loft. Use methods on the
        returned LoftCenterLineOrRails object to define the centerline or rails.
        """
        return _fusion.LoftFeatureInput__get_centerLineOrRails(self)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations":
        r"""Gets and sets the type of operation performed by the loft."""
        return _fusion.LoftFeatureInput__get_operation(self)

    def _set_operation(self, value: "FeatureOperations") -> "bool":
        r"""Gets and sets the type of operation performed by the loft."""
        return _fusion.LoftFeatureInput__set_operation(self, value)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the loft is created based on geometry (e.g. a profile and/or face(s))
        when the loft is being created in another component AND the loft is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.LoftFeatureInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, value: "Occurrence") -> "bool":
        r"""
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the loft is created based on geometry (e.g. a profile and/or face(s))
        when the loft is being created in another component AND the loft is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.LoftFeatureInput__set_creationOccurrence(self, value)

    def _get_isSolid(self) -> "bool":
        r"""
        Specifies if the loft should be created as a solid or surface. This is
        initialized to true so a solid will attempt to be created if it's not changed.
        """
        return _fusion.LoftFeatureInput__get_isSolid(self)

    def _set_isSolid(self, value: "bool") -> "bool":
        r"""
        Specifies if the loft should be created as a solid or surface. This is
        initialized to true so a solid will attempt to be created if it's not changed.
        """
        return _fusion.LoftFeatureInput__set_isSolid(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.LoftFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.LoftFeatureInput__set_targetBaseFeature(self, value)

    def _get_participantBodies(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepBody > > >":
        r"""
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        If this property has not been set, the default behavior is that all bodies that are intersected by the 
        feature will participate.
        This property can return null in the case where the feature has not been fully defined so that
        possible intersecting bodies can be computed.
        """
        return _fusion.LoftFeatureInput__get_participantBodies(self)

    def _set_participantBodies(self, value: "BRepBodyVector") -> "bool":
        r"""
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        If this property has not been set, the default behavior is that all bodies that are intersected by the 
        feature will participate.
        This property can return null in the case where the feature has not been fully defined so that
        possible intersecting bodies can be computed.
        """
        return _fusion.LoftFeatureInput__set_participantBodies(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.LoftFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.LoftFeatureInput__get_isValid(self)

# Register LoftFeatureInput in _fusion:
_fusion.LoftFeatureInput_swigregister(LoftFeatureInput)

def LoftFeatureInput_classType() -> "char const *":
    return _fusion.LoftFeatureInput_classType()


LoftFeatureInput.loftSections = property(LoftFeatureInput._get_loftSections, doc="The set of sections, (or profiles as they're referred to in the user-interface), that the loft will pass through. Use the add method on the LoftSections\nobject to specify new sections.")


LoftFeatureInput.centerLineOrRails = property(LoftFeatureInput._get_centerLineOrRails, doc="The single centerline or set of rails that define the shape of the loft. Use methods on the\nreturned LoftCenterLineOrRails object to define the centerline or rails.")


LoftFeatureInput.operation = property(LoftFeatureInput._get_operation, LoftFeatureInput._set_operation, doc="Gets and sets the type of operation performed by the loft.")


LoftFeatureInput.creationOccurrence = property(LoftFeatureInput._get_creationOccurrence, LoftFeatureInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an Occurrence for creation needs to be\nspecified when the loft is created based on geometry (e.g. a profile and/or face(s))\nwhen the loft is being created in another component AND the loft is not in the root component.\nThe CreationOccurrence is analogous to the active occurrence in the UI")


LoftFeatureInput.isSolid = property(LoftFeatureInput._get_isSolid, LoftFeatureInput._set_isSolid, doc="Specifies if the loft should be created as a solid or surface. This is\ninitialized to true so a solid will attempt to be created if it's not changed.")


LoftFeatureInput.targetBaseFeature = property(LoftFeatureInput._get_targetBaseFeature, LoftFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


LoftFeatureInput.participantBodies = property(LoftFeatureInput._get_participantBodies, LoftFeatureInput._set_participantBodies, doc="Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.\nIf this property has not been set, the default behavior is that all bodies that are intersected by the\nfeature will participate.\nThis property can return null in the case where the feature has not been fully defined so that\npossible intersecting bodies can be computed.")


LoftFeatureInput.cast = lambda arg: arg if isinstance(arg, LoftFeatureInput) else None

class LoftFeatures(Base):
    r"""Collection that provides access to all of the existing loft features in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::LoftFeatures *":
        return _fusion.LoftFeatures___deref__(self)

    def __eq__(self, rhs: "LoftFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.LoftFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "LoftFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.LoftFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.LoftFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::LoftFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.LoftFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.LoftFeatures_classType()
    __swig_destroy__ = _fusion.delete_LoftFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::LoftFeature >":
        r"""
        Function that returns the specified loft feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.LoftFeatures_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::LoftFeature >":
        r"""
        Function that returns the specified loft feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.LoftFeatures_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of loft features in the collection."""
        return _fusion.LoftFeatures__get_count(self)

    def createInput(self, operation: "FeatureOperations") -> "adsk::core::Ptr< adsk::fusion::LoftFeatureInput >":
        r"""
        Creates a LoftFeatureInput object. Use properties and methods on the returned LoftFeatureInput
        object to provide the required input to create a loft feature. The LoftFeatureInput object can then be used as input to the 
        add method to create the loft feature. 
        operation : The feature operation to perform. 
        Returns the newly created LoftFeatureInput object or null if the creation failed.
        """
        return _fusion.LoftFeatures_createInput(self, operation)

    def add(self, input: "LoftFeatureInput") -> "adsk::core::Ptr< adsk::fusion::LoftFeature >":
        r"""
        Creates a new loft feature. 
        input : A LoftFeatureInput object that defines the desired loft feature. Use the createInput 
        method to create a new LoftFeatureInput object and then use methods on it 
        (the LoftFeatureInput object) to define the required input. 
        Returns the newly created LoftFeature object or null if the creation failed.
        """
        return _fusion.LoftFeatures_add(self, input)

    def _get_objectType(self) -> "char const *":
        return _fusion.LoftFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.LoftFeatures__get_isValid(self)

# Register LoftFeatures in _fusion:
_fusion.LoftFeatures_swigregister(LoftFeatures)

def LoftFeatures_classType() -> "char const *":
    return _fusion.LoftFeatures_classType()


LoftFeatures.count = property(LoftFeatures._get_count, doc="The number of loft features in the collection.")


LoftFeatures.cast = lambda arg: arg if isinstance(arg, LoftFeatures) else None

class LoftSection(Base):
    r"""A single loft section."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::LoftSection *":
        return _fusion.LoftSection___deref__(self)

    def __eq__(self, rhs: "LoftSection") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.LoftSection___eq__(self, rhs)


    def __ne__(self, rhs: "LoftSection") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.LoftSection___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.LoftSection_classType()
    __swig_destroy__ = _fusion.delete_LoftSection

    def _get_entity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Get and sets the entity that defines the section of the loft. This can be a BRepFace, Profile, Path, SketchPoint, ConstructionPoint, or an ObjectCollection
        of contiguous profiles.
        If this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.LoftSection__get_entity(self)

    def _set_entity(self, value: "Base") -> "bool":
        r"""
        Get and sets the entity that defines the section of the loft. This can be a BRepFace, Profile, Path, SketchPoint, ConstructionPoint, or an ObjectCollection
        of contiguous profiles.
        If this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.LoftSection__set_entity(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this LoftSection.
        If this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        Returns true if the operation was successful.
        """
        return _fusion.LoftSection_deleteMe(self)

    def _get_index(self) -> "int":
        r"""
        The position of this LoftSection within the collection. The first section has an index
        of 0. This is also the order of how the section will be used in the loft. The order
        can be modified by using the reorder method.
        """
        return _fusion.LoftSection__get_index(self)

    def reorder(self, newIndex: "int") -> "bool":
        r"""
        Repositions this section so that it has the new index specified.
        If this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        newIndex : The new index value. For example, passing in zero as the new index will make this 
        the first section in the loft and (LoftSections.count - 1) will make it the last section.
        All other sections will be maintain their existing order but be shifted to allow space
        for this section. 
        Returns true if the reorder operation was successful.
        """
        return _fusion.LoftSection_reorder(self, newIndex)

    def _get_endCondition(self) -> "adsk::core::Ptr< adsk::fusion::LoftEndCondition >":
        r"""
        Returns the current end condition. This is only valid for the first and last
        section and when the result is not closed. In other cases this will return null.
        This returns one of the several objects derived from LoftEndCondition and represents
        the current end condition. You can edit the existing condition using properties
        on the returned object. You can change the end condition using one of the set methods
        on the LoftSection object.
        If this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.LoftSection__get_endCondition(self)

    def setFreeEndCondition(self) -> "bool":
        r"""
        Sets the end condition to be a 'Free' end condition. This is the default
        end condition when a new section is added.
        This is valid for sections defined with all curve types.
        If this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        Returns true if the operation was successful.
        """
        return _fusion.LoftSection_setFreeEndCondition(self)

    def setDirectionEndCondition(self, *args) -> "bool":
        r"""
        Sets the end condition to be defined by a direction and weight.
        This is valid for sections defined with sketch curves.
        If this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        angle : Input ValueInput object that specifies the direction by using an angle. This defaults to an angle of 0.0.
        If the ValueInput object is a string it must be an valid expression that can be evaluated as an angle.
        If the ValueInput is a value then it is in radians. 
        weight : Input ValueInput object that defines the weight or the amount of influence of end condition on the loft.
        This defaults to a value of 1.0. If the ValueInput object is a string it must be an valid expression that 
        can be evaluated as a unitless value. In any case, the value must be greater than 0. 
        Returns true if the operation was successful.
        """
        return _fusion.LoftSection_setDirectionEndCondition(self, *args)

    def setTangentEndCondition(self, weight: "ValueInput") -> "bool":
        r"""
        Sets the end condition to be tangent to the adjacent face. If the section is not defined by a BRepEdge,
        then this is ignored because there is no face to be tangent to.
        This is only valid on the first or last profile.
        If this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        weight : Input ValueInput object that defines the weight or the amount of influence of end condition on the loft.
        This defaults to a value of 1.0. If the ValueInput object is a string it must be an valid expression that 
        can be evaluated as a unitless value. In any case, the value must be greater than 0. 
        Returns true if the operation was successful.
        """
        return _fusion.LoftSection_setTangentEndCondition(self, weight)

    def setSmoothEndCondition(self, weight: "ValueInput") -> "bool":
        r"""
        Sets the end condition to be smooth to the adjacent face. If the end profile is not defined by a BRepEdge,
        then this is ignored because there is no face to be smooth to.
        This is only valid on the first or last section.
        If this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        weight : Input ValueInput object that defines the weight or the amount of influence of end condition on the loft.
        This defaults to a value of 1.0. If the ValueInput object is a string it must be an valid expression that 
        can be evaluated as a unitless value. In any case, the value must be greater than 0. 
        Returns true if the operation was successful.
        """
        return _fusion.LoftSection_setSmoothEndCondition(self, weight)

    def setPointSharpEndCondition(self) -> "bool":
        r"""
        Sets the end condition to be sharp where the section is a point. This is the default condition for a point section.
        If this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        Returns true if the operation was successful.
        """
        return _fusion.LoftSection_setPointSharpEndCondition(self)

    def setPointTangentEndCondition(self, weight: "ValueInput") -> "bool":
        r"""
        Set the end condition to a tangent condition in the case where the section is a point.
        If this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        weight : Input ValueInput object that defines the weight or the amount of influence of end condition on the loft.
        This defaults to a value of 1.0. If the ValueInput object is a string it must be an valid expression that 
        can be evaluated as a unitless value. In any case, the value must be greater than 0. 
        Returns true if the operation was successful.
        """
        return _fusion.LoftSection_setPointTangentEndCondition(self, weight)

    def _get_objectType(self) -> "char const *":
        return _fusion.LoftSection__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.LoftSection__get_isValid(self)

# Register LoftSection in _fusion:
_fusion.LoftSection_swigregister(LoftSection)

def LoftSection_classType() -> "char const *":
    return _fusion.LoftSection_classType()


LoftSection.entity = property(LoftSection._get_entity, LoftSection._set_entity, doc="Get and sets the entity that defines the section of the loft. This can be a BRepFace, Profile, Path, SketchPoint, ConstructionPoint, or an ObjectCollection\nof contiguous profiles.\nIf this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


LoftSection.index = property(LoftSection._get_index, doc="The position of this LoftSection within the collection. The first section has an index\nof 0. This is also the order of how the section will be used in the loft. The order\ncan be modified by using the reorder method.")


LoftSection.endCondition = property(LoftSection._get_endCondition, doc="Returns the current end condition. This is only valid for the first and last\nsection and when the result is not closed. In other cases this will return null.\nThis returns one of the several objects derived from LoftEndCondition and represents\nthe current end condition. You can edit the existing condition using properties\non the returned object. You can change the end condition using one of the set methods\non the LoftSection object.\nIf this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


LoftSection.cast = lambda arg: arg if isinstance(arg, LoftSection) else None

class LoftSections(Base):
    r"""The set of two or more sections used to define the shape of the loft."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::LoftSections *":
        return _fusion.LoftSections___deref__(self)

    def __eq__(self, rhs: "LoftSections") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.LoftSections___eq__(self, rhs)


    def __ne__(self, rhs: "LoftSections") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.LoftSections___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.LoftSections___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::LoftSection >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.LoftSections___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.LoftSections_classType()
    __swig_destroy__ = _fusion.delete_LoftSections

    def _get_count(self) -> "size_t":
        r"""The number of LoftSections in the collection."""
        return _fusion.LoftSections__get_count(self)

    def item(self, index: "int") -> "adsk::core::Ptr< adsk::fusion::LoftSection >":
        r"""
        Function that returns the specified LoftSection using an index into the collection. They are returned
        in the same order that they are used in the loft. Their order can be modified using the reorder method
        of the LoftSection object. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.LoftSections_item(self, index)

    def add(self, entity: "Base") -> "adsk::core::Ptr< adsk::fusion::LoftSection >":
        r"""
        Adds a new section to the loft. The initial end condition is 'Free'. Additional methods on the
        returned LoftSection can be used to further define the section.
        If this LoftSections object is associated with a created feature, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        entity : Specifies the BRepFace, Profile, Path, SketchPoint, ConstructionPoint, or an ObjectCollection containing
        a contiguous set of Profile objects that defines the section. 
        Returns the newly created LoftSection object.
        """
        return _fusion.LoftSections_add(self, entity)

    def _get_objectType(self) -> "char const *":
        return _fusion.LoftSections__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.LoftSections__get_isValid(self)

# Register LoftSections in _fusion:
_fusion.LoftSections_swigregister(LoftSections)

def LoftSections_classType() -> "char const *":
    return _fusion.LoftSections_classType()


LoftSections.count = property(LoftSections._get_count, doc="The number of LoftSections in the collection.")


LoftSections.cast = lambda arg: arg if isinstance(arg, LoftSections) else None

class MeshBodies(Base):
    r"""
    Provides access to the MeshBodies in the parent Component and
    supports the creation of new mesh bodies.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::MeshBodies *":
        return _fusion.MeshBodies___deref__(self)

    def __eq__(self, rhs: "MeshBodies") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.MeshBodies___eq__(self, rhs)


    def __ne__(self, rhs: "MeshBodies") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.MeshBodies___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.MeshBodies___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::MeshBody >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.MeshBodies___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.MeshBodies_classType()
    __swig_destroy__ = _fusion.delete_MeshBodies

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::MeshBodyList >":
        r"""
        Creates a new mesh body by importing an .stl or .obj file.
        Because of a current limitation, if you want to create a mesh body in a parametric model, 
        you must first call the edit method of the base or form feature, use this method to create 
        the mesh body, and then call the finishEdit method of the base or form feature. The base 
        or form feature must be in an 'edit' state to be able to add any additional items to it. 
        fullFilename : The full filename (path and file) of a .stl or .obj file. 
        units : The units to use when importing the file. 
        baseOrFormFeature : The BaseFeature or FormFeature object that this mesh body will be associated with. This is an optional
        requirement and is required when the model design history is being captured (paremetric model) but is
        ignored otherwise (direct edit model). 
        Returns a list of the newly created mesh bodies or null if the creation failed. Multiple
        bodies can be created in the case where a .obj file that contains multiple bodies was imported.
        stl files always contain a single body.
        """
        return _fusion.MeshBodies_add(self, *args)

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::MeshBody >":
        r"""
        Provides access to a mesh body within the collection. 
        index : The index of the mesh body to return, where an index of 0 is the first mesh body in the collection. 
        Returns the specified mesh body or null in the case of a invalid index.
        """
        return _fusion.MeshBodies_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of mesh bodies in the collection."""
        return _fusion.MeshBodies__get_count(self)

    def addByTriangleMeshData(self, coordinates: "DoubleVector", coordinateIndexList: "IntVector", normalVectors: "DoubleVector", normalIndexList: "IntVector") -> "adsk::core::Ptr< adsk::fusion::MeshBody >":
        r"""
        Createa a new mesh body using the mesh description provided. 
        coordinates : Input array of doubles that defines the X, Y, Z coordinates of each node in the mesh. Each set of three numbers define
        the coordinates of a node. 
        coordinateIndexList : An array of integers that represent indices into the coordinates to define the vertices of the triangles. If an empty
        array is provided, then it's assumed that the first three coordinates defines the first triangle, the next three define
        the second triangle, and so on. 
        normalVectors : An array of doubles that represent the x, y, z components of the normals at each coordinate. There should be a normal defined
        for each coordinate. If an empty array is provided for the normal vectors, Fusion 360 will automatically calculate normal vectors
        that are 90 degrees to the face of the triangle, making it appear flat. 
        normalIndexList : An array of integers that represent indices into the normal vectors to define the which vector corresponds to which vertex. This
        should be the same size as the vertex index list. If an empty array is input and normal vectors are provided, it is assumed that
        the normals match up one-to-one to each coordinate. 
        Returns the newly created MeshBody object or null in the case of a failure.
        """
        return _fusion.MeshBodies_addByTriangleMeshData(self, coordinates, coordinateIndexList, normalVectors, normalIndexList)

    def _get_objectType(self) -> "char const *":
        return _fusion.MeshBodies__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.MeshBodies__get_isValid(self)

# Register MeshBodies in _fusion:
_fusion.MeshBodies_swigregister(MeshBodies)

def MeshBodies_classType() -> "char const *":
    return _fusion.MeshBodies_classType()


MeshBodies.count = property(MeshBodies._get_count, doc="Returns the number of mesh bodies in the collection.")


MeshBodies.cast = lambda arg: arg if isinstance(arg, MeshBodies) else None

class MeshBody(Base):
    r"""Provides access to a mesh body."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::MeshBody *":
        return _fusion.MeshBody___deref__(self)

    def __eq__(self, rhs: "MeshBody") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.MeshBody___eq__(self, rhs)


    def __ne__(self, rhs: "MeshBody") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.MeshBody___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.MeshBody_classType()
    __swig_destroy__ = _fusion.delete_MeshBody

    def _get_name(self) -> "std::string":
        r"""Gets and sets the name of the mesh body as displayed in the browser."""
        return _fusion.MeshBody__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the name of the mesh body as displayed in the browser."""
        return _fusion.MeshBody__set_name(self, value)

    def _get_isSelectable(self) -> "bool":
        r"""Gets and sets if the mesh body is selectable in the graphics window."""
        return _fusion.MeshBody__get_isSelectable(self)

    def _set_isSelectable(self, value: "bool") -> "bool":
        r"""Gets and sets if the mesh body is selectable in the graphics window."""
        return _fusion.MeshBody__set_isSelectable(self, value)

    def _get_isLightBulbOn(self) -> "bool":
        r"""
        Is the light bulb (as displayed in the browser) on.
        A mesh body will only be visible if the light bulb is switched on. However,
        the light bulb can be on and the mesh body is still invisible if the light bulb
        for all bodies or the owning component is off.
        """
        return _fusion.MeshBody__get_isLightBulbOn(self)

    def _set_isLightBulbOn(self, value: "bool") -> "bool":
        r"""
        Is the light bulb (as displayed in the browser) on.
        A mesh body will only be visible if the light bulb is switched on. However,
        the light bulb can be on and the mesh body is still invisible if the light bulb
        for all bodies or the owning component is off.
        """
        return _fusion.MeshBody__set_isLightBulbOn(self, value)

    def _get_isVisible(self) -> "bool":
        r"""Gets if the mesh body point is visible."""
        return _fusion.MeshBody__get_isVisible(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the mesh body. 
        Returns true in the case where the selection was successful.
        """
        return _fusion.MeshBody_deleteMe(self)

    def _get_mesh(self) -> "adsk::core::Ptr< adsk::fusion::PolygonMesh >":
        r"""Returns the original mesh data that was imported. This can include triangles, quads, and polygons."""
        return _fusion.MeshBody__get_mesh(self)

    def _get_displayMesh(self) -> "adsk::core::Ptr< adsk::fusion::TriangleMesh >":
        r"""Returns the associated mesh that is used for the display. This will always be triangles and includes any textures."""
        return _fusion.MeshBody__get_displayMesh(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent Component."""
        return _fusion.MeshBody__get_parentComponent(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.MeshBody__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::MeshBody >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.MeshBody__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::MeshBody >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence.
        Fails if this object is not the NativeObject. 
        occurrence : The occurrence that represents the context you want to create this proxy in. 
        Returns the proxy for the occurrence in the context of the specified occurrence. Returns null if it failed.
        """
        return _fusion.MeshBody_createForAssemblyContext(self, occurrence)

    def _get_baseOrFormFeature(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        This property returns the base or form feature that this mesh body is associated with. It
        returns null in the case where the modeling design history is not being captured (direct edit model).
        """
        return _fusion.MeshBody__get_baseOrFormFeature(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this mesh body."""
        return _fusion.MeshBody__get_attributes(self)

    def _get_material(self) -> "adsk::core::Ptr< adsk::core::Material >":
        r"""Gets and sets the physical material assigned to this mesh body."""
        return _fusion.MeshBody__get_material(self)

    def _set_material(self, value: "Material") -> "bool":
        r"""Gets and sets the physical material assigned to this mesh body."""
        return _fusion.MeshBody__set_material(self, value)

    def _get_appearance(self) -> "adsk::core::Ptr< adsk::core::Appearance >":
        r"""
        Read-write property that gets and sets the current appearance of the body. Setting this property will result in applying
        an override appearance to the body and the AppearanceSourceType property will return OverrideAppearanceSource. Setting
        this property to null will remove any override.
        """
        return _fusion.MeshBody__get_appearance(self)

    def _set_appearance(self, value: "Appearance") -> "bool":
        r"""
        Read-write property that gets and sets the current appearance of the body. Setting this property will result in applying
        an override appearance to the body and the AppearanceSourceType property will return OverrideAppearanceSource. Setting
        this property to null will remove any override.
        """
        return _fusion.MeshBody__set_appearance(self, value)

    def _get_appearanceSourceType(self) -> "adsk::core::AppearanceSourceTypes":
        r"""
        Read-write property that gets the source of the appearance for the body. If this returns OverrideAppearanceSource, an override exists
        on this body. The override can be removed by setting the Appearance property to null.
        """
        return _fusion.MeshBody__get_appearanceSourceType(self)

    def _get_opacity(self) -> "double":
        r"""
        Gets and sets the opacity override assigned to this body. A value of 1.0 specifies
        that is it completely opaque and a value of 0.0 specifies that is it completely transparent.
        This value is not necessarily related to what the user sees because the opacity is inherited.
        For example, if you this body is in a component and that component's opacity is set to something
        other than 1.0, the body will also be shown as slightly transparent even though the opacity 
        property for the body will return 1.0. Because the component that contains the body can be 
        referenced as an occurrence in other components and they can have different opacity settings, 
        it's possible that different instances of the same body can display using different opacity levels. 
        To get the opacity that it is being displayed with use the MeshBody.visibleOpacity property.
        This is the API equivalent of the 'Opacity Control' command available for the body in the browser.
        """
        return _fusion.MeshBody__get_opacity(self)

    def _set_opacity(self, value: "double") -> "bool":
        r"""
        Gets and sets the opacity override assigned to this body. A value of 1.0 specifies
        that is it completely opaque and a value of 0.0 specifies that is it completely transparent.
        This value is not necessarily related to what the user sees because the opacity is inherited.
        For example, if you this body is in a component and that component's opacity is set to something
        other than 1.0, the body will also be shown as slightly transparent even though the opacity 
        property for the body will return 1.0. Because the component that contains the body can be 
        referenced as an occurrence in other components and they can have different opacity settings, 
        it's possible that different instances of the same body can display using different opacity levels. 
        To get the opacity that it is being displayed with use the MeshBody.visibleOpacity property.
        This is the API equivalent of the 'Opacity Control' command available for the body in the browser.
        """
        return _fusion.MeshBody__set_opacity(self, value)

    def _get_visibleOpacity(self) -> "double":
        r"""
        The user can set an override opacity for components and bodies these opacity overrides combine if
        children and parent components have overrides. This property returns the actual opacity that is
        being used to render the body. To set the opacity use the opacity property of the MeshBody object.
        """
        return _fusion.MeshBody__get_visibleOpacity(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the MeshBody object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same mesh body.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.MeshBody__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.MeshBody__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.MeshBody__get_isValid(self)

# Register MeshBody in _fusion:
_fusion.MeshBody_swigregister(MeshBody)

def MeshBody_classType() -> "char const *":
    return _fusion.MeshBody_classType()


MeshBody.name = property(MeshBody._get_name, MeshBody._set_name, doc="Gets and sets the name of the mesh body as displayed in the browser.")


MeshBody.isSelectable = property(MeshBody._get_isSelectable, MeshBody._set_isSelectable, doc="Gets and sets if the mesh body is selectable in the graphics window.")


MeshBody.isLightBulbOn = property(MeshBody._get_isLightBulbOn, MeshBody._set_isLightBulbOn, doc="Is the light bulb (as displayed in the browser) on.\nA mesh body will only be visible if the light bulb is switched on. However,\nthe light bulb can be on and the mesh body is still invisible if the light bulb\nfor all bodies or the owning component is off.")


MeshBody.isVisible = property(MeshBody._get_isVisible, doc="Gets if the mesh body point is visible.")


MeshBody.mesh = property(MeshBody._get_mesh, doc="Returns the original mesh data that was imported. This can include triangles, quads, and polygons.")


MeshBody.displayMesh = property(MeshBody._get_displayMesh, doc="Returns the associated mesh that is used for the display. This will always be triangles and includes any textures.")


MeshBody.parentComponent = property(MeshBody._get_parentComponent, doc="Returns the parent Component.")


MeshBody.assemblyContext = property(MeshBody._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")


MeshBody.nativeObject = property(MeshBody._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


MeshBody.baseOrFormFeature = property(MeshBody._get_baseOrFormFeature, doc="This property returns the base or form feature that this mesh body is associated with. It\nreturns null in the case where the modeling design history is not being captured (direct edit model).")


MeshBody.attributes = property(MeshBody._get_attributes, doc="Returns the collection of attributes associated with this mesh body.")


MeshBody.material = property(MeshBody._get_material, MeshBody._set_material, doc="Gets and sets the physical material assigned to this mesh body.")


MeshBody.appearance = property(MeshBody._get_appearance, MeshBody._set_appearance, doc="Read-write property that gets and sets the current appearance of the body. Setting this property will result in applying\nan override appearance to the body and the AppearanceSourceType property will return OverrideAppearanceSource. Setting\nthis property to null will remove any override.")


MeshBody.appearanceSourceType = property(MeshBody._get_appearanceSourceType, doc="Read-write property that gets the source of the appearance for the body. If this returns OverrideAppearanceSource, an override exists\non this body. The override can be removed by setting the Appearance property to null.")


MeshBody.opacity = property(MeshBody._get_opacity, MeshBody._set_opacity, doc="Gets and sets the opacity override assigned to this body. A value of 1.0 specifies\nthat is it completely opaque and a value of 0.0 specifies that is it completely transparent.\nThis value is not necessarily related to what the user sees because the opacity is inherited.\nFor example, if you this body is in a component and that component's opacity is set to something\nother than 1.0, the body will also be shown as slightly transparent even though the opacity\nproperty for the body will return 1.0. Because the component that contains the body can be\nreferenced as an occurrence in other components and they can have different opacity settings,\nit's possible that different instances of the same body can display using different opacity levels.\nTo get the opacity that it is being displayed with use the MeshBody.visibleOpacity property.\nThis is the API equivalent of the 'Opacity Control' command available for the body in the browser.")


MeshBody.visibleOpacity = property(MeshBody._get_visibleOpacity, doc="The user can set an override opacity for components and bodies these opacity overrides combine if\nchildren and parent components have overrides. This property returns the actual opacity that is\nbeing used to render the body. To set the opacity use the opacity property of the MeshBody object.")


MeshBody.entityToken = property(MeshBody._get_entityToken, doc="Returns a token for the MeshBody object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same mesh body.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.")


MeshBody.cast = lambda arg: arg if isinstance(arg, MeshBody) else None

class MeshBodyList(Base):
    r"""Provides access to a list of MeshBody objects."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::MeshBodyList *":
        return _fusion.MeshBodyList___deref__(self)

    def __eq__(self, rhs: "MeshBodyList") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.MeshBodyList___eq__(self, rhs)


    def __ne__(self, rhs: "MeshBodyList") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.MeshBodyList___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.MeshBodyList___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::MeshBody >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.MeshBodyList___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.MeshBodyList_classType()
    __swig_destroy__ = _fusion.delete_MeshBodyList

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::MeshBody >":
        r"""
        Provides access to a mesh body within the collection. 
        index : The index of the mesh body to return, where an index of 0 is the first mesh body in the collection. 
        Returns the specified mesh body or null in the case of a invalid index.
        """
        return _fusion.MeshBodyList_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of mesh bodies in the collection."""
        return _fusion.MeshBodyList__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.MeshBodyList__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.MeshBodyList__get_isValid(self)

# Register MeshBodyList in _fusion:
_fusion.MeshBodyList_swigregister(MeshBodyList)

def MeshBodyList_classType() -> "char const *":
    return _fusion.MeshBodyList_classType()


MeshBodyList.count = property(MeshBodyList._get_count, doc="Returns the number of mesh bodies in the collection.")


MeshBodyList.cast = lambda arg: arg if isinstance(arg, MeshBodyList) else None

class MeshManager(Base):
    r"""Provides access to meshes that approximate a B-Rep and T-Spline."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::MeshManager *":
        return _fusion.MeshManager___deref__(self)

    def __eq__(self, rhs: "MeshManager") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.MeshManager___eq__(self, rhs)


    def __ne__(self, rhs: "MeshManager") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.MeshManager___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.MeshManager_classType()
    __swig_destroy__ = _fusion.delete_MeshManager

    def createMeshCalculator(self) -> "adsk::core::Ptr< adsk::fusion::TriangleMeshCalculator >":
        r"""
        Creates a new MeshCalculator which is used to calculate
        new triangular meshes based on various parameters that control the calculation. 
        Returns the new MeshCalculator object or null if the creation failed.
        """
        return _fusion.MeshManager_createMeshCalculator(self)

    def _get_displayMeshes(self) -> "adsk::core::Ptr< adsk::fusion::TriangleMeshList >":
        r"""
        Returns a collection that provides access to all of the
        existing display meshes.
        """
        return _fusion.MeshManager__get_displayMeshes(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the parent BRepBody, BRepFace, BRepLump, BRepShell, SculptBody, or SculptFace object."""
        return _fusion.MeshManager__get_parent(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.MeshManager__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.MeshManager__get_isValid(self)

# Register MeshManager in _fusion:
_fusion.MeshManager_swigregister(MeshManager)

def MeshManager_classType() -> "char const *":
    return _fusion.MeshManager_classType()


MeshManager.displayMeshes = property(MeshManager._get_displayMeshes, doc="Returns a collection that provides access to all of the\nexisting display meshes.")


MeshManager.parent = property(MeshManager._get_parent, doc="Returns the parent BRepBody, BRepFace, BRepLump, BRepShell, SculptBody, or SculptFace object.")


MeshManager.cast = lambda arg: arg if isinstance(arg, MeshManager) else None

class MirrorFeatureInput(Base):
    r"""
    This class defines the methods and properties that pertain to the definition of a mirror 
    feature.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::MirrorFeatureInput *":
        return _fusion.MirrorFeatureInput___deref__(self)

    def __eq__(self, rhs: "MirrorFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.MirrorFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "MirrorFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.MirrorFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.MirrorFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_MirrorFeatureInput

    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the entities that are mirrored. It can contain faces, features, bodies, or components. 
        The input must all be of a single type. For example, you can't provide a body and a component but 
        the collection must be either all bodies or all components.
        """
        return _fusion.MirrorFeatureInput__get_inputEntities(self)

    def _set_inputEntities(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the entities that are mirrored. It can contain faces, features, bodies, or components. 
        The input must all be of a single type. For example, you can't provide a body and a component but 
        the collection must be either all bodies or all components.
        """
        return _fusion.MirrorFeatureInput__set_inputEntities(self, value)

    def _get_mirrorPlane(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets and sets the mirror plane. This can be either a planar face or construction plane."""
        return _fusion.MirrorFeatureInput__get_mirrorPlane(self)

    def _set_mirrorPlane(self, value: "Base") -> "bool":
        r"""Gets and sets the mirror plane. This can be either a planar face or construction plane."""
        return _fusion.MirrorFeatureInput__set_mirrorPlane(self, value)

    def _get_patternComputeOption(self) -> "adsk::fusion::PatternComputeOptions":
        r"""
        Gets and sets the compute option when mirroring features. The default value for this is AdjustPatternCompute.
        This property only applies when mirroring features and is ignored in the direct modeling environment.
        """
        return _fusion.MirrorFeatureInput__get_patternComputeOption(self)

    def _set_patternComputeOption(self, value: "PatternComputeOptions") -> "bool":
        r"""
        Gets and sets the compute option when mirroring features. The default value for this is AdjustPatternCompute.
        This property only applies when mirroring features and is ignored in the direct modeling environment.
        """
        return _fusion.MirrorFeatureInput__set_patternComputeOption(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.MirrorFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.MirrorFeatureInput__set_targetBaseFeature(self, value)

    def _get_isCombine(self) -> "bool":
        r"""
        Gets and sets whether the mirrored bodies should be combined with the original bodies.
        When true, the mirrored geometry will be Boolean unioned with the original solid or surface body(s)
        when they connect within the stitch tolerance defined with the stitchTolerance property. If the bodies
        cannot be unioned or stitched the result will be separate bodies.
        If any input object is not a body, then this setting is ignored.
        Default is false.
        """
        return _fusion.MirrorFeatureInput__get_isCombine(self)

    def _set_isCombine(self, value: "bool") -> "bool":
        r"""
        Gets and sets whether the mirrored bodies should be combined with the original bodies.
        When true, the mirrored geometry will be Boolean unioned with the original solid or surface body(s)
        when they connect within the stitch tolerance defined with the stitchTolerance property. If the bodies
        cannot be unioned or stitched the result will be separate bodies.
        If any input object is not a body, then this setting is ignored.
        Default is false.
        """
        return _fusion.MirrorFeatureInput__set_isCombine(self, value)

    def _get_stitchTolerance(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Gets and sets the ValueInput object that defines the Stitching Tolerance (length)
        to use when doing a mirror and combine for surface bodies.
        """
        return _fusion.MirrorFeatureInput__get_stitchTolerance(self)

    def _set_stitchTolerance(self, value: "ValueInput") -> "bool":
        r"""
        Gets and sets the ValueInput object that defines the Stitching Tolerance (length)
        to use when doing a mirror and combine for surface bodies.
        """
        return _fusion.MirrorFeatureInput__set_stitchTolerance(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.MirrorFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.MirrorFeatureInput__get_isValid(self)

# Register MirrorFeatureInput in _fusion:
_fusion.MirrorFeatureInput_swigregister(MirrorFeatureInput)

def MirrorFeatureInput_classType() -> "char const *":
    return _fusion.MirrorFeatureInput_classType()


MirrorFeatureInput.inputEntities = property(MirrorFeatureInput._get_inputEntities, MirrorFeatureInput._set_inputEntities, doc="Gets and sets the entities that are mirrored. It can contain faces, features, bodies, or components.\nThe input must all be of a single type. For example, you can't provide a body and a component but\nthe collection must be either all bodies or all components.")


MirrorFeatureInput.mirrorPlane = property(MirrorFeatureInput._get_mirrorPlane, MirrorFeatureInput._set_mirrorPlane, doc="Gets and sets the mirror plane. This can be either a planar face or construction plane.")


MirrorFeatureInput.patternComputeOption = property(MirrorFeatureInput._get_patternComputeOption, MirrorFeatureInput._set_patternComputeOption, doc="Gets and sets the compute option when mirroring features. The default value for this is AdjustPatternCompute.\nThis property only applies when mirroring features and is ignored in the direct modeling environment.")


MirrorFeatureInput.targetBaseFeature = property(MirrorFeatureInput._get_targetBaseFeature, MirrorFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


MirrorFeatureInput.isCombine = property(MirrorFeatureInput._get_isCombine, MirrorFeatureInput._set_isCombine, doc="Gets and sets whether the mirrored bodies should be combined with the original bodies.\nWhen true, the mirrored geometry will be Boolean unioned with the original solid or surface body(s)\nwhen they connect within the stitch tolerance defined with the stitchTolerance property. If the bodies\ncannot be unioned or stitched the result will be separate bodies.\nIf any input object is not a body, then this setting is ignored.\nDefault is false.")


MirrorFeatureInput.stitchTolerance = property(MirrorFeatureInput._get_stitchTolerance, MirrorFeatureInput._set_stitchTolerance, doc="Gets and sets the ValueInput object that defines the Stitching Tolerance (length)\nto use when doing a mirror and combine for surface bodies.")


MirrorFeatureInput.cast = lambda arg: arg if isinstance(arg, MirrorFeatureInput) else None

class MirrorFeatures(Base):
    r"""
    Collection that provides access to all of the existing mirror features in a component
    and supports the ability to create new mirror features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::MirrorFeatures *":
        return _fusion.MirrorFeatures___deref__(self)

    def __eq__(self, rhs: "MirrorFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.MirrorFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "MirrorFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.MirrorFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.MirrorFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::MirrorFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.MirrorFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.MirrorFeatures_classType()
    __swig_destroy__ = _fusion.delete_MirrorFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::MirrorFeature >":
        r"""
        Function that returns the specified mirror feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.MirrorFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of mirror features in the collection."""
        return _fusion.MirrorFeatures__get_count(self)

    def createInput(self, inputEntities: "ObjectCollection", mirrorPlane: "Base") -> "adsk::core::Ptr< adsk::fusion::MirrorFeatureInput >":
        r"""
        Creates a MirrorFeatureInput object. Use properties and methods on this object
        to define the mirror you want to create and then use the Add method, passing in 
        the MirrorFeatureInput object. 
        inputEntities : A collection of the entities to mirror. It can contain faces, features, bodies, or components. 
        The input must all be of a single type. For example, you can't provide a body and a component but 
        the collection must be either all bodies or all components. 
        mirrorPlane : Input planar entity that defines the mirror plane. This can be either a planar face or a construction plane. 
        Returns the newly created MirrorFeatureInput object or null if the creation failed.
        """
        return _fusion.MirrorFeatures_createInput(self, inputEntities, mirrorPlane)

    def add(self, input: "MirrorFeatureInput") -> "adsk::core::Ptr< adsk::fusion::MirrorFeature >":
        r"""
        Creates a new mirror feature. 
        input : A MirrorFeatureInput object that defines the desired mirror. Use the createInput 
        method to create a new MirrorFeatureInput object and then use methods on it 
        (the MirrorFeatureInput object) to define the mirror. 
        Returns the newly created MirrorFeature object or null if the creation failed.
        """
        return _fusion.MirrorFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::MirrorFeature >":
        r"""
        Function that returns the specified mirror feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.MirrorFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.MirrorFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.MirrorFeatures__get_isValid(self)

# Register MirrorFeatures in _fusion:
_fusion.MirrorFeatures_swigregister(MirrorFeatures)

def MirrorFeatures_classType() -> "char const *":
    return _fusion.MirrorFeatures_classType()


MirrorFeatures.count = property(MirrorFeatures._get_count, doc="The number of mirror features in the collection.")


MirrorFeatures.cast = lambda arg: arg if isinstance(arg, MirrorFeatures) else None

class ModelParameters(Base):
    r"""Provides access to the Model Parameters within a component."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ModelParameters *":
        return _fusion.ModelParameters___deref__(self)

    def __eq__(self, rhs: "ModelParameters") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ModelParameters___eq__(self, rhs)


    def __ne__(self, rhs: "ModelParameters") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ModelParameters___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.ModelParameters___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.ModelParameters___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ModelParameters_classType()
    __swig_destroy__ = _fusion.delete_ModelParameters

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Function that returns the specified Model Parameter using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection 
        has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ModelParameters_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Function that returns the specified Model Parameter using the name of the parameter as it is 
        displayed in the parameters dialog. 
        name : The name of the Model Parameter as it is displayed in the parameters dialog 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.ModelParameters_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""Returns the number of parameters in the collection."""
        return _fusion.ModelParameters__get_count(self)

    def _get_component(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the component that owns the Model Parameters collection"""
        return _fusion.ModelParameters__get_component(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ModelParameters__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ModelParameters__get_isValid(self)

# Register ModelParameters in _fusion:
_fusion.ModelParameters_swigregister(ModelParameters)

def ModelParameters_classType() -> "char const *":
    return _fusion.ModelParameters_classType()


ModelParameters.count = property(ModelParameters._get_count, doc="Returns the number of parameters in the collection.")


ModelParameters.component = property(ModelParameters._get_component, doc="Returns the component that owns the Model Parameters collection")


ModelParameters.cast = lambda arg: arg if isinstance(arg, ModelParameters) else None

class MoveFeatureInput(Base):
    r"""This class defines the methods and properties that pertain to the definition of a move feature."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::MoveFeatureInput *":
        return _fusion.MoveFeatureInput___deref__(self)

    def __eq__(self, rhs: "MoveFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.MoveFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "MoveFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.MoveFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.MoveFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_MoveFeatureInput

    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        An ObjectCollection containing the objects to move. The collection can contain 
        BRepBody or BRepFace objects but not a mixture of the two types.
        """
        return _fusion.MoveFeatureInput__get_inputEntities(self)

    def _set_inputEntities(self, value: "ObjectCollection") -> "bool":
        r"""
        An ObjectCollection containing the objects to move. The collection can contain 
        BRepBody or BRepFace objects but not a mixture of the two types.
        """
        return _fusion.MoveFeatureInput__set_inputEntities(self, value)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >":
        r"""
        Gets and sets the tranform to apply to the input entities. This can describe a move (translation) 
        or a rotation. The matrix must define an orthogonal transform. That is the axes remain 
        perpendicular to each other and there isn't any scale or mirror defined.
        """
        return _fusion.MoveFeatureInput__get_transform(self)

    def _set_transform(self, value: "Matrix3D") -> "bool":
        r"""
        Gets and sets the tranform to apply to the input entities. This can describe a move (translation) 
        or a rotation. The matrix must define an orthogonal transform. That is the axes remain 
        perpendicular to each other and there isn't any scale or mirror defined.
        """
        return _fusion.MoveFeatureInput__set_transform(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.MoveFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.MoveFeatureInput__set_targetBaseFeature(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.MoveFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.MoveFeatureInput__get_isValid(self)

# Register MoveFeatureInput in _fusion:
_fusion.MoveFeatureInput_swigregister(MoveFeatureInput)

def MoveFeatureInput_classType() -> "char const *":
    return _fusion.MoveFeatureInput_classType()


MoveFeatureInput.inputEntities = property(MoveFeatureInput._get_inputEntities, MoveFeatureInput._set_inputEntities, doc="An ObjectCollection containing the objects to move. The collection can contain\nBRepBody or BRepFace objects but not a mixture of the two types.")


MoveFeatureInput.transform = property(MoveFeatureInput._get_transform, MoveFeatureInput._set_transform, doc="Gets and sets the tranform to apply to the input entities. This can describe a move (translation)\nor a rotation. The matrix must define an orthogonal transform. That is the axes remain\nperpendicular to each other and there isn't any scale or mirror defined.")


MoveFeatureInput.targetBaseFeature = property(MoveFeatureInput._get_targetBaseFeature, MoveFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


MoveFeatureInput.cast = lambda arg: arg if isinstance(arg, MoveFeatureInput) else None

class MoveFeatures(Base):
    r"""
    Collection that provides access to all of the existing move features in a component
    and supports the ability to create new move features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::MoveFeatures *":
        return _fusion.MoveFeatures___deref__(self)

    def __eq__(self, rhs: "MoveFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.MoveFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "MoveFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.MoveFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.MoveFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::MoveFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.MoveFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.MoveFeatures_classType()
    __swig_destroy__ = _fusion.delete_MoveFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::MoveFeature >":
        r"""
        Function that returns the specified move feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.MoveFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of move features in the collection."""
        return _fusion.MoveFeatures__get_count(self)

    def createInput(self, inputEntities: "ObjectCollection", transform: "Matrix3D") -> "adsk::core::Ptr< adsk::fusion::MoveFeatureInput >":
        r"""
        Creates a MoveFeatureInput object. Use properties and methods on this object
        to define the move feature you want to create and then use the Add method, passing in 
        the MoveFeatureInput object. 
        inputEntities : An ObjectCollection containing the entities to move. This collection can only contain 
        BRepBody objects in parametric modeling. It can be BRep bodies, T-Spline bodies, 
        mesh bodies mixed or faces and features mixed in non-parametric modeling. 
        transform : The transform to apply to the input entities. This can describe a move (translation) or a rotation. The
        matrix must define an orthogonal transform. That is the axes must be perpendicular to each other and there
        can't be any scaling or mirroring defined. 
        Returns the newly created MoveFeatureInput object or null if the creation failed.
        """
        return _fusion.MoveFeatures_createInput(self, inputEntities, transform)

    def add(self, input: "MoveFeatureInput") -> "adsk::core::Ptr< adsk::fusion::MoveFeature >":
        r"""
        Creates a new move feature. 
        input : A MoveFeatureInput object that defines the desired move feature. Use the createInput2 
        method to create a new MoveFeatureInput object and then use methods on the MoveFeatureInput 
        object to define the move feature. 
        Returns the newly created MoveFeature object or null if the creation failed.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.MoveFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::MoveFeature >":
        r"""
        Function that returns the specified move feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.MoveFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.MoveFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.MoveFeatures__get_isValid(self)

# Register MoveFeatures in _fusion:
_fusion.MoveFeatures_swigregister(MoveFeatures)

def MoveFeatures_classType() -> "char const *":
    return _fusion.MoveFeatures_classType()


MoveFeatures.count = property(MoveFeatures._get_count, doc="The number of move features in the collection.")


MoveFeatures.cast = lambda arg: arg if isinstance(arg, MoveFeatures) else None

class Occurrence(Base):
    r"""Represents an occurrence of a component at any level within a subassembly."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::Occurrence *":
        return _fusion.Occurrence___deref__(self)

    def __eq__(self, rhs: "Occurrence") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.Occurrence___eq__(self, rhs)


    def __ne__(self, rhs: "Occurrence") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.Occurrence___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.Occurrence_classType()
    __swig_destroy__ = _fusion.delete_Occurrence

    def _get_sourceComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""
        This is the sourceComponent for the occurrence and is affected
        by the assembly context. 
        This is the top-level component where the path begins.
        """
        return _fusion.Occurrence__get_sourceComponent(self)

    def _get_childOccurrences(self) -> "adsk::core::Ptr< adsk::fusion::OccurrenceList >":
        r"""
        Returns a read only list of child occurrences where only the occurrences 
        in this occurrence's AssemblyContext are returned .
        """
        return _fusion.Occurrence__get_childOccurrences(self)

    def _get_component(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""The component this occurrence references."""
        return _fusion.Occurrence__get_component(self)

    def _get_name(self) -> "std::string":
        r"""
        The name of the occurrence. This is the name as seen in the browser. It is a reflection
        of the component name with an added counter suffix (i.e. 'OccurrenceName:1').
        """
        return _fusion.Occurrence__get_name(self)

    def _get_fullPathName(self) -> "std::string":
        r"""
        The name of the occurrence, including the full path of occurrences as seen in the browser.
        The top-level component will depend on the context but will typically be the root component
        of the design. A name for an occurrence that is at the third level of an assembly could be
        'Sub1:1+Sub2:1+PartA:1'.
        """
        return _fusion.Occurrence__get_fullPathName(self)

    def _get_appearance(self) -> "adsk::core::Ptr< adsk::core::Appearance >":
        r"""
        Read-write property that gets and sets the appearance override for this occurrence. 
        This property can return null indicating there is no override appearance and that the
        contents of the occurrence are displayed using there defined appearance. 
        Setting the property to null will remove any override appearance for this occurrence.
        """
        return _fusion.Occurrence__get_appearance(self)

    def _set_appearance(self, value: "Appearance") -> "bool":
        r"""
        Read-write property that gets and sets the appearance override for this occurrence. 
        This property can return null indicating there is no override appearance and that the
        contents of the occurrence are displayed using there defined appearance. 
        Setting the property to null will remove any override appearance for this occurrence.
        """
        return _fusion.Occurrence__set_appearance(self, value)

    def _get_isLightBulbOn(self) -> "bool":
        r"""
        Gets and sets if the light bulb of this occurrence as displayed in the browser is on or off.
        An occurrence will only be visible if the light bulb is switched on. However,
        the light bulb can be on and the occurrence still invisible if a higher level occurrence 
        in the assembly context is not visible because its light bulb is off.
        """
        return _fusion.Occurrence__get_isLightBulbOn(self)

    def _set_isLightBulbOn(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the light bulb of this occurrence as displayed in the browser is on or off.
        An occurrence will only be visible if the light bulb is switched on. However,
        the light bulb can be on and the occurrence still invisible if a higher level occurrence 
        in the assembly context is not visible because its light bulb is off.
        """
        return _fusion.Occurrence__set_isLightBulbOn(self, value)

    def _get_isVisible(self) -> "bool":
        r"""
        Gets whether the occurrence is visible. 
        This property is affected by the assembly context.
        """
        return _fusion.Occurrence__get_isVisible(self)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >":
        r"""
        Gets and sets the 3d matrix data that defines this occurrences orientation and
        position in its assembly context
        """
        return _fusion.Occurrence__get_transform(self)

    def _set_transform(self, value: "Matrix3D") -> "bool":
        r"""
        Gets and sets the 3d matrix data that defines this occurrences orientation and
        position in its assembly context
        """
        return _fusion.Occurrence__set_transform(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the occurrence from the design. If this is the last occurrence
        referencing a specific Component, the component is also deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.Occurrence_deleteMe(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with the creation of this occurrence."""
        return _fusion.Occurrence__get_timelineObject(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this
        object in an assembly. This is only valid in the case where this
        references the component the object is defined within.
        Returns null in the case where the object is not in the context of an assembly
        but is already the native object.
        """
        return _fusion.Occurrence__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        The return type is strongly typed for each object.
        """
        return _fusion.Occurrence__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence.
        Fails if this object is not the NativeObject. 
        occurrence : The occurrence that represents the context you want to create this proxy in. 
        Returns the proxy for the occurrence in the context of the specified occurrence. 
        Returns null if it failed.
        """
        return _fusion.Occurrence_createForAssemblyContext(self, occurrence)

    def _get_isGrounded(self) -> "bool":
        r"""Gets and sets whether this occurrence is grounded or not."""
        return _fusion.Occurrence__get_isGrounded(self)

    def _set_isGrounded(self, value: "bool") -> "bool":
        r"""Gets and sets whether this occurrence is grounded or not."""
        return _fusion.Occurrence__set_isGrounded(self, value)

    def _get_isSelectable(self) -> "bool":
        r"""Gets and sets whether this occurrence is selectable or not."""
        return _fusion.Occurrence__get_isSelectable(self)

    def _set_isSelectable(self, value: "bool") -> "bool":
        r"""Gets and sets whether this occurrence is selectable or not."""
        return _fusion.Occurrence__set_isSelectable(self, value)

    def _get_isIsolated(self) -> "bool":
        r"""
        Gets and sets whether this occurrence is isolated in the UI. When an occurrence
        is isolated it is the only one visible in the user-interface. Only one occurrence
        can be isolated at a time so setting this property to true will unisolate an occurrence
        that is currently isolated. Setting this property to false for an occurrence that is
        current isolated will unisolate it so that no occurrence will be isolated.
        """
        return _fusion.Occurrence__get_isIsolated(self)

    def _set_isIsolated(self, value: "bool") -> "bool":
        r"""
        Gets and sets whether this occurrence is isolated in the UI. When an occurrence
        is isolated it is the only one visible in the user-interface. Only one occurrence
        can be isolated at a time so setting this property to true will unisolate an occurrence
        that is currently isolated. Setting this property to false for an occurrence that is
        current isolated will unisolate it so that no occurrence will be isolated.
        """
        return _fusion.Occurrence__set_isIsolated(self, value)

    def _get_isActive(self) -> "bool":
        r"""
        Gets whether this occurrence is the active edit target in the user interface.
        This is the same as checking the state of the radio button next to the occurrence in the browser.
        To activate the occurrence use the Activate method.
        """
        return _fusion.Occurrence__get_isActive(self)

    def activate(self) -> "bool":
        r"""
        Makes the occurrence the active edit target in the user interface. This is the same
        as enabling the radio button next to the occurrence in the browser. 
        Returns true if the activation was successful.
        """
        return _fusion.Occurrence_activate(self)

    def moveToComponent(self, targetOccurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Moves this occurrence from it's current component into the component owned by the specified occurrence.
        This occurrence and the target occurrence must be in the same context. 
        targetOccurrence : The target occurrence defines both the component and the transform to apply when moving the occurrence. The
        occurrence will be copied into the parent component of the target occurrence and the target occurrence also defines 
        the transform of how the occurrence will be copied so that the occurrence maintains it's same position in model space. 
        Returns the moved Occurrence or null in the case the move failed.
        """
        return _fusion.Occurrence_moveToComponent(self, targetOccurrence)

    def _get_physicalProperties(self) -> "adsk::core::Ptr< adsk::fusion::PhysicalProperties >":
        r"""
        Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc 
        of this occurrence. Property values will be calulated using the 'LowCalculationAccuracy' setting when using this property
        to get the PhysicalProperties object. To specify a higher calculation tolerance, use the getPhysicalProperties method instead.
        """
        return _fusion.Occurrence__get_physicalProperties(self)

    def _get_isReferencedComponent(self) -> "bool":
        r"""Gets if this occurrence is referencing an external component."""
        return _fusion.Occurrence__get_isReferencedComponent(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the bounding box of this occurrence."""
        return _fusion.Occurrence__get_boundingBox(self)

    def _get_joints(self) -> "adsk::core::Ptr< adsk::fusion::JointList >":
        r"""
        Returns the joints that affect the position of this occurrence. For example, if a joint has
        been created between this occurrence and another occurrence, this property will return that
        joint. If the occurrence is a proxy, the joints returned will also be proxies in the same 
        context as the occurrence.
        """
        return _fusion.Occurrence__get_joints(self)

    def _get_rigidGroups(self) -> "adsk::core::Ptr< adsk::fusion::RigidGroupList >":
        r"""
        Returns the rigid groups that this occurrence is a member of. If the occurrence is a proxy,
        the joints returned will also be proxies in the same context as the occurrence.
        """
        return _fusion.Occurrence__get_rigidGroups(self)

    def _get_asBuiltJoints(self) -> "adsk::core::Ptr< adsk::fusion::AsBuiltJointList >":
        r"""
        Returns the as-built joints that affect the position of this occurrence. If the occurrence is a proxy,
        the as-built joints returned will also be proxies in the same context as the occurrence.
        """
        return _fusion.Occurrence__get_asBuiltJoints(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.Occurrence__get_attributes(self)

    def _get_bRepBodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the body proxies for the B-Rep bodies in the component referenced by this occurrence.
        For example if you get the occurrences from the root component and then use this property to
        get the bodies from those occurrences, the bodies returned will return information in the context of the root
        component, not the component they actually exist in.
        """
        return _fusion.Occurrence__get_bRepBodies(self)

    def getPhysicalProperties(self, *args) -> "adsk::core::Ptr< adsk::fusion::PhysicalProperties >":
        r"""
        Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc 
        of this occurrence. 
        accuracy : Specifies the desired level of computational accuracy of the property calculations.
        The default value of 'LowCalculationAccuracy' returns results within a +/- 1% error margin.
        """
        return _fusion.Occurrence_getPhysicalProperties(self, *args)

    def _get_visibleOpacity(self) -> "double":
        r"""
        The user can set an override opacity for components and these opacity overrides combine if
        children and parent components have overrides. This property returns the actual opacity that is
        being used to render the occurence. To set the opacity use the opacity property of the Component object.
        """
        return _fusion.Occurrence__get_visibleOpacity(self)

    def breakLink(self) -> "bool":
        r"""
        When the component this occurrence references is an external reference (the isReferencedComponent property returns true),
        this will break the link and create a local Component that this occurrence will reference. The new local Component can 
        be accessed through the Occurrence using the component property.
        This method will fail if the occurrence is not referencing an external component. 
        Returns true if the break link was successful.
        """
        return _fusion.Occurrence_breakLink(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Occurrence object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same occurrence.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.Occurrence__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.Occurrence__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.Occurrence__get_isValid(self)

# Register Occurrence in _fusion:
_fusion.Occurrence_swigregister(Occurrence)

def Occurrence_classType() -> "char const *":
    return _fusion.Occurrence_classType()


Occurrence.sourceComponent = property(Occurrence._get_sourceComponent, doc="This is the sourceComponent for the occurrence and is affected\nby the assembly context.\nThis is the top-level component where the path begins.")


Occurrence.childOccurrences = property(Occurrence._get_childOccurrences, doc="Returns a read only list of child occurrences where only the occurrences\nin this occurrence's AssemblyContext are returned .")


Occurrence.component = property(Occurrence._get_component, doc="The component this occurrence references.")


Occurrence.name = property(Occurrence._get_name, doc="The name of the occurrence. This is the name as seen in the browser. It is a reflection\nof the component name with an added counter suffix (i.e. 'OccurrenceName:1').")


Occurrence.fullPathName = property(Occurrence._get_fullPathName, doc="The name of the occurrence, including the full path of occurrences as seen in the browser.\nThe top-level component will depend on the context but will typically be the root component\nof the design. A name for an occurrence that is at the third level of an assembly could be\n'Sub1:1+Sub2:1+PartA:1'.")


Occurrence.appearance = property(Occurrence._get_appearance, Occurrence._set_appearance, doc="Read-write property that gets and sets the appearance override for this occurrence.\nThis property can return null indicating there is no override appearance and that the\ncontents of the occurrence are displayed using there defined appearance.\nSetting the property to null will remove any override appearance for this occurrence.")


Occurrence.isLightBulbOn = property(Occurrence._get_isLightBulbOn, Occurrence._set_isLightBulbOn, doc="Gets and sets if the light bulb of this occurrence as displayed in the browser is on or off.\nAn occurrence will only be visible if the light bulb is switched on. However,\nthe light bulb can be on and the occurrence still invisible if a higher level occurrence\nin the assembly context is not visible because its light bulb is off.")


Occurrence.isVisible = property(Occurrence._get_isVisible, doc="Gets whether the occurrence is visible.\nThis property is affected by the assembly context.")


Occurrence.transform = property(Occurrence._get_transform, Occurrence._set_transform, doc="Gets and sets the 3d matrix data that defines this occurrences orientation and\nposition in its assembly context")


Occurrence.timelineObject = property(Occurrence._get_timelineObject, doc="Returns the timeline object associated with the creation of this occurrence.")


Occurrence.assemblyContext = property(Occurrence._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this\nobject in an assembly. This is only valid in the case where this\nreferences the component the object is defined within.\nReturns null in the case where the object is not in the context of an assembly\nbut is already the native object.")


Occurrence.nativeObject = property(Occurrence._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.\nThe return type is strongly typed for each object.")


Occurrence.isGrounded = property(Occurrence._get_isGrounded, Occurrence._set_isGrounded, doc="Gets and sets whether this occurrence is grounded or not.")


Occurrence.isSelectable = property(Occurrence._get_isSelectable, Occurrence._set_isSelectable, doc="Gets and sets whether this occurrence is selectable or not.")


Occurrence.isIsolated = property(Occurrence._get_isIsolated, Occurrence._set_isIsolated, doc="Gets and sets whether this occurrence is isolated in the UI. When an occurrence\nis isolated it is the only one visible in the user-interface. Only one occurrence\ncan be isolated at a time so setting this property to true will unisolate an occurrence\nthat is currently isolated. Setting this property to false for an occurrence that is\ncurrent isolated will unisolate it so that no occurrence will be isolated.")


Occurrence.isActive = property(Occurrence._get_isActive, doc="Gets whether this occurrence is the active edit target in the user interface.\nThis is the same as checking the state of the radio button next to the occurrence in the browser.\nTo activate the occurrence use the Activate method.")


Occurrence.physicalProperties = property(Occurrence._get_physicalProperties, doc="Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc\nof this occurrence. Property values will be calulated using the 'LowCalculationAccuracy' setting when using this property\nto get the PhysicalProperties object. To specify a higher calculation tolerance, use the getPhysicalProperties method instead.")


Occurrence.isReferencedComponent = property(Occurrence._get_isReferencedComponent, doc="Gets if this occurrence is referencing an external component.")


Occurrence.boundingBox = property(Occurrence._get_boundingBox, doc="Returns the bounding box of this occurrence.")


Occurrence.joints = property(Occurrence._get_joints, doc="Returns the joints that affect the position of this occurrence. For example, if a joint has\nbeen created between this occurrence and another occurrence, this property will return that\njoint. If the occurrence is a proxy, the joints returned will also be proxies in the same\ncontext as the occurrence.")


Occurrence.rigidGroups = property(Occurrence._get_rigidGroups, doc="Returns the rigid groups that this occurrence is a member of. If the occurrence is a proxy,\nthe joints returned will also be proxies in the same context as the occurrence.")


Occurrence.asBuiltJoints = property(Occurrence._get_asBuiltJoints, doc="Returns the as-built joints that affect the position of this occurrence. If the occurrence is a proxy,\nthe as-built joints returned will also be proxies in the same context as the occurrence.")


Occurrence.attributes = property(Occurrence._get_attributes, doc="Returns the collection of attributes associated with this face.")


Occurrence.bRepBodies = property(Occurrence._get_bRepBodies, doc="Returns the body proxies for the B-Rep bodies in the component referenced by this occurrence.\nFor example if you get the occurrences from the root component and then use this property to\nget the bodies from those occurrences, the bodies returned will return information in the context of the root\ncomponent, not the component they actually exist in.")


Occurrence.visibleOpacity = property(Occurrence._get_visibleOpacity, doc="The user can set an override opacity for components and these opacity overrides combine if\nchildren and parent components have overrides. This property returns the actual opacity that is\nbeing used to render the occurence. To set the opacity use the opacity property of the Component object.")


Occurrence.entityToken = property(Occurrence._get_entityToken, doc="Returns a token for the Occurrence object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same occurrence.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.")


Occurrence.cast = lambda arg: arg if isinstance(arg, Occurrence) else None

class OccurrenceList(Base):
    r"""Provides a list of occurrences."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::OccurrenceList *":
        return _fusion.OccurrenceList___deref__(self)

    def __eq__(self, rhs: "OccurrenceList") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.OccurrenceList___eq__(self, rhs)


    def __ne__(self, rhs: "OccurrenceList") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.OccurrenceList___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.OccurrenceList___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::Occurrence >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.OccurrenceList___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.OccurrenceList_classType()
    __swig_destroy__ = _fusion.delete_OccurrenceList

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the specified occurrence using an index into the collection. 
        index : The index of the occurrence within the collection to return. The first item has an index of 0. 
        Returns the specified occurrence or null in the case of an invalid index.
        """
        return _fusion.OccurrenceList_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of occurrences in the collection."""
        return _fusion.OccurrenceList__get_count(self)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the specified occurrence using the name of the occurrence. 
        name : The name of the occurrence to return. 
        Returns the occurrence or null if an invalid name was specified
        """
        return _fusion.OccurrenceList_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.OccurrenceList__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.OccurrenceList__get_isValid(self)

# Register OccurrenceList in _fusion:
_fusion.OccurrenceList_swigregister(OccurrenceList)

def OccurrenceList_classType() -> "char const *":
    return _fusion.OccurrenceList_classType()


OccurrenceList.count = property(OccurrenceList._get_count, doc="Returns the number of occurrences in the collection.")


OccurrenceList.cast = lambda arg: arg if isinstance(arg, OccurrenceList) else None

class Occurrences(Base):
    r"""
    Provides access to occurrences within a component and provides
    methods to create new occurrences.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::Occurrences *":
        return _fusion.Occurrences___deref__(self)

    def __eq__(self, rhs: "Occurrences") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.Occurrences___eq__(self, rhs)


    def __ne__(self, rhs: "Occurrences") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.Occurrences___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.Occurrences___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::Occurrence >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.Occurrences___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.Occurrences_classType()
    __swig_destroy__ = _fusion.delete_Occurrences

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Function that returns the specified occurrence using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.Occurrences_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of occurrences in the collection."""
        return _fusion.Occurrences__get_count(self)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the specified occurrence using the name of the occurrence. 
        name : The name of the occurrence to return. 
        Returns the occurrence or null if an invalid name was specified
        """
        return _fusion.Occurrences_itemByName(self, name)

    def addExistingComponent(self, component: "Component", transform: "Matrix3D") -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Method that creates a new occurrence using an existing component. This is the equivalent
        of copying and pasting an occurrence in the user interface. 
        component : The existing component to create a new occurrence of. 
        transform : A transform that defines the location for the new occurrence 
        Returns the newly created occurrence or null if the creation failed.
        """
        return _fusion.Occurrences_addExistingComponent(self, component, transform)

    def addNewComponent(self, transform: "Matrix3D") -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Method that creates a new component and an occurrence that references it. 
        transform : A transform that defines the location for the new occurrence. 
        Returns the newly created occurrence or null if the creation failed.
        """
        return _fusion.Occurrences_addNewComponent(self, transform)

    def _get_asList(self) -> "adsk::core::Ptr< adsk::fusion::OccurrenceList >":
        r"""
        Returns the contents of this collection as an OccurrencesList object. This
        is useful when writing a function that traverses an assembly.
        """
        return _fusion.Occurrences__get_asList(self)

    def addByInsert(self, dataFile: "DataFile", transform: "Matrix3D", isReferencedComponent: "bool") -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Method that inserts an existing file. 
        dataFile : The dataFile to insert. 
        transform : A transform that defines the location for the new occurrence. 
        isReferencedComponent : Indicates if the insert is to be an external reference or embedded within this document.
        This method will fail if the dataFile being inserted is not from the same project as the document 
        it is being inserted into while isReferencedComponent is True. 
        Returns the newly created occurrence or null if the insert failed.
        Insert will fail if the dataFile being inserted is not from the same project as the document 
        it is being inserted into while isReferencedComponent is True.
        """
        return _fusion.Occurrences_addByInsert(self, dataFile, transform, isReferencedComponent)

    def _get_objectType(self) -> "char const *":
        return _fusion.Occurrences__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.Occurrences__get_isValid(self)

# Register Occurrences in _fusion:
_fusion.Occurrences_swigregister(Occurrences)

def Occurrences_classType() -> "char const *":
    return _fusion.Occurrences_classType()


Occurrences.count = property(Occurrences._get_count, doc="Returns the number of occurrences in the collection.")


Occurrences.asList = property(Occurrences._get_asList, doc="Returns the contents of this collection as an OccurrencesList object. This\nis useful when writing a function that traverses an assembly.")


Occurrences.cast = lambda arg: arg if isinstance(arg, Occurrences) else None

class OffsetFacesFeatures(Base):
    r"""
    Collection that provides access to all of the existing Offset Face features in a design.
    Offset Face features are created in the UI using the 'Press Pull' command.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::OffsetFacesFeatures *":
        return _fusion.OffsetFacesFeatures___deref__(self)

    def __eq__(self, rhs: "OffsetFacesFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.OffsetFacesFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "OffsetFacesFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.OffsetFacesFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.OffsetFacesFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::OffsetFacesFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.OffsetFacesFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.OffsetFacesFeatures_classType()
    __swig_destroy__ = _fusion.delete_OffsetFacesFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::OffsetFacesFeature >":
        r"""
        Function that returns the specified Offset Face feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.OffsetFacesFeatures_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::OffsetFacesFeature >":
        r"""
        Function that returns the specified Offset Face feature using the name of the feature.
        Offset Face features are created in the UI using the 'Press Pull' command. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.OffsetFacesFeatures_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""
        The number of Offset Face features in the collection. 
        Offset Face features are created in the UI using the 'Press Pull' command.
        """
        return _fusion.OffsetFacesFeatures__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.OffsetFacesFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.OffsetFacesFeatures__get_isValid(self)

# Register OffsetFacesFeatures in _fusion:
_fusion.OffsetFacesFeatures_swigregister(OffsetFacesFeatures)

def OffsetFacesFeatures_classType() -> "char const *":
    return _fusion.OffsetFacesFeatures_classType()


OffsetFacesFeatures.count = property(OffsetFacesFeatures._get_count, doc="The number of Offset Face features in the collection.\nOffset Face features are created in the UI using the 'Press Pull' command.")


OffsetFacesFeatures.cast = lambda arg: arg if isinstance(arg, OffsetFacesFeatures) else None

class OffsetFeatureInput(Base):
    r"""This class defines the methods and properties that pertain to the definition of a offset feature."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::OffsetFeatureInput *":
        return _fusion.OffsetFeatureInput___deref__(self)

    def __eq__(self, rhs: "OffsetFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.OffsetFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "OffsetFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.OffsetFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.OffsetFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_OffsetFeatureInput

    def _get_entities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""An ObjectCollection containing the BRepFace objects being offset."""
        return _fusion.OffsetFeatureInput__get_entities(self)

    def _set_entities(self, value: "ObjectCollection") -> "bool":
        r"""An ObjectCollection containing the BRepFace objects being offset."""
        return _fusion.OffsetFeatureInput__set_entities(self, value)

    def _get_isChainSelection(self) -> "bool":
        r"""Get and sets whether faces that are tangentially connected to the input faces will be included in the offset."""
        return _fusion.OffsetFeatureInput__get_isChainSelection(self)

    def _set_isChainSelection(self, value: "bool") -> "bool":
        r"""Get and sets whether faces that are tangentially connected to the input faces will be included in the offset."""
        return _fusion.OffsetFeatureInput__set_isChainSelection(self, value)

    def _get_distance(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Gets and sets the ValueInput object that defines the offset distance. A positive distance value results
        in an offset in the positive normal direction of the faces.
        """
        return _fusion.OffsetFeatureInput__get_distance(self)

    def _set_distance(self, value: "ValueInput") -> "bool":
        r"""
        Gets and sets the ValueInput object that defines the offset distance. A positive distance value results
        in an offset in the positive normal direction of the faces.
        """
        return _fusion.OffsetFeatureInput__set_distance(self, value)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations":
        r"""Gets and sets the feature operation to perform. Can be 'NewBodyFeatureOperation' or 'NewComponentFeatureOperation'."""
        return _fusion.OffsetFeatureInput__get_operation(self)

    def _set_operation(self, value: "FeatureOperations") -> "bool":
        r"""Gets and sets the feature operation to perform. Can be 'NewBodyFeatureOperation' or 'NewComponentFeatureOperation'."""
        return _fusion.OffsetFeatureInput__set_operation(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.OffsetFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.OffsetFeatureInput__set_targetBaseFeature(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.OffsetFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.OffsetFeatureInput__get_isValid(self)

# Register OffsetFeatureInput in _fusion:
_fusion.OffsetFeatureInput_swigregister(OffsetFeatureInput)

def OffsetFeatureInput_classType() -> "char const *":
    return _fusion.OffsetFeatureInput_classType()


OffsetFeatureInput.entities = property(OffsetFeatureInput._get_entities, OffsetFeatureInput._set_entities, doc="An ObjectCollection containing the BRepFace objects being offset.")


OffsetFeatureInput.isChainSelection = property(OffsetFeatureInput._get_isChainSelection, OffsetFeatureInput._set_isChainSelection, doc="Get and sets whether faces that are tangentially connected to the input faces will be included in the offset.")


OffsetFeatureInput.distance = property(OffsetFeatureInput._get_distance, OffsetFeatureInput._set_distance, doc="Gets and sets the ValueInput object that defines the offset distance. A positive distance value results\nin an offset in the positive normal direction of the faces.")


OffsetFeatureInput.operation = property(OffsetFeatureInput._get_operation, OffsetFeatureInput._set_operation, doc="Gets and sets the feature operation to perform. Can be 'NewBodyFeatureOperation' or 'NewComponentFeatureOperation'.")


OffsetFeatureInput.targetBaseFeature = property(OffsetFeatureInput._get_targetBaseFeature, OffsetFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


OffsetFeatureInput.cast = lambda arg: arg if isinstance(arg, OffsetFeatureInput) else None

class OffsetFeatures(Base):
    r"""
    Collection that provides access to all of the existing Offset features in a component
    and supports the ability to create new Offset features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::OffsetFeatures *":
        return _fusion.OffsetFeatures___deref__(self)

    def __eq__(self, rhs: "OffsetFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.OffsetFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "OffsetFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.OffsetFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.OffsetFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::OffsetFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.OffsetFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.OffsetFeatures_classType()
    __swig_destroy__ = _fusion.delete_OffsetFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::OffsetFeature >":
        r"""
        Function that returns the specified offset feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.OffsetFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of Offset features in the collection."""
        return _fusion.OffsetFeatures__get_count(self)

    def createInput(self, entities: "ObjectCollection", distance: "ValueInput", operation: "FeatureOperations", isChainSelection: "bool"=True) -> "adsk::core::Ptr< adsk::fusion::OffsetFeatureInput >":
        r"""
        Creates a OffsetFeatureInput object. Use properties and methods on this object
        to define the offset feature you want to create and then use the Add method, passing in 
        the OffsetFeatureInput object to create the feature. 
        entities : An ObjectCollection containing the BRepFace objects to offset. Additional faces may be
        automatically used depending on the value of the isChainSelection argument.
        Input faces need not be from the same body. 
        distance : ValueInput object that defines the offset distance. A positive value is in the positive
        normal direction of the face being offset. 
        operation : The feature operation to perform. 'NewBodyFeatureOperation' and 'NewComponentFeatureOperation' are the 
        options supported. 
        isChainSelection : A boolean value for setting whether or not faces that are tangentially connected to 
        the input faces (if any) will be included in the offset. The default value is true. 
        Returns the newly created OffsetFeatureInput object or null if the creation failed.
        """
        return _fusion.OffsetFeatures_createInput(self, entities, distance, operation, isChainSelection)

    def add(self, input: "OffsetFeatureInput") -> "adsk::core::Ptr< adsk::fusion::OffsetFeature >":
        r"""
        Creates a new offset feature. 
        input : A FeatureInput object that defines the desired offset feature. Use the createInput 
        method to create a new OffsetFeatureInput object and then use methods on it 
        (the OffsetFeatureInput object) to define the offset feature. 
        Returns the newly created OffsetFeature object or null if the creation failed.
        """
        return _fusion.OffsetFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::OffsetFeature >":
        r"""
        Function that returns the specified offset feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.OffsetFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.OffsetFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.OffsetFeatures__get_isValid(self)

# Register OffsetFeatures in _fusion:
_fusion.OffsetFeatures_swigregister(OffsetFeatures)

def OffsetFeatures_classType() -> "char const *":
    return _fusion.OffsetFeatures_classType()


OffsetFeatures.count = property(OffsetFeatures._get_count, doc="The number of Offset features in the collection.")


OffsetFeatures.cast = lambda arg: arg if isinstance(arg, OffsetFeatures) else None

class Parameter(Base):
    r"""The base class Parameter object that can represent model or user parameters."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::Parameter *":
        return _fusion.Parameter___deref__(self)

    def __eq__(self, rhs: "Parameter") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.Parameter___eq__(self, rhs)


    def __ne__(self, rhs: "Parameter") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.Parameter___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.Parameter_classType()
    __swig_destroy__ = _fusion.delete_Parameter

    def _get_value(self) -> "double":
        r"""
        Gets and sets the real value (a double) of the parameter in database units. 
        Setting this property will set/reset the expression value for this parameter
        """
        return _fusion.Parameter__get_value(self)

    def _set_value(self, value: "double") -> "bool":
        r"""
        Gets and sets the real value (a double) of the parameter in database units. 
        Setting this property will set/reset the expression value for this parameter
        """
        return _fusion.Parameter__set_value(self, value)

    def _get_expression(self) -> "std::string":
        r"""Gets and sets the expression (ie. '22.064 mm') used to calculate the value of the parameter"""
        return _fusion.Parameter__get_expression(self)

    def _set_expression(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the expression (ie. '22.064 mm') used to calculate the value of the parameter"""
        return _fusion.Parameter__set_expression(self, value)

    def _get_name(self) -> "std::string":
        r"""
        Gets and sets the name of the parameter. Setting the name can fail if the name 
        is not unique with respect to all other parameters in the design.
        """
        return _fusion.Parameter__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the name of the parameter. Setting the name can fail if the name 
        is not unique with respect to all other parameters in the design.
        """
        return _fusion.Parameter__set_name(self, value)

    def _get_unit(self) -> "std::string":
        r"""
        The unit type associated with this parameter. An empty string is returned for parameters
        that don't have a unit type.
        """
        return _fusion.Parameter__get_unit(self)

    def _get_comment(self) -> "std::string":
        r"""The comment associated with this parameter"""
        return _fusion.Parameter__get_comment(self)

    def _set_comment(self, value: "std::string const &") -> "bool":
        r"""The comment associated with this parameter"""
        return _fusion.Parameter__set_comment(self, value)

    def _get_isFavorite(self) -> "bool":
        r"""
        Gets and sets whether this parameter is included in the Favorites list in the
        parameters dialog
        """
        return _fusion.Parameter__get_isFavorite(self)

    def _set_isFavorite(self, value: "bool") -> "bool":
        r"""
        Gets and sets whether this parameter is included in the Favorites list in the
        parameters dialog
        """
        return _fusion.Parameter__set_isFavorite(self, value)

    def _get_dependentParameters(self) -> "adsk::core::Ptr< adsk::fusion::ParameterList >":
        r"""
        Returns a list of parameters that are dependent on this parameter as a result
        of this parameter being referenced in their equation.
        """
        return _fusion.Parameter__get_dependentParameters(self)

    def _get_isDeletable(self) -> "bool":
        r"""
        Gets if this parameter can be deleted. Parameters that cannot be deleted are: Model Parameters and 
        User Parameters that have dependents.
        """
        return _fusion.Parameter__get_isDeletable(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.Parameter__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Parameter object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same parameter.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.Parameter__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.Parameter__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.Parameter__get_isValid(self)

# Register Parameter in _fusion:
_fusion.Parameter_swigregister(Parameter)

def Parameter_classType() -> "char const *":
    return _fusion.Parameter_classType()


Parameter.value = property(Parameter._get_value, Parameter._set_value, doc="Gets and sets the real value (a double) of the parameter in database units.\nSetting this property will set/reset the expression value for this parameter")


Parameter.expression = property(Parameter._get_expression, Parameter._set_expression, doc="Gets and sets the expression (ie. '22.064 mm') used to calculate the value of the parameter")


Parameter.name = property(Parameter._get_name, Parameter._set_name, doc="Gets and sets the name of the parameter. Setting the name can fail if the name\nis not unique with respect to all other parameters in the design.")


Parameter.unit = property(Parameter._get_unit, doc="The unit type associated with this parameter. An empty string is returned for parameters\nthat don't have a unit type.")


Parameter.comment = property(Parameter._get_comment, Parameter._set_comment, doc="The comment associated with this parameter")


Parameter.isFavorite = property(Parameter._get_isFavorite, Parameter._set_isFavorite, doc="Gets and sets whether this parameter is included in the Favorites list in the\nparameters dialog")


Parameter.dependentParameters = property(Parameter._get_dependentParameters, doc="Returns a list of parameters that are dependent on this parameter as a result\nof this parameter being referenced in their equation.")


Parameter.isDeletable = property(Parameter._get_isDeletable, doc="Gets if this parameter can be deleted. Parameters that cannot be deleted are: Model Parameters and\nUser Parameters that have dependents.")


Parameter.attributes = property(Parameter._get_attributes, doc="Returns the collection of attributes associated with this face.")


Parameter.entityToken = property(Parameter._get_entityToken, doc="Returns a token for the Parameter object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same parameter.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.")


Parameter.cast = lambda arg: arg if isinstance(arg, Parameter) else None

class ParameterList(Base):
    r"""Transient object used to pass a set of parameters."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ParameterList *":
        return _fusion.ParameterList___deref__(self)

    def __eq__(self, rhs: "ParameterList") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ParameterList___eq__(self, rhs)


    def __ne__(self, rhs: "ParameterList") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ParameterList___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.ParameterList___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::Parameter >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.ParameterList___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ParameterList_classType()

    @staticmethod
    def create() -> "adsk::core::Ptr< adsk::fusion::ParameterList >":
        return _fusion.ParameterList_create()
    __swig_destroy__ = _fusion.delete_ParameterList

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::Parameter >":
        r"""
        Function that returns the specified parameter using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ParameterList_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::Parameter >":
        r"""
        Returns the specified parameter using the name of the parameter
        as it is displayed in the parameters dialog 
        name : The name of the parameter as it is displayed in the parameters dialog 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.ParameterList_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""Returns the number of parameters in the collection."""
        return _fusion.ParameterList__get_count(self)

    def add(self, parameter: "Parameter") -> "bool":
        r"""
        Adds a parameter to the list. This does not create a 
        new parameter, it adds an existing parameter to the list.
        Note that duplicates can exist in the list. 
        parameter : The existing parameter to add to the list 
        Returns true if successful. This method will fail if the list is read-only
        """
        return _fusion.ParameterList_add(self, parameter)

    def removeByIndex(self, index: "size_t") -> "bool":
        r"""
        Method that removes a parameter from the list using the index of the item
        in the list
        Will fail if the list is read only. 
        index : The index of the parameter to be removed from the list 
        Returns true if successful. This method will fail if the list is read-only
        """
        return _fusion.ParameterList_removeByIndex(self, index)

    def removeByItem(self, item: "Parameter") -> "bool":
        r"""
        Method that removes a parameter from the list by specifying the parameter (item) 
        to remove 
        item : The parameter item to remove from the list 
        Returns true if successful. This method will fail if the list is read-only
        """
        return _fusion.ParameterList_removeByItem(self, item)

    def find(self, parameter: "Parameter", startIndex: "size_t"=0) -> "int":
        r"""
        Finds the specified parameter in the list. The search can be started at a specified 
        index rather than from the beginning of the list.
        If not found, -1 is returned. 
        parameter : The parameter to find 
        startIndex : the index in the list to start the search from 
        Returns the index of the parameter found in the list.
        """
        return _fusion.ParameterList_find(self, parameter, startIndex)

    def contains(self, parameter: "Parameter") -> "bool":
        r"""
        Indicates whether or not ParameterList collection contains a specified parameter 
        parameter : The parameter to look for in the list 
        Returns true if list contains the specified parameter
        """
        return _fusion.ParameterList_contains(self, parameter)

    def _get_isReadOnly(self) -> "bool":
        r"""
        Indicates if the list is read-only
        Some lists returned by API calls (instead of lists created by the
        user) are read only. Items cannot be added or remove from such a list.
        """
        return _fusion.ParameterList__get_isReadOnly(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ParameterList__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ParameterList__get_isValid(self)

# Register ParameterList in _fusion:
_fusion.ParameterList_swigregister(ParameterList)

def ParameterList_classType() -> "char const *":
    return _fusion.ParameterList_classType()

def ParameterList_create() -> "adsk::core::Ptr< adsk::fusion::ParameterList >":
    return _fusion.ParameterList_create()


ParameterList.count = property(ParameterList._get_count, doc="Returns the number of parameters in the collection.")


ParameterList.isReadOnly = property(ParameterList._get_isReadOnly, doc="Indicates if the list is read-only\nSome lists returned by API calls (instead of lists created by the\nuser) are read only. Items cannot be added or remove from such a list.")


ParameterList.cast = lambda arg: arg if isinstance(arg, ParameterList) else None

class PatchFeatureInput(Base):
    r"""This class defines the methods and properties that pertain to the definition of a patch feature."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::PatchFeatureInput *":
        return _fusion.PatchFeatureInput___deref__(self)

    def __eq__(self, rhs: "PatchFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.PatchFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "PatchFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.PatchFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.PatchFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_PatchFeatureInput

    def _get_boundaryCurve(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and set the input geometry that will be used to define the boundary. This can be a sketch profile, 
        a single sketch curve, a single B-Rep edge, or a Path object. 
        If a single sketch curve or B-Rep edge is input, that is not closed, Fusion 360 will automatically find connected sketch curves 
        or B-Rep edges in order to define a closed loop. All sketch curves are valid as input. BRepEdges are valid if they are 
        an 'open' edge, which means they are only used by one face.
        If a Path is input it must define a closed shape and the B-Rep edges must be valid 'open' edges.
        """
        return _fusion.PatchFeatureInput__get_boundaryCurve(self)

    def _set_boundaryCurve(self, value: "Base") -> "bool":
        r"""
        Gets and set the input geometry that will be used to define the boundary. This can be a sketch profile, 
        a single sketch curve, a single B-Rep edge, or a Path object. 
        If a single sketch curve or B-Rep edge is input, that is not closed, Fusion 360 will automatically find connected sketch curves 
        or B-Rep edges in order to define a closed loop. All sketch curves are valid as input. BRepEdges are valid if they are 
        an 'open' edge, which means they are only used by one face.
        If a Path is input it must define a closed shape and the B-Rep edges must be valid 'open' edges.
        """
        return _fusion.PatchFeatureInput__set_boundaryCurve(self, value)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations":
        r"""
        Gets and sets the type of operation performed by the patch feature. Only 'NewBodyFeatureOperation' and 'NewComponentFeatureOperation' are 
        valid operations for patch features.
        """
        return _fusion.PatchFeatureInput__get_operation(self)

    def _set_operation(self, value: "FeatureOperations") -> "bool":
        r"""
        Gets and sets the type of operation performed by the patch feature. Only 'NewBodyFeatureOperation' and 'NewComponentFeatureOperation' are 
        valid operations for patch features.
        """
        return _fusion.PatchFeatureInput__set_operation(self, value)

    def _get_continuity(self) -> "adsk::fusion::SurfaceContinuityTypes":
        r"""
        Gets and sets type of surface continuity to use when matching boundary edges to face edges. When a new PatchFeatureInput is 
        created, this is initialized to ConnectedSurfaceContinuityType. This value is ignored when creating a patch for sketch curves.
        """
        return _fusion.PatchFeatureInput__get_continuity(self)

    def _set_continuity(self, value: "SurfaceContinuityTypes") -> "bool":
        r"""
        Gets and sets type of surface continuity to use when matching boundary edges to face edges. When a new PatchFeatureInput is 
        created, this is initialized to ConnectedSurfaceContinuityType. This value is ignored when creating a patch for sketch curves.
        """
        return _fusion.PatchFeatureInput__set_continuity(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.PatchFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.PatchFeatureInput__set_targetBaseFeature(self, value)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the Patch feature is created based on geometry (e.g. a profile, edges, faces)
        in another component AND (the Patch feature) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.PatchFeatureInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, value: "Occurrence") -> "bool":
        r"""
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the Patch feature is created based on geometry (e.g. a profile, edges, faces)
        in another component AND (the Patch feature) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.PatchFeatureInput__set_creationOccurrence(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.PatchFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.PatchFeatureInput__get_isValid(self)

# Register PatchFeatureInput in _fusion:
_fusion.PatchFeatureInput_swigregister(PatchFeatureInput)

def PatchFeatureInput_classType() -> "char const *":
    return _fusion.PatchFeatureInput_classType()


PatchFeatureInput.boundaryCurve = property(PatchFeatureInput._get_boundaryCurve, PatchFeatureInput._set_boundaryCurve, doc="Gets and set the input geometry that will be used to define the boundary. This can be a sketch profile,\na single sketch curve, a single B-Rep edge, or a Path object.\nIf a single sketch curve or B-Rep edge is input, that is not closed, Fusion 360 will automatically find connected sketch curves\nor B-Rep edges in order to define a closed loop. All sketch curves are valid as input. BRepEdges are valid if they are\nan 'open' edge, which means they are only used by one face.\nIf a Path is input it must define a closed shape and the B-Rep edges must be valid 'open' edges.")


PatchFeatureInput.operation = property(PatchFeatureInput._get_operation, PatchFeatureInput._set_operation, doc="Gets and sets the type of operation performed by the patch feature. Only 'NewBodyFeatureOperation' and 'NewComponentFeatureOperation' are\nvalid operations for patch features.")


PatchFeatureInput.continuity = property(PatchFeatureInput._get_continuity, PatchFeatureInput._set_continuity, doc="Gets and sets type of surface continuity to use when matching boundary edges to face edges. When a new PatchFeatureInput is\ncreated, this is initialized to ConnectedSurfaceContinuityType. This value is ignored when creating a patch for sketch curves.")


PatchFeatureInput.targetBaseFeature = property(PatchFeatureInput._get_targetBaseFeature, PatchFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


PatchFeatureInput.creationOccurrence = property(PatchFeatureInput._get_creationOccurrence, PatchFeatureInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an Occurrence for creation needs to be\nspecified when the Patch feature is created based on geometry (e.g. a profile, edges, faces)\nin another component AND (the Patch feature) is not in the root component.\nThe CreationOccurrence is analogous to the active occurrence in the UI")


PatchFeatureInput.cast = lambda arg: arg if isinstance(arg, PatchFeatureInput) else None

class PatchFeatures(Base):
    r"""
    Collection that provides access to all of the existing Patch features in a component
    and supports the ability to create new Patch features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::PatchFeatures *":
        return _fusion.PatchFeatures___deref__(self)

    def __eq__(self, rhs: "PatchFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.PatchFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "PatchFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.PatchFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.PatchFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::PatchFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.PatchFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.PatchFeatures_classType()
    __swig_destroy__ = _fusion.delete_PatchFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::PatchFeature >":
        r"""
        Function that returns the specified patch feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.PatchFeatures_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::PatchFeature >":
        r"""
        Function that returns the specified patch feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.PatchFeatures_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of Patch features in the collection."""
        return _fusion.PatchFeatures__get_count(self)

    def createInput(self, boundaryCurve: "Base", operation: "FeatureOperations") -> "adsk::core::Ptr< adsk::fusion::PatchFeatureInput >":
        r"""
        Creates a PatchFeatureInput object. Use properties and methods on the returned PatchFeatureInput
        object to set other settings. The PatchFeatureInput object can then be used as input to the 
        add method to create the patch feature. 
        boundaryCurve : Defines the input geometry that will be used to define the boundary. This can be a sketch profile, 
        a single sketch curve, a single B-Rep edge, or a Path object. 
        If a single sketch curve or B-Rep edge is input, that is not closed, Fusion 360 will automatically find connected sketch curves 
        or B-Rep edges in order to define a closed loop. All sketch curves are valid as input. BRepEdges are valid if they are 
        an 'open' edge, which means they are only used by one face.
        If a Path is input it must define a closed shape and the B-Rep edges must be valid 'open' edges. 
        operation : The feature operation to perform. Only 'NewBodyFeatureOperation' and 'NewComponentFeatureOperation' are 
        valid operations for patch features. 
        Returns the newly created PatchFeatureInput object or null if the creation failed.
        """
        return _fusion.PatchFeatures_createInput(self, boundaryCurve, operation)

    def add(self, input: "PatchFeatureInput") -> "adsk::core::Ptr< adsk::fusion::PatchFeature >":
        r"""
        Creates a new patch feature. 
        input : A PatchFeatureInput object that defines the desired patch feature. Use the createInput 
        method to create a new PatchFeatureInput object and then use methods on it 
        (the PatchFeatureInput object) to define the patch feature. 
        Returns the newly created PatchFeature object or null if the creation failed.
        """
        return _fusion.PatchFeatures_add(self, input)

    def _get_objectType(self) -> "char const *":
        return _fusion.PatchFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.PatchFeatures__get_isValid(self)

# Register PatchFeatures in _fusion:
_fusion.PatchFeatures_swigregister(PatchFeatures)

def PatchFeatures_classType() -> "char const *":
    return _fusion.PatchFeatures_classType()


PatchFeatures.count = property(PatchFeatures._get_count, doc="The number of Patch features in the collection.")


PatchFeatures.cast = lambda arg: arg if isinstance(arg, PatchFeatures) else None

class Path(Base):
    r"""
    The Path object represents a single set of connected curves. The order of the objects within the collection is the same as the connection order of the entities.
    When using a Path to create a feature, the Path serves as a way to pass in the set of sketch entities and edges. When
    getting the Path of an existing feature it returns the actual path used to define the feature geometry. In cases like a
    sweep feature, this can result in using portions of the original input sketch curves or edges and the returned path
    will provide these 'partial' curves as the PathEntity objects.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::Path *":
        return _fusion.Path___deref__(self)

    def __eq__(self, rhs: "Path") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.Path___eq__(self, rhs)


    def __ne__(self, rhs: "Path") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.Path___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.Path___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::PathEntity >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.Path___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.Path_classType()

    @staticmethod
    def create(curves: "Base", chainOptions: "ChainedCurveOptions") -> "adsk::core::Ptr< adsk::fusion::Path >":
        return _fusion.Path_create(curves, chainOptions)
    __swig_destroy__ = _fusion.delete_Path

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::PathEntity >":
        r"""
        Function that returns the specified PathEntity using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.Path_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of curves in the path."""
        return _fusion.Path__get_count(self)

    def _get_isClosed(self) -> "bool":
        r"""Indicates if the path is closed or not. Returns True in the case of a closed path."""
        return _fusion.Path__get_isClosed(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""This property is not supported for the Path object."""
        return _fusion.Path__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::Path >":
        r"""This property is not supported for the Path object."""
        return _fusion.Path__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::Path >":
        r"""
        This method is not supported for the Path object. 
        occurrence :
        """
        return _fusion.Path_createForAssemblyContext(self, occurrence)

    def addCurves(self, curves: "Base", chainOptions: "ChainedCurveOptions") -> "bool":
        r"""
        Adds additional curves to the existing path. This can be useful when creating a complex path for a sweep and you
        want to include sets of curves from multiple sketches and edges from multiple bodies. 
        curves : A SketchCurve, BRepEdge, or an ObjectCollection containing multiple sketch entities and/or BRepEdges. If a single sketch curve
        or BRepEdge is input the chainCurves argument is used to determine if connected curves or edges (they do not need to be tangent)
        should be automatically found. Searching for connected curves is only performed within the same sketch or open edges on the same
        body. If multiple curves are provided the chainCurves argument is treated as false so only the specified input curves are
        used. The input curves need to geometrically connect for a path to be created. 
        chainOptions : If a single SketchCurve or BRepEdge is input, this argument is used to specify the rules in how chained entities should be found. If
        an ObjectCollection is input, this argument is ignored. 
        Returns a bool indicating if the process was successful or not.
        """
        return _fusion.Path_addCurves(self, curves, chainOptions)

    def _get_objectType(self) -> "char const *":
        return _fusion.Path__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.Path__get_isValid(self)

# Register Path in _fusion:
_fusion.Path_swigregister(Path)

def Path_classType() -> "char const *":
    return _fusion.Path_classType()

def Path_create(curves: "Base", chainOptions: "ChainedCurveOptions") -> "adsk::core::Ptr< adsk::fusion::Path >":
    return _fusion.Path_create(curves, chainOptions)


Path.count = property(Path._get_count, doc="The number of curves in the path.")


Path.isClosed = property(Path._get_isClosed, doc="Indicates if the path is closed or not. Returns True in the case of a closed path.")


Path.assemblyContext = property(Path._get_assemblyContext, doc="This property is not supported for the Path object.")


Path.nativeObject = property(Path._get_nativeObject, doc="This property is not supported for the Path object.")


Path.cast = lambda arg: arg if isinstance(arg, Path) else None

class PathEntity(Base):
    r"""The PathEntity object represents a curve within a path"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::PathEntity *":
        return _fusion.PathEntity___deref__(self)

    def __eq__(self, rhs: "PathEntity") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.PathEntity___eq__(self, rhs)


    def __ne__(self, rhs: "PathEntity") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.PathEntity___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.PathEntity_classType()
    __swig_destroy__ = _fusion.delete_PathEntity

    def _get_curve(self) -> "adsk::core::Ptr< adsk::core::Curve3D >":
        r"""
        Property that returns the geometry of the entity.
        This is different from the original path curve if the true start point is not the same as the start point of the original path curve.
        """
        return _fusion.PathEntity__get_curve(self)

    def _get_curveType(self) -> "adsk::core::Curve3DTypes":
        r"""Property that returns the type of the curve referenced by the path entity. This property allows you to determine what type of object will be returned by the Curve property."""
        return _fusion.PathEntity__get_curveType(self)

    def _get_entity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Property that gets the sketch curve or edge this entity was derived from."""
        return _fusion.PathEntity__get_entity(self)

    def _get_parentPath(self) -> "adsk::core::Ptr< adsk::fusion::Path >":
        r"""Property that returns the parent Path of the entity."""
        return _fusion.PathEntity__get_parentPath(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""This property is not supported for a PathEntity object."""
        return _fusion.PathEntity__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::PathEntity >":
        r"""This property is not supported for a PathEntity object."""
        return _fusion.PathEntity__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::PathEntity >":
        r"""
        This method is not supported for a PathEntity object. 
        occurrence :
        """
        return _fusion.PathEntity_createForAssemblyContext(self, occurrence)

    def _get_isOpposedToEntity(self) -> "bool":
        r"""
        Indicates if the orientation of this PathEntity is in the same direction or opposed to the natural direction
        of the SketchCurve or BRepEdge object it is derived from.
        """
        return _fusion.PathEntity__get_isOpposedToEntity(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.PathEntity__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.PathEntity__get_isValid(self)

# Register PathEntity in _fusion:
_fusion.PathEntity_swigregister(PathEntity)

def PathEntity_classType() -> "char const *":
    return _fusion.PathEntity_classType()


PathEntity.curve = property(PathEntity._get_curve, doc="Property that returns the geometry of the entity.\nThis is different from the original path curve if the true start point is not the same as the start point of the original path curve.")


PathEntity.curveType = property(PathEntity._get_curveType, doc="Property that returns the type of the curve referenced by the path entity. This property allows you to determine what type of object will be returned by the Curve property.")


PathEntity.entity = property(PathEntity._get_entity, doc="Property that gets the sketch curve or edge this entity was derived from.")


PathEntity.parentPath = property(PathEntity._get_parentPath, doc="Property that returns the parent Path of the entity.")


PathEntity.assemblyContext = property(PathEntity._get_assemblyContext, doc="This property is not supported for a PathEntity object.")


PathEntity.nativeObject = property(PathEntity._get_nativeObject, doc="This property is not supported for a PathEntity object.")


PathEntity.isOpposedToEntity = property(PathEntity._get_isOpposedToEntity, doc="Indicates if the orientation of this PathEntity is in the same direction or opposed to the natural direction\nof the SketchCurve or BRepEdge object it is derived from.")


PathEntity.cast = lambda arg: arg if isinstance(arg, PathEntity) else None

class PathPatternFeatureInput(Base):
    r"""
    This class defines the methods and properties that pertain to the definition of a path pattern 
    feature.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::PathPatternFeatureInput *":
        return _fusion.PathPatternFeatureInput___deref__(self)

    def __eq__(self, rhs: "PathPatternFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.PathPatternFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "PathPatternFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.PathPatternFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.PathPatternFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_PathPatternFeatureInput

    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        """
        return _fusion.PathPatternFeatureInput__get_inputEntities(self)

    def _set_inputEntities(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        """
        return _fusion.PathPatternFeatureInput__set_inputEntities(self, value)

    def _get_path(self) -> "adsk::core::Ptr< adsk::fusion::Path >":
        r"""Gets and sets the path to create the pattern on path."""
        return _fusion.PathPatternFeatureInput__get_path(self)

    def _set_path(self, value: "Path") -> "bool":
        r"""Gets and sets the path to create the pattern on path."""
        return _fusion.PathPatternFeatureInput__set_path(self, value)

    def _get_quantity(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets and sets quantity of the elements."""
        return _fusion.PathPatternFeatureInput__get_quantity(self)

    def _set_quantity(self, value: "ValueInput") -> "bool":
        r"""Gets and sets quantity of the elements."""
        return _fusion.PathPatternFeatureInput__set_quantity(self, value)

    def _get_distance(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets and sets the distance."""
        return _fusion.PathPatternFeatureInput__get_distance(self)

    def _set_distance(self, value: "ValueInput") -> "bool":
        r"""Gets and sets the distance."""
        return _fusion.PathPatternFeatureInput__set_distance(self, value)

    def _get_startPoint(self) -> "double":
        r"""
        Gets and sets the start point on the path to count the distance.
        It's between 0 and 1. 0 means start point of the path, 1 means end point of the path.
        """
        return _fusion.PathPatternFeatureInput__get_startPoint(self)

    def _set_startPoint(self, value: "double") -> "bool":
        r"""
        Gets and sets the start point on the path to count the distance.
        It's between 0 and 1. 0 means start point of the path, 1 means end point of the path.
        """
        return _fusion.PathPatternFeatureInput__set_startPoint(self, value)

    def _get_isFlipDirection(self) -> "bool":
        r"""Gets and sets if flip the direction from start point."""
        return _fusion.PathPatternFeatureInput__get_isFlipDirection(self)

    def _set_isFlipDirection(self, value: "bool") -> "bool":
        r"""Gets and sets if flip the direction from start point."""
        return _fusion.PathPatternFeatureInput__set_isFlipDirection(self, value)

    def _get_patternDistanceType(self) -> "adsk::fusion::PatternDistanceType":
        r"""Gets and sets how the distance between elements is computed."""
        return _fusion.PathPatternFeatureInput__get_patternDistanceType(self)

    def _set_patternDistanceType(self, value: "PatternDistanceType") -> "bool":
        r"""Gets and sets how the distance between elements is computed."""
        return _fusion.PathPatternFeatureInput__set_patternDistanceType(self, value)

    def _get_isSymmetric(self) -> "bool":
        r"""Gets and sets if the pattern is in one direction or symmetric."""
        return _fusion.PathPatternFeatureInput__get_isSymmetric(self)

    def _set_isSymmetric(self, value: "bool") -> "bool":
        r"""Gets and sets if the pattern is in one direction or symmetric."""
        return _fusion.PathPatternFeatureInput__set_isSymmetric(self, value)

    def _get_isOrientationAlongPath(self) -> "bool":
        r"""
        Gets and sets if the orientation is along path.
        If false, the orientation is identical.
        """
        return _fusion.PathPatternFeatureInput__get_isOrientationAlongPath(self)

    def _set_isOrientationAlongPath(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the orientation is along path.
        If false, the orientation is identical.
        """
        return _fusion.PathPatternFeatureInput__set_isOrientationAlongPath(self, value)

    def _get_patternComputeOption(self) -> "adsk::fusion::PatternComputeOptions":
        r"""
        Gets and sets the compute option when patterning features. The default value for this is AdjustPatternCompute.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        """
        return _fusion.PathPatternFeatureInput__get_patternComputeOption(self)

    def _set_patternComputeOption(self, value: "PatternComputeOptions") -> "bool":
        r"""
        Gets and sets the compute option when patterning features. The default value for this is AdjustPatternCompute.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        """
        return _fusion.PathPatternFeatureInput__set_patternComputeOption(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.PathPatternFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.PathPatternFeatureInput__set_targetBaseFeature(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.PathPatternFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.PathPatternFeatureInput__get_isValid(self)

# Register PathPatternFeatureInput in _fusion:
_fusion.PathPatternFeatureInput_swigregister(PathPatternFeatureInput)

def PathPatternFeatureInput_classType() -> "char const *":
    return _fusion.PathPatternFeatureInput_classType()


PathPatternFeatureInput.inputEntities = property(PathPatternFeatureInput._get_inputEntities, PathPatternFeatureInput._set_inputEntities, doc="Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.\nAll of the entities must be of a single type. For example, it can't contain features and occurrences\nbut only features or occurrences.")


PathPatternFeatureInput.path = property(PathPatternFeatureInput._get_path, PathPatternFeatureInput._set_path, doc="Gets and sets the path to create the pattern on path.")


PathPatternFeatureInput.quantity = property(PathPatternFeatureInput._get_quantity, PathPatternFeatureInput._set_quantity, doc="Gets and sets quantity of the elements.")


PathPatternFeatureInput.distance = property(PathPatternFeatureInput._get_distance, PathPatternFeatureInput._set_distance, doc="Gets and sets the distance.")


PathPatternFeatureInput.startPoint = property(PathPatternFeatureInput._get_startPoint, PathPatternFeatureInput._set_startPoint, doc="Gets and sets the start point on the path to count the distance.\nIt's between 0 and 1. 0 means start point of the path, 1 means end point of the path.")


PathPatternFeatureInput.isFlipDirection = property(PathPatternFeatureInput._get_isFlipDirection, PathPatternFeatureInput._set_isFlipDirection, doc="Gets and sets if flip the direction from start point.")


PathPatternFeatureInput.patternDistanceType = property(PathPatternFeatureInput._get_patternDistanceType, PathPatternFeatureInput._set_patternDistanceType, doc="Gets and sets how the distance between elements is computed.")


PathPatternFeatureInput.isSymmetric = property(PathPatternFeatureInput._get_isSymmetric, PathPatternFeatureInput._set_isSymmetric, doc="Gets and sets if the pattern is in one direction or symmetric.")


PathPatternFeatureInput.isOrientationAlongPath = property(PathPatternFeatureInput._get_isOrientationAlongPath, PathPatternFeatureInput._set_isOrientationAlongPath, doc="Gets and sets if the orientation is along path.\nIf false, the orientation is identical.")


PathPatternFeatureInput.patternComputeOption = property(PathPatternFeatureInput._get_patternComputeOption, PathPatternFeatureInput._set_patternComputeOption, doc="Gets and sets the compute option when patterning features. The default value for this is AdjustPatternCompute.\nThis property only applies when patterning features and is ignored in the direct modeling environment.")


PathPatternFeatureInput.targetBaseFeature = property(PathPatternFeatureInput._get_targetBaseFeature, PathPatternFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


PathPatternFeatureInput.cast = lambda arg: arg if isinstance(arg, PathPatternFeatureInput) else None

class PathPatternFeatures(Base):
    r"""
    Collection that provides access to all of the existing path pattern features in a component
    and supports the ability to create new path pattern features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::PathPatternFeatures *":
        return _fusion.PathPatternFeatures___deref__(self)

    def __eq__(self, rhs: "PathPatternFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.PathPatternFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "PathPatternFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.PathPatternFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.PathPatternFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::PathPatternFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.PathPatternFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.PathPatternFeatures_classType()
    __swig_destroy__ = _fusion.delete_PathPatternFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::PathPatternFeature >":
        r"""
        Function that returns the specified path pattern feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.PathPatternFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of path pattern features in the collection."""
        return _fusion.PathPatternFeatures__get_count(self)

    def createInput(self, inputEntities: "ObjectCollection", path: "Path", quantity: "ValueInput", distance: "ValueInput", patternDistanceType: "PatternDistanceType") -> "adsk::core::Ptr< adsk::fusion::PathPatternFeatureInput >":
        r"""
        Creates a PathPatternFeatureInput object. Use properties and methods on this object
        to define the path pattern you want to create and then use the Add method, passing in 
        the PathPatternFeatureInput object. 
        inputEntities : The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences. 
        path : The Path object that represents a single set of connected curves along which to drive the pattern. 
        quantity : Specifies the number of instances in the first direction. 
        distance : Specifies the distance. How this value is used depends on the value of the PatternDistanceType property. A
        negative value can be used to change the direction.
        If the value is ExtentPatternDistanceType then it defines the total distance of the pattern.
        If the value is SpacingPatternDistanceType then it defines the distance between each element. 
        patternDistanceType : Specifies how the distance between elements is computed. 
        Returns the newly created PathPatternFeatureInput object or null if the creation failed.
        """
        return _fusion.PathPatternFeatures_createInput(self, inputEntities, path, quantity, distance, patternDistanceType)

    def add(self, input: "PathPatternFeatureInput") -> "adsk::core::Ptr< adsk::fusion::PathPatternFeature >":
        r"""
        Creates a new path pattern feature. 
        input : A PathPatternFeatureInput object that defines the desired path pattern. Use the createInput 
        method to create a new PathPatternFeatureInput object and then use methods on it 
        (the PathPatternFeatureInput object) to define the path pattern. 
        Returns the newly created PathPatternFeature object or null if the creation failed.
        """
        return _fusion.PathPatternFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::PathPatternFeature >":
        r"""
        Function that returns the specified path pattern feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.PathPatternFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.PathPatternFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.PathPatternFeatures__get_isValid(self)

# Register PathPatternFeatures in _fusion:
_fusion.PathPatternFeatures_swigregister(PathPatternFeatures)

def PathPatternFeatures_classType() -> "char const *":
    return _fusion.PathPatternFeatures_classType()


PathPatternFeatures.count = property(PathPatternFeatures._get_count, doc="The number of path pattern features in the collection.")


PathPatternFeatures.cast = lambda arg: arg if isinstance(arg, PathPatternFeatures) else None

class PatternElement(Base):
    r"""This class defines the properties that pertain to the pattern element."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::PatternElement *":
        return _fusion.PatternElement___deref__(self)

    def __eq__(self, rhs: "PatternElement") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.PatternElement___eq__(self, rhs)


    def __ne__(self, rhs: "PatternElement") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.PatternElement___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.PatternElement_classType()
    __swig_destroy__ = _fusion.delete_PatternElement

    def _get_faces(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepFace > > >":
        r"""Gets the faces generated as a result of this particular element."""
        return _fusion.PatternElement__get_faces(self)

    def _get_id(self) -> "size_t":
        r"""Gets the id of this element within the pattern."""
        return _fusion.PatternElement__get_id(self)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >":
        r"""Gets the feature pattern this element is a member of."""
        return _fusion.PatternElement__get_parentFeature(self)

    def _get_isSuppressed(self) -> "bool":
        r"""Gets and sets whether the element is suppressed or not. A value of True indicates it is suppressed"""
        return _fusion.PatternElement__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""Gets and sets whether the element is suppressed or not. A value of True indicates it is suppressed"""
        return _fusion.PatternElement__set_isSuppressed(self, value)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >":
        r"""
        Get the transform that describes this elements relative position to the parent object(s).
        The transform returned for the first element in a pattern will be an identity matrix.
        """
        return _fusion.PatternElement__get_transform(self)

    def _get_name(self) -> "std::string":
        r"""Get the name of the pattern element."""
        return _fusion.PatternElement__get_name(self)

    def _get_occurrences(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence >,std::allocator< adsk::core::Ptr< adsk::fusion::Occurrence > > >":
        r"""
        If the patternEntityType property of the parent feature returns OccurrencesPatternType
        then this property will return the occurrences associated with this particular pattern
        element.
        """
        return _fusion.PatternElement__get_occurrences(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.PatternElement__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.PatternElement__get_isValid(self)

# Register PatternElement in _fusion:
_fusion.PatternElement_swigregister(PatternElement)

def PatternElement_classType() -> "char const *":
    return _fusion.PatternElement_classType()


PatternElement.faces = property(PatternElement._get_faces, doc="Gets the faces generated as a result of this particular element.")


PatternElement.id = property(PatternElement._get_id, doc="Gets the id of this element within the pattern.")


PatternElement.parentFeature = property(PatternElement._get_parentFeature, doc="Gets the feature pattern this element is a member of.")


PatternElement.isSuppressed = property(PatternElement._get_isSuppressed, PatternElement._set_isSuppressed, doc="Gets and sets whether the element is suppressed or not. A value of True indicates it is suppressed")


PatternElement.transform = property(PatternElement._get_transform, doc="Get the transform that describes this elements relative position to the parent object(s).\nThe transform returned for the first element in a pattern will be an identity matrix.")


PatternElement.name = property(PatternElement._get_name, doc="Get the name of the pattern element.")


PatternElement.occurrences = property(PatternElement._get_occurrences, doc="If the patternEntityType property of the parent feature returns OccurrencesPatternType\nthen this property will return the occurrences associated with this particular pattern\nelement.")


PatternElement.cast = lambda arg: arg if isinstance(arg, PatternElement) else None

class PatternElements(Base):
    r"""Collection that provides access to pattern elements of mirror and pattern features."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::PatternElements *":
        return _fusion.PatternElements___deref__(self)

    def __eq__(self, rhs: "PatternElements") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.PatternElements___eq__(self, rhs)


    def __ne__(self, rhs: "PatternElements") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.PatternElements___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.PatternElements___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::PatternElement >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.PatternElements___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.PatternElements_classType()
    __swig_destroy__ = _fusion.delete_PatternElements

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::PatternElement >":
        r"""
        Function that returns the specified pattern element using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.PatternElements_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of pattern elements in the collection."""
        return _fusion.PatternElements__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.PatternElements__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.PatternElements__get_isValid(self)

# Register PatternElements in _fusion:
_fusion.PatternElements_swigregister(PatternElements)

def PatternElements_classType() -> "char const *":
    return _fusion.PatternElements_classType()


PatternElements.count = property(PatternElements._get_count, doc="The number of pattern elements in the collection.")


PatternElements.cast = lambda arg: arg if isinstance(arg, PatternElements) else None

class PhysicalProperties(Base):
    r"""The physical properties of a Component, Occurrence or BRepBody"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::PhysicalProperties *":
        return _fusion.PhysicalProperties___deref__(self)

    def __eq__(self, rhs: "PhysicalProperties") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.PhysicalProperties___eq__(self, rhs)


    def __ne__(self, rhs: "PhysicalProperties") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.PhysicalProperties___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.PhysicalProperties_classType()
    __swig_destroy__ = _fusion.delete_PhysicalProperties

    def _get_area(self) -> "double":
        r"""Gets the area in square centimeters."""
        return _fusion.PhysicalProperties__get_area(self)

    def _get_density(self) -> "double":
        r"""Gets the density in kilograms per cubic centimeter."""
        return _fusion.PhysicalProperties__get_density(self)

    def _get_mass(self) -> "double":
        r"""Gets the mass in kilograms."""
        return _fusion.PhysicalProperties__get_mass(self)

    def _get_volume(self) -> "double":
        r"""Gets the volume in the cubic centimeters."""
        return _fusion.PhysicalProperties__get_volume(self)

    def _get_accuracy(self) -> "adsk::fusion::CalculationAccuracy":
        r"""Returns the accuracy that was used for the calculation."""
        return _fusion.PhysicalProperties__get_accuracy(self)

    def _get_centerOfMass(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Returns the center of mass position"""
        return _fusion.PhysicalProperties__get_centerOfMass(self)

    def getPrincipalAxes(self) -> "bool":
        r"""
        Method that returns the principal axes. 
        xAxis : The output Vector3D object that indicates the direction of the x axis. 
        yAxis : The output Vector3D object that indicates the direction of the y axis. 
        zAxis : The output Vector3D object that indicates the direction of the z axis. 
        Returns true if successful
        """
        return _fusion.PhysicalProperties_getPrincipalAxes(self)

    def getPrincipalMomentsOfInertia(self) -> "bool":
        r"""
        Method that returns the moments of inertia about the principal axes. Unit for returned values is kg/cm^2. 
        i1 : Output Double that specifies the first moment of inertia. 
        i2 : Output Double that specifies the second moment of inertia. 
        i3 : Output Double that specifies the third moment of inertia. 
        Returns true if successful
        """
        return _fusion.PhysicalProperties_getPrincipalMomentsOfInertia(self)

    def getRadiusOfGyration(self) -> "bool":
        r"""
        Method that returns the radius of gyration about the principal axes. Unit for returned values is cm. 
        kx : Output Double that returns the X partial radius of gyration. 
        ky : Output Double that returns the Y partial radius of gyration. 
        kz : Output Double that returns the Z partial radius of gyration. 
        Returns true if successful
        """
        return _fusion.PhysicalProperties_getRadiusOfGyration(self)

    def getRotationToPrincipal(self) -> "bool":
        r"""
        Gets the rotation from the world coordinate system of the target to the principal coordinate system. 
        rx : 
        ry : 
        rz : 
        Returns true if successful
        """
        return _fusion.PhysicalProperties_getRotationToPrincipal(self)

    def getXYZMomentsOfInertia(self) -> "bool":
        r"""
        Method that gets the moment of inertia about the world coordinate system.
        Unit for returned values is kg/cm^2. 
        xx : Output Double that returns the XX partial moment. 
        yy : Output Double that returns the YY partial moment. 
        zz : Output Double that returns the ZZ partial moment. 
        xy : Output Double that returns the XY partial moment. 
        yz : Output Double that returns the YZ partial moment. 
        xz : Output Double that returns the XZ partial moment. 
        Returns true if successful
        """
        return _fusion.PhysicalProperties_getXYZMomentsOfInertia(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.PhysicalProperties__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.PhysicalProperties__get_isValid(self)

# Register PhysicalProperties in _fusion:
_fusion.PhysicalProperties_swigregister(PhysicalProperties)

def PhysicalProperties_classType() -> "char const *":
    return _fusion.PhysicalProperties_classType()


PhysicalProperties.area = property(PhysicalProperties._get_area, doc="Gets the area in square centimeters.")


PhysicalProperties.density = property(PhysicalProperties._get_density, doc="Gets the density in kilograms per cubic centimeter.")


PhysicalProperties.mass = property(PhysicalProperties._get_mass, doc="Gets the mass in kilograms.")


PhysicalProperties.volume = property(PhysicalProperties._get_volume, doc="Gets the volume in the cubic centimeters.")


PhysicalProperties.accuracy = property(PhysicalProperties._get_accuracy, doc="Returns the accuracy that was used for the calculation.")


PhysicalProperties.centerOfMass = property(PhysicalProperties._get_centerOfMass, doc="Returns the center of mass position")


PhysicalProperties.cast = lambda arg: arg if isinstance(arg, PhysicalProperties) else None

class PipeFeatures(Base):
    r"""Collection that provides access to all of the existing pipe features in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::PipeFeatures *":
        return _fusion.PipeFeatures___deref__(self)

    def __eq__(self, rhs: "PipeFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.PipeFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "PipeFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.PipeFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.PipeFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::PipeFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.PipeFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.PipeFeatures_classType()
    __swig_destroy__ = _fusion.delete_PipeFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::PipeFeature >":
        r"""
        Function that returns the specified pipe feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.PipeFeatures_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::PipeFeature >":
        r"""
        Function that returns the specified pipe feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.PipeFeatures_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of pipe features in the collection."""
        return _fusion.PipeFeatures__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.PipeFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.PipeFeatures__get_isValid(self)

# Register PipeFeatures in _fusion:
_fusion.PipeFeatures_swigregister(PipeFeatures)

def PipeFeatures_classType() -> "char const *":
    return _fusion.PipeFeatures_classType()


PipeFeatures.count = property(PipeFeatures._get_count, doc="The number of pipe features in the collection.")


PipeFeatures.cast = lambda arg: arg if isinstance(arg, PipeFeatures) else None

class PolygonMesh(Base):
    r"""
    The PolygonMesh represents a mesh that can contain any
    combination of polygons, quads, and triangles.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::PolygonMesh *":
        return _fusion.PolygonMesh___deref__(self)

    def __eq__(self, rhs: "PolygonMesh") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.PolygonMesh___eq__(self, rhs)


    def __ne__(self, rhs: "PolygonMesh") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.PolygonMesh___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.PolygonMesh_classType()
    __swig_destroy__ = _fusion.delete_PolygonMesh

    def _get_nodeCount(self) -> "int":
        r"""Returns the number of nodes in the mesh."""
        return _fusion.PolygonMesh__get_nodeCount(self)

    def _get_nodeCoordinatesAsDouble(self) -> "std::vector< double,std::allocator< double > >":
        r"""
        Returns the node coordinates as an array of doubles where
        they are the x, y, z components of each coordinate.
        """
        return _fusion.PolygonMesh__get_nodeCoordinatesAsDouble(self)

    def _get_nodeCoordinatesAsFloat(self) -> "std::vector< float,std::allocator< float > >":
        r"""
        Returns the node coordinates as an array of floats where
        they are the x, y, z components of each coordinate.
        """
        return _fusion.PolygonMesh__get_nodeCoordinatesAsFloat(self)

    def _get_nodeCoordinates(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D >,std::allocator< adsk::core::Ptr< adsk::core::Point3D > > >":
        r"""Returns the node coordinates as an array of Point3D objects."""
        return _fusion.PolygonMesh__get_nodeCoordinates(self)

    def _get_triangleCount(self) -> "int":
        r"""Returns the number of triangles in the mesh."""
        return _fusion.PolygonMesh__get_triangleCount(self)

    def _get_quadCount(self) -> "int":
        r"""Returns the number of quads in the mesh."""
        return _fusion.PolygonMesh__get_quadCount(self)

    def _get_polygonCount(self) -> "int":
        r"""Returns the number of polygons (more than 4 sides) in the mesh."""
        return _fusion.PolygonMesh__get_polygonCount(self)

    def _get_normalVectorsAsDouble(self) -> "std::vector< double,std::allocator< double > >":
        r"""
        Returns the normal vectors as an array of doubles where
        they are the x, y, z components of each vector. There is one normal vector for each index.
        """
        return _fusion.PolygonMesh__get_normalVectorsAsDouble(self)

    def _get_normalVectorsAsFloat(self) -> "std::vector< float,std::allocator< float > >":
        r"""Returns the normal vectors as an array of floats. There is one normal vector for each index."""
        return _fusion.PolygonMesh__get_normalVectorsAsFloat(self)

    def _get_normalVectors(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D >,std::allocator< adsk::core::Ptr< adsk::core::Vector3D > > >":
        r"""Returns the normal vectors as an array of Vector 3D objects. There is one normal vector for each index."""
        return _fusion.PolygonMesh__get_normalVectors(self)

    def _get_triangleNodeIndices(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        Returns the index values that index into the NodeCoordinates and NormalVectors arrays to
        define the three coordinates of each triangle and the corresponding normal.
        """
        return _fusion.PolygonMesh__get_triangleNodeIndices(self)

    def _get_quadNodeIndices(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        Returns the index values that index into the NodeCoordinates and NormalVectors arrays to
        define the four coordinates of each quad and the corresponding normal.
        """
        return _fusion.PolygonMesh__get_quadNodeIndices(self)

    def _get_polygonNodeIndices(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        Returns the index values that index into the NodeCoordinates and NormalVectors arrays to
        define the coordinates of each polygon and the corresponding normal.
        """
        return _fusion.PolygonMesh__get_polygonNodeIndices(self)

    def _get_nodeCountPerPolygon(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        Returns the number of nodes that define each polygon. For example, 
        if NodeCountPerPolygon[0] returns 6 it indicates the first polygon
        is defined using 6 nodes. The first six indices returned by the 
        PolygonNodeIndices properties provide the look-up into the NodeCoordinates
        array.
        """
        return _fusion.PolygonMesh__get_nodeCountPerPolygon(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.PolygonMesh__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.PolygonMesh__get_isValid(self)

# Register PolygonMesh in _fusion:
_fusion.PolygonMesh_swigregister(PolygonMesh)

def PolygonMesh_classType() -> "char const *":
    return _fusion.PolygonMesh_classType()


PolygonMesh.nodeCount = property(PolygonMesh._get_nodeCount, doc="Returns the number of nodes in the mesh.")


PolygonMesh.nodeCoordinatesAsDouble = property(PolygonMesh._get_nodeCoordinatesAsDouble, doc="Returns the node coordinates as an array of doubles where\nthey are the x, y, z components of each coordinate.")


PolygonMesh.nodeCoordinatesAsFloat = property(PolygonMesh._get_nodeCoordinatesAsFloat, doc="Returns the node coordinates as an array of floats where\nthey are the x, y, z components of each coordinate.")


PolygonMesh.nodeCoordinates = property(PolygonMesh._get_nodeCoordinates, doc="Returns the node coordinates as an array of Point3D objects.")


PolygonMesh.triangleCount = property(PolygonMesh._get_triangleCount, doc="Returns the number of triangles in the mesh.")


PolygonMesh.quadCount = property(PolygonMesh._get_quadCount, doc="Returns the number of quads in the mesh.")


PolygonMesh.polygonCount = property(PolygonMesh._get_polygonCount, doc="Returns the number of polygons (more than 4 sides) in the mesh.")


PolygonMesh.normalVectorsAsDouble = property(PolygonMesh._get_normalVectorsAsDouble, doc="Returns the normal vectors as an array of doubles where\nthey are the x, y, z components of each vector. There is one normal vector for each index.")


PolygonMesh.normalVectorsAsFloat = property(PolygonMesh._get_normalVectorsAsFloat, doc="Returns the normal vectors as an array of floats. There is one normal vector for each index.")


PolygonMesh.normalVectors = property(PolygonMesh._get_normalVectors, doc="Returns the normal vectors as an array of Vector 3D objects. There is one normal vector for each index.")


PolygonMesh.triangleNodeIndices = property(PolygonMesh._get_triangleNodeIndices, doc="Returns the index values that index into the NodeCoordinates and NormalVectors arrays to\ndefine the three coordinates of each triangle and the corresponding normal.")


PolygonMesh.quadNodeIndices = property(PolygonMesh._get_quadNodeIndices, doc="Returns the index values that index into the NodeCoordinates and NormalVectors arrays to\ndefine the four coordinates of each quad and the corresponding normal.")


PolygonMesh.polygonNodeIndices = property(PolygonMesh._get_polygonNodeIndices, doc="Returns the index values that index into the NodeCoordinates and NormalVectors arrays to\ndefine the coordinates of each polygon and the corresponding normal.")


PolygonMesh.nodeCountPerPolygon = property(PolygonMesh._get_nodeCountPerPolygon, doc="Returns the number of nodes that define each polygon. For example,\nif NodeCountPerPolygon[0] returns 6 it indicates the first polygon\nis defined using 6 nodes. The first six indices returned by the\nPolygonNodeIndices properties provide the look-up into the NodeCoordinates\narray.")


PolygonMesh.cast = lambda arg: arg if isinstance(arg, PolygonMesh) else None

class Profile(Base):
    r"""
    Represents a profile in a sketch. Profiles are automatically computed by Fusion 360 and
    represent closed areas within the sketch.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::Profile *":
        return _fusion.Profile___deref__(self)

    def __eq__(self, rhs: "Profile") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.Profile___eq__(self, rhs)


    def __ne__(self, rhs: "Profile") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.Profile___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.Profile_classType()
    __swig_destroy__ = _fusion.delete_Profile

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the 3D bounding box of the profile in sketch space."""
        return _fusion.Profile__get_boundingBox(self)

    def _get_plane(self) -> "adsk::core::Ptr< adsk::core::Plane >":
        r"""
        Returns the plane the profile is defined in. Profiles are always planar and exist within 
        a single plane.
        """
        return _fusion.Profile__get_plane(self)

    def _get_profileLoops(self) -> "adsk::core::Ptr< adsk::fusion::ProfileLoops >":
        r"""
        The loops or closed areas within this profile. There is always a single outer loop
        but there can be zero to many inner loops defining voids in the profile.
        """
        return _fusion.Profile__get_profileLoops(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch of the profile."""
        return _fusion.Profile__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this
        object in an assembly. This is only valid in the case where this
        is acting as a proxy in an assembly. Returns null 
        in the case where the object is not in the context of an assembly.
        but is already the native object.
        """
        return _fusion.Profile__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::Profile >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.Profile__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::Profile >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence.
        Returns null if this isn't the NativeObject. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.Profile_createForAssemblyContext(self, occurrence)

    def areaProperties(self, *args) -> "adsk::core::Ptr< adsk::fusion::AreaProperties >":
        r"""
        Returns the AreaProperties object that has properties for getting the area, perimeter, centroid, etc 
        of this profile. 
        accuracy : Specifies the desired level of computational accuracy of the property calculations.
        The default value of 'LowCalculationAccuracy' returns results within a +/- 1% error margin.
        """
        return _fusion.Profile_areaProperties(self, *args)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Profile object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same profile.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.Profile__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.Profile__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.Profile__get_isValid(self)

# Register Profile in _fusion:
_fusion.Profile_swigregister(Profile)

def Profile_classType() -> "char const *":
    return _fusion.Profile_classType()


Profile.boundingBox = property(Profile._get_boundingBox, doc="Returns the 3D bounding box of the profile in sketch space.")


Profile.plane = property(Profile._get_plane, doc="Returns the plane the profile is defined in. Profiles are always planar and exist within\na single plane.")


Profile.profileLoops = property(Profile._get_profileLoops, doc="The loops or closed areas within this profile. There is always a single outer loop\nbut there can be zero to many inner loops defining voids in the profile.")


Profile.parentSketch = property(Profile._get_parentSketch, doc="Returns the parent sketch of the profile.")


Profile.assemblyContext = property(Profile._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this\nobject in an assembly. This is only valid in the case where this\nis acting as a proxy in an assembly. Returns null\nin the case where the object is not in the context of an assembly.\nbut is already the native object.")


Profile.nativeObject = property(Profile._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


Profile.entityToken = property(Profile._get_entityToken, doc="Returns a token for the Profile object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same profile.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.")


Profile.cast = lambda arg: arg if isinstance(arg, Profile) else None

class ProfileCurve(Base):
    r"""A single curve in a profile."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ProfileCurve *":
        return _fusion.ProfileCurve___deref__(self)

    def __eq__(self, rhs: "ProfileCurve") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ProfileCurve___eq__(self, rhs)


    def __ne__(self, rhs: "ProfileCurve") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ProfileCurve___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ProfileCurve_classType()
    __swig_destroy__ = _fusion.delete_ProfileCurve

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Curve3D >":
        r"""Returns the geometric entity of this portion of the profile."""
        return _fusion.ProfileCurve__get_geometry(self)

    def _get_geometryType(self) -> "adsk::core::Curve3DTypes":
        r"""Return the geometry type that the Geometry property will return."""
        return _fusion.ProfileCurve__get_geometryType(self)

    def _get_sketchEntity(self) -> "adsk::core::Ptr< adsk::fusion::SketchEntity >":
        r"""Returns the associated sketch entity that defines this curve."""
        return _fusion.ProfileCurve__get_sketchEntity(self)

    def _get_parentProfileLoop(self) -> "adsk::core::Ptr< adsk::fusion::ProfileLoop >":
        r"""Returns the parent ProfileLoop object."""
        return _fusion.ProfileCurve__get_parentProfileLoop(self)

    def _get_parentProfile(self) -> "adsk::core::Ptr< adsk::fusion::Profile >":
        r"""Returns the parent Profile object."""
        return _fusion.ProfileCurve__get_parentProfile(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent Profile object."""
        return _fusion.ProfileCurve__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ProfileCurve__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ProfileCurve >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ProfileCurve__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::ProfileCurve >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence.
        Returns null if this isn't the NativeObject. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ProfileCurve_createForAssemblyContext(self, occurrence)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the bounding box of the profile curve in sketch space."""
        return _fusion.ProfileCurve__get_boundingBox(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ProfileCurve__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ProfileCurve__get_isValid(self)

# Register ProfileCurve in _fusion:
_fusion.ProfileCurve_swigregister(ProfileCurve)

def ProfileCurve_classType() -> "char const *":
    return _fusion.ProfileCurve_classType()


ProfileCurve.geometry = property(ProfileCurve._get_geometry, doc="Returns the geometric entity of this portion of the profile.")


ProfileCurve.geometryType = property(ProfileCurve._get_geometryType, doc="Return the geometry type that the Geometry property will return.")


ProfileCurve.sketchEntity = property(ProfileCurve._get_sketchEntity, doc="Returns the associated sketch entity that defines this curve.")


ProfileCurve.parentProfileLoop = property(ProfileCurve._get_parentProfileLoop, doc="Returns the parent ProfileLoop object.")


ProfileCurve.parentProfile = property(ProfileCurve._get_parentProfile, doc="Returns the parent Profile object.")


ProfileCurve.parentSketch = property(ProfileCurve._get_parentSketch, doc="Returns the parent Profile object.")


ProfileCurve.assemblyContext = property(ProfileCurve._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")


ProfileCurve.nativeObject = property(ProfileCurve._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


ProfileCurve.boundingBox = property(ProfileCurve._get_boundingBox, doc="Returns the bounding box of the profile curve in sketch space.")


ProfileCurve.cast = lambda arg: arg if isinstance(arg, ProfileCurve) else None

class ProfileCurves(Base):
    r"""A collection of profile curves within a profile loop."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ProfileCurves *":
        return _fusion.ProfileCurves___deref__(self)

    def __eq__(self, rhs: "ProfileCurves") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ProfileCurves___eq__(self, rhs)


    def __ne__(self, rhs: "ProfileCurves") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ProfileCurves___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.ProfileCurves___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::ProfileCurve >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.ProfileCurves___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ProfileCurves_classType()
    __swig_destroy__ = _fusion.delete_ProfileCurves

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::ProfileCurve >":
        r"""
        Function that returns the specified profile curve using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ProfileCurves_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of curves in the collection."""
        return _fusion.ProfileCurves__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ProfileCurves__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ProfileCurves__get_isValid(self)

# Register ProfileCurves in _fusion:
_fusion.ProfileCurves_swigregister(ProfileCurves)

def ProfileCurves_classType() -> "char const *":
    return _fusion.ProfileCurves_classType()


ProfileCurves.count = property(ProfileCurves._get_count, doc="Returns the number of curves in the collection.")


ProfileCurves.cast = lambda arg: arg if isinstance(arg, ProfileCurves) else None

class ProfileLoop(Base):
    r"""A loop within a profile."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ProfileLoop *":
        return _fusion.ProfileLoop___deref__(self)

    def __eq__(self, rhs: "ProfileLoop") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ProfileLoop___eq__(self, rhs)


    def __ne__(self, rhs: "ProfileLoop") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ProfileLoop___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ProfileLoop_classType()
    __swig_destroy__ = _fusion.delete_ProfileLoop

    def _get_isOuter(self) -> "bool":
        r"""
        Indicates if this is an outer or inner loop. Profiles always have 
        one outer loop and have an zero to many inner loops defining voids.
        """
        return _fusion.ProfileLoop__get_isOuter(self)

    def _get_profileCurves(self) -> "adsk::core::Ptr< adsk::fusion::ProfileCurves >":
        r"""Returns a collection of the curves making up this loop."""
        return _fusion.ProfileLoop__get_profileCurves(self)

    def _get_parentProfile(self) -> "adsk::core::Ptr< adsk::fusion::Profile >":
        r"""Returns the parent Profile object."""
        return _fusion.ProfileLoop__get_parentProfile(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ProfileLoop__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ProfileLoop >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ProfileLoop__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::ProfileLoop >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence.
        Returns null if this isn't the NativeObject. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ProfileLoop_createForAssemblyContext(self, occurrence)

    def _get_objectType(self) -> "char const *":
        return _fusion.ProfileLoop__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ProfileLoop__get_isValid(self)

# Register ProfileLoop in _fusion:
_fusion.ProfileLoop_swigregister(ProfileLoop)

def ProfileLoop_classType() -> "char const *":
    return _fusion.ProfileLoop_classType()


ProfileLoop.isOuter = property(ProfileLoop._get_isOuter, doc="Indicates if this is an outer or inner loop. Profiles always have\none outer loop and have an zero to many inner loops defining voids.")


ProfileLoop.profileCurves = property(ProfileLoop._get_profileCurves, doc="Returns a collection of the curves making up this loop.")


ProfileLoop.parentProfile = property(ProfileLoop._get_parentProfile, doc="Returns the parent Profile object.")


ProfileLoop.assemblyContext = property(ProfileLoop._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")


ProfileLoop.nativeObject = property(ProfileLoop._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


ProfileLoop.cast = lambda arg: arg if isinstance(arg, ProfileLoop) else None

class ProfileLoops(Base):
    r"""A collection of loops within a Profile."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ProfileLoops *":
        return _fusion.ProfileLoops___deref__(self)

    def __eq__(self, rhs: "ProfileLoops") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ProfileLoops___eq__(self, rhs)


    def __ne__(self, rhs: "ProfileLoops") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ProfileLoops___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.ProfileLoops___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::ProfileLoop >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.ProfileLoops___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ProfileLoops_classType()
    __swig_destroy__ = _fusion.delete_ProfileLoops

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::ProfileLoop >":
        r"""
        Function that returns the specified profile loop using an index into the collection. 
        index : The index of the item within the collection to return. 
        The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ProfileLoops_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of loops within this profile."""
        return _fusion.ProfileLoops__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ProfileLoops__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ProfileLoops__get_isValid(self)

# Register ProfileLoops in _fusion:
_fusion.ProfileLoops_swigregister(ProfileLoops)

def ProfileLoops_classType() -> "char const *":
    return _fusion.ProfileLoops_classType()


ProfileLoops.count = property(ProfileLoops._get_count, doc="Returns the number of loops within this profile.")


ProfileLoops.cast = lambda arg: arg if isinstance(arg, ProfileLoops) else None

class Profiles(Base):
    r"""
    A collection of all of the closed profiles currently calculated for this sketch. Closed profiles are 
    automatically computed by Fusion 360 and represent closed areas within the sketch.
    This class also provides some additional utility functions to create open profiles and text based profiles
    that can be used as input for various features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::Profiles *":
        return _fusion.Profiles___deref__(self)

    def __eq__(self, rhs: "Profiles") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.Profiles___eq__(self, rhs)


    def __ne__(self, rhs: "Profiles") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.Profiles___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.Profiles___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::Profile >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.Profiles___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.Profiles_classType()
    __swig_destroy__ = _fusion.delete_Profiles

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::Profile >":
        r"""
        Function that returns the specified closed profile using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the 
        collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.Profiles_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of closed profiles in the sketch. Open and text based profiles are not included."""
        return _fusion.Profiles__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.Profiles__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.Profiles__get_isValid(self)

# Register Profiles in _fusion:
_fusion.Profiles_swigregister(Profiles)

def Profiles_classType() -> "char const *":
    return _fusion.Profiles_classType()


Profiles.count = property(Profiles._get_count, doc="Returns the number of closed profiles in the sketch. Open and text based profiles are not included.")


Profiles.cast = lambda arg: arg if isinstance(arg, Profiles) else None

class RectangularPatternFeatureInput(Base):
    r"""
    This class defines the methods and properties that pertain to the definition of a rectangular pattern 
    feature.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RectangularPatternFeatureInput *":
        return _fusion.RectangularPatternFeatureInput___deref__(self)

    def __eq__(self, rhs: "RectangularPatternFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RectangularPatternFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "RectangularPatternFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RectangularPatternFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RectangularPatternFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_RectangularPatternFeatureInput

    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        """
        return _fusion.RectangularPatternFeatureInput__get_inputEntities(self)

    def _set_inputEntities(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        """
        return _fusion.RectangularPatternFeatureInput__set_inputEntities(self, value)

    def setDirectionTwo(self, directionTwoEntity: "Base", quantityTwo: "ValueInput", distanceTwo: "ValueInput") -> "bool":
        r"""
        Sets all of the input required to define the pattern in the second direction. 
        directionTwoEntity : Specifies the entity used to define the second direction entity. This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
        If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
        This argument can be null to indicate that the default second direction is to be used, which is 90 degrees to the first direction. 
        quantityTwo : Specifies the number of instances in the second direction. 
        distanceTwo : Specifies the distance in the second direction. How this value is used depends on the value of the PatternDistanceType property.
        If the value is ExtentPatternDistanceType then it defines the total distance of the pattern.
        If the value is SpacingPatternDistanceType then it defines the distance between each element. 
        Returns true if it was successful.
        """
        return _fusion.RectangularPatternFeatureInput_setDirectionTwo(self, directionTwoEntity, quantityTwo, distanceTwo)

    def _get_directionOneEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the first direction entity.
        This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
        If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
        """
        return _fusion.RectangularPatternFeatureInput__get_directionOneEntity(self)

    def _set_directionOneEntity(self, value: "Base") -> "bool":
        r"""
        Gets and sets the first direction entity.
        This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
        If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
        """
        return _fusion.RectangularPatternFeatureInput__set_directionOneEntity(self, value)

    def _get_directionTwoEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the second direction entity.
        This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
        If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
        """
        return _fusion.RectangularPatternFeatureInput__get_directionTwoEntity(self)

    def _set_directionTwoEntity(self, value: "Base") -> "bool":
        r"""
        Gets and sets the second direction entity.
        This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
        If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
        """
        return _fusion.RectangularPatternFeatureInput__set_directionTwoEntity(self, value)

    def _get_quantityOne(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets and sets the number of instances in the first direction."""
        return _fusion.RectangularPatternFeatureInput__get_quantityOne(self)

    def _set_quantityOne(self, value: "ValueInput") -> "bool":
        r"""Gets and sets the number of instances in the first direction."""
        return _fusion.RectangularPatternFeatureInput__set_quantityOne(self, value)

    def _get_quantityTwo(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets and sets the number of instances in the second direction."""
        return _fusion.RectangularPatternFeatureInput__get_quantityTwo(self)

    def _set_quantityTwo(self, value: "ValueInput") -> "bool":
        r"""Gets and sets the number of instances in the second direction."""
        return _fusion.RectangularPatternFeatureInput__set_quantityTwo(self, value)

    def _get_distanceOne(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets and sets the distance in the first direction."""
        return _fusion.RectangularPatternFeatureInput__get_distanceOne(self)

    def _set_distanceOne(self, value: "ValueInput") -> "bool":
        r"""Gets and sets the distance in the first direction."""
        return _fusion.RectangularPatternFeatureInput__set_distanceOne(self, value)

    def _get_distanceTwo(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets and sets the distance in the second direction."""
        return _fusion.RectangularPatternFeatureInput__get_distanceTwo(self)

    def _set_distanceTwo(self, value: "ValueInput") -> "bool":
        r"""Gets and sets the distance in the second direction."""
        return _fusion.RectangularPatternFeatureInput__set_distanceTwo(self, value)

    def _get_directionOne(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Returns a Vector3D indicating the positive direction of direction one."""
        return _fusion.RectangularPatternFeatureInput__get_directionOne(self)

    def _get_directionTwo(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Returns a Vector3D indicating the positive direction of direction two."""
        return _fusion.RectangularPatternFeatureInput__get_directionTwo(self)

    def _get_isSymmetricInDirectionOne(self) -> "bool":
        r"""Gets and sets if the pattern in direction one is in one direction or symmetric."""
        return _fusion.RectangularPatternFeatureInput__get_isSymmetricInDirectionOne(self)

    def _set_isSymmetricInDirectionOne(self, value: "bool") -> "bool":
        r"""Gets and sets if the pattern in direction one is in one direction or symmetric."""
        return _fusion.RectangularPatternFeatureInput__set_isSymmetricInDirectionOne(self, value)

    def _get_isSymmetricInDirectionTwo(self) -> "bool":
        r"""Gets and sets if the pattern in direction two is in one direction or symmetric."""
        return _fusion.RectangularPatternFeatureInput__get_isSymmetricInDirectionTwo(self)

    def _set_isSymmetricInDirectionTwo(self, value: "bool") -> "bool":
        r"""Gets and sets if the pattern in direction two is in one direction or symmetric."""
        return _fusion.RectangularPatternFeatureInput__set_isSymmetricInDirectionTwo(self, value)

    def _get_patternDistanceType(self) -> "adsk::fusion::PatternDistanceType":
        r"""Gets and sets how the distance between elements is computed."""
        return _fusion.RectangularPatternFeatureInput__get_patternDistanceType(self)

    def _set_patternDistanceType(self, value: "PatternDistanceType") -> "bool":
        r"""Gets and sets how the distance between elements is computed."""
        return _fusion.RectangularPatternFeatureInput__set_patternDistanceType(self, value)

    def _get_patternComputeOption(self) -> "adsk::fusion::PatternComputeOptions":
        r"""
        Gets and sets the compute option when patterning features. The default value for this is AdjustPatternCompute.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        """
        return _fusion.RectangularPatternFeatureInput__get_patternComputeOption(self)

    def _set_patternComputeOption(self, value: "PatternComputeOptions") -> "bool":
        r"""
        Gets and sets the compute option when patterning features. The default value for this is AdjustPatternCompute.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        """
        return _fusion.RectangularPatternFeatureInput__set_patternComputeOption(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.RectangularPatternFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.RectangularPatternFeatureInput__set_targetBaseFeature(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.RectangularPatternFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RectangularPatternFeatureInput__get_isValid(self)

# Register RectangularPatternFeatureInput in _fusion:
_fusion.RectangularPatternFeatureInput_swigregister(RectangularPatternFeatureInput)

def RectangularPatternFeatureInput_classType() -> "char const *":
    return _fusion.RectangularPatternFeatureInput_classType()


RectangularPatternFeatureInput.inputEntities = property(RectangularPatternFeatureInput._get_inputEntities, RectangularPatternFeatureInput._set_inputEntities, doc="Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.\nAll of the entities must be of a single type. For example, it can't contain features and occurrences\nbut only features or occurrences.")


RectangularPatternFeatureInput.directionOneEntity = property(RectangularPatternFeatureInput._get_directionOneEntity, RectangularPatternFeatureInput._set_directionOneEntity, doc="Gets and sets the first direction entity.\nThis can be a linear edge, construction axis, sketch line or rectangular pattern feature.\nIf a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.")


RectangularPatternFeatureInput.directionTwoEntity = property(RectangularPatternFeatureInput._get_directionTwoEntity, RectangularPatternFeatureInput._set_directionTwoEntity, doc="Gets and sets the second direction entity.\nThis can be a linear edge, construction axis, sketch line or rectangular pattern feature.\nIf a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.")


RectangularPatternFeatureInput.quantityOne = property(RectangularPatternFeatureInput._get_quantityOne, RectangularPatternFeatureInput._set_quantityOne, doc="Gets and sets the number of instances in the first direction.")


RectangularPatternFeatureInput.quantityTwo = property(RectangularPatternFeatureInput._get_quantityTwo, RectangularPatternFeatureInput._set_quantityTwo, doc="Gets and sets the number of instances in the second direction.")


RectangularPatternFeatureInput.distanceOne = property(RectangularPatternFeatureInput._get_distanceOne, RectangularPatternFeatureInput._set_distanceOne, doc="Gets and sets the distance in the first direction.")


RectangularPatternFeatureInput.distanceTwo = property(RectangularPatternFeatureInput._get_distanceTwo, RectangularPatternFeatureInput._set_distanceTwo, doc="Gets and sets the distance in the second direction.")


RectangularPatternFeatureInput.directionOne = property(RectangularPatternFeatureInput._get_directionOne, doc="Returns a Vector3D indicating the positive direction of direction one.")


RectangularPatternFeatureInput.directionTwo = property(RectangularPatternFeatureInput._get_directionTwo, doc="Returns a Vector3D indicating the positive direction of direction two.")


RectangularPatternFeatureInput.isSymmetricInDirectionOne = property(RectangularPatternFeatureInput._get_isSymmetricInDirectionOne, RectangularPatternFeatureInput._set_isSymmetricInDirectionOne, doc="Gets and sets if the pattern in direction one is in one direction or symmetric.")


RectangularPatternFeatureInput.isSymmetricInDirectionTwo = property(RectangularPatternFeatureInput._get_isSymmetricInDirectionTwo, RectangularPatternFeatureInput._set_isSymmetricInDirectionTwo, doc="Gets and sets if the pattern in direction two is in one direction or symmetric.")


RectangularPatternFeatureInput.patternDistanceType = property(RectangularPatternFeatureInput._get_patternDistanceType, RectangularPatternFeatureInput._set_patternDistanceType, doc="Gets and sets how the distance between elements is computed.")


RectangularPatternFeatureInput.patternComputeOption = property(RectangularPatternFeatureInput._get_patternComputeOption, RectangularPatternFeatureInput._set_patternComputeOption, doc="Gets and sets the compute option when patterning features. The default value for this is AdjustPatternCompute.\nThis property only applies when patterning features and is ignored in the direct modeling environment.")


RectangularPatternFeatureInput.targetBaseFeature = property(RectangularPatternFeatureInput._get_targetBaseFeature, RectangularPatternFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


RectangularPatternFeatureInput.cast = lambda arg: arg if isinstance(arg, RectangularPatternFeatureInput) else None

class RectangularPatternFeatures(Base):
    r"""
    Collection that provides access to all of the existing rectangular pattern features in a component
    and supports the ability to create new rectangular pattern features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RectangularPatternFeatures *":
        return _fusion.RectangularPatternFeatures___deref__(self)

    def __eq__(self, rhs: "RectangularPatternFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RectangularPatternFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "RectangularPatternFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RectangularPatternFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.RectangularPatternFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::RectangularPatternFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.RectangularPatternFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RectangularPatternFeatures_classType()
    __swig_destroy__ = _fusion.delete_RectangularPatternFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::RectangularPatternFeature >":
        r"""
        Function that returns the specified rectangular pattern feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.RectangularPatternFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of rectangular pattern features in the collection."""
        return _fusion.RectangularPatternFeatures__get_count(self)

    def createInput(self, inputEntities: "ObjectCollection", directionOneEntity: "Base", quantityOne: "ValueInput", distanceOne: "ValueInput", patternDistanceType: "PatternDistanceType") -> "adsk::core::Ptr< adsk::fusion::RectangularPatternFeatureInput >":
        r"""
        Creates a RectangularPatternFeatureInput object. Use properties and methods on this object
        to define the rectangular pattern you want to create and then use the Add method, passing in 
        the RectangularPatternFeatureInput object. 
        inputEntities : The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences. 
        directionOneEntity : Specifies the entity used to define the first direction entity. This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
        If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature. 
        quantityOne : Specifies the number of instances in the first direction. 
        distanceOne : Specifies the distance in the first direction. How this value is used depends on the value of the PatternDistanceType property. A
        negative value can be used to change the direction.
        If the value is ExtentPatternDistanceType then it defines the total distance of the pattern.
        If the value is SpacingPatternDistanceType then it defines the distance between each element. 
        patternDistanceType : Specifies how the distance between elements is computed. 
        Returns the newly created RectangularPatternFeatureInput object or null if the creation failed.
        """
        return _fusion.RectangularPatternFeatures_createInput(self, inputEntities, directionOneEntity, quantityOne, distanceOne, patternDistanceType)

    def add(self, input: "RectangularPatternFeatureInput") -> "adsk::core::Ptr< adsk::fusion::RectangularPatternFeature >":
        r"""
        Creates a new rectangular pattern feature. 
        input : A RectangularPatternFeatureInput object that defines the desired rectangular pattern. Use the createInput 
        method to create a new RectangularPatternFeatureInput object and then use methods on it 
        (the RectangularPatternFeatureInput object) to define the rectangular pattern. 
        Returns the newly created RectangularPatternFeature object or null if the creation failed.
        """
        return _fusion.RectangularPatternFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::RectangularPatternFeature >":
        r"""
        Function that returns the specified rectangular pattern feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.RectangularPatternFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.RectangularPatternFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RectangularPatternFeatures__get_isValid(self)

# Register RectangularPatternFeatures in _fusion:
_fusion.RectangularPatternFeatures_swigregister(RectangularPatternFeatures)

def RectangularPatternFeatures_classType() -> "char const *":
    return _fusion.RectangularPatternFeatures_classType()


RectangularPatternFeatures.count = property(RectangularPatternFeatures._get_count, doc="The number of rectangular pattern features in the collection.")


RectangularPatternFeatures.cast = lambda arg: arg if isinstance(arg, RectangularPatternFeatures) else None

class RefoldFeatures(Base):
    r"""Collection that provides access to all of the existing refold features in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RefoldFeatures *":
        return _fusion.RefoldFeatures___deref__(self)

    def __eq__(self, rhs: "RefoldFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RefoldFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "RefoldFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RefoldFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.RefoldFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::RefoldFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.RefoldFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RefoldFeatures_classType()
    __swig_destroy__ = _fusion.delete_RefoldFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::RefoldFeature >":
        r"""
        Function that returns the specified refold feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.RefoldFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of refold features in the collection."""
        return _fusion.RefoldFeatures__get_count(self)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::RefoldFeature >":
        r"""
        Function that returns the specified refold feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.RefoldFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.RefoldFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RefoldFeatures__get_isValid(self)

# Register RefoldFeatures in _fusion:
_fusion.RefoldFeatures_swigregister(RefoldFeatures)

def RefoldFeatures_classType() -> "char const *":
    return _fusion.RefoldFeatures_classType()


RefoldFeatures.count = property(RefoldFeatures._get_count, doc="The number of refold features in the collection.")


RefoldFeatures.cast = lambda arg: arg if isinstance(arg, RefoldFeatures) else None

class RemoveFeatures(Base):
    r"""
    Collection that provides access to all of the existing Remove features in a component
    and supports the ability to create new Remove features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RemoveFeatures *":
        return _fusion.RemoveFeatures___deref__(self)

    def __eq__(self, rhs: "RemoveFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RemoveFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "RemoveFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RemoveFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.RemoveFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::RemoveFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.RemoveFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RemoveFeatures_classType()
    __swig_destroy__ = _fusion.delete_RemoveFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::RemoveFeature >":
        r"""
        Function that returns the specified Remove feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.RemoveFeatures_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::RemoveFeature >":
        r"""
        Function that returns the specified remove feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.RemoveFeatures_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of Remove features in the collection."""
        return _fusion.RemoveFeatures__get_count(self)

    def add(self, itemToRemove: "Base") -> "adsk::core::Ptr< adsk::fusion::RemoveFeature >":
        r"""
        Creates a new Remove feature. 
        itemToRemove : A single body (solid or surface) or component occurrence to remove. 
        Returns the newly created RemoveFeature object or null if the creation failed.
        """
        return _fusion.RemoveFeatures_add(self, itemToRemove)

    def _get_objectType(self) -> "char const *":
        return _fusion.RemoveFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RemoveFeatures__get_isValid(self)

# Register RemoveFeatures in _fusion:
_fusion.RemoveFeatures_swigregister(RemoveFeatures)

def RemoveFeatures_classType() -> "char const *":
    return _fusion.RemoveFeatures_classType()


RemoveFeatures.count = property(RemoveFeatures._get_count, doc="The number of Remove features in the collection.")


RemoveFeatures.cast = lambda arg: arg if isinstance(arg, RemoveFeatures) else None

class ReplaceFaceFeatureInput(Base):
    r"""This class defines the methods and properties that pertain to the definition of a replace face feature."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ReplaceFaceFeatureInput *":
        return _fusion.ReplaceFaceFeatureInput___deref__(self)

    def __eq__(self, rhs: "ReplaceFaceFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ReplaceFaceFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "ReplaceFaceFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ReplaceFaceFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ReplaceFaceFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_ReplaceFaceFeatureInput

    def _get_sourceFaces(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the entities that define the source faces to perform replace.
        The collection can contain the faces from a solid and/or from features. All the faces must be on the same body.
        """
        return _fusion.ReplaceFaceFeatureInput__get_sourceFaces(self)

    def _set_sourceFaces(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the entities that define the source faces to perform replace.
        The collection can contain the faces from a solid and/or from features. All the faces must be on the same body.
        """
        return _fusion.ReplaceFaceFeatureInput__set_sourceFaces(self, value)

    def _get_targetFaces(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the entities that define the target faces. The new faces must completely intersect the part.
        The collection can contain the surface faces, surface bodies and construction planes.
        """
        return _fusion.ReplaceFaceFeatureInput__get_targetFaces(self)

    def _set_targetFaces(self, value: "Base") -> "bool":
        r"""
        Gets and sets the entities that define the target faces. The new faces must completely intersect the part.
        The collection can contain the surface faces, surface bodies and construction planes.
        """
        return _fusion.ReplaceFaceFeatureInput__set_targetFaces(self, value)

    def _get_isTangentChain(self) -> "bool":
        r"""
        Gets and sets if any faces that are tangentially connected to any of 
        the input faces will also be included in setting InputEntities. It defaults to true.
        """
        return _fusion.ReplaceFaceFeatureInput__get_isTangentChain(self)

    def _set_isTangentChain(self, value: "bool") -> "bool":
        r"""
        Gets and sets if any faces that are tangentially connected to any of 
        the input faces will also be included in setting InputEntities. It defaults to true.
        """
        return _fusion.ReplaceFaceFeatureInput__set_isTangentChain(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ReplaceFaceFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ReplaceFaceFeatureInput__set_targetBaseFeature(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.ReplaceFaceFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ReplaceFaceFeatureInput__get_isValid(self)

# Register ReplaceFaceFeatureInput in _fusion:
_fusion.ReplaceFaceFeatureInput_swigregister(ReplaceFaceFeatureInput)

def ReplaceFaceFeatureInput_classType() -> "char const *":
    return _fusion.ReplaceFaceFeatureInput_classType()


ReplaceFaceFeatureInput.sourceFaces = property(ReplaceFaceFeatureInput._get_sourceFaces, ReplaceFaceFeatureInput._set_sourceFaces, doc="Gets and sets the entities that define the source faces to perform replace.\nThe collection can contain the faces from a solid and/or from features. All the faces must be on the same body.")


ReplaceFaceFeatureInput.targetFaces = property(ReplaceFaceFeatureInput._get_targetFaces, ReplaceFaceFeatureInput._set_targetFaces, doc="Gets and sets the entities that define the target faces. The new faces must completely intersect the part.\nThe collection can contain the surface faces, surface bodies and construction planes.")


ReplaceFaceFeatureInput.isTangentChain = property(ReplaceFaceFeatureInput._get_isTangentChain, ReplaceFaceFeatureInput._set_isTangentChain, doc="Gets and sets if any faces that are tangentially connected to any of\nthe input faces will also be included in setting InputEntities. It defaults to true.")


ReplaceFaceFeatureInput.targetBaseFeature = property(ReplaceFaceFeatureInput._get_targetBaseFeature, ReplaceFaceFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


ReplaceFaceFeatureInput.cast = lambda arg: arg if isinstance(arg, ReplaceFaceFeatureInput) else None

class ReplaceFaceFeatures(Base):
    r"""
    Collection that provides access to all of the existing replace face features in a component
    and supports the ability to create new replace face features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ReplaceFaceFeatures *":
        return _fusion.ReplaceFaceFeatures___deref__(self)

    def __eq__(self, rhs: "ReplaceFaceFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ReplaceFaceFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "ReplaceFaceFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ReplaceFaceFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.ReplaceFaceFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::ReplaceFaceFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.ReplaceFaceFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ReplaceFaceFeatures_classType()
    __swig_destroy__ = _fusion.delete_ReplaceFaceFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::ReplaceFaceFeature >":
        r"""
        Function that returns the specified replace face feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ReplaceFaceFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of replace face features in the collection."""
        return _fusion.ReplaceFaceFeatures__get_count(self)

    def createInput(self, sourceFaces: "ObjectCollection", isTangentChain: "bool", targetFaces: "Base") -> "adsk::core::Ptr< adsk::fusion::ReplaceFaceFeatureInput >":
        r"""
        Creates a ReplaceFaceFeatureInput object. Use properties and methods on this object
        to define the replace face you want to create and then use the Add method, passing in 
        the ReplaceFaceFeatureInput object. 
        sourceFaces : Input the entities that define the source faces (the faces to be replaced).
        The collection can contain the faces from a solid and/or features. All the faces must be on the same body. 
        isTangentChain : A boolean value for setting whether or not faces that are tangentially connected to 
        the input faces (if any) will also be included. A value of true indicates that tangent
        faces will be included. 
        targetFaces : Input the entities that define the target faces. The new faces must completely intersect the part.
        The collection can contain the surface faces, surface bodies and construction planes. 
        Returns the newly created ReplaceFaceFeatureInput object or null if the creation failed.
        """
        return _fusion.ReplaceFaceFeatures_createInput(self, sourceFaces, isTangentChain, targetFaces)

    def add(self, input: "ReplaceFaceFeatureInput") -> "adsk::core::Ptr< adsk::fusion::ReplaceFaceFeature >":
        r"""
        Creates a new replace face feature. 
        input : A ReplaceFaceFeatureInput object that defines the desired replace face. Use the createInput 
        method to create a new ReplaceFaceFeatureInput object and then use methods on it 
        (the ReplaceFaceFeatureInput object) to define the replace face. 
        Returns the newly created ReplaceFaceFeature object or null if the creation failed.
        """
        return _fusion.ReplaceFaceFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::ReplaceFaceFeature >":
        r"""
        Function that returns the specified replace face feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.ReplaceFaceFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.ReplaceFaceFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ReplaceFaceFeatures__get_isValid(self)

# Register ReplaceFaceFeatures in _fusion:
_fusion.ReplaceFaceFeatures_swigregister(ReplaceFaceFeatures)

def ReplaceFaceFeatures_classType() -> "char const *":
    return _fusion.ReplaceFaceFeatures_classType()


ReplaceFaceFeatures.count = property(ReplaceFaceFeatures._get_count, doc="The number of replace face features in the collection.")


ReplaceFaceFeatures.cast = lambda arg: arg if isinstance(arg, ReplaceFaceFeatures) else None

class ReverseNormalFeatures(Base):
    r"""
    Collection that provides access to all of the existing Reverse Normal features in a component
    and supports the ability to create new Reverse Normal features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ReverseNormalFeatures *":
        return _fusion.ReverseNormalFeatures___deref__(self)

    def __eq__(self, rhs: "ReverseNormalFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ReverseNormalFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "ReverseNormalFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ReverseNormalFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.ReverseNormalFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::ReverseNormalFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.ReverseNormalFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ReverseNormalFeatures_classType()
    __swig_destroy__ = _fusion.delete_ReverseNormalFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::ReverseNormalFeature >":
        r"""
        Function that returns the specified Reverse Normal feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ReverseNormalFeatures_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::ReverseNormalFeature >":
        r"""
        Function that returns the specified reverse normal feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.ReverseNormalFeatures_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of Reverse Normal features in the collection."""
        return _fusion.ReverseNormalFeatures__get_count(self)

    def add(self, surfaces: "ObjectCollection") -> "adsk::core::Ptr< adsk::fusion::ReverseNormalFeature >":
        r"""
        Creates a new Reverse Normal feature. 
        surfaces : One or more surface bodies (open BRepBodies) containing the faces whose normals are to be reversed. 
        All faces of the input surface bodies get reversed. 
        Returns the newly created ReverseNormalFeature object or null if the creation failed.
        """
        return _fusion.ReverseNormalFeatures_add(self, surfaces)

    def _get_objectType(self) -> "char const *":
        return _fusion.ReverseNormalFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ReverseNormalFeatures__get_isValid(self)

# Register ReverseNormalFeatures in _fusion:
_fusion.ReverseNormalFeatures_swigregister(ReverseNormalFeatures)

def ReverseNormalFeatures_classType() -> "char const *":
    return _fusion.ReverseNormalFeatures_classType()


ReverseNormalFeatures.count = property(ReverseNormalFeatures._get_count, doc="The number of Reverse Normal features in the collection.")


ReverseNormalFeatures.cast = lambda arg: arg if isinstance(arg, ReverseNormalFeatures) else None

class RevolveFeatureInput(Base):
    r"""
    This class defines the methods and properties that pertain to the definition of a revolve 
    feature.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RevolveFeatureInput *":
        return _fusion.RevolveFeatureInput___deref__(self)

    def __eq__(self, rhs: "RevolveFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RevolveFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "RevolveFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RevolveFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RevolveFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_RevolveFeatureInput

    def _get_profile(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the profiles or planar faces used to define the shape of the revolve.
        This property can return or be set with a single Profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        This property returns null in the case where the feature is non-parametric.
        To create a surface (non-solid) revolution, you can use the createOpenProfile and createBRepEdgeProfile
        methods of the Component object to create an open profile. The isSolid property of the
        RevolveFeatureInput property must also be False.
        """
        return _fusion.RevolveFeatureInput__get_profile(self)

    def _set_profile(self, value: "Base") -> "bool":
        r"""
        Gets and sets the profiles or planar faces used to define the shape of the revolve.
        This property can return or be set with a single Profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        This property returns null in the case where the feature is non-parametric.
        To create a surface (non-solid) revolution, you can use the createOpenProfile and createBRepEdgeProfile
        methods of the Component object to create an open profile. The isSolid property of the
        RevolveFeatureInput property must also be False.
        """
        return _fusion.RevolveFeatureInput__set_profile(self, value)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations":
        r"""Gets and sets the type of operation performed by the revolve."""
        return _fusion.RevolveFeatureInput__get_operation(self)

    def _set_operation(self, value: "FeatureOperations") -> "bool":
        r"""Gets and sets the type of operation performed by the revolve."""
        return _fusion.RevolveFeatureInput__set_operation(self, value)

    def _get_axis(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the entity used to define the axis of revolution.
        The axis can be a sketch line, construction axis, or linear edge. If it is not in
        the same plane as the profile, it is projected onto the profile plane.
        """
        return _fusion.RevolveFeatureInput__get_axis(self)

    def _set_axis(self, value: "Base") -> "bool":
        r"""
        Gets and sets the entity used to define the axis of revolution.
        The axis can be a sketch line, construction axis, or linear edge. If it is not in
        the same plane as the profile, it is projected onto the profile plane.
        """
        return _fusion.RevolveFeatureInput__set_axis(self, value)

    def setAngleExtent(self, isSymmetric: "bool", angle: "ValueInput") -> "bool":
        r"""
        Defines the extent of the revolution to be at a specified angle.
        An angle and whether the extent is symmetric or only in one direction
        is specified. If it's not symmetric a positive or negative angle can be
        used to control the direction. If symmetric, the angle is the angle on one
        side so the entire angle of the revolution will be twice the specified angle. 
        Use an angle of 360 deg or 2 pi radians to create a full revolve. 
        isSymmetric : Set to 'true' for a revolve symmetrical about the profile plane 
        angle : The ValueInput object that defines the angle of the revolution 
        Returns true if successful
        """
        return _fusion.RevolveFeatureInput_setAngleExtent(self, isSymmetric, angle)

    def setTwoSideAngleExtent(self, angleOne: "ValueInput", angleTwo: "ValueInput") -> "bool":
        r"""
        Defines the angle of the revolve to be to applied to both sides of the profile 
        at the specified angles. 
        angleOne : The ValueInput object that defines the angle for the first side of the revolution 
        angleTwo : The ValueInput object that defines the angle for the second side of the revolution 
        Returns true if successful
        """
        return _fusion.RevolveFeatureInput_setTwoSideAngleExtent(self, angleOne, angleTwo)

    def setOneSideToExtent(self, *args) -> "bool":
        r"""
        Defines the extent of the revolve to be from the sketch or profile plane to the 
        specified 'To' face. 
        toEntity : The entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For a revolve it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        directionHint : Specifies the direction of the revolve. 
        Returns true if successful.
        """
        return _fusion.RevolveFeatureInput_setOneSideToExtent(self, *args)

    def setTwoSideToExtent(self, toEntityOne: "Base", toEntityTwo: "Base") -> "bool":
        r"""
        Defines the extents of the revolve to be from the sketch plane to specified 
        faces in both directions. If the matchShape argument is true, the faces to revolve to
        are extended to fully intersect the revolve. 
        toEntityOne : The first entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For a revolve it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        toEntityTwo : The second entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For a revolve it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        Returns true if successful.
        """
        return _fusion.RevolveFeatureInput_setTwoSideToExtent(self, toEntityOne, toEntityTwo)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the Revolve is created based on geometry (e.g. a profile and/or face(s))
        in another component AND (the Revolve) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.RevolveFeatureInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, value: "Occurrence") -> "bool":
        r"""
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the Revolve is created based on geometry (e.g. a profile and/or face(s))
        in another component AND (the Revolve) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.RevolveFeatureInput__set_creationOccurrence(self, value)

    def _get_isSolid(self) -> "bool":
        r"""
        Specifies if the revolution should be created as a solid or surface. If
        it's a surface then there aren't any end caps and it's open. This is
        initialized to true so a solid will be created if it's not changed.
        """
        return _fusion.RevolveFeatureInput__get_isSolid(self)

    def _set_isSolid(self, value: "bool") -> "bool":
        r"""
        Specifies if the revolution should be created as a solid or surface. If
        it's a surface then there aren't any end caps and it's open. This is
        initialized to true so a solid will be created if it's not changed.
        """
        return _fusion.RevolveFeatureInput__set_isSolid(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.RevolveFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.RevolveFeatureInput__set_targetBaseFeature(self, value)

    def _get_participantBodies(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepBody > > >":
        r"""
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        If this property has not been set, the default behavior is that all bodies that are intersected by the 
        feature will participate.
        This property can return null in the case where the feature has not been fully defined so that
        possible intersecting bodies can be computed.
        """
        return _fusion.RevolveFeatureInput__get_participantBodies(self)

    def _set_participantBodies(self, value: "BRepBodyVector") -> "bool":
        r"""
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        If this property has not been set, the default behavior is that all bodies that are intersected by the 
        feature will participate.
        This property can return null in the case where the feature has not been fully defined so that
        possible intersecting bodies can be computed.
        """
        return _fusion.RevolveFeatureInput__set_participantBodies(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.RevolveFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RevolveFeatureInput__get_isValid(self)

# Register RevolveFeatureInput in _fusion:
_fusion.RevolveFeatureInput_swigregister(RevolveFeatureInput)

def RevolveFeatureInput_classType() -> "char const *":
    return _fusion.RevolveFeatureInput_classType()


RevolveFeatureInput.profile = property(RevolveFeatureInput._get_profile, RevolveFeatureInput._set_profile, doc="Gets and sets the profiles or planar faces used to define the shape of the revolve.\nThis property can return or be set with a single Profile, a single planar face, or\nan ObjectCollection consisting of multiple profiles and planar faces. When an\nObjectCollection is used all of the profiles and faces must be co-planar.\nThis property returns null in the case where the feature is non-parametric.\nTo create a surface (non-solid) revolution, you can use the createOpenProfile and createBRepEdgeProfile\nmethods of the Component object to create an open profile. The isSolid property of the\nRevolveFeatureInput property must also be False.")


RevolveFeatureInput.operation = property(RevolveFeatureInput._get_operation, RevolveFeatureInput._set_operation, doc="Gets and sets the type of operation performed by the revolve.")


RevolveFeatureInput.axis = property(RevolveFeatureInput._get_axis, RevolveFeatureInput._set_axis, doc="Gets and sets the entity used to define the axis of revolution.\nThe axis can be a sketch line, construction axis, or linear edge. If it is not in\nthe same plane as the profile, it is projected onto the profile plane.")


RevolveFeatureInput.creationOccurrence = property(RevolveFeatureInput._get_creationOccurrence, RevolveFeatureInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an Occurrence for creation needs to be\nspecified when the Revolve is created based on geometry (e.g. a profile and/or face(s))\nin another component AND (the Revolve) is not in the root component.\nThe CreationOccurrence is analogous to the active occurrence in the UI")


RevolveFeatureInput.isSolid = property(RevolveFeatureInput._get_isSolid, RevolveFeatureInput._set_isSolid, doc="Specifies if the revolution should be created as a solid or surface. If\nit's a surface then there aren't any end caps and it's open. This is\ninitialized to true so a solid will be created if it's not changed.")


RevolveFeatureInput.targetBaseFeature = property(RevolveFeatureInput._get_targetBaseFeature, RevolveFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


RevolveFeatureInput.participantBodies = property(RevolveFeatureInput._get_participantBodies, RevolveFeatureInput._set_participantBodies, doc="Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.\nIf this property has not been set, the default behavior is that all bodies that are intersected by the\nfeature will participate.\nThis property can return null in the case where the feature has not been fully defined so that\npossible intersecting bodies can be computed.")


RevolveFeatureInput.cast = lambda arg: arg if isinstance(arg, RevolveFeatureInput) else None

class RevolveFeatures(Base):
    r"""
    Collection that provides access to all of the existing revolve features in a design
    and supports the ability to create new revolve features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RevolveFeatures *":
        return _fusion.RevolveFeatures___deref__(self)

    def __eq__(self, rhs: "RevolveFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RevolveFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "RevolveFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RevolveFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.RevolveFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::RevolveFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.RevolveFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RevolveFeatures_classType()
    __swig_destroy__ = _fusion.delete_RevolveFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::RevolveFeature >":
        r"""
        Function that returns the specified revolve feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.RevolveFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of revolve features in the collection."""
        return _fusion.RevolveFeatures__get_count(self)

    def createInput(self, profile: "Base", axis: "Base", operation: "FeatureOperations") -> "adsk::core::Ptr< adsk::fusion::RevolveFeatureInput >":
        r"""
        Creates a new RevolveFeatureInput object that is used to specify the input needed
        to create a new revolve feature. 
        profile : The profile argument can be a single Profile, a single
        planar face, or an ObjectCollection consisting of multiple profiles and planar faces.
        When an ObjectCollection is used all of the profiles and faces must be co-planar.
        To create a surface (non-solid) revolution, you can use the createOpenProfile and createBRepEdgeProfile
        methods of the Component object to create an open profile. You also need to set the isSolid property
        of the returned RevolveFeatureInput property to False. 
        axis : The axis can be a sketch line, construction axis, or linear edge. If it is not in
        the same plane as the profile, it is projected onto the profile plane. 
        operation : The operation type to perform. 
        Returns the newly created RevolveFeatureInput object or null if the creation failed.
        """
        return _fusion.RevolveFeatures_createInput(self, profile, axis, operation)

    def add(self, input: "RevolveFeatureInput") -> "adsk::core::Ptr< adsk::fusion::RevolveFeature >":
        r"""
        Creates a new revolve feature based on the information provided by the provided 
        RevolveFeatureInput object.
        To create a new revolve, use the createInput function to create a new input object 
        and then use the methods and properties on that object to define the required input 
        for a revolve. Once the information is defined on the input object you can pass it 
        to the Add method to create the revolve. 
        input : The RevolveFeatureInput object that specifies the input needed to create a new extrude 
        Returns the newly created RevolveFeature or null if the creation failed.
        """
        return _fusion.RevolveFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::RevolveFeature >":
        r"""
        Function that returns the specified revolve feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.RevolveFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.RevolveFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RevolveFeatures__get_isValid(self)

# Register RevolveFeatures in _fusion:
_fusion.RevolveFeatures_swigregister(RevolveFeatures)

def RevolveFeatures_classType() -> "char const *":
    return _fusion.RevolveFeatures_classType()


RevolveFeatures.count = property(RevolveFeatures._get_count, doc="The number of revolve features in the collection.")


RevolveFeatures.cast = lambda arg: arg if isinstance(arg, RevolveFeatures) else None

class RibFeatures(Base):
    r"""Collection that provides access to all of the existing rib features in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RibFeatures *":
        return _fusion.RibFeatures___deref__(self)

    def __eq__(self, rhs: "RibFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RibFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "RibFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RibFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.RibFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::RibFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.RibFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RibFeatures_classType()
    __swig_destroy__ = _fusion.delete_RibFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::RibFeature >":
        r"""
        Function that returns the specified Rib feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.RibFeatures_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::RibFeature >":
        r"""
        Function that returns the specified Rib feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.RibFeatures_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of Rib features in the collection."""
        return _fusion.RibFeatures__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.RibFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RibFeatures__get_isValid(self)

# Register RibFeatures in _fusion:
_fusion.RibFeatures_swigregister(RibFeatures)

def RibFeatures_classType() -> "char const *":
    return _fusion.RibFeatures_classType()


RibFeatures.count = property(RibFeatures._get_count, doc="The number of Rib features in the collection.")


RibFeatures.cast = lambda arg: arg if isinstance(arg, RibFeatures) else None

class RigidGroup(Base):
    r"""Represents a rigid group within an assembly."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RigidGroup *":
        return _fusion.RigidGroup___deref__(self)

    def __eq__(self, rhs: "RigidGroup") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RigidGroup___eq__(self, rhs)


    def __ne__(self, rhs: "RigidGroup") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RigidGroup___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RigidGroup_classType()
    __swig_destroy__ = _fusion.delete_RigidGroup

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this rigid group."""
        return _fusion.RigidGroup__get_parentComponent(self)

    def _get_name(self) -> "std::string":
        r"""Gets and sets the name of the rigid group as seen in the timeline."""
        return _fusion.RigidGroup__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the name of the rigid group as seen in the timeline."""
        return _fusion.RigidGroup__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this rigid group. 
        Returns True if the delete was successful.
        """
        return _fusion.RigidGroup_deleteMe(self)

    def _get_occurrences(self) -> "adsk::core::Ptr< adsk::fusion::OccurrenceList >":
        r"""Returns the list of occurrences that are part of the rigid group."""
        return _fusion.RigidGroup__get_occurrences(self)

    def setOccurrences(self, occurrences: "ObjectCollection", includeChildren: "bool") -> "bool":
        r"""
        Sets which occurrences are to be part of this rigid group. 
        occurrences : An ObjectCollection containing the occurrences to use in creating the rigid group. 
        includeChildren : Boolean indicating if the children of the input occurrences should be included in the rigid group. 
        Returns true if successful.
        """
        return _fusion.RigidGroup_setOccurrences(self, occurrences, includeChildren)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this rigid group."""
        return _fusion.RigidGroup__get_timelineObject(self)

    def _get_isSuppressed(self) -> "bool":
        r"""Gets and sets if this rigid group is suppressed."""
        return _fusion.RigidGroup__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""Gets and sets if this rigid group is suppressed."""
        return _fusion.RigidGroup__set_isSuppressed(self, value)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::RigidGroup >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.RigidGroup__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::RigidGroup >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.RigidGroup_createForAssemblyContext(self, occurrence)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.RigidGroup__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this rigid group."""
        return _fusion.RigidGroup__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the RigidGroup object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same rigid group.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.RigidGroup__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.RigidGroup__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RigidGroup__get_isValid(self)

# Register RigidGroup in _fusion:
_fusion.RigidGroup_swigregister(RigidGroup)

def RigidGroup_classType() -> "char const *":
    return _fusion.RigidGroup_classType()


RigidGroup.parentComponent = property(RigidGroup._get_parentComponent, doc="Returns the parent component that owns this rigid group.")


RigidGroup.name = property(RigidGroup._get_name, RigidGroup._set_name, doc="Gets and sets the name of the rigid group as seen in the timeline.")


RigidGroup.occurrences = property(RigidGroup._get_occurrences, doc="Returns the list of occurrences that are part of the rigid group.")


RigidGroup.timelineObject = property(RigidGroup._get_timelineObject, doc="Returns the timeline object associated with this rigid group.")


RigidGroup.isSuppressed = property(RigidGroup._get_isSuppressed, RigidGroup._set_isSuppressed, doc="Gets and sets if this rigid group is suppressed.")


RigidGroup.nativeObject = property(RigidGroup._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


RigidGroup.assemblyContext = property(RigidGroup._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")


RigidGroup.attributes = property(RigidGroup._get_attributes, doc="Returns the collection of attributes associated with this rigid group.")


RigidGroup.entityToken = property(RigidGroup._get_entityToken, doc="Returns a token for the RigidGroup object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same rigid group.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.")


RigidGroup.cast = lambda arg: arg if isinstance(arg, RigidGroup) else None

class RigidGroupList(Base):
    r"""A list of rigid groups."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RigidGroupList *":
        return _fusion.RigidGroupList___deref__(self)

    def __eq__(self, rhs: "RigidGroupList") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RigidGroupList___eq__(self, rhs)


    def __ne__(self, rhs: "RigidGroupList") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RigidGroupList___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.RigidGroupList___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::RigidGroup >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.RigidGroupList___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RigidGroupList_classType()
    __swig_destroy__ = _fusion.delete_RigidGroupList

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::RigidGroup >":
        r"""
        Function that returns the specified rigid group using an index into the list. 
        index : The index of the item within the list to return. The first item in the list has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.RigidGroupList_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::RigidGroup >":
        r"""
        Function that returns the specified rigid group using a name. 
        name : The name of the item within the list to return. 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.RigidGroupList_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""Returns number of rigid groups in the list."""
        return _fusion.RigidGroupList__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.RigidGroupList__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RigidGroupList__get_isValid(self)

# Register RigidGroupList in _fusion:
_fusion.RigidGroupList_swigregister(RigidGroupList)

def RigidGroupList_classType() -> "char const *":
    return _fusion.RigidGroupList_classType()


RigidGroupList.count = property(RigidGroupList._get_count, doc="Returns number of rigid groups in the list.")


RigidGroupList.cast = lambda arg: arg if isinstance(arg, RigidGroupList) else None

class RigidGroups(Base):
    r"""
    The collection of rigid groups in this component. This provides access to all existing 
    rigid groups and supports the ability to create new rigid groups.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RigidGroups *":
        return _fusion.RigidGroups___deref__(self)

    def __eq__(self, rhs: "RigidGroups") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RigidGroups___eq__(self, rhs)


    def __ne__(self, rhs: "RigidGroups") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RigidGroups___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.RigidGroups___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::RigidGroup >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.RigidGroups___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RigidGroups_classType()
    __swig_destroy__ = _fusion.delete_RigidGroups

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::RigidGroup >":
        r"""
        Function that returns the specified rigid group using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.RigidGroups_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::RigidGroup >":
        r"""
        Function that returns the specified rigid group using a name. 
        name : The name of the item within the collection to return. 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.RigidGroups_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""Returns number of joint origins in the collection."""
        return _fusion.RigidGroups__get_count(self)

    def add(self, occurrences: "ObjectCollection", includeChildren: "bool") -> "adsk::core::Ptr< adsk::fusion::RigidGroup >":
        r"""
        Creates a new rigid group. 
        occurrences : An ObjectCollection containing the occurrences to use in creating the rigid group. 
        includeChildren : Boolean indicating if the children of the input occurrences should be included in the rigid group. 
        Returns the new RigidGroup object or null in the case of failure.
        """
        return _fusion.RigidGroups_add(self, occurrences, includeChildren)

    def _get_objectType(self) -> "char const *":
        return _fusion.RigidGroups__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RigidGroups__get_isValid(self)

# Register RigidGroups in _fusion:
_fusion.RigidGroups_swigregister(RigidGroups)

def RigidGroups_classType() -> "char const *":
    return _fusion.RigidGroups_classType()


RigidGroups.count = property(RigidGroups._get_count, doc="Returns number of joint origins in the collection.")


RigidGroups.cast = lambda arg: arg if isinstance(arg, RigidGroups) else None

class RuledSurfaceFeatureInput(Base):
    r"""This class defines the methods and properties that pertain to the definition of a Ruled Surface feature."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RuledSurfaceFeatureInput *":
        return _fusion.RuledSurfaceFeatureInput___deref__(self)

    def __eq__(self, rhs: "RuledSurfaceFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RuledSurfaceFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "RuledSurfaceFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RuledSurfaceFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RuledSurfaceFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_RuledSurfaceFeatureInput

    def _get_profile(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the Profile object that defines the sketch geometry or edges that define the shape of 
        the ruled surface. The Component.createBRepEdgeProfile method is useful to create a profile defined from edges.
        """
        return _fusion.RuledSurfaceFeatureInput__get_profile(self)

    def _set_profile(self, value: "Base") -> "bool":
        r"""
        Gets and sets the Profile object that defines the sketch geometry or edges that define the shape of 
        the ruled surface. The Component.createBRepEdgeProfile method is useful to create a profile defined from edges.
        """
        return _fusion.RuledSurfaceFeatureInput__set_profile(self, value)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the Ruled Surface is created based on geometry (e.g. a profile)
        in another component AND (the Ruled Surface) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.RuledSurfaceFeatureInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, value: "Occurrence") -> "bool":
        r"""
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the Ruled Surface is created based on geometry (e.g. a profile)
        in another component AND (the Ruled Surface) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.RuledSurfaceFeatureInput__set_creationOccurrence(self, value)

    def _get_distance(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Gets and sets the ValueInput object that defines the Ruled Surface distance. If the value input is
        a real value it will define the distance in centimeters.
        """
        return _fusion.RuledSurfaceFeatureInput__get_distance(self)

    def _set_distance(self, value: "ValueInput") -> "bool":
        r"""
        Gets and sets the ValueInput object that defines the Ruled Surface distance. If the value input is
        a real value it will define the distance in centimeters.
        """
        return _fusion.RuledSurfaceFeatureInput__set_distance(self, value)

    def _get_angle(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Gets and sets the ValueInput object that defines the Ruled Surface angle. 
        If the input is a real value, the units are radians.
        """
        return _fusion.RuledSurfaceFeatureInput__get_angle(self)

    def _set_angle(self, value: "ValueInput") -> "bool":
        r"""
        Gets and sets the ValueInput object that defines the Ruled Surface angle. 
        If the input is a real value, the units are radians.
        """
        return _fusion.RuledSurfaceFeatureInput__set_angle(self, value)

    def _get_ruledSurfaceType(self) -> "adsk::fusion::RuledSurfaceTypes":
        r"""
        Gets and sets the type of ruled surface to create. To set this to DirectionRuledSurfaceType,
        use the direction property to set the direction entity, which will automatically set
        this to DirectionRuledSurfaceType.
        """
        return _fusion.RuledSurfaceFeatureInput__get_ruledSurfaceType(self)

    def _set_ruledSurfaceType(self, value: "RuledSurfaceTypes") -> "bool":
        r"""
        Gets and sets the type of ruled surface to create. To set this to DirectionRuledSurfaceType,
        use the direction property to set the direction entity, which will automatically set
        this to DirectionRuledSurfaceType.
        """
        return _fusion.RuledSurfaceFeatureInput__set_ruledSurfaceType(self, value)

    def _get_direction(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the entity that defines the direction when the ruled surface type is DirectionRuledSurfaceType.
        The direction is specified by providing a linear or planar entity. For example, a linear edge, construction axis, 
        planar face, or construction plane can be used as input.
        If this property is set when the ruledSurfaceType is not DirectionRuledSurfaceType, the type will automatically be
        changed to DirectionRuledSurfaceType. If you get this property when the direction is not DirectionRuledSurfaceType,
        it will return null.
        """
        return _fusion.RuledSurfaceFeatureInput__get_direction(self)

    def _set_direction(self, value: "Base") -> "bool":
        r"""
        Gets and sets the entity that defines the direction when the ruled surface type is DirectionRuledSurfaceType.
        The direction is specified by providing a linear or planar entity. For example, a linear edge, construction axis, 
        planar face, or construction plane can be used as input.
        If this property is set when the ruledSurfaceType is not DirectionRuledSurfaceType, the type will automatically be
        changed to DirectionRuledSurfaceType. If you get this property when the direction is not DirectionRuledSurfaceType,
        it will return null.
        """
        return _fusion.RuledSurfaceFeatureInput__set_direction(self, value)

    def _get_alternateFace(self) -> "bool":
        r"""
        Gets and sets if the other face is used for creation of the Ruled Surface.
        When creating a ruled surface using the edges of a solid or the interior edges
        of a surface the angle of the ruled surface is measured with respect to the
        face the selected edge is bounding. For a solid, or an interior edge on a surface,
        the edge connects to two faces. This setting toggles which of the two faces will
        be used for measuring the angle.
        """
        return _fusion.RuledSurfaceFeatureInput__get_alternateFace(self)

    def _set_alternateFace(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the other face is used for creation of the Ruled Surface.
        When creating a ruled surface using the edges of a solid or the interior edges
        of a surface the angle of the ruled surface is measured with respect to the
        face the selected edge is bounding. For a solid, or an interior edge on a surface,
        the edge connects to two faces. This setting toggles which of the two faces will
        be used for measuring the angle.
        """
        return _fusion.RuledSurfaceFeatureInput__set_alternateFace(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.RuledSurfaceFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.RuledSurfaceFeatureInput__set_targetBaseFeature(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.RuledSurfaceFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RuledSurfaceFeatureInput__get_isValid(self)

# Register RuledSurfaceFeatureInput in _fusion:
_fusion.RuledSurfaceFeatureInput_swigregister(RuledSurfaceFeatureInput)

def RuledSurfaceFeatureInput_classType() -> "char const *":
    return _fusion.RuledSurfaceFeatureInput_classType()


RuledSurfaceFeatureInput.profile = property(RuledSurfaceFeatureInput._get_profile, RuledSurfaceFeatureInput._set_profile, doc="Gets and sets the Profile object that defines the sketch geometry or edges that define the shape of\nthe ruled surface. The Component.createBRepEdgeProfile method is useful to create a profile defined from edges.")


RuledSurfaceFeatureInput.creationOccurrence = property(RuledSurfaceFeatureInput._get_creationOccurrence, RuledSurfaceFeatureInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an Occurrence for creation needs to be\nspecified when the Ruled Surface is created based on geometry (e.g. a profile)\nin another component AND (the Ruled Surface) is not in the root component.\nThe CreationOccurrence is analogous to the active occurrence in the UI")


RuledSurfaceFeatureInput.distance = property(RuledSurfaceFeatureInput._get_distance, RuledSurfaceFeatureInput._set_distance, doc="Gets and sets the ValueInput object that defines the Ruled Surface distance. If the value input is\na real value it will define the distance in centimeters.")


RuledSurfaceFeatureInput.angle = property(RuledSurfaceFeatureInput._get_angle, RuledSurfaceFeatureInput._set_angle, doc="Gets and sets the ValueInput object that defines the Ruled Surface angle.\nIf the input is a real value, the units are radians.")


RuledSurfaceFeatureInput.ruledSurfaceType = property(RuledSurfaceFeatureInput._get_ruledSurfaceType, RuledSurfaceFeatureInput._set_ruledSurfaceType, doc="Gets and sets the type of ruled surface to create. To set this to DirectionRuledSurfaceType,\nuse the direction property to set the direction entity, which will automatically set\nthis to DirectionRuledSurfaceType.")


RuledSurfaceFeatureInput.direction = property(RuledSurfaceFeatureInput._get_direction, RuledSurfaceFeatureInput._set_direction, doc="Gets and sets the entity that defines the direction when the ruled surface type is DirectionRuledSurfaceType.\nThe direction is specified by providing a linear or planar entity. For example, a linear edge, construction axis,\nplanar face, or construction plane can be used as input.\nIf this property is set when the ruledSurfaceType is not DirectionRuledSurfaceType, the type will automatically be\nchanged to DirectionRuledSurfaceType. If you get this property when the direction is not DirectionRuledSurfaceType,\nit will return null.")


RuledSurfaceFeatureInput.alternateFace = property(RuledSurfaceFeatureInput._get_alternateFace, RuledSurfaceFeatureInput._set_alternateFace, doc="Gets and sets if the other face is used for creation of the Ruled Surface.\nWhen creating a ruled surface using the edges of a solid or the interior edges\nof a surface the angle of the ruled surface is measured with respect to the\nface the selected edge is bounding. For a solid, or an interior edge on a surface,\nthe edge connects to two faces. This setting toggles which of the two faces will\nbe used for measuring the angle.")


RuledSurfaceFeatureInput.targetBaseFeature = property(RuledSurfaceFeatureInput._get_targetBaseFeature, RuledSurfaceFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


RuledSurfaceFeatureInput.cast = lambda arg: arg if isinstance(arg, RuledSurfaceFeatureInput) else None

class RuledSurfaceFeatures(Base):
    r"""
    Collection that provides access to all of the existing Ruled Surface features in a component
    and supports the ability to create new Ruled Surface features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RuledSurfaceFeatures *":
        return _fusion.RuledSurfaceFeatures___deref__(self)

    def __eq__(self, rhs: "RuledSurfaceFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RuledSurfaceFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "RuledSurfaceFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RuledSurfaceFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.RuledSurfaceFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::RuledSurfaceFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.RuledSurfaceFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RuledSurfaceFeatures_classType()
    __swig_destroy__ = _fusion.delete_RuledSurfaceFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::RuledSurfaceFeature >":
        r"""
        Function that returns the specified ruled surface feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.RuledSurfaceFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of RuledSurface features in the collection."""
        return _fusion.RuledSurfaceFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::RuledSurfaceFeatureInput >":
        r"""
        Creates a RuledSurfaceFeatureInput object that defines the input needed to create a ruled surface feature. Use the input
        object to define the input to create the desired feature and then use the Add method, passing in the RuledSurfaceFeatureInput object. 
        profile : A Profile object that defines the sketch geometry or edges that define the shape of the ruled surface. The Component.createBRepEdgeProfile 
        method is useful to create a profile defined from edges. 
        distance : ValueInput object that defines the extension distance of the Ruled Surface.. 
        angle : ValueInput object that defines angle to use when creating the Ruled Surface. When the input is a real value, the units are radians. 
        ruledSurfaceType : The Ruled Surface type (TangentRuledSurfaceType, NormalRuledSurfaceType, or DirectionRuledSurfaceType). 
        direction : If the ruled surface type is DirectionRuledSurfaceType, you must specify the direction. The direction is specified by
        providing a linear or planar entity. For example, a linear edge, construction axis, planar face, or construction plane can be used as input. 
        Returns the newly created RuledSurfaceFeatureInput object or null if the creation failed.
        """
        return _fusion.RuledSurfaceFeatures_createInput(self, *args)

    def add(self, input: "RuledSurfaceFeatureInput") -> "adsk::core::Ptr< adsk::fusion::RuledSurfaceFeature >":
        r"""
        Creates a new RuledSurface feature. 
        input : An RuledSurfaceFeatureInput object that defines the desired RuledSurface feature. Use the createInput 
        method to create a new RuledSurfaceFeatureInput object and then use methods on it 
        (the RuledSurfaceFeatureInput object) to define the desired options for the ruled surface feature. 
        Returns the newly created RuledSurfaceFeature object or null if the creation failed.
        """
        return _fusion.RuledSurfaceFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::RuledSurfaceFeature >":
        r"""
        Function that returns the specified RuledSurface feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.RuledSurfaceFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.RuledSurfaceFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RuledSurfaceFeatures__get_isValid(self)

# Register RuledSurfaceFeatures in _fusion:
_fusion.RuledSurfaceFeatures_swigregister(RuledSurfaceFeatures)

def RuledSurfaceFeatures_classType() -> "char const *":
    return _fusion.RuledSurfaceFeatures_classType()


RuledSurfaceFeatures.count = property(RuledSurfaceFeatures._get_count, doc="The number of RuledSurface features in the collection.")


RuledSurfaceFeatures.cast = lambda arg: arg if isinstance(arg, RuledSurfaceFeatures) else None

class RuleFilletFeatures(Base):
    r"""Collection that provides access to all of the existing rule fillet features in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RuleFilletFeatures *":
        return _fusion.RuleFilletFeatures___deref__(self)

    def __eq__(self, rhs: "RuleFilletFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RuleFilletFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "RuleFilletFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RuleFilletFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.RuleFilletFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::RuleFilletFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.RuleFilletFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RuleFilletFeatures_classType()
    __swig_destroy__ = _fusion.delete_RuleFilletFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::RuleFilletFeature >":
        r"""
        Function that returns the specified rule fillet feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.RuleFilletFeatures_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::RuleFilletFeature >":
        r"""
        Function that returns the specified rule fillet feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.RuleFilletFeatures_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of rule fillet features in the collection."""
        return _fusion.RuleFilletFeatures__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.RuleFilletFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RuleFilletFeatures__get_isValid(self)

# Register RuleFilletFeatures in _fusion:
_fusion.RuleFilletFeatures_swigregister(RuleFilletFeatures)

def RuleFilletFeatures_classType() -> "char const *":
    return _fusion.RuleFilletFeatures_classType()


RuleFilletFeatures.count = property(RuleFilletFeatures._get_count, doc="The number of rule fillet features in the collection.")


RuleFilletFeatures.cast = lambda arg: arg if isinstance(arg, RuleFilletFeatures) else None

class ScaleFeatureInput(Base):
    r"""
    This class defines the methods and properties that pertain to the definition of a scale 
    feature.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ScaleFeatureInput *":
        return _fusion.ScaleFeatureInput___deref__(self)

    def __eq__(self, rhs: "ScaleFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ScaleFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "ScaleFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ScaleFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ScaleFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_ScaleFeatureInput

    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the input entities.
        This collection can contain sketches, BRep bodies and T-Spline bodies in parametric modeling.
        It can contain sketches, BRep bodies, T-Spline bodies, mesh bodies, root component and occurrences in non-parametric modeling.
        If the scaling is non-uniform (the isUniform property is false), this collection cannot contain sketches or components.
        """
        return _fusion.ScaleFeatureInput__get_inputEntities(self)

    def _set_inputEntities(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the input entities.
        This collection can contain sketches, BRep bodies and T-Spline bodies in parametric modeling.
        It can contain sketches, BRep bodies, T-Spline bodies, mesh bodies, root component and occurrences in non-parametric modeling.
        If the scaling is non-uniform (the isUniform property is false), this collection cannot contain sketches or components.
        """
        return _fusion.ScaleFeatureInput__set_inputEntities(self, value)

    def _get_point(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets and sets the origin point of the scale. This can be a BRepVertex, a SketchPoint or a ConstructionPoint."""
        return _fusion.ScaleFeatureInput__get_point(self)

    def _set_point(self, value: "Base") -> "bool":
        r"""Gets and sets the origin point of the scale. This can be a BRepVertex, a SketchPoint or a ConstructionPoint."""
        return _fusion.ScaleFeatureInput__set_point(self, value)

    def _get_scaleFactor(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Gets and sets the scale factor used for a uniform scale.
        Setting this value will cause the isUniform property to be set to true.
        """
        return _fusion.ScaleFeatureInput__get_scaleFactor(self)

    def _set_scaleFactor(self, value: "ValueInput") -> "bool":
        r"""
        Gets and sets the scale factor used for a uniform scale.
        Setting this value will cause the isUniform property to be set to true.
        """
        return _fusion.ScaleFeatureInput__set_scaleFactor(self, value)

    def _get_isUniform(self) -> "bool":
        r"""Gets if the scale is uniform."""
        return _fusion.ScaleFeatureInput__get_isUniform(self)

    def setToNonUniform(self, xScale: "ValueInput", yScale: "ValueInput", zScale: "ValueInput") -> "bool":
        r"""
        Sets the scale factor for the x, y, z directions to define a non-uniform scale.
        Calling this method will cause the isUniform property to be set to false.
        This will fail if the inputEntities collection contains sketches or components. 
        xScale : A ValueInput object that defines the scale in the X direction. 
        yScale : A ValueInput object that defines the scale in the Y direction. 
        zScale : A ValueInput object that defines the scale in the Z direction. 
        Returns true if successful.
        """
        return _fusion.ScaleFeatureInput_setToNonUniform(self, xScale, yScale, zScale)

    def _get_xScale(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets the scale in X direction."""
        return _fusion.ScaleFeatureInput__get_xScale(self)

    def _get_yScale(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets the scale in Y direction."""
        return _fusion.ScaleFeatureInput__get_yScale(self)

    def _get_zScale(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets the scale in Z direction."""
        return _fusion.ScaleFeatureInput__get_zScale(self)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ScaleFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ScaleFeatureInput__set_targetBaseFeature(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.ScaleFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ScaleFeatureInput__get_isValid(self)

# Register ScaleFeatureInput in _fusion:
_fusion.ScaleFeatureInput_swigregister(ScaleFeatureInput)

def ScaleFeatureInput_classType() -> "char const *":
    return _fusion.ScaleFeatureInput_classType()


ScaleFeatureInput.inputEntities = property(ScaleFeatureInput._get_inputEntities, ScaleFeatureInput._set_inputEntities, doc="Gets and sets the input entities.\nThis collection can contain sketches, BRep bodies and T-Spline bodies in parametric modeling.\nIt can contain sketches, BRep bodies, T-Spline bodies, mesh bodies, root component and occurrences in non-parametric modeling.\nIf the scaling is non-uniform (the isUniform property is false), this collection cannot contain sketches or components.")


ScaleFeatureInput.point = property(ScaleFeatureInput._get_point, ScaleFeatureInput._set_point, doc="Gets and sets the origin point of the scale. This can be a BRepVertex, a SketchPoint or a ConstructionPoint.")


ScaleFeatureInput.scaleFactor = property(ScaleFeatureInput._get_scaleFactor, ScaleFeatureInput._set_scaleFactor, doc="Gets and sets the scale factor used for a uniform scale.\nSetting this value will cause the isUniform property to be set to true.")


ScaleFeatureInput.isUniform = property(ScaleFeatureInput._get_isUniform, doc="Gets if the scale is uniform.")


ScaleFeatureInput.xScale = property(ScaleFeatureInput._get_xScale, doc="Gets the scale in X direction.")


ScaleFeatureInput.yScale = property(ScaleFeatureInput._get_yScale, doc="Gets the scale in Y direction.")


ScaleFeatureInput.zScale = property(ScaleFeatureInput._get_zScale, doc="Gets the scale in Z direction.")


ScaleFeatureInput.targetBaseFeature = property(ScaleFeatureInput._get_targetBaseFeature, ScaleFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


ScaleFeatureInput.cast = lambda arg: arg if isinstance(arg, ScaleFeatureInput) else None

class ScaleFeatures(Base):
    r"""
    Collection that provides access to all of the existing scale features in a component
    and supports the ability to create new scale features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ScaleFeatures *":
        return _fusion.ScaleFeatures___deref__(self)

    def __eq__(self, rhs: "ScaleFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ScaleFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "ScaleFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ScaleFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.ScaleFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::ScaleFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.ScaleFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ScaleFeatures_classType()
    __swig_destroy__ = _fusion.delete_ScaleFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::ScaleFeature >":
        r"""
        Function that returns the specified scale feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ScaleFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of scale features in the collection."""
        return _fusion.ScaleFeatures__get_count(self)

    def createInput(self, inputEntities: "ObjectCollection", point: "Base", scaleFactor: "ValueInput") -> "adsk::core::Ptr< adsk::fusion::ScaleFeatureInput >":
        r"""
        Creates a ScaleFeatureInput object. Use properties and methods on this object
        to define the scale you want to create and then use the Add method, passing in 
        the ScaleFeatureInput object. 
        inputEntities : This collection can contain sketches, BRep bodies and T-Spline bodies in parametric modeling.
        It can contain sketches, BRep bodies, T-Spline bodies, mesh bodies, root component and occurrences in non-parametric modeling. 
        point : Input a point as reference to scale. This can be a BRepVertex, a SketchPoint or a ConstructionPoint. 
        scaleFactor : The ValueInput object that defines the scale factor for uniform scale. 
        Returns the newly created ScaleFeatureInput object or null if the creation failed.
        """
        return _fusion.ScaleFeatures_createInput(self, inputEntities, point, scaleFactor)

    def add(self, input: "ScaleFeatureInput") -> "adsk::core::Ptr< adsk::fusion::ScaleFeature >":
        r"""
        Creates a new scale feature. 
        input : A ScaleFeatureInput object that defines the desired scale. Use the createInput 
        method to create a new ScaleFeatureInput object and then use methods on it 
        (the ScaleFeatureInput object) to define the scale. 
        Returns the newly created ScaleFeature object or null if the creation failed.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ScaleFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::ScaleFeature >":
        r"""
        Function that returns the specified scale feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.ScaleFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.ScaleFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ScaleFeatures__get_isValid(self)

# Register ScaleFeatures in _fusion:
_fusion.ScaleFeatures_swigregister(ScaleFeatures)

def ScaleFeatures_classType() -> "char const *":
    return _fusion.ScaleFeatures_classType()


ScaleFeatures.count = property(ScaleFeatures._get_count, doc="The number of scale features in the collection.")


ScaleFeatures.cast = lambda arg: arg if isinstance(arg, ScaleFeatures) else None

class ShellFeatureInput(Base):
    r"""
    This class defines the methods and properties that pertain to the definition of a shell 
    feature.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ShellFeatureInput *":
        return _fusion.ShellFeatureInput___deref__(self)

    def __eq__(self, rhs: "ShellFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ShellFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "ShellFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ShellFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ShellFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_ShellFeatureInput

    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the input faces/bodies.
        If IsTangentChain is true, all the faces that are tangentially connected to the input faces (if any) will also be included.
        Fails if any faces are input, and the owning bodies of the faces are also input.
        """
        return _fusion.ShellFeatureInput__get_inputEntities(self)

    def _set_inputEntities(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the input faces/bodies.
        If IsTangentChain is true, all the faces that are tangentially connected to the input faces (if any) will also be included.
        Fails if any faces are input, and the owning bodies of the faces are also input.
        """
        return _fusion.ShellFeatureInput__set_inputEntities(self, value)

    def _get_isTangentChain(self) -> "bool":
        r"""
        Gets and sets if any faces that are tangentially connected to any of 
        the input faces will also be included in setting InputEntities. It defaults to true.
        """
        return _fusion.ShellFeatureInput__get_isTangentChain(self)

    def _set_isTangentChain(self, value: "bool") -> "bool":
        r"""
        Gets and sets if any faces that are tangentially connected to any of 
        the input faces will also be included in setting InputEntities. It defaults to true.
        """
        return _fusion.ShellFeatureInput__set_isTangentChain(self, value)

    def _get_insideThickness(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets and sets the inside thickness."""
        return _fusion.ShellFeatureInput__get_insideThickness(self)

    def _set_insideThickness(self, value: "ValueInput") -> "bool":
        r"""Gets and sets the inside thickness."""
        return _fusion.ShellFeatureInput__set_insideThickness(self, value)

    def _get_outsideThickness(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets and sets the outside thickness."""
        return _fusion.ShellFeatureInput__get_outsideThickness(self)

    def _set_outsideThickness(self, value: "ValueInput") -> "bool":
        r"""Gets and sets the outside thickness."""
        return _fusion.ShellFeatureInput__set_outsideThickness(self, value)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the shell is created based on geometry (e.g. a profile and/or face(s))
        in another component AND (the shell) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.ShellFeatureInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, value: "Occurrence") -> "bool":
        r"""
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the shell is created based on geometry (e.g. a profile and/or face(s))
        in another component AND (the shell) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.ShellFeatureInput__set_creationOccurrence(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ShellFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ShellFeatureInput__set_targetBaseFeature(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.ShellFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ShellFeatureInput__get_isValid(self)

# Register ShellFeatureInput in _fusion:
_fusion.ShellFeatureInput_swigregister(ShellFeatureInput)

def ShellFeatureInput_classType() -> "char const *":
    return _fusion.ShellFeatureInput_classType()


ShellFeatureInput.inputEntities = property(ShellFeatureInput._get_inputEntities, ShellFeatureInput._set_inputEntities, doc="Gets and sets the input faces/bodies.\nIf IsTangentChain is true, all the faces that are tangentially connected to the input faces (if any) will also be included.\nFails if any faces are input, and the owning bodies of the faces are also input.")


ShellFeatureInput.isTangentChain = property(ShellFeatureInput._get_isTangentChain, ShellFeatureInput._set_isTangentChain, doc="Gets and sets if any faces that are tangentially connected to any of\nthe input faces will also be included in setting InputEntities. It defaults to true.")


ShellFeatureInput.insideThickness = property(ShellFeatureInput._get_insideThickness, ShellFeatureInput._set_insideThickness, doc="Gets and sets the inside thickness.")


ShellFeatureInput.outsideThickness = property(ShellFeatureInput._get_outsideThickness, ShellFeatureInput._set_outsideThickness, doc="Gets and sets the outside thickness.")


ShellFeatureInput.creationOccurrence = property(ShellFeatureInput._get_creationOccurrence, ShellFeatureInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an Occurrence for creation needs to be\nspecified when the shell is created based on geometry (e.g. a profile and/or face(s))\nin another component AND (the shell) is not in the root component.\nThe CreationOccurrence is analogous to the active occurrence in the UI")


ShellFeatureInput.targetBaseFeature = property(ShellFeatureInput._get_targetBaseFeature, ShellFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


ShellFeatureInput.cast = lambda arg: arg if isinstance(arg, ShellFeatureInput) else None

class ShellFeatures(Base):
    r"""
    Collection that provides access to all of the existing shell features in a component
    and supports the ability to create new shell features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ShellFeatures *":
        return _fusion.ShellFeatures___deref__(self)

    def __eq__(self, rhs: "ShellFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ShellFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "ShellFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ShellFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.ShellFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::ShellFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.ShellFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ShellFeatures_classType()
    __swig_destroy__ = _fusion.delete_ShellFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::ShellFeature >":
        r"""
        Function that returns the specified shell feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ShellFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of shell features in the collection."""
        return _fusion.ShellFeatures__get_count(self)

    def createInput(self, inputEntities: "ObjectCollection", isTangentChain: "bool"=True) -> "adsk::core::Ptr< adsk::fusion::ShellFeatureInput >":
        r"""
        Creates a ShellFeatureInput object. Use properties and methods on this object
        to define the shell you want to create and then use the Add method, passing in 
        the ShellFeatureInput object. 
        inputEntities : The collection contains the faces to remove and the bodies to perform shell.
        Fails if any faces are input, and the owning bodies of the faces are also input. 
        isTangentChain : A boolean value for setting whether or not faces that are tangentially connected to 
        the input faces (if any) will also be included. It defaults to true. 
        Returns the newly created ShellFeatureInput object or null if the creation failed.
        """
        return _fusion.ShellFeatures_createInput(self, inputEntities, isTangentChain)

    def add(self, input: "ShellFeatureInput") -> "adsk::core::Ptr< adsk::fusion::ShellFeature >":
        r"""
        Creates a new shell feature. 
        input : A ShellFeatureInput object that defines the desired shell. Use the createInput 
        method to create a new ShellFeatureInput object and then use methods on it 
        (the ShellFeatureInput object) to define the shell. 
        Returns the newly created ShellFeature object or null if the creation failed.
        """
        return _fusion.ShellFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::ShellFeature >":
        r"""
        Function that returns the specified shell feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.ShellFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.ShellFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ShellFeatures__get_isValid(self)

# Register ShellFeatures in _fusion:
_fusion.ShellFeatures_swigregister(ShellFeatures)

def ShellFeatures_classType() -> "char const *":
    return _fusion.ShellFeatures_classType()


ShellFeatures.count = property(ShellFeatures._get_count, doc="The number of shell features in the collection.")


ShellFeatures.cast = lambda arg: arg if isinstance(arg, ShellFeatures) else None

class SilhouetteSplitFeatureInput(Base):
    r"""This class defines the methods and properties that pertain to the definition of a silhouette split feature."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SilhouetteSplitFeatureInput *":
        return _fusion.SilhouetteSplitFeatureInput___deref__(self)

    def __eq__(self, rhs: "SilhouetteSplitFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SilhouetteSplitFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "SilhouetteSplitFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SilhouetteSplitFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SilhouetteSplitFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_SilhouetteSplitFeatureInput

    def _get_targetBody(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""Gets and sets the solid body to split."""
        return _fusion.SilhouetteSplitFeatureInput__get_targetBody(self)

    def _set_targetBody(self, value: "BRepBody") -> "bool":
        r"""Gets and sets the solid body to split."""
        return _fusion.SilhouetteSplitFeatureInput__set_targetBody(self, value)

    def _get_viewDirection(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the entity that defines the silhouette view direction, which can be a 
        construction axis, linear BRepEdge, planar BRepFace or a construction plane.
        """
        return _fusion.SilhouetteSplitFeatureInput__get_viewDirection(self)

    def _set_viewDirection(self, value: "Base") -> "bool":
        r"""
        Gets and sets the entity that defines the silhouette view direction, which can be a 
        construction axis, linear BRepEdge, planar BRepFace or a construction plane.
        """
        return _fusion.SilhouetteSplitFeatureInput__set_viewDirection(self, value)

    def _get_operation(self) -> "adsk::fusion::SilhouetteSplitOperations":
        r"""Gets and sets the type of silhouette split operation to perform."""
        return _fusion.SilhouetteSplitFeatureInput__get_operation(self)

    def _set_operation(self, value: "SilhouetteSplitOperations") -> "bool":
        r"""Gets and sets the type of silhouette split operation to perform."""
        return _fusion.SilhouetteSplitFeatureInput__set_operation(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.SilhouetteSplitFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.SilhouetteSplitFeatureInput__set_targetBaseFeature(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.SilhouetteSplitFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SilhouetteSplitFeatureInput__get_isValid(self)

# Register SilhouetteSplitFeatureInput in _fusion:
_fusion.SilhouetteSplitFeatureInput_swigregister(SilhouetteSplitFeatureInput)

def SilhouetteSplitFeatureInput_classType() -> "char const *":
    return _fusion.SilhouetteSplitFeatureInput_classType()


SilhouetteSplitFeatureInput.targetBody = property(SilhouetteSplitFeatureInput._get_targetBody, SilhouetteSplitFeatureInput._set_targetBody, doc="Gets and sets the solid body to split.")


SilhouetteSplitFeatureInput.viewDirection = property(SilhouetteSplitFeatureInput._get_viewDirection, SilhouetteSplitFeatureInput._set_viewDirection, doc="Gets and sets the entity that defines the silhouette view direction, which can be a\nconstruction axis, linear BRepEdge, planar BRepFace or a construction plane.")


SilhouetteSplitFeatureInput.operation = property(SilhouetteSplitFeatureInput._get_operation, SilhouetteSplitFeatureInput._set_operation, doc="Gets and sets the type of silhouette split operation to perform.")


SilhouetteSplitFeatureInput.targetBaseFeature = property(SilhouetteSplitFeatureInput._get_targetBaseFeature, SilhouetteSplitFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


SilhouetteSplitFeatureInput.cast = lambda arg: arg if isinstance(arg, SilhouetteSplitFeatureInput) else None

class SilhouetteSplitFeatures(Base):
    r"""
    Collection that provides access to all of the existing Silhouette Split features in a component
    and supports the ability to create new Silhouette Split features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SilhouetteSplitFeatures *":
        return _fusion.SilhouetteSplitFeatures___deref__(self)

    def __eq__(self, rhs: "SilhouetteSplitFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SilhouetteSplitFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "SilhouetteSplitFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SilhouetteSplitFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.SilhouetteSplitFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::SilhouetteSplitFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.SilhouetteSplitFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SilhouetteSplitFeatures_classType()
    __swig_destroy__ = _fusion.delete_SilhouetteSplitFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::SilhouetteSplitFeature >":
        r"""
        Function that returns the specified silhouette split feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SilhouetteSplitFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of Silhouette Split features in the collection."""
        return _fusion.SilhouetteSplitFeatures__get_count(self)

    def createInput(self, viewDirection: "Base", targetBody: "BRepBody", operation: "SilhouetteSplitOperations") -> "adsk::core::Ptr< adsk::fusion::SilhouetteSplitFeatureInput >":
        r"""
        Creates a SilhouetteSplitFeatureInput object. Use properties and methods on this object
        to define the silhouette split you want to create and then use the Add method, passing in 
        the SilhouetteSplitFeatureInput object. 
        viewDirection : A construction axis, linear BRepEdge, planar BRepFace or a construction plane that defines the view direction
        where the silhouette is calculated. 
        targetBody : Input the single solid body to split 
        operation : The type of silhouette split operation to perform. 
        Returns the newly created SilhouetteSplitFeatureInput object or null if the creation failed.
        """
        return _fusion.SilhouetteSplitFeatures_createInput(self, viewDirection, targetBody, operation)

    def add(self, input: "SilhouetteSplitFeatureInput") -> "adsk::core::Ptr< adsk::fusion::SilhouetteSplitFeature >":
        r"""
        Creates a new silhouette split feature. 
        input : A SilhouetteSplitFeatureInput object that defines the desired silhouette split feature. Use the createInput 
        method to create a new SilhouetteSplitFeatureInput object and then use methods on it 
        (the SilhouetteSplitFeatureInput object) to define the silhouette split. 
        Returns the newly created SilhouetteSplitFeature object or null if the creation failed.
        """
        return _fusion.SilhouetteSplitFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::SilhouetteSplitFeature >":
        r"""
        Function that returns the specified silhouette split feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.SilhouetteSplitFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.SilhouetteSplitFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SilhouetteSplitFeatures__get_isValid(self)

# Register SilhouetteSplitFeatures in _fusion:
_fusion.SilhouetteSplitFeatures_swigregister(SilhouetteSplitFeatures)

def SilhouetteSplitFeatures_classType() -> "char const *":
    return _fusion.SilhouetteSplitFeatures_classType()


SilhouetteSplitFeatures.count = property(SilhouetteSplitFeatures._get_count, doc="The number of Silhouette Split features in the collection.")


SilhouetteSplitFeatures.cast = lambda arg: arg if isinstance(arg, SilhouetteSplitFeatures) else None

class Sketch(Base):
    r"""Represents a sketch within a component."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::Sketch *":
        return _fusion.Sketch___deref__(self)

    def __eq__(self, rhs: "Sketch") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.Sketch___eq__(self, rhs)


    def __ne__(self, rhs: "Sketch") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.Sketch___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.Sketch_classType()
    __swig_destroy__ = _fusion.delete_Sketch

    def _get_name(self) -> "std::string":
        r"""Gets and sets the name of this sketch as seen in the browser and timeline."""
        return _fusion.Sketch__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the name of this sketch as seen in the browser and timeline."""
        return _fusion.Sketch__set_name(self, value)

    def _get_sketchPoints(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoints >":
        r"""
        Returns the sketch points collection associated with this sketch.
        This provides access to the existing sketch points and supports
        the creation of new sketch points.
        """
        return _fusion.Sketch__get_sketchPoints(self)

    def _get_sketchCurves(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurves >":
        r"""
        Returns the sketch curves collection associated with this sketch.
        This provides access to the existing sketch curves which is all
        geometry in the sketch except for sketch points. It is through this 
        collection that new sketch geometry gets created.
        """
        return _fusion.Sketch__get_sketchCurves(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensions >":
        r"""
        Returns the sketch dimensions collection associated with this sketch.
        This provides access to the existing sketch dimensions and supports
        the creation of new sketch dimensions.
        """
        return _fusion.Sketch__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraints >":
        r"""
        Returns the sketch constraints collection associated with this sketch.
        This provides access to the existing sketch constraints and supports
        the creation of new sketch constraints.
        """
        return _fusion.Sketch__get_geometricConstraints(self)

    def project(self, entity: "Base") -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Projects the specified entity onto the x-y plane of the sketch
        and returns the created sketch entity(s). 
        entity : The entity to project. This can be a sketch entity, an edge, a face to get all 
        of its edges, a vertex, a construction axis, a construction point, or a 
        construction plane that is perpendicular to the sketch to create a line. 
        Returns a collection of the sketch entities that were created as a result of the 
        projection.
        """
        return _fusion.Sketch_project(self, entity)

    def projectCutEdges(self, body: "BRepBody") -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Intersects the specified body with the sketch plane and creates new
        curves representing the intersection. 
        body : The body to be intersected by the sketch. 
        Returns a collection of the sketch entities that were created a a result of the 
        cut.
        """
        return _fusion.Sketch_projectCutEdges(self, body)

    def include(self, entity: "Base") -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Creates new sketch curves and points that represent the specified entity 
        as sketch geometry. The sketch geometry is not projected but is created
        in the same location in space as the input geometry. 
        entity : The entity to include into the sketch. This can be a sketch entity from 
        another sketch, edge, face (which results in getting all of its edges, a 
        vertex, construction axis, or construction point. 
        Returns a collection of the sketch entities that were created as a result of the include.
        When including this curves it will be a single sketch curve, but for faces, multiple
        sketch curves will be created; one for each edge.
        """
        return _fusion.Sketch_include(self, entity)

    def findConnectedCurves(self, curve: "SketchCurve") -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Finds the sketch curves that are end connected to the input curve. This can be useful
        for many cases but is especially useful in gathering the input when creating an offset. 
        curve : The initial sketch curve that will be used to find the connected curves. 
        A collection of the connected curves. They are returned in their connected order with
        the original input curve being one of the curves.
        """
        return _fusion.Sketch_findConnectedCurves(self, curve)

    def offset(self, curves: "ObjectCollection", directionPoint: "Point3D", offset: "double"=0) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Creates offset curves for the set of input curves. If the offset distance is not 
        provided, the offset distance is defined by the direction point. 
        curves : A set of end connected curves. The Sketch.FindConnectedCurves method is a convenient way to get 
        this set of curves. 
        directionPoint : Defines which side of the input curves to create the offset on 
        offset : The distance to offset the curves in centimeters. 
        A collection of the new offset sketch curves created
        """
        return _fusion.Sketch_offset(self, curves, directionPoint, offset)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >":
        r"""
        Gets and sets the transform of the sketch with respect to model space.
        This defines the transform from the parent component space
        to the sketch space. For example, if you have point coordinates in the space
        of the parent component and apply this transform it will result in the
        coordinates of the equivalent position in sketch space.
        The transform is sensitive to the assembly context.
        Setting the transform will fail in the case where the sketch is parametric
        """
        return _fusion.Sketch__get_transform(self)

    def _set_transform(self, value: "Matrix3D") -> "bool":
        r"""
        Gets and sets the transform of the sketch with respect to model space.
        This defines the transform from the parent component space
        to the sketch space. For example, if you have point coordinates in the space
        of the parent component and apply this transform it will result in the
        coordinates of the equivalent position in sketch space.
        The transform is sensitive to the assembly context.
        Setting the transform will fail in the case where the sketch is parametric
        """
        return _fusion.Sketch__set_transform(self, value)

    def modelToSketchSpace(self, modelCoordinate: "Point3D") -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""
        A specified point in model space returns the equivalent point in sketch space.
        This is sensitive to the assembly context. 
        modelCoordinate : A coordinate in model space. 
        Returns the equivalent point in sketch space.
        """
        return _fusion.Sketch_modelToSketchSpace(self, modelCoordinate)

    def sketchToModelSpace(self, sketchCoordinate: "Point3D") -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""
        A specified point in sketch space returns the equivalent point in model space.
        This is sensitive to the assembly context. 
        sketchCoordinate : A coordinate in sketch space. 
        Returns the equivalent point in model space.
        """
        return _fusion.Sketch_sketchToModelSpace(self, sketchCoordinate)

    def _get_isParametric(self) -> "bool":
        r"""
        Indicates if this sketch is parametric or not. For parametric sketches, you can also
        get the construction plane or face it is associative to using the ReferencePlane property.
        """
        return _fusion.Sketch__get_isParametric(self)

    def _get_isVisible(self) -> "bool":
        r"""
        Gets if this sketch is currently visible in the graphics window. Use the
        isLightBulbOn to change if the light bulb beside the sketch node in the 
        browser is on or not. Parent nodes in the browser can have their light
        bulb off which affects all of their children. This property indicates 
        the final result and whether this body is actually visible or not.
        """
        return _fusion.Sketch__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""
        Gets if this sketch is currently visible in the graphics window. Use the
        isLightBulbOn to change if the light bulb beside the sketch node in the 
        browser is on or not. Parent nodes in the browser can have their light
        bulb off which affects all of their children. This property indicates 
        the final result and whether this body is actually visible or not.
        """
        return _fusion.Sketch__set_isVisible(self, value)

    def _get_areDimensionsShown(self) -> "bool":
        r"""
        Indicates if the dimensions of the sketch are displayed when the sketch is not active 
        (in sketch edit mode)
        """
        return _fusion.Sketch__get_areDimensionsShown(self)

    def _set_areDimensionsShown(self, value: "bool") -> "bool":
        r"""
        Indicates if the dimensions of the sketch are displayed when the sketch is not active 
        (in sketch edit mode)
        """
        return _fusion.Sketch__set_areDimensionsShown(self, value)

    def _get_areProfilesShown(self) -> "bool":
        r"""Indicates if the profiles of the sketch are displayed"""
        return _fusion.Sketch__get_areProfilesShown(self)

    def _set_areProfilesShown(self, value: "bool") -> "bool":
        r"""Indicates if the profiles of the sketch are displayed"""
        return _fusion.Sketch__set_areProfilesShown(self, value)

    def _get_origin(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Returns the origin point of the sketch in model space."""
        return _fusion.Sketch__get_origin(self)

    def _get_xDirection(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Returns the X direction of the sketch as defined in model space."""
        return _fusion.Sketch__get_xDirection(self)

    def _get_yDirection(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Returns the Y direction of the sketch as defined in model space."""
        return _fusion.Sketch__get_yDirection(self)

    def _get_referencePlane(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the construction plane or planar face the sketch is associated
        to. This is only valid when the IsParametric property is True otherwise this 
        returns null and setting the property will fail.
        Setting this property is the equivalent of the Redefine command.
        """
        return _fusion.Sketch__get_referencePlane(self)

    def _set_referencePlane(self, value: "Base") -> "bool":
        r"""
        Gets and sets the construction plane or planar face the sketch is associated
        to. This is only valid when the IsParametric property is True otherwise this 
        returns null and setting the property will fail.
        Setting this property is the equivalent of the Redefine command.
        """
        return _fusion.Sketch__set_referencePlane(self, value)

    def _get_isComputeDeferred(self) -> "bool":
        r"""
        Temporarily turns off the compute of the sketch. This is used to
        increase the performance as sketch geometry is created. Once the
        sketch is drawn the this property should be set to false to allow
        the sketch to recompute. This setting is not saved by the file and is 
        always false when a file is opened.
        """
        return _fusion.Sketch__get_isComputeDeferred(self)

    def _set_isComputeDeferred(self, value: "bool") -> "bool":
        r"""
        Temporarily turns off the compute of the sketch. This is used to
        increase the performance as sketch geometry is created. Once the
        sketch is drawn the this property should be set to false to allow
        the sketch to recompute. This setting is not saved by the file and is 
        always false when a file is opened.
        """
        return _fusion.Sketch__set_isComputeDeferred(self, value)

    def move(self, sketchEntities: "ObjectCollection", transform: "Matrix3D") -> "bool":
        r"""
        Moves the specified sketch entities using the specified transform.
        Transform respects any constraints that would normally prohibit the move. 
        sketchEntities : A collection of sketch entities to transform. 
        transform : The transform that defines the move, rotate or scale. 
        Returns true if the move was successful.
        """
        return _fusion.Sketch_move(self, sketchEntities, transform)

    def copy(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Copies the specified sketch entities, applying the specified transform.
        Any geometric or dimension constraints associated with the entities will
        automatically be copied, if possible. For example, if there is a horizontal
        dimension and the transform defines a rotation then it will not be included in the
        result. This same behavior can be seen when performing a copy/paste operation
        in the user interface. 
        sketchEntities : The collection of sketch entities to copy. They must all exist in this sketch. 
        transform : The transform to apply to the copied entities. 
        targetSketch : Optionally specifies the sketch to copy the entities to. If not provided the entities are copied to this sketch. 
        Returns a collection of the new sketch entities that were created as a result of the copy.
        """
        return _fusion.Sketch_copy(self, *args)

    def _get_profiles(self) -> "adsk::core::Ptr< adsk::fusion::Profiles >":
        r"""Returns the profiles currently computed for the sketch."""
        return _fusion.Sketch__get_profiles(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the sketch. 
        Returns true if the delete was successful.
        """
        return _fusion.Sketch_deleteMe(self)

    def saveAsDXF(self, fullFilename: "std::string const &") -> "bool":
        r"""
        Saves the contents of the sketch to a specified DXF file. 
        fullFilename : The full filename, including the path, of the DXF file. 
        Returns true if the operation was successful.
        """
        return _fusion.Sketch_saveAsDXF(self, fullFilename)

    def importSVG(self, fullFilename: "std::string const &", xPosition: "double", yPosition: "double", scale: "double") -> "bool":
        r"""
        Imports the contents of an SVG file into the active sketch. 
        fullFilename : The full filename, including the path, of the SVG file. 
        xPosition : The X offset in centimeters in the sketch for the origin of the SVG data 
        relative to the sketch origin. 
        yPosition : The Y offset in centimeters in the sketch for the origin of the SVG data 
        relative to the sketch origin. 
        scale : The scale value to apply to the imported SVG data. 
        Returns true if the import was successful.
        """
        return _fusion.Sketch_importSVG(self, fullFilename, xPosition, yPosition, scale)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this sketch."""
        return _fusion.Sketch__get_timelineObject(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent Component."""
        return _fusion.Sketch__get_parentComponent(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this
        object in an assembly. This is only valid in the case where this
        is acting as a proxy in an assembly. Returns null 
        in the case where the object is not in the context of an assembly.
        but is already the native object.
        """
        return _fusion.Sketch__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.Sketch__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.Sketch_createForAssemblyContext(self, occurrence)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the 3D bounding box of the sketch"""
        return _fusion.Sketch__get_boundingBox(self)

    def _get_sketchTexts(self) -> "adsk::core::Ptr< adsk::fusion::SketchTexts >":
        r"""
        Returns the sketch text collection associated with this sketch.
        This provides access to existing text and supports the creation
        of new text.
        """
        return _fusion.Sketch__get_sketchTexts(self)

    def _get_originPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""
        Returns the sketch point that was automatically created by projecting the
        origin construction point into the sketch.
        """
        return _fusion.Sketch__get_originPoint(self)

    def _get_isFullyConstrained(self) -> "bool":
        r"""Indicates if this sketch is fully constrained."""
        return _fusion.Sketch__get_isFullyConstrained(self)

    def redefine(self, planarEntity: "Base") -> "bool":
        r"""
        Changes which plane the sketch is based on. 
        planarEntity : A construction plane or planar face that defines the sketch plane 
        Returns true if the operation was successful.
        """
        return _fusion.Sketch_redefine(self, planarEntity)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.Sketch__get_attributes(self)

    def _get_baseOrFormFeature(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        This property returns the base or form feature that this sketch is associated with. It returns
        null in the case where the sketch is parametrically defined and is not related to a base or form
        feature. It also returns null in the case where the modeling design history is not being captured (direct edit model).
        """
        return _fusion.Sketch__get_baseOrFormFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of this sketch."""
        return _fusion.Sketch__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.Sketch__get_errorOrWarningMessage(self)

    def intersectWithSketchPlane(self, entities: "BaseVector") -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity >,std::allocator< adsk::core::Ptr< adsk::fusion::SketchEntity > > >":
        r"""
        Intersects the specified entities (BRepBody, BRepFace, BRepEdge, BRepVertex, SketchCurve, ConstructionPoint,
        ConstructionAxis, and ConstructionPlane) with the sketch plane and creates sketch geometry that represents
        the intersection. 
        entities : An array containing the entities to intersect with the sketch plane. 
        An array returning the sketch entities that were created as a result of the
        intersections. It's possible that this can come back empty in the case where the input
        entities don't intersect the sketch plane.
        """
        return _fusion.Sketch_intersectWithSketchPlane(self, entities)

    def projectToSurface(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity >,std::allocator< adsk::core::Ptr< adsk::fusion::SketchEntity > > >":
        r"""
        Projects the specified set of curves onto the specified set of faces using the specified method of projection.
        if the projection type is along a vector, then the directionEntity argument must be supplied. if the projectionType
        is the closest point method, the directionEntity argument is ignored. 
        faces : An array of BRepFace objects that the curves will be projected onto. 
        curves : An array of various curve objects that will be projected onto the faces. The curves can be sketch curves and points,
        BRepEdge objects, ConstructionAxis objects, and ConstructionPoint objects. 
        projectType : Specifies which projection type to use which defines the direction of projection. If this is set to AlongVectorSurfaceProjectType
        the directionEntity argument must be provided. 
        directionEntity : if the projectType argument is AlongVectorSurfaceProjectType, this argument must be specified and defines the
        direction of projection. It can be a linear BRepEdge, a BRepFace where the normal will be used, a SketchLine, or 
        a ConstructionLine. 
        Returns an array of the sketch entities that were created as a result of projection the specified curves onto
        the faces.
        """
        return _fusion.Sketch_projectToSurface(self, *args)

    def _get_revisionId(self) -> "std::string":
        r"""
        Returns the current revision ID of the sketch. This ID changes any time the sketch is modified in any way. By getting
        and saving the ID when you create any data that is dependent on the sketch, you can then compare the saved
        ID with the current ID to determine if the sketch has changed to know if you should update your data.
        """
        return _fusion.Sketch__get_revisionId(self)

    def _get_areConstraintsShown(self) -> "bool":
        r"""Indicates if the constraints of the sketch are displayed when the sketch is active."""
        return _fusion.Sketch__get_areConstraintsShown(self)

    def _set_areConstraintsShown(self, value: "bool") -> "bool":
        r"""Indicates if the constraints of the sketch are displayed when the sketch is active."""
        return _fusion.Sketch__set_areConstraintsShown(self, value)

    def _get_arePointsShown(self) -> "bool":
        r"""
        Indicates if the sketch points in the sketch are displayed. Points that are not connected to any other
        geometry will continue to be shown.
        """
        return _fusion.Sketch__get_arePointsShown(self)

    def _set_arePointsShown(self, value: "bool") -> "bool":
        r"""
        Indicates if the sketch points in the sketch are displayed. Points that are not connected to any other
        geometry will continue to be shown.
        """
        return _fusion.Sketch__set_arePointsShown(self, value)

    def _get_isLightBulbOn(self) -> "bool":
        r"""
        Gets and set if the light bulb beside the sketch node in the 
        browser is on or not. Parent nodes in the browser can have their light
        bulb off which affects all of their children so this property does not
        indicate if the body is actually visible, just that it should be visible
        if all of it's parent nodes are also visible. Use the isVisible property
        to determine if it's actually visible.
        """
        return _fusion.Sketch__get_isLightBulbOn(self)

    def _set_isLightBulbOn(self, value: "bool") -> "bool":
        r"""
        Gets and set if the light bulb beside the sketch node in the 
        browser is on or not. Parent nodes in the browser can have their light
        bulb off which affects all of their children so this property does not
        indicate if the body is actually visible, just that it should be visible
        if all of it's parent nodes are also visible. Use the isVisible property
        to determine if it's actually visible.
        """
        return _fusion.Sketch__set_isLightBulbOn(self, value)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Sketch object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same token.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.Sketch__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.Sketch__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.Sketch__get_isValid(self)

# Register Sketch in _fusion:
_fusion.Sketch_swigregister(Sketch)

def Sketch_classType() -> "char const *":
    return _fusion.Sketch_classType()


Sketch.name = property(Sketch._get_name, Sketch._set_name, doc="Gets and sets the name of this sketch as seen in the browser and timeline.")


Sketch.sketchPoints = property(Sketch._get_sketchPoints, doc="Returns the sketch points collection associated with this sketch.\nThis provides access to the existing sketch points and supports\nthe creation of new sketch points.")


Sketch.sketchCurves = property(Sketch._get_sketchCurves, doc="Returns the sketch curves collection associated with this sketch.\nThis provides access to the existing sketch curves which is all\ngeometry in the sketch except for sketch points. It is through this\ncollection that new sketch geometry gets created.")


Sketch.sketchDimensions = property(Sketch._get_sketchDimensions, doc="Returns the sketch dimensions collection associated with this sketch.\nThis provides access to the existing sketch dimensions and supports\nthe creation of new sketch dimensions.")


Sketch.geometricConstraints = property(Sketch._get_geometricConstraints, doc="Returns the sketch constraints collection associated with this sketch.\nThis provides access to the existing sketch constraints and supports\nthe creation of new sketch constraints.")


Sketch.transform = property(Sketch._get_transform, Sketch._set_transform, doc="Gets and sets the transform of the sketch with respect to model space.\nThis defines the transform from the parent component space\nto the sketch space. For example, if you have point coordinates in the space\nof the parent component and apply this transform it will result in the\ncoordinates of the equivalent position in sketch space.\nThe transform is sensitive to the assembly context.\nSetting the transform will fail in the case where the sketch is parametric")


Sketch.isParametric = property(Sketch._get_isParametric, doc="Indicates if this sketch is parametric or not. For parametric sketches, you can also\nget the construction plane or face it is associative to using the ReferencePlane property.")


Sketch.isVisible = property(Sketch._get_isVisible, Sketch._set_isVisible, doc="Gets if this sketch is currently visible in the graphics window. Use the\nisLightBulbOn to change if the light bulb beside the sketch node in the\nbrowser is on or not. Parent nodes in the browser can have their light\nbulb off which affects all of their children. This property indicates\nthe final result and whether this body is actually visible or not.")


Sketch.areDimensionsShown = property(Sketch._get_areDimensionsShown, Sketch._set_areDimensionsShown, doc="Indicates if the dimensions of the sketch are displayed when the sketch is not active\n(in sketch edit mode)")


Sketch.areProfilesShown = property(Sketch._get_areProfilesShown, Sketch._set_areProfilesShown, doc="Indicates if the profiles of the sketch are displayed")


Sketch.origin = property(Sketch._get_origin, doc="Returns the origin point of the sketch in model space.")


Sketch.xDirection = property(Sketch._get_xDirection, doc="Returns the X direction of the sketch as defined in model space.")


Sketch.yDirection = property(Sketch._get_yDirection, doc="Returns the Y direction of the sketch as defined in model space.")


Sketch.referencePlane = property(Sketch._get_referencePlane, Sketch._set_referencePlane, doc="Gets and sets the construction plane or planar face the sketch is associated\nto. This is only valid when the IsParametric property is True otherwise this\nreturns null and setting the property will fail.\nSetting this property is the equivalent of the Redefine command.")


Sketch.isComputeDeferred = property(Sketch._get_isComputeDeferred, Sketch._set_isComputeDeferred, doc="Temporarily turns off the compute of the sketch. This is used to\nincrease the performance as sketch geometry is created. Once the\nsketch is drawn the this property should be set to false to allow\nthe sketch to recompute. This setting is not saved by the file and is\nalways false when a file is opened.")


Sketch.profiles = property(Sketch._get_profiles, doc="Returns the profiles currently computed for the sketch.")


Sketch.timelineObject = property(Sketch._get_timelineObject, doc="Returns the timeline object associated with this sketch.")


Sketch.parentComponent = property(Sketch._get_parentComponent, doc="Returns the parent Component.")


Sketch.assemblyContext = property(Sketch._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this\nobject in an assembly. This is only valid in the case where this\nis acting as a proxy in an assembly. Returns null\nin the case where the object is not in the context of an assembly.\nbut is already the native object.")


Sketch.nativeObject = property(Sketch._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


Sketch.boundingBox = property(Sketch._get_boundingBox, doc="Returns the 3D bounding box of the sketch")


Sketch.sketchTexts = property(Sketch._get_sketchTexts, doc="Returns the sketch text collection associated with this sketch.\nThis provides access to existing text and supports the creation\nof new text.")


Sketch.originPoint = property(Sketch._get_originPoint, doc="Returns the sketch point that was automatically created by projecting the\norigin construction point into the sketch.")


Sketch.isFullyConstrained = property(Sketch._get_isFullyConstrained, doc="Indicates if this sketch is fully constrained.")


Sketch.attributes = property(Sketch._get_attributes, doc="Returns the collection of attributes associated with this face.")


Sketch.baseOrFormFeature = property(Sketch._get_baseOrFormFeature, doc="This property returns the base or form feature that this sketch is associated with. It returns\nnull in the case where the sketch is parametrically defined and is not related to a base or form\nfeature. It also returns null in the case where the modeling design history is not being captured (direct edit model).")


Sketch.healthState = property(Sketch._get_healthState, doc="Returns the current health state of this sketch.")


Sketch.errorOrWarningMessage = property(Sketch._get_errorOrWarningMessage, doc="Returns the error or warning message in the case where the healthState property returns either\nWarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.")


Sketch.revisionId = property(Sketch._get_revisionId, doc="Returns the current revision ID of the sketch. This ID changes any time the sketch is modified in any way. By getting\nand saving the ID when you create any data that is dependent on the sketch, you can then compare the saved\nID with the current ID to determine if the sketch has changed to know if you should update your data.")


Sketch.areConstraintsShown = property(Sketch._get_areConstraintsShown, Sketch._set_areConstraintsShown, doc="Indicates if the constraints of the sketch are displayed when the sketch is active.")


Sketch.arePointsShown = property(Sketch._get_arePointsShown, Sketch._set_arePointsShown, doc="Indicates if the sketch points in the sketch are displayed. Points that are not connected to any other\ngeometry will continue to be shown.")


Sketch.isLightBulbOn = property(Sketch._get_isLightBulbOn, Sketch._set_isLightBulbOn, doc="Gets and set if the light bulb beside the sketch node in the\nbrowser is on or not. Parent nodes in the browser can have their light\nbulb off which affects all of their children so this property does not\nindicate if the body is actually visible, just that it should be visible\nif all of it's parent nodes are also visible. Use the isVisible property\nto determine if it's actually visible.")


Sketch.entityToken = property(Sketch._get_entityToken, doc="Returns a token for the Sketch object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same token.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.")


Sketch.cast = lambda arg: arg if isinstance(arg, Sketch) else None

class SketchArcs(Base):
    r"""
    The collection of arcs in a sketch. This provides access to the existing
    arcs and supports the methods to create new arcs.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchArcs *":
        return _fusion.SketchArcs___deref__(self)

    def __eq__(self, rhs: "SketchArcs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchArcs___eq__(self, rhs)


    def __ne__(self, rhs: "SketchArcs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchArcs___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.SketchArcs___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::SketchArc >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.SketchArcs___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchArcs_classType()
    __swig_destroy__ = _fusion.delete_SketchArcs

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::SketchArc >":
        r"""
        Function that returns the specified sketch arc using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchArcs_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of arcs in the sketch."""
        return _fusion.SketchArcs__get_count(self)

    def addByCenterStartSweep(self, centerPoint: "Base", startPoint: "Base", sweepAngle: "double") -> "adsk::core::Ptr< adsk::fusion::SketchArc >":
        r"""
        Creates a sketch arc that is always parallel to the x-y plane of the sketch
        and is centered at the specified point. 
        centerPoint : The center point of the arc. This can be either an existing SketchPoint or a Point3D object. 
        startPoint : The start point of the arc. The distance between this point and the center defines the radius
        of the arc. This can be either an existing SketchPoint or a Point3D object. 
        sweepAngle : The sweep of the arc. This is defined in radians and a positive value defines a counter-clockwise sweep. 
        Returns the newly created SketchArc object or null if the creation failed.
        """
        return _fusion.SketchArcs_addByCenterStartSweep(self, centerPoint, startPoint, sweepAngle)

    def addByThreePoints(self, startPoint: "Base", point: "Point3D", endPoint: "Base") -> "adsk::core::Ptr< adsk::fusion::SketchArc >":
        r"""
        Creates a sketch arc that passes through the three points. 
        startPoint : The start point of the arc. This can be either an existing SketchPoint or a Point3D object. 
        point : A point along the arc. This is a Point3D object. 
        endPoint : The end point of the arc. This can be either an existing SketchPoint or a Point3D object. 
        Returns the newly created SketchArc or null in the case of a failure.
        """
        return _fusion.SketchArcs_addByThreePoints(self, startPoint, point, endPoint)

    def addFillet(self, firstEntity: "SketchCurve", firstEntityPoint: "Point3D", secondEnitity: "SketchCurve", secondEntityPoint: "Point3D", radius: "double") -> "adsk::core::Ptr< adsk::fusion::SketchArc >":
        r"""
        Creates a fillet between two sketch entities
        The side (quadrant) the fillet is created on is determined by the points specified.
        The point for each entity can be its startSketchPoint or endSketchPoint 
        firstEntity : The first curve for the fillet definition. The curve must be open. 
        firstEntityPoint : A point on or closer to one end of the first curve that indicates the side to create the fillet on 
        secondEnitity : The second curve for the fillet definition. The curve must be open. 
        secondEntityPoint : A point on or closer to one end of the second curve that indicates the side to create the fillet on 
        radius : radius of the arc in centimeters 
        Returns the newly created SketchArc object (fillet) if the operation was successful or null if it failed.
        """
        return _fusion.SketchArcs_addFillet(self, firstEntity, firstEntityPoint, secondEnitity, secondEntityPoint, radius)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchArcs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchArcs__get_isValid(self)

# Register SketchArcs in _fusion:
_fusion.SketchArcs_swigregister(SketchArcs)

def SketchArcs_classType() -> "char const *":
    return _fusion.SketchArcs_classType()


SketchArcs.count = property(SketchArcs._get_count, doc="Returns the number of arcs in the sketch.")


SketchArcs.cast = lambda arg: arg if isinstance(arg, SketchArcs) else None

class SketchCircles(Base):
    r"""
    The collection of circles in a sketch. This provides access to the existing
    circles and supports the methods to create new circles.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchCircles *":
        return _fusion.SketchCircles___deref__(self)

    def __eq__(self, rhs: "SketchCircles") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchCircles___eq__(self, rhs)


    def __ne__(self, rhs: "SketchCircles") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchCircles___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.SketchCircles___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::SketchCircle >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.SketchCircles___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchCircles_classType()
    __swig_destroy__ = _fusion.delete_SketchCircles

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::SketchCircle >":
        r"""
        Function that returns the specified sketch circle using an index into the collection. 
        index : The index of the item within the collection to return. 
        The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchCircles_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of circles in the sketch."""
        return _fusion.SketchCircles__get_count(self)

    def addByCenterRadius(self, centerPoint: "Base", radius: "double") -> "adsk::core::Ptr< adsk::fusion::SketchCircle >":
        r"""
        Creates a sketch circle that is always parallel to the x-y plane of the sketch
        and is centered at the specified point. 
        centerPoint : The center point of the circle. It can be an existing SketchPoint or a Point3D object. 
        radius : The radius of the circle in centimeters. 
        Returns the newly created SketchCircle object or null if the creation failed.
        """
        return _fusion.SketchCircles_addByCenterRadius(self, centerPoint, radius)

    def addByTwoPoints(self, pointOne: "Point3D", pointTwo: "Point3D") -> "adsk::core::Ptr< adsk::fusion::SketchCircle >":
        r"""
        Creates a sketch circle where the circle passes through the two points and the
        distance between the two points is the diameter of the circle. 
        pointOne : A Point3D object that defines a point is sketch space and lies on the x-y plane of the sketch. 
        pointTwo : A Point3D object that defines a point is sketch space and lies on the x-y plane of the sketch. 
        Returns the newly created SketchCircle object or null if the creation failed.
        """
        return _fusion.SketchCircles_addByTwoPoints(self, pointOne, pointTwo)

    def addByThreePoints(self, pointOne: "Point3D", pointTwo: "Point3D", pointThree: "Point3D") -> "adsk::core::Ptr< adsk::fusion::SketchCircle >":
        r"""
        Creates a sketch circle that passes through the three points. The three points must
        lie on the x-y plane of the sketch. 
        pointOne : The first point that the circle will pass through. The z component must be zero. 
        pointTwo : The second point that the circle will pass through. The z component must be zero. 
        pointThree : The third point that the circle will pass through. The z component must be zero. 
        Returns the newly created SketchCircle object or null if the creation failed.
        """
        return _fusion.SketchCircles_addByThreePoints(self, pointOne, pointTwo, pointThree)

    def addByTwoTangents(self, tangentOne: "SketchLine", tangentTwo: "SketchLine", radius: "double", hintPoint: "Point3D") -> "adsk::core::Ptr< adsk::fusion::SketchCircle >":
        r"""
        Creates a sketch circle that is tangent to the two input lines.
        The two lines must lie on the x-y plane of the sketch. 
        tangentOne : The first line that the circle will be tangent to.
        The line must lie on the x-y plane of the sketch. 
        tangentTwo : The second line that the circle will be tangent to.
        The line must lie on the x-y plane of the sketch and cannot 
        be parallel to the first line. 
        radius : The radius of the circle in centimeters. 
        hintPoint : A point that specifies which of the possible four solutions to use
        when creating the circle. If you consider the two input lines to be infinite
        they create four quadrants which results in four possible solutions for the
        creation of the circle. The hint point is a point anywhere within the quadrant
        where you want the circle created. 
        Returns the newly created SketchCircle object or null if the creation failed.
        """
        return _fusion.SketchCircles_addByTwoTangents(self, tangentOne, tangentTwo, radius, hintPoint)

    def addByThreeTangents(self, tangentOne: "SketchLine", tangentTwo: "SketchLine", tangentThree: "SketchLine", hintPoint: "Point3D") -> "adsk::core::Ptr< adsk::fusion::SketchCircle >":
        r"""
        Creates a sketch circle that is tangent to the three input lines.
        The three lines must lie on the x-y plane of the sketch. 
        tangentOne : The first line that the circle will be tangent to.
        The line must lie on the x-y plane of the sketch and cannot be parallel 
        to the second or third line. 
        tangentTwo : The second line that the circle will be tangent to.
        The line must lie on the x-y plane of the sketch and cannot be parallel 
        to the first or third line. 
        tangentThree : The third line that the circle will be tangent to.
        The line must lie on the x-y plane of the sketch and cannot be parallel 
        to the first or second line. 
        hintPoint : A point that specifies which of the possible multiple solutions to use
        when creating the circle. If you consider the three input lines to be infinite
        there are many possible solutions when creating a circle that is tangent to all
        three lines. The hint point is a point anywhere within the area defined by the
        three lines where the circle is to be created. 
        Returns the newly created SketchCircle object or null if the creation failed.
        """
        return _fusion.SketchCircles_addByThreeTangents(self, tangentOne, tangentTwo, tangentThree, hintPoint)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchCircles__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchCircles__get_isValid(self)

# Register SketchCircles in _fusion:
_fusion.SketchCircles_swigregister(SketchCircles)

def SketchCircles_classType() -> "char const *":
    return _fusion.SketchCircles_classType()


SketchCircles.count = property(SketchCircles._get_count, doc="Returns the number of circles in the sketch.")


SketchCircles.cast = lambda arg: arg if isinstance(arg, SketchCircles) else None

class SketchConicCurves(Base):
    r"""
    The collection of conic curves in a sketch. This provides access to the existing
    conic curves and supports the method to create new conic curves.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchConicCurves *":
        return _fusion.SketchConicCurves___deref__(self)

    def __eq__(self, rhs: "SketchConicCurves") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchConicCurves___eq__(self, rhs)


    def __ne__(self, rhs: "SketchConicCurves") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchConicCurves___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.SketchConicCurves___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::SketchConicCurve >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.SketchConicCurves___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchConicCurves_classType()
    __swig_destroy__ = _fusion.delete_SketchConicCurves

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::SketchConicCurve >":
        r"""
        Function that returns the specified conic curve using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchConicCurves_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of conic curves in the sketch."""
        return _fusion.SketchConicCurves__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchConicCurves__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchConicCurves__get_isValid(self)

# Register SketchConicCurves in _fusion:
_fusion.SketchConicCurves_swigregister(SketchConicCurves)

def SketchConicCurves_classType() -> "char const *":
    return _fusion.SketchConicCurves_classType()


SketchConicCurves.count = property(SketchConicCurves._get_count, doc="Returns the number of conic curves in the sketch.")


SketchConicCurves.cast = lambda arg: arg if isinstance(arg, SketchConicCurves) else None

class SketchCurves(Base):
    r"""
    A collection of sketch curves in a sketch. This also provides access to collections
    for the specific types of curves where you can get the curves based on type and
    create new curves.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchCurves *":
        return _fusion.SketchCurves___deref__(self)

    def __eq__(self, rhs: "SketchCurves") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchCurves___eq__(self, rhs)


    def __ne__(self, rhs: "SketchCurves") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchCurves___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.SketchCurves___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::SketchCurve >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.SketchCurves___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchCurves_classType()
    __swig_destroy__ = _fusion.delete_SketchCurves

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::SketchCurve >":
        r"""
        Function that returns the specified sketch curve using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchCurves_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of sketch curves in the sketch."""
        return _fusion.SketchCurves__get_count(self)

    def _get_sketchArcs(self) -> "adsk::core::Ptr< adsk::fusion::SketchArcs >":
        r"""
        Returns the sketch arcs collection associated with this sketch.
        This provides access to the existing sketch arcs and supports
        the creation of new sketch arcs.
        """
        return _fusion.SketchCurves__get_sketchArcs(self)

    def _get_sketchCircles(self) -> "adsk::core::Ptr< adsk::fusion::SketchCircles >":
        r"""
        Returns the sketch circles collection associated with this sketch.
        This provides access to the existing sketch circles and supports
        the creation of new sketch circles.
        """
        return _fusion.SketchCurves__get_sketchCircles(self)

    def _get_sketchEllipses(self) -> "adsk::core::Ptr< adsk::fusion::SketchEllipses >":
        r"""
        Returns the sketch ellipses collection associated with this sketch.
        This provides access to the existing sketch ellipses and supports
        the creation of new sketch ellipses.
        """
        return _fusion.SketchCurves__get_sketchEllipses(self)

    def _get_sketchEllipticalArcs(self) -> "adsk::core::Ptr< adsk::fusion::SketchEllipticalArcs >":
        r"""
        Returns the sketch elliptical arcs collection associated with this sketch.
        This provides access to the existing sketch elliptical arcs and supports
        the creation of new sketch elliptical arcs.
        """
        return _fusion.SketchCurves__get_sketchEllipticalArcs(self)

    def _get_sketchLines(self) -> "adsk::core::Ptr< adsk::fusion::SketchLines >":
        r"""
        Returns the sketch lines collection associated with this sketch.
        This provides access to the existing sketch lines and supports
        the creation of new sketch lines.
        """
        return _fusion.SketchCurves__get_sketchLines(self)

    def _get_sketchFittedSplines(self) -> "adsk::core::Ptr< adsk::fusion::SketchFittedSplines >":
        r"""
        Returns the sketch splines collection associated with this sketch.
        This provides access to the existing sketch splines and supports
        the creation of new sketch splines.
        """
        return _fusion.SketchCurves__get_sketchFittedSplines(self)

    def _get_sketchFixedSplines(self) -> "adsk::core::Ptr< adsk::fusion::SketchFixedSplines >":
        r"""
        Returns the fixed sketch splines collection associated with this sketch.
        This provides access to the existing fixed sketch splines and supports
        the creation of new fixed sketch splines.
        """
        return _fusion.SketchCurves__get_sketchFixedSplines(self)

    def _get_sketchConicCurves(self) -> "adsk::core::Ptr< adsk::fusion::SketchConicCurves >":
        r"""
        Returns the conic curves collection associated with this sketch.
        This provides access to the existing conic curves and support the
        creation of new conic curves.
        """
        return _fusion.SketchCurves__get_sketchConicCurves(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchCurves__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchCurves__get_isValid(self)

# Register SketchCurves in _fusion:
_fusion.SketchCurves_swigregister(SketchCurves)

def SketchCurves_classType() -> "char const *":
    return _fusion.SketchCurves_classType()


SketchCurves.count = property(SketchCurves._get_count, doc="Returns the number of sketch curves in the sketch.")


SketchCurves.sketchArcs = property(SketchCurves._get_sketchArcs, doc="Returns the sketch arcs collection associated with this sketch.\nThis provides access to the existing sketch arcs and supports\nthe creation of new sketch arcs.")


SketchCurves.sketchCircles = property(SketchCurves._get_sketchCircles, doc="Returns the sketch circles collection associated with this sketch.\nThis provides access to the existing sketch circles and supports\nthe creation of new sketch circles.")


SketchCurves.sketchEllipses = property(SketchCurves._get_sketchEllipses, doc="Returns the sketch ellipses collection associated with this sketch.\nThis provides access to the existing sketch ellipses and supports\nthe creation of new sketch ellipses.")


SketchCurves.sketchEllipticalArcs = property(SketchCurves._get_sketchEllipticalArcs, doc="Returns the sketch elliptical arcs collection associated with this sketch.\nThis provides access to the existing sketch elliptical arcs and supports\nthe creation of new sketch elliptical arcs.")


SketchCurves.sketchLines = property(SketchCurves._get_sketchLines, doc="Returns the sketch lines collection associated with this sketch.\nThis provides access to the existing sketch lines and supports\nthe creation of new sketch lines.")


SketchCurves.sketchFittedSplines = property(SketchCurves._get_sketchFittedSplines, doc="Returns the sketch splines collection associated with this sketch.\nThis provides access to the existing sketch splines and supports\nthe creation of new sketch splines.")


SketchCurves.sketchFixedSplines = property(SketchCurves._get_sketchFixedSplines, doc="Returns the fixed sketch splines collection associated with this sketch.\nThis provides access to the existing fixed sketch splines and supports\nthe creation of new fixed sketch splines.")


SketchCurves.sketchConicCurves = property(SketchCurves._get_sketchConicCurves, doc="Returns the conic curves collection associated with this sketch.\nThis provides access to the existing conic curves and support the\ncreation of new conic curves.")


SketchCurves.cast = lambda arg: arg if isinstance(arg, SketchCurves) else None

class SketchDimension(Base):
    r"""The base class for the all sketch dimensions."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchDimension *":
        return _fusion.SketchDimension___deref__(self)

    def __eq__(self, rhs: "SketchDimension") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchDimension___eq__(self, rhs)


    def __ne__(self, rhs: "SketchDimension") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchDimension___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchDimension_classType()
    __swig_destroy__ = _fusion.delete_SketchDimension

    def deleteMe(self) -> "bool":
        r"""
        Deletes this dimension. The IsDeletable property indicates if this dimension can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SketchDimension_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this dimension is deletable."""
        return _fusion.SketchDimension__get_isDeletable(self)

    def _get_textPosition(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets position of the dimension text."""
        return _fusion.SketchDimension__get_textPosition(self)

    def _set_textPosition(self, value: "Point3D") -> "bool":
        r"""Gets and sets position of the dimension text."""
        return _fusion.SketchDimension__set_textPosition(self, value)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.SketchDimension__get_parentSketch(self)

    def _get_parameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""Returns the associated parameter or null if there is no associated parameter."""
        return _fusion.SketchDimension__get_parameter(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchDimension__get_assemblyContext(self)

    def _get_isDriving(self) -> "bool":
        r"""
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchDimension__get_isDriving(self)

    def _set_isDriving(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchDimension__set_isDriving(self, value)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this sketch dimension."""
        return _fusion.SketchDimension__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the SketchDimension object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same sketch dimension.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SketchDimension__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchDimension__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchDimension__get_isValid(self)

# Register SketchDimension in _fusion:
_fusion.SketchDimension_swigregister(SketchDimension)

def SketchDimension_classType() -> "char const *":
    return _fusion.SketchDimension_classType()


SketchDimension.isDeletable = property(SketchDimension._get_isDeletable, doc="Indicates if this dimension is deletable.")


SketchDimension.textPosition = property(SketchDimension._get_textPosition, SketchDimension._set_textPosition, doc="Gets and sets position of the dimension text.")


SketchDimension.parentSketch = property(SketchDimension._get_parentSketch, doc="Returns the parent sketch object.")


SketchDimension.parameter = property(SketchDimension._get_parameter, doc="Returns the associated parameter or null if there is no associated parameter.")


SketchDimension.assemblyContext = property(SketchDimension._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")


SketchDimension.isDriving = property(SketchDimension._get_isDriving, SketchDimension._set_isDriving, doc="Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension\nmay fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.")


SketchDimension.attributes = property(SketchDimension._get_attributes, doc="Returns the collection of attributes associated with this sketch dimension.")


SketchDimension.entityToken = property(SketchDimension._get_entityToken, doc="Returns a token for the SketchDimension object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same sketch dimension.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.")


SketchDimension.cast = lambda arg: arg if isinstance(arg, SketchDimension) else None

class SketchDimensionList(Base):
    r"""A list of sketch dimensions."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchDimensionList *":
        return _fusion.SketchDimensionList___deref__(self)

    def __eq__(self, rhs: "SketchDimensionList") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchDimensionList___eq__(self, rhs)


    def __ne__(self, rhs: "SketchDimensionList") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchDimensionList___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.SketchDimensionList___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::SketchDimension >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.SketchDimensionList___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchDimensionList_classType()
    __swig_destroy__ = _fusion.delete_SketchDimensionList

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::SketchDimension >":
        r"""
        Function that returns the specified sketch dimension using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection 
        has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchDimensionList_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of sketch dimensions in the sketch."""
        return _fusion.SketchDimensionList__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchDimensionList__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchDimensionList__get_isValid(self)

# Register SketchDimensionList in _fusion:
_fusion.SketchDimensionList_swigregister(SketchDimensionList)

def SketchDimensionList_classType() -> "char const *":
    return _fusion.SketchDimensionList_classType()


SketchDimensionList.count = property(SketchDimensionList._get_count, doc="Returns the number of sketch dimensions in the sketch.")


SketchDimensionList.cast = lambda arg: arg if isinstance(arg, SketchDimensionList) else None

class SketchDimensions(Base):
    r"""
    A collection of the dimensions in a sketch. This object also supports the methods to add 
    new sketch dimensions.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchDimensions *":
        return _fusion.SketchDimensions___deref__(self)

    def __eq__(self, rhs: "SketchDimensions") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchDimensions___eq__(self, rhs)


    def __ne__(self, rhs: "SketchDimensions") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchDimensions___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.SketchDimensions___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::SketchDimension >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.SketchDimensions___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchDimensions_classType()
    __swig_destroy__ = _fusion.delete_SketchDimensions

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::SketchDimension >":
        r"""
        Function that returns the specified sketch dimension using an index into the 
        collection. 
        index : The index of the item within the collection to return. The first item in the 
        collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchDimensions_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of sketch dimensions in the sketch."""
        return _fusion.SketchDimensions__get_count(self)

    def addDistanceDimension(self, pointOne: "SketchPoint", pointTwo: "SketchPoint", orientation: "DimensionOrientations", textPoint: "Point3D", isDriving: "bool"=True) -> "adsk::core::Ptr< adsk::fusion::SketchLinearDimension >":
        r"""
        Creates a new linear dimension constraint between the two input entities. 
        pointOne : The first SketchPoint to dimension to. 
        pointTwo : The second SketchPoint to dimension to.. 
        orientation : The orientation of the dimension. 
        textPoint : A Point3D object that defines the position of the dimension text. 
        isDriving : Optional argument that specifies if a driving (the dimension controls the geoemtry) 
        or a driven (the geometry controls the dimension) dimension is created. If not provided
        a driving dimension will be created. 
        Returns the newly created dimension or null if the creation failed.
        """
        return _fusion.SketchDimensions_addDistanceDimension(self, pointOne, pointTwo, orientation, textPoint, isDriving)

    def addOffsetDimension(self, line: "SketchLine", entityTwo: "SketchEntity", textPoint: "Point3D", isDriving: "bool"=True) -> "adsk::core::Ptr< adsk::fusion::SketchOffsetDimension >":
        r"""
        Creates a new linear dimension constraint between the two input entities. The first input
        entity must be a sketch line. The second entity can be a point or a line that is parallel
        to the first. The dimension controls the distance as measured perpendicular to the first
        input line. 
        line : The SketchLine to dimension to. 
        entityTwo : The parallel SketchLine or SketchPoint to dimension to. If a SketchLine is used it must be 
        parallel to the first line. 
        textPoint : A Point3D object that defines the position of the dimension text. 
        isDriving : Optional argument that specifies if a driving (the dimension controls the geoemtry) 
        or a driven (the geometry controls the dimension) dimension is created. If not provided
        a driving dimension will be created. 
        Returns the newly created dimension or null if the creation failed.
        """
        return _fusion.SketchDimensions_addOffsetDimension(self, line, entityTwo, textPoint, isDriving)

    def addAngularDimension(self, lineOne: "SketchLine", lineTwo: "SketchLine", textPoint: "Point3D", isDriving: "bool"=True) -> "adsk::core::Ptr< adsk::fusion::SketchAngularDimension >":
        r"""
        Creates a new angular dimension constraint between the two input lines. 
        The position of the text controls which of the four quadrants will be dimensioned. 
        lineOne : The first SketchLine to dimension to. 
        lineTwo : The second SketchLine to dimension to. 
        textPoint : A Point3D object that defines the position of the dimension text. The position of this
        text defines which quadrant will be dimensioned. 
        isDriving : Optional argument that specifies if a driving (the dimension controls the geoemtry) 
        or a driven (the geometry controls the dimension) dimension is created. If not provided
        a driving dimension will be created. 
        Returns the newly created dimension or null if the creation failed.
        """
        return _fusion.SketchDimensions_addAngularDimension(self, lineOne, lineTwo, textPoint, isDriving)

    def addDiameterDimension(self, entity: "SketchCurve", textPoint: "Point3D", isDriving: "bool"=True) -> "adsk::core::Ptr< adsk::fusion::SketchDiameterDimension >":
        r"""
        Creates a new diameter dimension constraint on the arc or circle. 
        entity : The SketchCircle or SketchArc to dimension. 
        textPoint : A Point3D object that defines the position of the dimension text. 
        isDriving : Optional argument that specifies if a driving (the dimension controls the geoemtry) 
        or a driven (the geometry controls the dimension) dimension is created. If not provided
        a driving dimension will be created. 
        Returns the newly created dimension or null if the creation failed.
        """
        return _fusion.SketchDimensions_addDiameterDimension(self, entity, textPoint, isDriving)

    def addRadialDimension(self, entity: "SketchCurve", textPoint: "Point3D", isDriving: "bool"=True) -> "adsk::core::Ptr< adsk::fusion::SketchRadialDimension >":
        r"""
        Creates a new radial dimension constraint on the arc or circle. 
        entity : The SketchCircle or SketchArc to dimension. 
        textPoint : A Point3D object that defines the position of the dimension text. 
        isDriving : Optional argument that specifies if a driving (the dimension controls the geoemtry) 
        or a driven (the geometry controls the dimension) dimension is created. If not provided
        a driving dimension will be created. 
        Returns the newly created dimension or null if the creation failed.
        """
        return _fusion.SketchDimensions_addRadialDimension(self, entity, textPoint, isDriving)

    def addEllipseMajorRadiusDimension(self, ellipse: "SketchCurve", textPoint: "Point3D", isDriving: "bool"=True) -> "adsk::core::Ptr< adsk::fusion::SketchEllipseMajorRadiusDimension >":
        r"""
        Creates a new dimension constraint on the major radius of an ellipse. 
        ellipse : The SketchEllipse to dimension. 
        textPoint : A Point3D object that defines the position of the dimension text. 
        isDriving : Optional argument that specifies if a driving (the dimension controls the geoemtry) 
        or a driven (the geometry controls the dimension) dimension is created. If not provided
        a driving dimension will be created. 
        Returns the newly created dimension or null if the creation failed.
        """
        return _fusion.SketchDimensions_addEllipseMajorRadiusDimension(self, ellipse, textPoint, isDriving)

    def addEllipseMinorRadiusDimension(self, ellipse: "SketchCurve", textPoint: "Point3D", isDriving: "bool"=True) -> "adsk::core::Ptr< adsk::fusion::SketchEllipseMinorRadiusDimension >":
        r"""
        Creates a new dimension constraint on the minor radius of an ellipse. 
        ellipse : The SketchEllipse to dimension. 
        textPoint : A Point3D object that defines the position of the dimension text. 
        isDriving : Optional argument that specifies if a driving (the dimension controls the geoemtry) 
        or a driven (the geometry controls the dimension) dimension is created. If not provided
        a driving dimension will be created. 
        Returns the newly created dimension or null if the creation failed.
        """
        return _fusion.SketchDimensions_addEllipseMinorRadiusDimension(self, ellipse, textPoint, isDriving)

    def addConcentricCircleDimension(self, circleOne: "SketchCurve", circleTwo: "SketchCurve", textPoint: "Point3D", isDriving: "bool"=True) -> "adsk::core::Ptr< adsk::fusion::SketchConcentricCircleDimension >":
        r"""
        Creates a new dimension constraint between to concentric circles or arcs. 
        circleOne : The first SketchCircle or SketchArc to dimension. 
        circleTwo : The second SketchCircle or SketchArc to dimension. 
        textPoint : A Point3D object that defines the position of the dimension text. 
        isDriving : Optional argument that specifies if a driving (the dimension controls the geoemtry) 
        or a driven (the geometry controls the dimension) dimension is created. If not provided
        a driving dimension will be created. 
        Returns the newly created dimension or null if the creation failed.
        """
        return _fusion.SketchDimensions_addConcentricCircleDimension(self, circleOne, circleTwo, textPoint, isDriving)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchDimensions__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchDimensions__get_isValid(self)

# Register SketchDimensions in _fusion:
_fusion.SketchDimensions_swigregister(SketchDimensions)

def SketchDimensions_classType() -> "char const *":
    return _fusion.SketchDimensions_classType()


SketchDimensions.count = property(SketchDimensions._get_count, doc="Returns the number of sketch dimensions in the sketch.")


SketchDimensions.cast = lambda arg: arg if isinstance(arg, SketchDimensions) else None

class SketchEllipses(Base):
    r"""
    The collection of ellipses in a sketch. This provides access to the existing
    ellipses and supports the methods to create new ellipses.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchEllipses *":
        return _fusion.SketchEllipses___deref__(self)

    def __eq__(self, rhs: "SketchEllipses") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchEllipses___eq__(self, rhs)


    def __ne__(self, rhs: "SketchEllipses") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchEllipses___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.SketchEllipses___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::SketchEllipse >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.SketchEllipses___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchEllipses_classType()
    __swig_destroy__ = _fusion.delete_SketchEllipses

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::SketchEllipse >":
        r"""
        Function that returns the specified sketch ellipse using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchEllipses_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of ellipses in the sketch."""
        return _fusion.SketchEllipses__get_count(self)

    def add(self, centerPoint: "Base", majorAxisPoint: "Point3D", point: "Point3D") -> "adsk::core::Ptr< adsk::fusion::SketchEllipse >":
        r"""
        Creates a sketch ellipse using the center point, a point defining the major axis
        and a third point anywhere along the ellipse. The created ellipse is parallel to the 
        x-y plane of the sketch. 
        centerPoint : The center point of the ellipse. This can be either an existing SketchPoint or a Point3D object. 
        majorAxisPoint : A point3D object that defines both the major axis direction and major axis radius. 
        point : A point3D object that the ellipse will pass through. 
        Returns the newly created SketchEllipse object if the creation was successful or null if it failed.
        """
        return _fusion.SketchEllipses_add(self, centerPoint, majorAxisPoint, point)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchEllipses__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchEllipses__get_isValid(self)

# Register SketchEllipses in _fusion:
_fusion.SketchEllipses_swigregister(SketchEllipses)

def SketchEllipses_classType() -> "char const *":
    return _fusion.SketchEllipses_classType()


SketchEllipses.count = property(SketchEllipses._get_count, doc="Returns the number of ellipses in the sketch.")


SketchEllipses.cast = lambda arg: arg if isinstance(arg, SketchEllipses) else None

class SketchEllipticalArcs(Base):
    r"""
    The collection of elliptical arcs in a sketch. This provides access to the existing
    elliptical arcs and supports the methods to create new elliptical arcs.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchEllipticalArcs *":
        return _fusion.SketchEllipticalArcs___deref__(self)

    def __eq__(self, rhs: "SketchEllipticalArcs") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchEllipticalArcs___eq__(self, rhs)


    def __ne__(self, rhs: "SketchEllipticalArcs") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchEllipticalArcs___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.SketchEllipticalArcs___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::SketchEllipticalArc >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.SketchEllipticalArcs___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchEllipticalArcs_classType()
    __swig_destroy__ = _fusion.delete_SketchEllipticalArcs

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::SketchEllipticalArc >":
        r"""
        Function that returns the specified sketch elliptical arc using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchEllipticalArcs_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of elliptical arcs in the sketch."""
        return _fusion.SketchEllipticalArcs__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchEllipticalArcs__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchEllipticalArcs__get_isValid(self)

# Register SketchEllipticalArcs in _fusion:
_fusion.SketchEllipticalArcs_swigregister(SketchEllipticalArcs)

def SketchEllipticalArcs_classType() -> "char const *":
    return _fusion.SketchEllipticalArcs_classType()


SketchEllipticalArcs.count = property(SketchEllipticalArcs._get_count, doc="Returns the number of elliptical arcs in the sketch.")


SketchEllipticalArcs.cast = lambda arg: arg if isinstance(arg, SketchEllipticalArcs) else None

class SketchEntity(Base):
    r"""
    This object represents all geometry in a sketch, including
    points and lines and the various curves.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchEntity *":
        return _fusion.SketchEntity___deref__(self)

    def __eq__(self, rhs: "SketchEntity") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchEntity___eq__(self, rhs)


    def __ne__(self, rhs: "SketchEntity") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchEntity___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchEntity_classType()
    __swig_destroy__ = _fusion.delete_SketchEntity

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch."""
        return _fusion.SketchEntity__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >":
        r"""Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchEntity__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >":
        r"""Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchEntity__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool":
        r"""Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchEntity__get_is2D(self)

    def _get_isReference(self) -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchEntity__get_isReference(self)

    def _set_isReference(self, value: "bool") -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchEntity__set_isReference(self, value)

    def _get_isFixed(self) -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchEntity__get_isFixed(self)

    def _set_isFixed(self, value: "bool") -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchEntity__set_isFixed(self, value)

    def _get_isVisible(self) -> "bool":
        r"""
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchEntity__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchEntity__get_boundingBox(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchEntity_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchEntity__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchEntity__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool":
        r"""
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchEntity__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool":
        r"""Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchEntity__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.SketchEntity__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the SketchEntity object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same sketch entity.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SketchEntity__get_entityToken(self)

    def _get_isLinked(self) -> "bool":
        r"""
        Indicates if this sketch entity was created by a projection, inclusion, or driven by an API script.
        If this returns true, then the entity is presented to the user as not editable and with a 'break link'
        command available.
        """
        return _fusion.SketchEntity__get_isLinked(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchEntity__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchEntity__get_isValid(self)

# Register SketchEntity in _fusion:
_fusion.SketchEntity_swigregister(SketchEntity)

def SketchEntity_classType() -> "char const *":
    return _fusion.SketchEntity_classType()


SketchEntity.parentSketch = property(SketchEntity._get_parentSketch, doc="Returns the parent sketch.")


SketchEntity.sketchDimensions = property(SketchEntity._get_sketchDimensions, doc="Returns the sketch dimensions that are attached to this curve.")


SketchEntity.geometricConstraints = property(SketchEntity._get_geometricConstraints, doc="Returns the sketch constraints that are attached to this curve.")


SketchEntity.is2D = property(SketchEntity._get_is2D, doc="Indicates if this curve lies entirely on the sketch x-y plane.")


SketchEntity.isReference = property(SketchEntity._get_isReference, SketchEntity._set_isReference, doc="Indicates if this geometry is a reference.\nChanging this property from true to false removes the reference.\nThis property can not be set to true if it is already false.")


SketchEntity.isFixed = property(SketchEntity._get_isFixed, SketchEntity._set_isFixed, doc="Indicates if this geometry is 'fixed'.")


SketchEntity.isVisible = property(SketchEntity._get_isVisible, doc="When a sketch is created, geometry is sometimes automatically added to the sketch.\nFor example a sketch point that references the origin point is always included and\nif a face was selected to create the sketch on, geometry from the face is also included.\nThis automatically created geometry behaves in a special way in that it is invisible\nbut is available for selection and it also participates in profile calculations. It's\nnot possible to make them visible but they can be deleted and they can be used for any\nother standard sketch operation.")


SketchEntity.boundingBox = property(SketchEntity._get_boundingBox, doc="Returns the bounding box of the entity in sketch space.")


SketchEntity.referencedEntity = property(SketchEntity._get_referencedEntity, doc="Returns the referenced entity in the case where IsReference\nis true. However, this property can also return null when\nIsReference is true in the case where the reference is not\nparametric.")


SketchEntity.assemblyContext = property(SketchEntity._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")


SketchEntity.isDeletable = property(SketchEntity._get_isDeletable, doc="Indicates if this sketch entity can be deleted. There are cases, especially with sketch\npoints where another entity is dependent on an entity so deleting it is not allowed.\nFor example, you can't delete the center point of circle by itself but deleting the circle\nwill delete the point. The same is true for the end points of a line.")


SketchEntity.isFullyConstrained = property(SketchEntity._get_isFullyConstrained, doc="Indicates if this sketch entity is fully constrained.")


SketchEntity.attributes = property(SketchEntity._get_attributes, doc="Returns the collection of attributes associated with this face.")


SketchEntity.entityToken = property(SketchEntity._get_entityToken, doc="Returns a token for the SketchEntity object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same sketch entity.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.")


SketchEntity.isLinked = property(SketchEntity._get_isLinked, doc="Indicates if this sketch entity was created by a projection, inclusion, or driven by an API script.\nIf this returns true, then the entity is presented to the user as not editable and with a 'break link'\ncommand available.")


SketchEntity.cast = lambda arg: arg if isinstance(arg, SketchEntity) else None

class SketchEntityList(Base):
    r"""A list of sketch entities."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchEntityList *":
        return _fusion.SketchEntityList___deref__(self)

    def __eq__(self, rhs: "SketchEntityList") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchEntityList___eq__(self, rhs)


    def __ne__(self, rhs: "SketchEntityList") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchEntityList___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.SketchEntityList___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::SketchEntity >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.SketchEntityList___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchEntityList_classType()
    __swig_destroy__ = _fusion.delete_SketchEntityList

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::SketchEntity >":
        r"""
        Function that returns the specified sketch entity using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchEntityList_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of sketch entities in the list."""
        return _fusion.SketchEntityList__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchEntityList__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchEntityList__get_isValid(self)

# Register SketchEntityList in _fusion:
_fusion.SketchEntityList_swigregister(SketchEntityList)

def SketchEntityList_classType() -> "char const *":
    return _fusion.SketchEntityList_classType()


SketchEntityList.count = property(SketchEntityList._get_count, doc="Returns the number of sketch entities in the list.")


SketchEntityList.cast = lambda arg: arg if isinstance(arg, SketchEntityList) else None

class Sketches(Base):
    r"""
    Provides access to the sketches within a design and provides
    methods to create new sketches.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::Sketches *":
        return _fusion.Sketches___deref__(self)

    def __eq__(self, rhs: "Sketches") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.Sketches___eq__(self, rhs)


    def __ne__(self, rhs: "Sketches") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.Sketches___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.Sketches___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::Sketch >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.Sketches___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.Sketches_classType()
    __swig_destroy__ = _fusion.delete_Sketches

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""
        Function that returns the specified sketch using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the 
        collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.Sketches_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""
        Returns the sketch with the specified name. 
        name : The name of the sketch as seen in the browser and the timeline. 
        Returns the sketch or null if there isn't a sketch with that name.
        """
        return _fusion.Sketches_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""Returns the number of sketches in a component"""
        return _fusion.Sketches__get_count(self)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""
        Creates a new sketch on the specified planar entity. 
        planarEntity : A construction plane or planar face that defines the sketch plane 
        occurrenceForCreation : A creation occurrence is needed if the planarEntity is in another component AND the 
        sketch is not in the root component. The occurrenceForCreation is analogous 
        to the active occurrence in the UI. 
        Returns the newly created Sketch or null if the creation failed.
        """
        return _fusion.Sketches_add(self, *args)

    def addToBaseOrFormFeature(self, planarEntity: "Base", targetBaseOrFormFeature: "Base", includeFaceEdges: "bool") -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""
        Creates a parametric sketch that is associated with a base feature.
        Because of a current limitation, if you want to create a sketch associated with a base
        feature, you must first call the edit method of the base feature, use this method to 
        create the sketch, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it. 
        planarEntity : A construction plane or planar face that defines the sketch plane. 
        targetBaseOrFormFeature : The existing base feature that you want to associate this sketch with. 
        includeFaceEdges : When a BrepFace is used as the planarEntity argument, this defines if the edges of the face
        should be included in the sketch. 
        Returns the newly created Sketch or null if the creation failed.
        """
        return _fusion.Sketches_addToBaseOrFormFeature(self, planarEntity, targetBaseOrFormFeature, includeFaceEdges)

    def addWithoutEdges(self, *args) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""
        Creates a new sketch on the specified planar entity. If a BRepFace is provided, the edges of the face
        are not projected into the sketch so the result of creating a new sketch with this method will
        always be a new empty sketch. 
        planarEntity : A construction plane or planar face that defines the sketch plane. 
        occurrenceForCreation : A creation occurrence is needed if the planarEntity is in another component AND the 
        sketch is not in the root component. The occurrenceForCreation is analogous 
        to the active occurrence in the UI. 
        Returns the newly created Sketch or null if the creation failed.
        """
        return _fusion.Sketches_addWithoutEdges(self, *args)

    def _get_objectType(self) -> "char const *":
        return _fusion.Sketches__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.Sketches__get_isValid(self)

# Register Sketches in _fusion:
_fusion.Sketches_swigregister(Sketches)

def Sketches_classType() -> "char const *":
    return _fusion.Sketches_classType()


Sketches.count = property(Sketches._get_count, doc="Returns the number of sketches in a component")


Sketches.cast = lambda arg: arg if isinstance(arg, Sketches) else None

class SketchFittedSplines(Base):
    r"""
    The collection of fitted splines in a sketch. This provides access to the existing
    fitted splines and supports the methods to create new fitted splines.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchFittedSplines *":
        return _fusion.SketchFittedSplines___deref__(self)

    def __eq__(self, rhs: "SketchFittedSplines") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchFittedSplines___eq__(self, rhs)


    def __ne__(self, rhs: "SketchFittedSplines") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchFittedSplines___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.SketchFittedSplines___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::SketchFittedSpline >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.SketchFittedSplines___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchFittedSplines_classType()
    __swig_destroy__ = _fusion.delete_SketchFittedSplines

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::SketchFittedSpline >":
        r"""
        Function that returns the specified sketch fitted spline using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchFittedSplines_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of fitted splines in the sketch."""
        return _fusion.SketchFittedSplines__get_count(self)

    def add(self, fitPoints: "ObjectCollection") -> "adsk::core::Ptr< adsk::fusion::SketchFittedSpline >":
        r"""
        Creates a new fitted spline through the specified points. 
        fitPoints : A collection of points that the curve will fit through. They
        can be any combination of existing SketchPoint or Point3D objects. 
        Returns the newly created SketchFittedSpline object if the creation was successful or null if it failed.
        """
        return _fusion.SketchFittedSplines_add(self, fitPoints)

    def addByNurbsCurve(self, nurbsCurve: "NurbsCurve3D") -> "adsk::core::Ptr< adsk::fusion::SketchFittedSpline >":
        r"""
        Creates a new fitted spline using the input NurbsCurve3D to define the shape. Fit points are created
        to create a curve that exactly matches the input curve. 
        nurbsCurve : A NurbsCurve3D object that defines a valid NURBS curve. 
        Returns the newly created SketchFittedSpline object if the creation was successful or null if it failed.
        """
        return _fusion.SketchFittedSplines_addByNurbsCurve(self, nurbsCurve)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchFittedSplines__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchFittedSplines__get_isValid(self)

# Register SketchFittedSplines in _fusion:
_fusion.SketchFittedSplines_swigregister(SketchFittedSplines)

def SketchFittedSplines_classType() -> "char const *":
    return _fusion.SketchFittedSplines_classType()


SketchFittedSplines.count = property(SketchFittedSplines._get_count, doc="Returns the number of fitted splines in the sketch.")


SketchFittedSplines.cast = lambda arg: arg if isinstance(arg, SketchFittedSplines) else None

class SketchFixedSplines(Base):
    r"""
    The collection of fixed splines in a sketch. Fixed splines are splines that were created
    as the result of some operation (i.e. intersection) and is not directly editable.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchFixedSplines *":
        return _fusion.SketchFixedSplines___deref__(self)

    def __eq__(self, rhs: "SketchFixedSplines") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchFixedSplines___eq__(self, rhs)


    def __ne__(self, rhs: "SketchFixedSplines") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchFixedSplines___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.SketchFixedSplines___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::SketchFixedSpline >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.SketchFixedSplines___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchFixedSplines_classType()
    __swig_destroy__ = _fusion.delete_SketchFixedSplines

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::SketchFixedSpline >":
        r"""
        Function that returns the specified sketch fixed spline using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchFixedSplines_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of fitted splines in the sketch."""
        return _fusion.SketchFixedSplines__get_count(self)

    def addByNurbsCurve(self, nurbsCurve: "NurbsCurve3D") -> "adsk::core::Ptr< adsk::fusion::SketchFixedSpline >":
        r"""
        Creates a new fixed spline using the input NurbsCurve3D to define the shape. The resulting curve
        is not editable by the user but can be updated via the API using the replaceGeometry method on the 
        SketchFixedSpline object. 
        nurbsCurve : A NurbsCurve3D object that defines a valid NURBS curve. 
        Returns the newly created SketchFixedSpline object if the creation was successful or null if it failed.
        """
        return _fusion.SketchFixedSplines_addByNurbsCurve(self, nurbsCurve)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchFixedSplines__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchFixedSplines__get_isValid(self)

# Register SketchFixedSplines in _fusion:
_fusion.SketchFixedSplines_swigregister(SketchFixedSplines)

def SketchFixedSplines_classType() -> "char const *":
    return _fusion.SketchFixedSplines_classType()


SketchFixedSplines.count = property(SketchFixedSplines._get_count, doc="Returns the number of fitted splines in the sketch.")


SketchFixedSplines.cast = lambda arg: arg if isinstance(arg, SketchFixedSplines) else None

class SketchLineList(Base):
    r"""A list of sketch lines."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchLineList *":
        return _fusion.SketchLineList___deref__(self)

    def __eq__(self, rhs: "SketchLineList") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchLineList___eq__(self, rhs)


    def __ne__(self, rhs: "SketchLineList") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchLineList___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.SketchLineList___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::SketchLine >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.SketchLineList___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchLineList_classType()
    __swig_destroy__ = _fusion.delete_SketchLineList

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""
        Function that returns the specified sketch line using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchLineList_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of sketch lines in the list."""
        return _fusion.SketchLineList__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchLineList__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchLineList__get_isValid(self)

# Register SketchLineList in _fusion:
_fusion.SketchLineList_swigregister(SketchLineList)

def SketchLineList_classType() -> "char const *":
    return _fusion.SketchLineList_classType()


SketchLineList.count = property(SketchLineList._get_count, doc="Returns the number of sketch lines in the list.")


SketchLineList.cast = lambda arg: arg if isinstance(arg, SketchLineList) else None

class SketchLines(Base):
    r"""
    The collection of lines in a sketch. This provides access to the existing
    lines and supports the methods to create new lines.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchLines *":
        return _fusion.SketchLines___deref__(self)

    def __eq__(self, rhs: "SketchLines") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchLines___eq__(self, rhs)


    def __ne__(self, rhs: "SketchLines") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchLines___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.SketchLines___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::SketchLine >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.SketchLines___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchLines_classType()
    __swig_destroy__ = _fusion.delete_SketchLines

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""
        Function that returns the specified sketch line using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchLines_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of lines in the sketch."""
        return _fusion.SketchLines__get_count(self)

    def addByTwoPoints(self, startPoint: "Base", endPoint: "Base") -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""
        Creates a sketch line between the two input points. The input points
        can be either existing SketchPoints or Point3D objects. If a SketchPoint
        is used the new line will be based on that sketch point and update if the
        sketch point is modified. 
        startPoint : The start point of the line. It can be a SketchPoint or Point3D object. 
        endPoint : The end point of the line. It can be a SketchPoint or Point3D object. 
        Returns the newly created SketchLine object or null if the creation failed.
        """
        return _fusion.SketchLines_addByTwoPoints(self, startPoint, endPoint)

    def addTwoPointRectangle(self, pointOne: "Base", pointTwo: "Base") -> "adsk::core::Ptr< adsk::fusion::SketchLineList >":
        r"""
        Creates four sketch lines representing a rectangle where the two points are the opposing corners
        of the rectangle. The input points can be either existing SketchPoints or Point3D objects.
        If a SketchPoint is used the new lines will be based on that sketch point and update if the
        sketch point is modified. 
        pointOne : The first corner of the rectangle. It can be a SketchPoint or Point3D object. 
        pointTwo : The second corner of the rectangle. It can be a SketchPoint or Point3D object. 
        Returns the four new sketch lines or null if the creation failed.
        """
        return _fusion.SketchLines_addTwoPointRectangle(self, pointOne, pointTwo)

    def addThreePointRectangle(self, pointOne: "Base", pointTwo: "Base", pointThree: "Point3D") -> "adsk::core::Ptr< adsk::fusion::SketchLineList >":
        r"""
        Creates four sketch lines representing a rectangle where the first two points are the base corners
        of the rectangle and the third point defines the height. 
        pointOne : The first corner of the rectangle. It can be a SketchPoint or Point3D object. 
        pointTwo : The first corner of the rectangle. It can be a SketchPoint or Point3D object. 
        pointThree : The first corner of the rectangle. a Point3D object defining the height of the rectangle. 
        Returns the four new sketch lines or null if the creation failed.
        """
        return _fusion.SketchLines_addThreePointRectangle(self, pointOne, pointTwo, pointThree)

    def addCenterPointRectangle(self, centerPoint: "Point3D", cornerPoint: "Base") -> "adsk::core::Ptr< adsk::fusion::SketchLineList >":
        r"""
        Creates four sketch lines representing a rectangle where the first point represents the center of 
        the rectangle. The second point is the corner of the rectangle and can be either an existing 
        SketchPoint or Point3D object. The four sketch lines are returned. 
        centerPoint : The center point of the rectangle 
        cornerPoint : The corner of the rectangle. It can be a SketchPoint or Point3D object. 
        Returns the four new sketch lines or null if the creation failed.
        """
        return _fusion.SketchLines_addCenterPointRectangle(self, centerPoint, cornerPoint)

    def addDistanceChamfer(self, firstLine: "SketchLine", firstLinePoint: "Point3D", secondLine: "SketchLine", secondLinePoint: "Point3D", distanceOne: "double", distanceTwo: "double") -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""
        Creates a chamfer between two sketch lines. In the case where the two input lines cross each other creating
        an 'X' shape, this results in four quadrants where the chamfer can be placed. The point arguments are used
        to define which of the four quadrants the chamfer should be created in. The two points define which side of
        the two lines should be kept and the other end will be trimmed by the chamfer. The easiest way to use this is
        to use the end points of the lines on the side you want to keep.
        In the case where the lines don't intersect or connect at the end points, there is only one valid quadrant
        for the chamfer so the points are ignored. 
        firstLine : The first line you want to chamfer. 
        firstLinePoint : A point on the first line that is on the side of the intersection with the second line that you want to keep. 
        secondLine : The second line you want to chamfer. 
        secondLinePoint : A point on the second line that is on the side of the intersection with the first line that you want to keep. 
        distanceOne : Defines the distance of the start point of the chamfer line from the intersection point of the two lines along the first line.
        The distance is defined in centimeters. 
        distanceTwo : Defines the distance of the start point of the chamfer line from the intersection point of the two lines along the second line.
        The distance is defined in centimeters. 
        Returns the newly created SketchLine object that represents the chamfer or null if the creation failed.
        """
        return _fusion.SketchLines_addDistanceChamfer(self, firstLine, firstLinePoint, secondLine, secondLinePoint, distanceOne, distanceTwo)

    def addAngleChamfer(self, firstLine: "SketchLine", firstLinePoint: "Point3D", secondLine: "SketchLine", secondLinePoint: "Point3D", distance: "double", angle: "double") -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""
        Creates a chamfer between two sketch lines. In the case where the two input lines cross each other creating
        an 'X' shape, this results in four quadrants where the chamfer can be placed. The point arguments are used
        to define which of the four quadrants the chamfer should be created in. The two points define which side of
        the two lines should be kept and the other end will be trimmed by the chamfer. The easiest way to use this is
        to use the end points of the lines on the side you want to keep.
        In the case where the lines don't intersect or connect at the end points, there is only one valid quadrant
        for the chamfer so the points are ignored. 
        firstLine : The first line you want to chamfer. 
        firstLinePoint : A point on the first line that is on the side of the intersection with the second line that you want to keep. 
        secondLine : The second line you want to chamfer. 
        secondLinePoint : A point on the second line that is on the side of the intersection with the first line that you want to keep. 
        distance : Defines the distance of the start point of the chamfer from the intersection point of the two lines along the first line.
        The distance is defined in centimeters. 
        angle : Defines the angle of the chamfer as measured from the first line.
        The angle is defined in radians. 
        Returns the newly created SketchLine object that represents the chamfer or null if the creation failed.
        """
        return _fusion.SketchLines_addAngleChamfer(self, firstLine, firstLinePoint, secondLine, secondLinePoint, distance, angle)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchLines__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchLines__get_isValid(self)

# Register SketchLines in _fusion:
_fusion.SketchLines_swigregister(SketchLines)

def SketchLines_classType() -> "char const *":
    return _fusion.SketchLines_classType()


SketchLines.count = property(SketchLines._get_count, doc="Returns the number of lines in the sketch.")


SketchLines.cast = lambda arg: arg if isinstance(arg, SketchLines) else None

class SketchPointList(Base):
    r"""A list of sketch points."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchPointList *":
        return _fusion.SketchPointList___deref__(self)

    def __eq__(self, rhs: "SketchPointList") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchPointList___eq__(self, rhs)


    def __ne__(self, rhs: "SketchPointList") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchPointList___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.SketchPointList___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.SketchPointList___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchPointList_classType()
    __swig_destroy__ = _fusion.delete_SketchPointList

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""
        Function that returns the specified sketch point using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchPointList_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of sketch points in the list."""
        return _fusion.SketchPointList__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchPointList__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchPointList__get_isValid(self)

# Register SketchPointList in _fusion:
_fusion.SketchPointList_swigregister(SketchPointList)

def SketchPointList_classType() -> "char const *":
    return _fusion.SketchPointList_classType()


SketchPointList.count = property(SketchPointList._get_count, doc="Returns the number of sketch points in the list.")


SketchPointList.cast = lambda arg: arg if isinstance(arg, SketchPointList) else None

class SketchPoints(Base):
    r"""A collection of sketch points."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchPoints *":
        return _fusion.SketchPoints___deref__(self)

    def __eq__(self, rhs: "SketchPoints") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchPoints___eq__(self, rhs)


    def __ne__(self, rhs: "SketchPoints") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchPoints___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.SketchPoints___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.SketchPoints___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchPoints_classType()
    __swig_destroy__ = _fusion.delete_SketchPoints

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""
        Function that returns the specified sketch using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchPoints_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of sketch points in the sketch."""
        return _fusion.SketchPoints__get_count(self)

    def add(self, point: "Point3D") -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""
        Creates a point at the specified location. This is the equivalent
        of creating a sketch point using the Point command in the user
        interface and will create a visible point in the graphics window. 
        point : The coordinate location to create the sketch point. 
        Returns the new sketch point or null if the creation fails.
        """
        return _fusion.SketchPoints_add(self, point)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchPoints__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchPoints__get_isValid(self)

# Register SketchPoints in _fusion:
_fusion.SketchPoints_swigregister(SketchPoints)

def SketchPoints_classType() -> "char const *":
    return _fusion.SketchPoints_classType()


SketchPoints.count = property(SketchPoints._get_count, doc="Returns the number of sketch points in the sketch.")


SketchPoints.cast = lambda arg: arg if isinstance(arg, SketchPoints) else None

class SketchTextDefinition(Base):
    r"""The base class for the classes that define how text can be defined."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchTextDefinition *":
        return _fusion.SketchTextDefinition___deref__(self)

    def __eq__(self, rhs: "SketchTextDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchTextDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "SketchTextDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchTextDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchTextDefinition_classType()
    __swig_destroy__ = _fusion.delete_SketchTextDefinition

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchTextDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchTextDefinition__get_isValid(self)

# Register SketchTextDefinition in _fusion:
_fusion.SketchTextDefinition_swigregister(SketchTextDefinition)

def SketchTextDefinition_classType() -> "char const *":
    return _fusion.SketchTextDefinition_classType()


SketchTextDefinition.cast = lambda arg: arg if isinstance(arg, SketchTextDefinition) else None

class SketchTextInput(Base):
    r"""
    The SketchTextInput object is equivalent to the Sketch Text dialog in that it collects all of the input required
    to create sketch text. Once the properties of the SketchTextInput object have been defined, use the add method
    to create the sketch text. A SketchTextInput object is created by using the createInput of the SketchTexts object.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchTextInput *":
        return _fusion.SketchTextInput___deref__(self)

    def __eq__(self, rhs: "SketchTextInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchTextInput___eq__(self, rhs)


    def __ne__(self, rhs: "SketchTextInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchTextInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchTextInput_classType()
    __swig_destroy__ = _fusion.delete_SketchTextInput

    def _get_height(self) -> "double":
        r"""Gets and sets the height of the text in centimeters."""
        return _fusion.SketchTextInput__get_height(self)

    def _set_height(self, value: "double") -> "bool":
        r"""Gets and sets the height of the text in centimeters."""
        return _fusion.SketchTextInput__set_height(self, value)

    def _get_text(self) -> "std::string":
        r"""Gets and sets the text."""
        return _fusion.SketchTextInput__get_text(self)

    def _set_text(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the text."""
        return _fusion.SketchTextInput__set_text(self, value)

    def _get_position(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""
        Gets and sets the position of the text on the x-y plane of the sketch. The text must lie on the x-y plane so the Z component
        of the point is ignored and always treated as zero.
        """
        return _fusion.SketchTextInput__get_position(self)

    def _set_position(self, value: "Point3D") -> "bool":
        r"""
        Gets and sets the position of the text on the x-y plane of the sketch. The text must lie on the x-y plane so the Z component
        of the point is ignored and always treated as zero.
        """
        return _fusion.SketchTextInput__set_position(self, value)

    def _get_fontName(self) -> "std::string":
        r"""Gets and sets the name of the font to use."""
        return _fusion.SketchTextInput__get_fontName(self)

    def _set_fontName(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the name of the font to use."""
        return _fusion.SketchTextInput__set_fontName(self, value)

    def _get_angle(self) -> "double":
        r"""Gets and sets the angle of the text relative to the x-axis of the x-y plane of the sketch."""
        return _fusion.SketchTextInput__get_angle(self)

    def _set_angle(self, value: "double") -> "bool":
        r"""Gets and sets the angle of the text relative to the x-axis of the x-y plane of the sketch."""
        return _fusion.SketchTextInput__set_angle(self, value)

    def _get_textStyle(self) -> "adsk::fusion::TextStyles":
        r"""
        Gets and sets the text style to apply to the entire text. This is a bitwise enum so styles
        can be combined to apply multiple styles. For example you can apply bold and italic.
        """
        return _fusion.SketchTextInput__get_textStyle(self)

    def _set_textStyle(self, value: "TextStyles") -> "bool":
        r"""
        Gets and sets the text style to apply to the entire text. This is a bitwise enum so styles
        can be combined to apply multiple styles. For example you can apply bold and italic.
        """
        return _fusion.SketchTextInput__set_textStyle(self, value)

    def _get_isHorizontalFlip(self) -> "bool":
        r"""Gets and sets if the text is flipped horizontally."""
        return _fusion.SketchTextInput__get_isHorizontalFlip(self)

    def _set_isHorizontalFlip(self, value: "bool") -> "bool":
        r"""Gets and sets if the text is flipped horizontally."""
        return _fusion.SketchTextInput__set_isHorizontalFlip(self, value)

    def _get_isVerticalFlip(self) -> "bool":
        r"""Gets and sets if the text is flipped vertically."""
        return _fusion.SketchTextInput__get_isVerticalFlip(self)

    def _set_isVerticalFlip(self, value: "bool") -> "bool":
        r"""Gets and sets if the text is flipped vertically."""
        return _fusion.SketchTextInput__set_isVerticalFlip(self, value)

    def setAsFitOnPath(self, path: "Base", isAbovePath: "bool") -> "bool":
        r"""
        Sets this SketchTextInput to define text that fits along a specified path. Fitting on a path will
        space the characters so the text fits along the entire length of the path entity. 
        path : The entity that defines the path for the text. This can be a SketchCurve or BRepEdge object. 
        isAbovePath : Indicates if the text should be positioned above or below the path entity. 
        Returns true if the setting the definition was successful.
        """
        return _fusion.SketchTextInput_setAsFitOnPath(self, path, isAbovePath)

    def setAsAlongPath(self, path: "Base", isAbovePath: "bool", horizontalAlignment: "HorizontalAlignments", characterSpacing: "double") -> "bool":
        r"""
        Sets this SketchTextInput to define text that follows along a specified path. 
        path : The entity that defines the path for the text. This can be a SketchCurve or BRepEdge object. 
        isAbovePath : Indicates if the text should be positioned above or below the path entity. 
        horizontalAlignment : Specifies the horizontal alignment of the text with respect to the path curve. 
        characterSpacing : The percentage change in default spacing between characters. 
        Returns true if the setting the definition was successful.
        """
        return _fusion.SketchTextInput_setAsAlongPath(self, path, isAbovePath, horizontalAlignment, characterSpacing)

    def setAsMultiLine(self, cornerPoint: "Base", diagonalPoint: "Base", horizontalAlignment: "HorizontalAlignments", verticalAlignment: "VerticalAlignments", characterSpacing: "double") -> "bool":
        r"""
        Defines the first corner point of the rectangle that will contain the text. 
        cornerPoint : Specifies the location of one of the corner points of the rectangle that will contain the text.
        This can be a Point3D object, with a Z component of zero, to define any arbitrary location on the X-Y
        plane of the sketch or it can be an existing SketchPoint that lies on the sketch X-Y plane. 
        diagonalPoint : Specifies the location of the diagonal point of the rectangle that will contain the text. This point
        cannot be aligned vertically or horizontally to the corner point but be a diagonal point to define
        a rectangle. This can be a Point3D object, with a Z component of zero, to define any arbitrary location on the X-Y
        plane of the sketch or it can be an existing SketchPoint that lies on the sketch X-Y plane and the sketch point
        will become the opposing corner point. 
        horizontalAlignment : Specifies the horizontal alignment of the text with respect to the text rectangle. 
        verticalAlignment : Specifies the vertical alignment of the text with respect to the text rectangle. 
        characterSpacing : The spacing between the characters. This is an additional spacing to apply that is defined
        as a percentage of the default spacing. A spacing of 0 indicates no additional spacing.
        A spacing of 50 indicates to use the default plus 50% of the default. 
        Returns true if the setting the definition was successful.
        """
        return _fusion.SketchTextInput_setAsMultiLine(self, cornerPoint, diagonalPoint, horizontalAlignment, verticalAlignment, characterSpacing)

    def _get_definition(self) -> "adsk::core::Ptr< adsk::fusion::SketchTextDefinition >":
        r"""
        Returns the SketchTextDefinition object associated with this input. When the SketchTextInput is first created this
        property will return null. Once one of the 'set' methods have been called, this will return the SketchTextDefinition
        of the appropriate type and can be used to make any additional changes to the text.
        """
        return _fusion.SketchTextInput__get_definition(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchTextInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchTextInput__get_isValid(self)

# Register SketchTextInput in _fusion:
_fusion.SketchTextInput_swigregister(SketchTextInput)

def SketchTextInput_classType() -> "char const *":
    return _fusion.SketchTextInput_classType()


SketchTextInput.height = property(SketchTextInput._get_height, SketchTextInput._set_height, doc="Gets and sets the height of the text in centimeters.")


SketchTextInput.text = property(SketchTextInput._get_text, SketchTextInput._set_text, doc="Gets and sets the text.")


SketchTextInput.position = property(SketchTextInput._get_position, SketchTextInput._set_position, doc="Gets and sets the position of the text on the x-y plane of the sketch. The text must lie on the x-y plane so the Z component\nof the point is ignored and always treated as zero.")


SketchTextInput.fontName = property(SketchTextInput._get_fontName, SketchTextInput._set_fontName, doc="Gets and sets the name of the font to use.")


SketchTextInput.angle = property(SketchTextInput._get_angle, SketchTextInput._set_angle, doc="Gets and sets the angle of the text relative to the x-axis of the x-y plane of the sketch.")


SketchTextInput.textStyle = property(SketchTextInput._get_textStyle, SketchTextInput._set_textStyle, doc="Gets and sets the text style to apply to the entire text. This is a bitwise enum so styles\ncan be combined to apply multiple styles. For example you can apply bold and italic.")


SketchTextInput.isHorizontalFlip = property(SketchTextInput._get_isHorizontalFlip, SketchTextInput._set_isHorizontalFlip, doc="Gets and sets if the text is flipped horizontally.")


SketchTextInput.isVerticalFlip = property(SketchTextInput._get_isVerticalFlip, SketchTextInput._set_isVerticalFlip, doc="Gets and sets if the text is flipped vertically.")


SketchTextInput.definition = property(SketchTextInput._get_definition, doc="Returns the SketchTextDefinition object associated with this input. When the SketchTextInput is first created this\nproperty will return null. Once one of the 'set' methods have been called, this will return the SketchTextDefinition\nof the appropriate type and can be used to make any additional changes to the text.")


SketchTextInput.cast = lambda arg: arg if isinstance(arg, SketchTextInput) else None

class SketchTexts(Base):
    r"""
    The collection of text blocks in a sketch. This provides access to the existing
    text blocks and supports creating new text blocks.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchTexts *":
        return _fusion.SketchTexts___deref__(self)

    def __eq__(self, rhs: "SketchTexts") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchTexts___eq__(self, rhs)


    def __ne__(self, rhs: "SketchTexts") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchTexts___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.SketchTexts___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::SketchText >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.SketchTexts___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchTexts_classType()
    __swig_destroy__ = _fusion.delete_SketchTexts

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::SketchText >":
        r"""
        Function that returns the specified sketch text using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchTexts_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of texts in the sketch."""
        return _fusion.SketchTexts__get_count(self)

    def createInput(self, formattedText: "std::string const &", height: "double", position: "Point3D") -> "adsk::core::Ptr< adsk::fusion::SketchTextInput >":
        r"""
        Creates a SketchTextInput object that can be used to define additional settings when creating sketch text. The 
        SketchTextInput object is equivalent to the Sketch Text dialog in that it collects all of the input required
        to create sketch text. Once the properties of the SketchTextInput object have been defined, use the add method
        to create the sketch text. 
        formattedText : The text used for the sketch text. This is a simple string as no additional formatting is currently supported. 
        height : The height of the text in centimeters. 
        position : The position of the text on the x-y plane of the sketch. The text must lie on the x-y plane so the Z component
        of the point is ignored and always treated as zero. 
        Returns a SketchTextInput object that can be used to set additional formatting and is used as input to the add method.
        """
        return _fusion.SketchTexts_createInput(self, formattedText, height, position)

    def add(self, input: "SketchTextInput") -> "adsk::core::Ptr< adsk::fusion::SketchText >":
        r"""
        Creates a sketch text. 
        input : A SketchTextInput object created using the SketchTexts.createInput method. 
        Returns the newly created SketchText object or null in the case of failure.
        """
        return _fusion.SketchTexts_add(self, input)

    def createInput2(self, formattedText: "std::string const &", height: "double") -> "adsk::core::Ptr< adsk::fusion::SketchTextInput >":
        r"""
        Creates a SketchTextInput object that is used to define the additional input to create text. The SketchTextInput
        object is equivalent to the Sketch Text dialog in that it collects all of the input required to create sketch text.
        You must call setAsFitOnPath, setAsAlongPath, or setAsMultiLine methods to define one of the three types of text and
        can use other and define any
        setAs Once the properties of the SketchTextInput object have been defined, use the add method
        to create the sketch text. 
        formattedText : The text used for the sketch text. This is a simple string as no additional formatting is currently supported. 
        height : The height of the text in centimeters. 
        Returns a SketchTextInput object that can be used to set additional formatting and is used as input to the add method.
        """
        return _fusion.SketchTexts_createInput2(self, formattedText, height)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchTexts__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchTexts__get_isValid(self)

# Register SketchTexts in _fusion:
_fusion.SketchTexts_swigregister(SketchTexts)

def SketchTexts_classType() -> "char const *":
    return _fusion.SketchTexts_classType()


SketchTexts.count = property(SketchTexts._get_count, doc="Returns the number of texts in the sketch.")


SketchTexts.cast = lambda arg: arg if isinstance(arg, SketchTexts) else None

class Snapshot(Base):
    r"""Object that represents a Snapshot in the timeline"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::Snapshot *":
        return _fusion.Snapshot___deref__(self)

    def __eq__(self, rhs: "Snapshot") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.Snapshot___eq__(self, rhs)


    def __ne__(self, rhs: "Snapshot") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.Snapshot___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.Snapshot_classType()
    __swig_destroy__ = _fusion.delete_Snapshot

    def _get_name(self) -> "std::string":
        r"""Gets and sets the name of the snapshot as seen in the timeline."""
        return _fusion.Snapshot__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the name of the snapshot as seen in the timeline."""
        return _fusion.Snapshot__set_name(self, value)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this snapshot."""
        return _fusion.Snapshot__get_timelineObject(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this snapshot. 
        Returns true if the delete was successful.
        """
        return _fusion.Snapshot_deleteMe(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.Snapshot__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.Snapshot__get_isValid(self)

# Register Snapshot in _fusion:
_fusion.Snapshot_swigregister(Snapshot)

def Snapshot_classType() -> "char const *":
    return _fusion.Snapshot_classType()


Snapshot.name = property(Snapshot._get_name, Snapshot._set_name, doc="Gets and sets the name of the snapshot as seen in the timeline.")


Snapshot.timelineObject = property(Snapshot._get_timelineObject, doc="Returns the timeline object associated with this snapshot.")


Snapshot.cast = lambda arg: arg if isinstance(arg, Snapshot) else None

class Snapshots(Base):
    r"""
    Provides access to the Snapshots within a design and provides 
    methods to create new Snapshots.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::Snapshots *":
        return _fusion.Snapshots___deref__(self)

    def __eq__(self, rhs: "Snapshots") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.Snapshots___eq__(self, rhs)


    def __ne__(self, rhs: "Snapshots") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.Snapshots___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.Snapshots___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::Snapshot >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.Snapshots___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.Snapshots_classType()
    __swig_destroy__ = _fusion.delete_Snapshots

    def add(self) -> "adsk::core::Ptr< adsk::fusion::Snapshot >":
        r"""
        Creates a new snapshot. Creating a snapshot is only valid when the HasPendingTransforms property returns true. 
        Returns the newly created snapshot.
        """
        return _fusion.Snapshots_add(self)

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::Snapshot >":
        r"""
        Function that returns the specified snapshot in the collection using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.Snapshots_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of items in the collection."""
        return _fusion.Snapshots__get_count(self)

    def _get_hasPendingSnapshot(self) -> "bool":
        r"""Indicates if there are any changes that have been made than can be snapshot."""
        return _fusion.Snapshots__get_hasPendingSnapshot(self)

    def revertPendingSnapshot(self) -> "bool":
        r"""
        Reverts and changes that have been made that can be snapshot. This effectively
        reverts the design back to the last snapshot. This is only valid when the
        HasPendingSnapshot property returns true. 
        Returns true if the revert was successful.
        """
        return _fusion.Snapshots_revertPendingSnapshot(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.Snapshots__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.Snapshots__get_isValid(self)

# Register Snapshots in _fusion:
_fusion.Snapshots_swigregister(Snapshots)

def Snapshots_classType() -> "char const *":
    return _fusion.Snapshots_classType()


Snapshots.count = property(Snapshots._get_count, doc="The number of items in the collection.")


Snapshots.hasPendingSnapshot = property(Snapshots._get_hasPendingSnapshot, doc="Indicates if there are any changes that have been made than can be snapshot.")


Snapshots.cast = lambda arg: arg if isinstance(arg, Snapshots) else None

class SphereFeatures(Base):
    r"""Collection that provides access to all of the existing torus features in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SphereFeatures *":
        return _fusion.SphereFeatures___deref__(self)

    def __eq__(self, rhs: "SphereFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SphereFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "SphereFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SphereFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.SphereFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::SphereFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.SphereFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SphereFeatures_classType()
    __swig_destroy__ = _fusion.delete_SphereFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::SphereFeature >":
        r"""
        Function that returns the specified sphere feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SphereFeatures_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::SphereFeature >":
        r"""
        Function that returns the specified sphere feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.SphereFeatures_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of sphere features in the collection."""
        return _fusion.SphereFeatures__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SphereFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SphereFeatures__get_isValid(self)

# Register SphereFeatures in _fusion:
_fusion.SphereFeatures_swigregister(SphereFeatures)

def SphereFeatures_classType() -> "char const *":
    return _fusion.SphereFeatures_classType()


SphereFeatures.count = property(SphereFeatures._get_count, doc="The number of sphere features in the collection.")


SphereFeatures.cast = lambda arg: arg if isinstance(arg, SphereFeatures) else None

class SplitBodyFeatureInput(Base):
    r"""This class defines the methods and properties that pertain to the definition of a split body feature."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SplitBodyFeatureInput *":
        return _fusion.SplitBodyFeatureInput___deref__(self)

    def __eq__(self, rhs: "SplitBodyFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SplitBodyFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "SplitBodyFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SplitBodyFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SplitBodyFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_SplitBodyFeatureInput

    def _get_splitBodies(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the input solid or open bodies to be split. This can be a 
        single BRepBody or an ObjectCollection if multiple bodies are to be split.
        """
        return _fusion.SplitBodyFeatureInput__get_splitBodies(self)

    def _set_splitBodies(self, value: "Base") -> "bool":
        r"""
        Gets and sets the input solid or open bodies to be split. This can be a 
        single BRepBody or an ObjectCollection if multiple bodies are to be split.
        """
        return _fusion.SplitBodyFeatureInput__set_splitBodies(self, value)

    def _get_splittingTool(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the entity that defines the splitting tool. The splitting tool is a single 
        entity that can be either a solid or open BRepBody, construction plane, profile, or a face.
        """
        return _fusion.SplitBodyFeatureInput__get_splittingTool(self)

    def _set_splittingTool(self, value: "Base") -> "bool":
        r"""
        Gets and sets the entity that defines the splitting tool. The splitting tool is a single 
        entity that can be either a solid or open BRepBody, construction plane, profile, or a face.
        """
        return _fusion.SplitBodyFeatureInput__set_splittingTool(self, value)

    def _get_isSplittingToolExtended(self) -> "bool":
        r"""
        Gets and sets whether or not the splitting tool is to be automatically extended (if possible) so as to
        completely intersect the bodyToSplit.
        """
        return _fusion.SplitBodyFeatureInput__get_isSplittingToolExtended(self)

    def _set_isSplittingToolExtended(self, value: "bool") -> "bool":
        r"""
        Gets and sets whether or not the splitting tool is to be automatically extended (if possible) so as to
        completely intersect the bodyToSplit.
        """
        return _fusion.SplitBodyFeatureInput__set_isSplittingToolExtended(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.SplitBodyFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.SplitBodyFeatureInput__set_targetBaseFeature(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.SplitBodyFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SplitBodyFeatureInput__get_isValid(self)

# Register SplitBodyFeatureInput in _fusion:
_fusion.SplitBodyFeatureInput_swigregister(SplitBodyFeatureInput)

def SplitBodyFeatureInput_classType() -> "char const *":
    return _fusion.SplitBodyFeatureInput_classType()


SplitBodyFeatureInput.splitBodies = property(SplitBodyFeatureInput._get_splitBodies, SplitBodyFeatureInput._set_splitBodies, doc="Gets and sets the input solid or open bodies to be split. This can be a\nsingle BRepBody or an ObjectCollection if multiple bodies are to be split.")


SplitBodyFeatureInput.splittingTool = property(SplitBodyFeatureInput._get_splittingTool, SplitBodyFeatureInput._set_splittingTool, doc="Gets and sets the entity that defines the splitting tool. The splitting tool is a single\nentity that can be either a solid or open BRepBody, construction plane, profile, or a face.")


SplitBodyFeatureInput.isSplittingToolExtended = property(SplitBodyFeatureInput._get_isSplittingToolExtended, SplitBodyFeatureInput._set_isSplittingToolExtended, doc="Gets and sets whether or not the splitting tool is to be automatically extended (if possible) so as to\ncompletely intersect the bodyToSplit.")


SplitBodyFeatureInput.targetBaseFeature = property(SplitBodyFeatureInput._get_targetBaseFeature, SplitBodyFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


SplitBodyFeatureInput.cast = lambda arg: arg if isinstance(arg, SplitBodyFeatureInput) else None

class SplitBodyFeatures(Base):
    r"""
    Collection that provides access to all of the existing split body features in a component
    and supports the ability to create new split body features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SplitBodyFeatures *":
        return _fusion.SplitBodyFeatures___deref__(self)

    def __eq__(self, rhs: "SplitBodyFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SplitBodyFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "SplitBodyFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SplitBodyFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.SplitBodyFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::SplitBodyFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.SplitBodyFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SplitBodyFeatures_classType()
    __swig_destroy__ = _fusion.delete_SplitBodyFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::SplitBodyFeature >":
        r"""
        Function that returns the specified split body feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SplitBodyFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of split body features in the collection."""
        return _fusion.SplitBodyFeatures__get_count(self)

    def createInput(self, splitBodies: "Base", splittingTool: "Base", isSplittingToolExtended: "bool") -> "adsk::core::Ptr< adsk::fusion::SplitBodyFeatureInput >":
        r"""
        Creates a SplitBodyFeatureInput object. Use properties and methods on this object
        to define the split body you want to create and then use the Add method, passing in 
        the SplitBodyFeatureInput object. 
        splitBodies : Input solid body or open bodies to be split. This can be a single BRepBody or an ObjectCollection if multliple
        bodies are to be split. 
        splittingTool : Input entity that defines the splitting tool. The splitting tool is a single entity that can be either a solid or open BRepBody,
        construction plane, profile, or a face. 
        isSplittingToolExtended : A boolean value for setting whether or not the splitting tool is to be automatically extended (if possible) so as to
        completely intersect the bodyToSplit. 
        Returns the newly created SplitBodyFeatureInput object or null if the creation failed.
        """
        return _fusion.SplitBodyFeatures_createInput(self, splitBodies, splittingTool, isSplittingToolExtended)

    def add(self, input: "SplitBodyFeatureInput") -> "adsk::core::Ptr< adsk::fusion::SplitBodyFeature >":
        r"""
        Creates a new split body feature. 
        input : A SplitBodyFeatureInput object that defines the desired split body feature. Use the createInput 
        method to create a new SplitBodyFeatureInput object and then use methods on it 
        (the SplitBodyFeatureInput object) to define the split body. 
        Returns the newly created SplitBodyFeature object or null if the creation failed.
        """
        return _fusion.SplitBodyFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::SplitBodyFeature >":
        r"""
        Function that returns the specified split body feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.SplitBodyFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.SplitBodyFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SplitBodyFeatures__get_isValid(self)

# Register SplitBodyFeatures in _fusion:
_fusion.SplitBodyFeatures_swigregister(SplitBodyFeatures)

def SplitBodyFeatures_classType() -> "char const *":
    return _fusion.SplitBodyFeatures_classType()


SplitBodyFeatures.count = property(SplitBodyFeatures._get_count, doc="The number of split body features in the collection.")


SplitBodyFeatures.cast = lambda arg: arg if isinstance(arg, SplitBodyFeatures) else None

class SplitFaceFeatureInput(Base):
    r"""This class defines the methods and properties that pertain to the definition of a split face feature."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SplitFaceFeatureInput *":
        return _fusion.SplitFaceFeatureInput___deref__(self)

    def __eq__(self, rhs: "SplitFaceFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SplitFaceFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "SplitFaceFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SplitFaceFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SplitFaceFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_SplitFaceFeatureInput

    def _get_facesToSplit(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the faces to be split.
        The collection can contain one or more faces selected from solid and/or open bodies.
        """
        return _fusion.SplitFaceFeatureInput__get_facesToSplit(self)

    def _set_facesToSplit(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the faces to be split.
        The collection can contain one or more faces selected from solid and/or open bodies.
        """
        return _fusion.SplitFaceFeatureInput__set_facesToSplit(self, value)

    def _get_splittingTool(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the entity(s) that define the splitting tool(s). The splitting tool can be a single entity or an 
        ObjectCollection containing solid and/or open bodies, construction planes, faces, or sketch curves that partially 
        or fully intersect the faces that are being split.
        """
        return _fusion.SplitFaceFeatureInput__get_splittingTool(self)

    def _set_splittingTool(self, value: "Base") -> "bool":
        r"""
        Gets and sets the entity(s) that define the splitting tool(s). The splitting tool can be a single entity or an 
        ObjectCollection containing solid and/or open bodies, construction planes, faces, or sketch curves that partially 
        or fully intersect the faces that are being split.
        """
        return _fusion.SplitFaceFeatureInput__set_splittingTool(self, value)

    def _get_isSplittingToolExtended(self) -> "bool":
        r"""
        Gets and sets whether or not the splittingTool is to be automatically extended (if possible) so as to
        completely intersect the facesToSplit.
        """
        return _fusion.SplitFaceFeatureInput__get_isSplittingToolExtended(self)

    def _set_isSplittingToolExtended(self, value: "bool") -> "bool":
        r"""
        Gets and sets whether or not the splittingTool is to be automatically extended (if possible) so as to
        completely intersect the facesToSplit.
        """
        return _fusion.SplitFaceFeatureInput__set_isSplittingToolExtended(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.SplitFaceFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.SplitFaceFeatureInput__set_targetBaseFeature(self, value)

    def setAlongVectorSplitType(self, directionEntity: "Base") -> "bool":
        r"""
        Sets the split type to project the splitting tool along the direction defined by the
        specified entity. 
        directionEntity : An entity that defines the direction of projection of the splitting tool. This can be
        a linear BRepEdge, SketchLine, ConstructionLine, or a planar face where the face
        normal is used. 
        Returns true is setting the split type was successful.
        """
        return _fusion.SplitFaceFeatureInput_setAlongVectorSplitType(self, directionEntity)

    def setClosestPointSplitType(self) -> "bool":
        r"""
        Sets the split type to be a curve that defined by projecting the splitting curve to the
        closest point on the surface. 
        Returns true is setting the split type was successful.
        """
        return _fusion.SplitFaceFeatureInput_setClosestPointSplitType(self)

    def setSurfaceIntersectionSplitType(self, isSplittingToolExtended: "bool") -> "bool":
        r"""
        Set the split type to be a surface to surface intersection. If the split tool is a curve
        it will be extruded into a surface to use in the split. If it's a surface, the surface will
        be used and optionally extended to fully intersect the faces to be split. 
        isSplittingToolExtended : Specifies if the splitting tool should be extended so that is fully intersects the faces to be split. 
        Returns true is setting the split type was successful.
        """
        return _fusion.SplitFaceFeatureInput_setSurfaceIntersectionSplitType(self, isSplittingToolExtended)

    def _get_splitType(self) -> "adsk::fusion::SplitFaceSplitTypes":
        r"""Returns the type of split type currently defined."""
        return _fusion.SplitFaceFeatureInput__get_splitType(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SplitFaceFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SplitFaceFeatureInput__get_isValid(self)

# Register SplitFaceFeatureInput in _fusion:
_fusion.SplitFaceFeatureInput_swigregister(SplitFaceFeatureInput)

def SplitFaceFeatureInput_classType() -> "char const *":
    return _fusion.SplitFaceFeatureInput_classType()


SplitFaceFeatureInput.facesToSplit = property(SplitFaceFeatureInput._get_facesToSplit, SplitFaceFeatureInput._set_facesToSplit, doc="Gets and sets the faces to be split.\nThe collection can contain one or more faces selected from solid and/or open bodies.")


SplitFaceFeatureInput.splittingTool = property(SplitFaceFeatureInput._get_splittingTool, SplitFaceFeatureInput._set_splittingTool, doc="Gets and sets the entity(s) that define the splitting tool(s). The splitting tool can be a single entity or an\nObjectCollection containing solid and/or open bodies, construction planes, faces, or sketch curves that partially\nor fully intersect the faces that are being split.")


SplitFaceFeatureInput.isSplittingToolExtended = property(SplitFaceFeatureInput._get_isSplittingToolExtended, SplitFaceFeatureInput._set_isSplittingToolExtended, doc="Gets and sets whether or not the splittingTool is to be automatically extended (if possible) so as to\ncompletely intersect the facesToSplit.")


SplitFaceFeatureInput.targetBaseFeature = property(SplitFaceFeatureInput._get_targetBaseFeature, SplitFaceFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


SplitFaceFeatureInput.splitType = property(SplitFaceFeatureInput._get_splitType, doc="Returns the type of split type currently defined.")


SplitFaceFeatureInput.cast = lambda arg: arg if isinstance(arg, SplitFaceFeatureInput) else None

class SplitFaceFeatures(Base):
    r"""
    Collection that provides access to all of the existing split face features in a component
    and supports the ability to create new split face features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SplitFaceFeatures *":
        return _fusion.SplitFaceFeatures___deref__(self)

    def __eq__(self, rhs: "SplitFaceFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SplitFaceFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "SplitFaceFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SplitFaceFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.SplitFaceFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::SplitFaceFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.SplitFaceFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SplitFaceFeatures_classType()
    __swig_destroy__ = _fusion.delete_SplitFaceFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::SplitFaceFeature >":
        r"""
        Function that returns the specified split face feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SplitFaceFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of split face features in the collection."""
        return _fusion.SplitFaceFeatures__get_count(self)

    def createInput(self, facesToSplit: "ObjectCollection", splittingTool: "Base", isSplittingToolExtended: "bool") -> "adsk::core::Ptr< adsk::fusion::SplitFaceFeatureInput >":
        r"""
        Creates a SplitFaceFeatureInput object. Use properties and methods on this object
        to define the split face you want to create and then use the Add method, passing in 
        the SplitFaceFeatureInput object. 
        A newly created SplitFaceFeatureInput object defaults to creating a split face feature 
        using the 'Split with Surface' option. You can use functions on the SplitFaceFeatureInput
        object to define a different type of split type. 
        facesToSplit : Input the faces to be split. The collection can contain one or more faces from solid and/or open bodies. 
        splittingTool : Input entity(s) that defines the splitting tool. The splitting tool can be a single entity or an ObjectCollection
        containing solid and/or open bodies, construction planes, faces, or sketch curves that partially or fully intersect
        the faces that are being split. 
        isSplittingToolExtended : A boolean value for setting whether or not the splittingTool is to be automatically extended (if possible) so as to
        completely intersect the faces that are to be split. This is only used when the split type is 'split with surface'
        which is the default type when a new createInput is created. Use functions on the returned SplitFaceFeatureInput
        to define a different type of split type. 
        Returns the newly created SplitFaceFeatureInput object or null if the creation failed.
        """
        return _fusion.SplitFaceFeatures_createInput(self, facesToSplit, splittingTool, isSplittingToolExtended)

    def add(self, input: "SplitFaceFeatureInput") -> "adsk::core::Ptr< adsk::fusion::SplitFaceFeature >":
        r"""
        Creates a new split face feature. 
        input : A SplitFaceFeatureInput object that defines the desired split face feature. Use the createInput 
        method to create a new SplitFaceFeatureInput object and then use methods on it 
        (the SplitFaceFeatureInput object) to define the split face. 
        Returns the newly created SplitFaceFeature object or null if the creation failed.
        """
        return _fusion.SplitFaceFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::SplitFaceFeature >":
        r"""
        Function that returns the specified split face feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.SplitFaceFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.SplitFaceFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SplitFaceFeatures__get_isValid(self)

# Register SplitFaceFeatures in _fusion:
_fusion.SplitFaceFeatures_swigregister(SplitFaceFeatures)

def SplitFaceFeatures_classType() -> "char const *":
    return _fusion.SplitFaceFeatures_classType()


SplitFaceFeatures.count = property(SplitFaceFeatures._get_count, doc="The number of split face features in the collection.")


SplitFaceFeatures.cast = lambda arg: arg if isinstance(arg, SplitFaceFeatures) else None

class StitchFeatureInput(Base):
    r"""This class defines the methods and properties that pertain to the definition of a stitch feature."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::StitchFeatureInput *":
        return _fusion.StitchFeatureInput___deref__(self)

    def __eq__(self, rhs: "StitchFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.StitchFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "StitchFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.StitchFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.StitchFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_StitchFeatureInput

    def _get_stitchSurfaces(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""Gets and sets the surfaces to stitch together."""
        return _fusion.StitchFeatureInput__get_stitchSurfaces(self)

    def _set_stitchSurfaces(self, value: "ObjectCollection") -> "bool":
        r"""Gets and sets the surfaces to stitch together."""
        return _fusion.StitchFeatureInput__set_stitchSurfaces(self, value)

    def _get_tolerance(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets and sets the ValueInput object that defines the stitching tolerance. It must define a length."""
        return _fusion.StitchFeatureInput__get_tolerance(self)

    def _set_tolerance(self, value: "ValueInput") -> "bool":
        r"""Gets and sets the ValueInput object that defines the stitching tolerance. It must define a length."""
        return _fusion.StitchFeatureInput__set_tolerance(self, value)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations":
        r"""
        Gets and sets the feature operation to perform. This property value is only valid if the isSolid property returns
        true. Otherwise the value of this property is ignored.
        """
        return _fusion.StitchFeatureInput__get_operation(self)

    def _set_operation(self, value: "FeatureOperations") -> "bool":
        r"""
        Gets and sets the feature operation to perform. This property value is only valid if the isSolid property returns
        true. Otherwise the value of this property is ignored.
        """
        return _fusion.StitchFeatureInput__set_operation(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.StitchFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.StitchFeatureInput__set_targetBaseFeature(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.StitchFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.StitchFeatureInput__get_isValid(self)

# Register StitchFeatureInput in _fusion:
_fusion.StitchFeatureInput_swigregister(StitchFeatureInput)

def StitchFeatureInput_classType() -> "char const *":
    return _fusion.StitchFeatureInput_classType()


StitchFeatureInput.stitchSurfaces = property(StitchFeatureInput._get_stitchSurfaces, StitchFeatureInput._set_stitchSurfaces, doc="Gets and sets the surfaces to stitch together.")


StitchFeatureInput.tolerance = property(StitchFeatureInput._get_tolerance, StitchFeatureInput._set_tolerance, doc="Gets and sets the ValueInput object that defines the stitching tolerance. It must define a length.")


StitchFeatureInput.operation = property(StitchFeatureInput._get_operation, StitchFeatureInput._set_operation, doc="Gets and sets the feature operation to perform. This property value is only valid if the isSolid property returns\ntrue. Otherwise the value of this property is ignored.")


StitchFeatureInput.targetBaseFeature = property(StitchFeatureInput._get_targetBaseFeature, StitchFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


StitchFeatureInput.cast = lambda arg: arg if isinstance(arg, StitchFeatureInput) else None

class StitchFeatures(Base):
    r"""
    Collection that provides access to all of the existing Stitch features in a component
    and supports the ability to create new Stitch features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::StitchFeatures *":
        return _fusion.StitchFeatures___deref__(self)

    def __eq__(self, rhs: "StitchFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.StitchFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "StitchFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.StitchFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.StitchFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::StitchFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.StitchFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.StitchFeatures_classType()
    __swig_destroy__ = _fusion.delete_StitchFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::StitchFeature >":
        r"""
        Function that returns the specified stitch feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.StitchFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of Stitch features in the collection."""
        return _fusion.StitchFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::StitchFeatureInput >":
        r"""
        Creates a StitchFeatureInput object. Use properties and methods on this object
        to define the stitch feature you want to create and then use the Add method, passing in 
        the StitchFeatureInput object. 
        stitchSurfaces : The surfaces (open BRepBodies) to stitch together.
        Stitching surfaces can form multiple closed volumes resulting in multiple solids.
        Stitch Surfaces can form multiple BRepShells (entirely connected set of entities) that would result in a 
        single non-solid BRepBody. 
        tolerance : ValueInput object that defines the stitching tolerance. It must define a distance value. 
        operation : Specifies the operation type for the result when the final result is a closed solid. Otherwise
        this argument is ignored. 
        Returns the newly created StitchFeatureInput object or null if the creation failed.
        """
        return _fusion.StitchFeatures_createInput(self, *args)

    def add(self, input: "StitchFeatureInput") -> "adsk::core::Ptr< adsk::fusion::StitchFeature >":
        r"""
        Creates a new stitch feature. 
        input : A StitchFeatureInput object that defines the desired stitch feature. Use the createInput 
        method to create a new StitchFeatureInput object and then use methods on it 
        (the StitchFeatureInput object) to define the stitch feature. 
        Returns the newly created StitchFeature object or null if the creation failed.
        """
        return _fusion.StitchFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::StitchFeature >":
        r"""
        Function that returns the specified stitch feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.StitchFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.StitchFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.StitchFeatures__get_isValid(self)

# Register StitchFeatures in _fusion:
_fusion.StitchFeatures_swigregister(StitchFeatures)

def StitchFeatures_classType() -> "char const *":
    return _fusion.StitchFeatures_classType()


StitchFeatures.count = property(StitchFeatures._get_count, doc="The number of Stitch features in the collection.")


StitchFeatures.cast = lambda arg: arg if isinstance(arg, StitchFeatures) else None

class SurfaceDeleteFaceFeatures(Base):
    r"""
    Collection that provides access to all of the existing SurfaceDeleteFaceFeature features in a component
    and supports the ability to create new SurfaceDeleteFaceFeature features.
    The SurfaceDeleteFaceFeature and DeleteFaceFeature differ in that the SurfaceDeleteFaceFeature
    can delete any face without any restrictions. If the body is a solid, it will become a surface
    when the first face is deleted. The specified face is deleted without any other changes being
    made to the body. The DeleteFaceFeature deletes the specified face and also modifies the other faces
    in the body to heal or fill in the area of the deleted face. This means that a solid body will
    remain solid.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SurfaceDeleteFaceFeatures *":
        return _fusion.SurfaceDeleteFaceFeatures___deref__(self)

    def __eq__(self, rhs: "SurfaceDeleteFaceFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SurfaceDeleteFaceFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "SurfaceDeleteFaceFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SurfaceDeleteFaceFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.SurfaceDeleteFaceFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::SurfaceDeleteFaceFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.SurfaceDeleteFaceFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SurfaceDeleteFaceFeatures_classType()
    __swig_destroy__ = _fusion.delete_SurfaceDeleteFaceFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::SurfaceDeleteFaceFeature >":
        r"""
        Function that returns the specified SurfaceDeleteFaceFeature object using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SurfaceDeleteFaceFeatures_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::SurfaceDeleteFaceFeature >":
        r"""
        Function that returns the specified SurfaceDeleteFaceFeature object using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.SurfaceDeleteFaceFeatures_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of SurfaceDeleteFaceFeature objects in the collection."""
        return _fusion.SurfaceDeleteFaceFeatures__get_count(self)

    def add(self, facesToDelete: "Base") -> "adsk::core::Ptr< adsk::fusion::SurfaceDeleteFaceFeature >":
        r"""
        Creates a new SurfaceDeleteFaceFeature feature. This deletes the specified faces
        from their bodies without any attempt to heal the openings. This is equivalent
        to selecting and deleting faces when in the Patch workspace. 
        facesToDelete : A single BRepFace or an ObjectCollection containing multiple BRepFace objects. 
        Returns the newly created SurfaceDeleteFaceFeature object or null if the creation failed.
        """
        return _fusion.SurfaceDeleteFaceFeatures_add(self, facesToDelete)

    def _get_objectType(self) -> "char const *":
        return _fusion.SurfaceDeleteFaceFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SurfaceDeleteFaceFeatures__get_isValid(self)

# Register SurfaceDeleteFaceFeatures in _fusion:
_fusion.SurfaceDeleteFaceFeatures_swigregister(SurfaceDeleteFaceFeatures)

def SurfaceDeleteFaceFeatures_classType() -> "char const *":
    return _fusion.SurfaceDeleteFaceFeatures_classType()


SurfaceDeleteFaceFeatures.count = property(SurfaceDeleteFaceFeatures._get_count, doc="The number of SurfaceDeleteFaceFeature objects in the collection.")


SurfaceDeleteFaceFeatures.cast = lambda arg: arg if isinstance(arg, SurfaceDeleteFaceFeatures) else None

class SweepFeatureInput(Base):
    r"""
    This class defines the methods and properties that pertain to the definition of a sweep 
    feature.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SweepFeatureInput *":
        return _fusion.SweepFeatureInput___deref__(self)

    def __eq__(self, rhs: "SweepFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SweepFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "SweepFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SweepFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SweepFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_SweepFeatureInput

    def _get_profile(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the profiles or planar faces used to define the shape of the sweep.
        This property can return or be set with a single Profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        """
        return _fusion.SweepFeatureInput__get_profile(self)

    def _set_profile(self, value: "Base") -> "bool":
        r"""
        Gets and sets the profiles or planar faces used to define the shape of the sweep.
        This property can return or be set with a single Profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        """
        return _fusion.SweepFeatureInput__set_profile(self, value)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations":
        r"""Gets and sets the type of operation performed by the sweep."""
        return _fusion.SweepFeatureInput__get_operation(self)

    def _set_operation(self, value: "FeatureOperations") -> "bool":
        r"""Gets and sets the type of operation performed by the sweep."""
        return _fusion.SweepFeatureInput__set_operation(self, value)

    def _get_path(self) -> "adsk::core::Ptr< adsk::fusion::Path >":
        r"""Gets and sets the path to create the sweep."""
        return _fusion.SweepFeatureInput__get_path(self)

    def _set_path(self, value: "Path") -> "bool":
        r"""Gets and sets the path to create the sweep."""
        return _fusion.SweepFeatureInput__set_path(self, value)

    def _get_distanceOne(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Gets and sets the distance for the first side.
        The distance is a value from 0 to 1 indicating the position along the path where 0
        is at the start and 1 is at the end. The value is default to 1.0.
        """
        return _fusion.SweepFeatureInput__get_distanceOne(self)

    def _set_distanceOne(self, value: "ValueInput") -> "bool":
        r"""
        Gets and sets the distance for the first side.
        The distance is a value from 0 to 1 indicating the position along the path where 0
        is at the start and 1 is at the end. The value is default to 1.0.
        """
        return _fusion.SweepFeatureInput__set_distanceOne(self, value)

    def _get_distanceTwo(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Gets and sets the distance for the second side.
        The distance is a value from 0 to 1 indicating the position along the path where 0
        is at the start and 1 is at the end. The value defaults to 0 in the case where the path is closed, otherwise it defaults to 1.0.
        It is ignored if the path is only on one side of the profile or if the sweep definition includes a guide rail.
        It's always the distance against the normal of the profile if available.
        """
        return _fusion.SweepFeatureInput__get_distanceTwo(self)

    def _set_distanceTwo(self, value: "ValueInput") -> "bool":
        r"""
        Gets and sets the distance for the second side.
        The distance is a value from 0 to 1 indicating the position along the path where 0
        is at the start and 1 is at the end. The value defaults to 0 in the case where the path is closed, otherwise it defaults to 1.0.
        It is ignored if the path is only on one side of the profile or if the sweep definition includes a guide rail.
        It's always the distance against the normal of the profile if available.
        """
        return _fusion.SweepFeatureInput__set_distanceTwo(self, value)

    def _get_orientation(self) -> "adsk::fusion::SweepOrientationTypes":
        r"""
        Gets and sets the sweep orientation. It defaults to PerpendicularOrientationType.
        This property is ignored when a guide rail has been specified.
        """
        return _fusion.SweepFeatureInput__get_orientation(self)

    def _set_orientation(self, value: "SweepOrientationTypes") -> "bool":
        r"""
        Gets and sets the sweep orientation. It defaults to PerpendicularOrientationType.
        This property is ignored when a guide rail has been specified.
        """
        return _fusion.SweepFeatureInput__set_orientation(self, value)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the sweep is created based on geometry (e.g. a profile and/or face(s))
        in another component AND (the sweep) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.SweepFeatureInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, value: "Occurrence") -> "bool":
        r"""
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the sweep is created based on geometry (e.g. a profile and/or face(s))
        in another component AND (the sweep) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.SweepFeatureInput__set_creationOccurrence(self, value)

    def _get_isSolid(self) -> "bool":
        r"""
        Specifies if the sweep should be created as a solid or surface. If
        it's a surface then there aren't any end caps and it's open. This is
        initialized to true so a solid will be created if it's not changed.
        """
        return _fusion.SweepFeatureInput__get_isSolid(self)

    def _set_isSolid(self, value: "bool") -> "bool":
        r"""
        Specifies if the sweep should be created as a solid or surface. If
        it's a surface then there aren't any end caps and it's open. This is
        initialized to true so a solid will be created if it's not changed.
        """
        return _fusion.SweepFeatureInput__set_isSolid(self, value)

    def _get_guideRail(self) -> "adsk::core::Ptr< adsk::fusion::Path >":
        r"""
        Gets and sets the guide rail to create the sweep. This can be set to 
        null to remove the guide rail definition and have a single path sweep feature.
        """
        return _fusion.SweepFeatureInput__get_guideRail(self)

    def _set_guideRail(self, value: "Path") -> "bool":
        r"""
        Gets and sets the guide rail to create the sweep. This can be set to 
        null to remove the guide rail definition and have a single path sweep feature.
        """
        return _fusion.SweepFeatureInput__set_guideRail(self, value)

    def _get_isDirectionFlipped(self) -> "bool":
        r"""
        Gets and sets if the direction of the sweep is flipped. 
        This property only applies to sweep features that include a guide rail and whose path runs on both 
        sides of the profile.
        """
        return _fusion.SweepFeatureInput__get_isDirectionFlipped(self)

    def _set_isDirectionFlipped(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the direction of the sweep is flipped. 
        This property only applies to sweep features that include a guide rail and whose path runs on both 
        sides of the profile.
        """
        return _fusion.SweepFeatureInput__set_isDirectionFlipped(self, value)

    def _get_profileScaling(self) -> "adsk::fusion::SweepProfileScalingOptions":
        r"""
        Gets and sets the sweep profile scaling option. It defaults to SweepProfileScaleOption.
        This property is only used when a guide rail has been specified.
        """
        return _fusion.SweepFeatureInput__get_profileScaling(self)

    def _set_profileScaling(self, value: "SweepProfileScalingOptions") -> "bool":
        r"""
        Gets and sets the sweep profile scaling option. It defaults to SweepProfileScaleOption.
        This property is only used when a guide rail has been specified.
        """
        return _fusion.SweepFeatureInput__set_profileScaling(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.SweepFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.SweepFeatureInput__set_targetBaseFeature(self, value)

    def _get_participantBodies(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepBody > > >":
        r"""
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        If this property has not been set, the default behavior is that all bodies that are intersected by the 
        feature will participate.
        This property can return null in the case where the feature has not been fully defined so that
        possible intersecting bodies can be computed.
        """
        return _fusion.SweepFeatureInput__get_participantBodies(self)

    def _set_participantBodies(self, value: "BRepBodyVector") -> "bool":
        r"""
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        If this property has not been set, the default behavior is that all bodies that are intersected by the 
        feature will participate.
        This property can return null in the case where the feature has not been fully defined so that
        possible intersecting bodies can be computed.
        """
        return _fusion.SweepFeatureInput__set_participantBodies(self, value)

    def _get_taperAngle(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Gets and sets the taper angle of the sweep. This property is initialized with a taper angle of zero.
        A negative angle will taper the sweep inward while a positive value will taper
        the sweep outward. This property is valid for both parametric and non-parametric extrusions.
        """
        return _fusion.SweepFeatureInput__get_taperAngle(self)

    def _set_taperAngle(self, value: "ValueInput") -> "bool":
        r"""
        Gets and sets the taper angle of the sweep. This property is initialized with a taper angle of zero.
        A negative angle will taper the sweep inward while a positive value will taper
        the sweep outward. This property is valid for both parametric and non-parametric extrusions.
        """
        return _fusion.SweepFeatureInput__set_taperAngle(self, value)

    def _get_twistAngle(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Gets and sets the taper angle of the sweep. This property is initialized with a taper angle of zero.
        A negative angle will taper the sweep inward while a positive value will taper
        the sweep outward. This property is valid for both parametric and non-parametric extrusions.
        """
        return _fusion.SweepFeatureInput__get_twistAngle(self)

    def _set_twistAngle(self, value: "ValueInput") -> "bool":
        r"""
        Gets and sets the taper angle of the sweep. This property is initialized with a taper angle of zero.
        A negative angle will taper the sweep inward while a positive value will taper
        the sweep outward. This property is valid for both parametric and non-parametric extrusions.
        """
        return _fusion.SweepFeatureInput__set_twistAngle(self, value)

    def _get_extent(self) -> "adsk::fusion::SweepExtentTypes":
        r"""
        Gets and sets the sweep extent type. It defaults to PerpendicularToPathExtentType.
        This property is ignored when a guide rail has not been specified.
        """
        return _fusion.SweepFeatureInput__get_extent(self)

    def _set_extent(self, value: "SweepExtentTypes") -> "bool":
        r"""
        Gets and sets the sweep extent type. It defaults to PerpendicularToPathExtentType.
        This property is ignored when a guide rail has not been specified.
        """
        return _fusion.SweepFeatureInput__set_extent(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.SweepFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SweepFeatureInput__get_isValid(self)

# Register SweepFeatureInput in _fusion:
_fusion.SweepFeatureInput_swigregister(SweepFeatureInput)

def SweepFeatureInput_classType() -> "char const *":
    return _fusion.SweepFeatureInput_classType()


SweepFeatureInput.profile = property(SweepFeatureInput._get_profile, SweepFeatureInput._set_profile, doc="Gets and sets the profiles or planar faces used to define the shape of the sweep.\nThis property can return or be set with a single Profile, a single planar face, or\nan ObjectCollection consisting of multiple profiles and planar faces. When an\nObjectCollection is used all of the profiles and faces must be co-planar.")


SweepFeatureInput.operation = property(SweepFeatureInput._get_operation, SweepFeatureInput._set_operation, doc="Gets and sets the type of operation performed by the sweep.")


SweepFeatureInput.path = property(SweepFeatureInput._get_path, SweepFeatureInput._set_path, doc="Gets and sets the path to create the sweep.")


SweepFeatureInput.distanceOne = property(SweepFeatureInput._get_distanceOne, SweepFeatureInput._set_distanceOne, doc="Gets and sets the distance for the first side.\nThe distance is a value from 0 to 1 indicating the position along the path where 0\nis at the start and 1 is at the end. The value is default to 1.0.")


SweepFeatureInput.distanceTwo = property(SweepFeatureInput._get_distanceTwo, SweepFeatureInput._set_distanceTwo, doc="Gets and sets the distance for the second side.\nThe distance is a value from 0 to 1 indicating the position along the path where 0\nis at the start and 1 is at the end. The value defaults to 0 in the case where the path is closed, otherwise it defaults to 1.0.\nIt is ignored if the path is only on one side of the profile or if the sweep definition includes a guide rail.\nIt's always the distance against the normal of the profile if available.")


SweepFeatureInput.orientation = property(SweepFeatureInput._get_orientation, SweepFeatureInput._set_orientation, doc="Gets and sets the sweep orientation. It defaults to PerpendicularOrientationType.\nThis property is ignored when a guide rail has been specified.")


SweepFeatureInput.creationOccurrence = property(SweepFeatureInput._get_creationOccurrence, SweepFeatureInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an Occurrence for creation needs to be\nspecified when the sweep is created based on geometry (e.g. a profile and/or face(s))\nin another component AND (the sweep) is not in the root component.\nThe CreationOccurrence is analogous to the active occurrence in the UI")


SweepFeatureInput.isSolid = property(SweepFeatureInput._get_isSolid, SweepFeatureInput._set_isSolid, doc="Specifies if the sweep should be created as a solid or surface. If\nit's a surface then there aren't any end caps and it's open. This is\ninitialized to true so a solid will be created if it's not changed.")


SweepFeatureInput.guideRail = property(SweepFeatureInput._get_guideRail, SweepFeatureInput._set_guideRail, doc="Gets and sets the guide rail to create the sweep. This can be set to\nnull to remove the guide rail definition and have a single path sweep feature.")


SweepFeatureInput.isDirectionFlipped = property(SweepFeatureInput._get_isDirectionFlipped, SweepFeatureInput._set_isDirectionFlipped, doc="Gets and sets if the direction of the sweep is flipped.\nThis property only applies to sweep features that include a guide rail and whose path runs on both\nsides of the profile.")


SweepFeatureInput.profileScaling = property(SweepFeatureInput._get_profileScaling, SweepFeatureInput._set_profileScaling, doc="Gets and sets the sweep profile scaling option. It defaults to SweepProfileScaleOption.\nThis property is only used when a guide rail has been specified.")


SweepFeatureInput.targetBaseFeature = property(SweepFeatureInput._get_targetBaseFeature, SweepFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


SweepFeatureInput.participantBodies = property(SweepFeatureInput._get_participantBodies, SweepFeatureInput._set_participantBodies, doc="Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.\nIf this property has not been set, the default behavior is that all bodies that are intersected by the\nfeature will participate.\nThis property can return null in the case where the feature has not been fully defined so that\npossible intersecting bodies can be computed.")


SweepFeatureInput.taperAngle = property(SweepFeatureInput._get_taperAngle, SweepFeatureInput._set_taperAngle, doc="Gets and sets the taper angle of the sweep. This property is initialized with a taper angle of zero.\nA negative angle will taper the sweep inward while a positive value will taper\nthe sweep outward. This property is valid for both parametric and non-parametric extrusions.")


SweepFeatureInput.twistAngle = property(SweepFeatureInput._get_twistAngle, SweepFeatureInput._set_twistAngle, doc="Gets and sets the taper angle of the sweep. This property is initialized with a taper angle of zero.\nA negative angle will taper the sweep inward while a positive value will taper\nthe sweep outward. This property is valid for both parametric and non-parametric extrusions.")


SweepFeatureInput.extent = property(SweepFeatureInput._get_extent, SweepFeatureInput._set_extent, doc="Gets and sets the sweep extent type. It defaults to PerpendicularToPathExtentType.\nThis property is ignored when a guide rail has not been specified.")


SweepFeatureInput.cast = lambda arg: arg if isinstance(arg, SweepFeatureInput) else None

class SweepFeatures(Base):
    r"""
    Collection that provides access to all of the existing sweep features in a component
    and supports the ability to create new sweep features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SweepFeatures *":
        return _fusion.SweepFeatures___deref__(self)

    def __eq__(self, rhs: "SweepFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SweepFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "SweepFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SweepFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.SweepFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::SweepFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.SweepFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SweepFeatures_classType()
    __swig_destroy__ = _fusion.delete_SweepFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::SweepFeature >":
        r"""
        Function that returns the specified sweep feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SweepFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of sweep features in the collection."""
        return _fusion.SweepFeatures__get_count(self)

    def createInput(self, profile: "Base", path: "Path", operation: "FeatureOperations") -> "adsk::core::Ptr< adsk::fusion::SweepFeatureInput >":
        r"""
        Creates a SweepFeatureInput object for defining a simple sweep feature with only a path and no guide rail. 
        Use properties and methods on this object to define the sweep you want to create and then use the Add method, 
        passing in the SweepFeatureInput object. 
        profile : The profile argument can be a single Profile, a single
        planar face, or an ObjectCollection consisting of multiple profiles and planar faces.
        When an ObjectCollection is used all of the profiles and faces must be co-planar. 
        path : The path to create the sweep. 
        operation : The feature operation to perform 
        Returns the newly created SweepFeatureInput object or null if the creation failed.
        """
        return _fusion.SweepFeatures_createInput(self, profile, path, operation)

    def add(self, input: "SweepFeatureInput") -> "adsk::core::Ptr< adsk::fusion::SweepFeature >":
        r"""
        Creates a new sweep feature. 
        input : A SweepFeatureInput object that defines the desired sweep. Use the createInput 
        method to create a new SweepFeatureInput object and then use methods on it 
        (the SweepFeatureInput object) to define the sweep. 
        Returns the newly created SweepFeature object or null if the creation failed.
        """
        return _fusion.SweepFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::SweepFeature >":
        r"""
        Function that returns the specified sweep feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.SweepFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.SweepFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SweepFeatures__get_isValid(self)

# Register SweepFeatures in _fusion:
_fusion.SweepFeatures_swigregister(SweepFeatures)

def SweepFeatures_classType() -> "char const *":
    return _fusion.SweepFeatures_classType()


SweepFeatures.count = property(SweepFeatures._get_count, doc="The number of sweep features in the collection.")


SweepFeatures.cast = lambda arg: arg if isinstance(arg, SweepFeatures) else None

class TemporaryBRepManager(Base):
    r"""
    A utility object that provides functionality to create and manipulate B-Rep data outside
    the context of a document. The provides direct access to the modeling core without the
    overhead of parametrics, persistence, transactions, or graphics. It also provides a way
    of directly defining and creating B-Rep data.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::TemporaryBRepManager *":
        return _fusion.TemporaryBRepManager___deref__(self)

    def __eq__(self, rhs: "TemporaryBRepManager") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.TemporaryBRepManager___eq__(self, rhs)


    def __ne__(self, rhs: "TemporaryBRepManager") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.TemporaryBRepManager___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.TemporaryBRepManager_classType()

    @staticmethod
    def get() -> "adsk::core::Ptr< adsk::fusion::TemporaryBRepManager >":
        return _fusion.TemporaryBRepManager_get()
    __swig_destroy__ = _fusion.delete_TemporaryBRepManager

    def copy(self, bRepEntity: "Base") -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Creates a temporary copy of the input BRepBody, BRepFace, or BRepEdge object. 
        bRepEntity : The BRepBody, BRepFace, BRepLoop, or BRepEdge to create a copy of. This can be a parametric
        B-Rep entity or a temporary B-Rep entity. 
        Returns a BRepBody that contains the result. If a BRepBody is input the copy is
        of the entire body. If a BRepFace is input, then the result is a BRepBody that 
        contains a single face. If a BRepLoop is input then the result is a BRepBody that
        contains a wire where each edge in the loop will have a corresponding edge in the wire.
        If a BRepEdge is input then the result is a BRepBody that contains a wire that contains 
        the single edge.
        """
        return _fusion.TemporaryBRepManager_copy(self, bRepEntity)

    def planeIntersection(self, body: "BRepBody", plane: "Plane") -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Calculates the intersection between the input body and plane and creates a
        wire body that represents the intersection curves. 
        body : The BRepBody to intersection. 
        plane : The geometry Plane to intersect with the body. 
        Returns a BRepBody that contains a wire body that represents the intersection.
        """
        return _fusion.TemporaryBRepManager_planeIntersection(self, body, plane)

    def createRuledSurface(self, sectionOne: "BRepWire", sectionTwo: "BRepWire") -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Creates a new body by creating a ruled surface between the two input wire bodies. 
        sectionOne : BRepWire that defines the shape of the first section. 
        sectionTwo : BRepWire that defines the shape of the second section. 
        Returns the created ruled surface as a BRepBody object.
        """
        return _fusion.TemporaryBRepManager_createRuledSurface(self, sectionOne, sectionTwo)

    def createSilhouetteCurves(self, face: "BRepFace", viewDirection: "Vector3D", returnCoincidentSilhouettes: "bool") -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Calculates the silhouette curve geometry for a given face as viewed from a given direction. 
        face : Input BRepFace object to calculate the silhouette curve for. 
        viewDirection : Input Vector3D object that defines the view direction to calculate the silhouette curve relative to. 
        The silhouette curve(s) will lie along the path where the face normal is perpendicular to the view direction. 
        returnCoincidentSilhouettes : Input Boolean that specifies if silhouette curves that are coincident to the edges of the face should be 
        returned or not. If true, these curves will be returned. 
        Returns a SurfaceBody object that will contain one or more BRepWire objects that represent the silhouette curve(s). 
        This method can return null in the case where there is not a silhouette curve for the specified face.
        """
        return _fusion.TemporaryBRepManager_createSilhouetteCurves(self, face, viewDirection, returnCoincidentSilhouettes)

    def deleteFaces(self, faces: "BRepFaceVector", deleteSpecifiedFaces: "bool") -> "bool":
        r"""
        Deletes one or more faces from a temporary BRepBody. The body that will be modified is determined
        by getting the parent body of the input faces. 
        faces : An array of BRepFace objects to delete. If more than one face is provided,
        all of the faces must exist within the same body. 
        deleteSpecifiedFaces : This allows you to either delete the faces that were input or to keep those faces and delete all the
        other faces in the body. 
        Returns true if the operation was successful.
        """
        return _fusion.TemporaryBRepManager_deleteFaces(self, faces, deleteSpecifiedFaces)

    def booleanOperation(self, targetBody: "BRepBody", toolBody: "BRepBody", booleanType: "BooleanTypes") -> "bool":
        r"""
        Performs the specified Boolean operation between the two input bodies. The input bodies need
        not be solid but can be faces that are combined or trimmed. 
        targetBody : The target body that will be modified as a result of the Boolean operation. 
        toolBody : The tool body that will be used to operate on the target body. 
        booleanType : The type of Boolean operation to perform. 
        Returns true if the operation was successful. If successful, the target body is modified as a result of the 
        Boolean operation. Because of this the targetBody must always be a temporary BRepBody. The toolbody is not 
        modified. This is analogous to a machining operation where you have the target that is being machined and 
        the tool that removes material.
        """
        return _fusion.TemporaryBRepManager_booleanOperation(self, targetBody, toolBody, booleanType)

    def transform(self, body: "BRepBody", transform: "Matrix3D") -> "bool":
        r"""
        Transforms the input body using the specified transformation matrix. 
        body : The BRepBody object to transform. 
        transform : The transformation matrix that defines the transform to apply to the body. 
        Returns true if the specified transform was successfully applied to the body.
        """
        return _fusion.TemporaryBRepManager_transform(self, body, transform)

    def createFromFile(self, filename: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Creates new BRepBody objects based on the contents of the specified file. 
        filename : The full path and name of the file to read in. This can be a SMT, SMB, SAT, or SAB file. 
        A BRepBodies collection object is returned which can contain multiple BRepBody objects.
        null is returned in the case where it was unable to read the file.
        """
        return _fusion.TemporaryBRepManager_createFromFile(self, filename)

    def exportToFile(self, bodies: "BRepBodyVector", filename: "std::string const &") -> "bool":
        r"""
        Exports the input bodies to the specified file. 
        bodies : An array of BRepBody objects that you want to export. 
        filename : The filename to write the BRepBody objects to. The type of file to create
        is inferred from the extension of the file. The valid extensions are '.sat' and '.smt'. 
        Returns true if the export was successful.
        """
        return _fusion.TemporaryBRepManager_exportToFile(self, bodies, filename)

    def createBox(self, box: "OrientedBoundingBox3D") -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Creates a new temporary solid box BRepBody object. 
        box : The OrientedBoundingBox3D object that defines the position, orientation, and
        size of the box to crate. 
        Returns the newly created temporary BRepBody object or null in the case of failure.
        """
        return _fusion.TemporaryBRepManager_createBox(self, box)

    def createCylinderOrCone(self, pointOne: "Point3D", pointOneRadius: "double", pointTwo: "Point3D", pointTwoRadius: "double") -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Creates a temporary solid cylinder or cone BRepBody object. 
        pointOne : A point at one end of the cylinder or cone. 
        pointOneRadius : The radius of the cylinder or cone at the point one end, in centimeters. 
        pointTwo : A point at the opposite end of the cylinder or cone. 
        pointTwoRadius : The radius of the cylinder or cone at the point two end, in centimeters.
        For a cylinder the pointTwoRadius should be equal to the pointOneRadius. 
        Returns the newly created temporary BRepBody object or null in the case of failure.
        """
        return _fusion.TemporaryBRepManager_createCylinderOrCone(self, pointOne, pointOneRadius, pointTwo, pointTwoRadius)

    def createEllipticalCylinderOrCone(self, pointOne: "Point3D", pointOneMajorRadius: "double", pointOneMinorRadius: "double", pointTwo: "Point3D", pointTwoMajorRadius: "double", majorAxisDirection: "Vector3D") -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Creates a temporary elliptical solid cylinder or cone BrepBody object. 
        pointOne : A point at one end of the cylinder or cone. 
        pointOneMajorRadius : The major radius of the cylinder or cone at the point one end, in centimeters. 
        pointOneMinorRadius : The minor radius of the cylinder or cone at the point one end, in centimeters. 
        pointTwo : A point at the opposite end of the cone. 
        pointTwoMajorRadius : The major radius of the cylinder or cone at the point two end, in centimeters. The 
        minor radius is automatically determined using the point one ratio of the minor and major
        radii. 
        majorAxisDirection : A Vector3D object that defines the direction of the major axis. 
        Returns the newly created temporary BRepBody object or null in the case of failure.
        """
        return _fusion.TemporaryBRepManager_createEllipticalCylinderOrCone(self, pointOne, pointOneMajorRadius, pointOneMinorRadius, pointTwo, pointTwoMajorRadius, majorAxisDirection)

    def createSphere(self, center: "Point3D", radius: "double") -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Creates a temporary spherical BRepBody object. 
        center : The center point of the sphere. 
        radius : The radius of the sphere in centimeters. 
        Returns the newly created temporary BRepBody object or null in the case of failure.
        """
        return _fusion.TemporaryBRepManager_createSphere(self, center, radius)

    def createTorus(self, center: "Point3D", axis: "Vector3D", majorRadius: "double", minorRadius: "double") -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Creates a temporary torioidal BRepBody object. 
        center : The center point of the torus. 
        axis : The axis of the torus. 
        majorRadius : The radius, in centimeters, of the major radius of the torus. If the torus was created
        by sweeping a circle around another cirlce this would be the radius of the path circle. 
        minorRadius : The radius, in centimeters, of the minor radius of the torus. If the torus was created
        by sweeping a circle around another cirlce this would be the radius of the profile circle. 
        Returns the newly created temporary BRepBody object or null in the case of failure.
        """
        return _fusion.TemporaryBRepManager_createTorus(self, center, axis, majorRadius, minorRadius)

    def createFaceFromPlanarWires(self, wireBodies: "BRepBodyVector") -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Creates a body from multiple wires that all lie within the same plane. Multiple wires are
        used when creating a plane with interior holes. One wire defines the outer shape and the
        other wires define the interior loops of the created face. 
        wireBodies : An array of bodies that contiain planar wires. Each wire must be closed, they should not overlap,
        and they should all lie on the same plane. 
        Returns a BRepBody containing the created BRepFace object or null in the case of failure.
        """
        return _fusion.TemporaryBRepManager_createFaceFromPlanarWires(self, wireBodies)

    def imprintOverlapBodies(self, bodyOne: "BRepBody", bodyTwo: "BRepBody", imprintCoincidentEdges: "bool", tolerance: "double"=0) -> "bool":
        r"""
        <p>Method that finds regions of faces on two bodies which overlap and creates new bodies where the faces 
        are split at the edges of the overlaps. This does not modify the original bodies but creates new 
        temporary bodies that contain the imprints.</p>
        <p>The picture below shows an example of imprinting. The picture on the left shows the initial two bodies 
        that are positioned so there are coincident faces. The picture on the right shows the two bodies individually 
        so you can see the result of the imprint and how the coincident faces were split. </p>
        <br/><br/><center><img src='../Images/ImprintBodies.png'></center><br/>
        <p>The ability to imprint solids can be important to applications that need to mesh models. By creating edges 
        at the poins where solids connect, it guarantees that there will be mesh nodes along those boundaries.</p> 
        bodyOne : Input BRepBody that will participate in the imprint operation. This body can be either a parametric 
        or temporary body. 
        bodyTwo : Input BRepBody that will participate in the imprint operation. This body can be either a parametric 
        or temporary body. 
        imprintCoincidentEdges : <p>Input Boolean that indicates if overlapping edges should be included in the result. The picture below 
        shows an example of when this argument will make a difference. The two bodies have overlapping faces 
        and there is also an overlapping edge. If this argument is true, then the edge shown in red below 
        will be included in the output as an overlapping edge. If False it will not be included and only 
        the edges of the overlapping faces will be in the overlapping faces collections.</p>
        <br/><br/><center><img src='../Images/ImprintOverlappingEdges.png'></center> 
        resultBodyOne : Output temporary BRepBody that contains the imprinted body that corresponds to the body provided through the bodyOne argument. 
        resultBodyTwo : Output temporary BRepBody that contains the imprinted body that corresponds to the body provided through the bodyTwo argument. 
        bodyOneOverlappingFaces : Output array of BRepFace objects that represent the overlapping faces that are part of resultBodyOne. Faces at the same index within the
        collection returned here and that returned by the bodyTwoOverlappingFaces are overlapping. 
        bodyTwoOverlappingFaces : Output array of BRepFace objects that represent the overlapping faces that are part of resultBodyTwo. Faces at the same index within the
        collection returned here and that returned by the bodyOneOverlappingFaces are overlapping. 
        bodyOneOverlappingEdges : Output array of BRepEdge objects that represent the overlapping edges that are part of resultBodyOne. Edges at the same index within the
        collection returned here and that returned by the bodyTwoOverlappingEdges are overlapping. 
        bodyTwoOverlappingEdges : Output array of BRepEdge objects that represent the overlapping edges that are part of resultBodyTwo. Edges at the same index within the
        collection returned here and that returned by the bodyOneOverlappingEdges are overlapping. 
        tolerance : Optional Input double that specifies the tolerance, in centimeters, to use when comparing the bodies. If not specified, or a value of zero
        is specified, the internal modeling tolerance will be used. 
        Returns true if the imprint calculation was successful.
        """
        return _fusion.TemporaryBRepManager_imprintOverlapBodies(self, bodyOne, bodyTwo, imprintCoincidentEdges, tolerance)

    def createWireFromCurves(self, curves: "Curve3DVector", allowSelfIntersections: "bool"=False) -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Give an array of curve geometry objects, this method creates a new wire body. 
        curves : An array containing the input Curve3D objects. These can be Arc3D, Circle3D, Ellipse3D, EllipticalArc3D or Line3D objects. 
        edgeMap : An array of edges in the returned body. The order that the edges are in this collection is the
        same order as the original corresponding Curve3D object is in the input curves array. This allows you to 
        map between the original input curve and created edge. 
        allowSelfIntersections : Specifies if you want to allow self-intersection in the input curves or not. 
        Returns the B-Rep body containing the created wire or null in the case of failure.
        """
        return _fusion.TemporaryBRepManager_createWireFromCurves(self, curves, allowSelfIntersections)

    def createHelixWire(self, axisPoint: "Point3D", axisVector: "Vector3D", startPoint: "Point3D", pitch: "double", turns: "double", taperAngle: "double") -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Creates a B-Rep body that contains a wire with a single edge that represents a helical curve. 
        axisPoint : A Point3D object that defines a point along the axis of the helix. 
        axisVector : A Vector3D object that defines the direction of the axis of the hellix. 
        startPoint : A Point3D that defines the start point of the helix. This is a point on the helix and defines the starting
        point of the helix. The distance of this point to the axis defines the starting radius of the helix. 
        pitch : The pitch of the helix, or the distance between each of the turns, in centimeters. 
        turns : The number of turns of the helix. 
        taperAngle : The taper angle of the helix in radians.
        """
        return _fusion.TemporaryBRepManager_createHelixWire(self, axisPoint, axisVector, startPoint, pitch, turns, taperAngle)

    def _get_objectType(self) -> "char const *":
        return _fusion.TemporaryBRepManager__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.TemporaryBRepManager__get_isValid(self)

# Register TemporaryBRepManager in _fusion:
_fusion.TemporaryBRepManager_swigregister(TemporaryBRepManager)

def TemporaryBRepManager_classType() -> "char const *":
    return _fusion.TemporaryBRepManager_classType()

def TemporaryBRepManager_get() -> "adsk::core::Ptr< adsk::fusion::TemporaryBRepManager >":
    return _fusion.TemporaryBRepManager_get()


TemporaryBRepManager.cast = lambda arg: arg if isinstance(arg, TemporaryBRepManager) else None

class TextureImage(Base):
    r"""Provides access to the image data associated with a texture map."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::TextureImage *":
        return _fusion.TextureImage___deref__(self)

    def __eq__(self, rhs: "TextureImage") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.TextureImage___eq__(self, rhs)


    def __ne__(self, rhs: "TextureImage") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.TextureImage___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.TextureImage_classType()
    __swig_destroy__ = _fusion.delete_TextureImage

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix2D >":
        r"""The transform of the texture image in parametric space."""
        return _fusion.TextureImage__get_transform(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.TextureImage__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.TextureImage__get_isValid(self)

# Register TextureImage in _fusion:
_fusion.TextureImage_swigregister(TextureImage)

def TextureImage_classType() -> "char const *":
    return _fusion.TextureImage_classType()


TextureImage.transform = property(TextureImage._get_transform, doc="The transform of the texture image in parametric space.")


TextureImage.cast = lambda arg: arg if isinstance(arg, TextureImage) else None

class ThickenFeatureInput(Base):
    r"""This class defines the methods and properties that pertain to the definition of a Thicken feature."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ThickenFeatureInput *":
        return _fusion.ThickenFeatureInput___deref__(self)

    def __eq__(self, rhs: "ThickenFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ThickenFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "ThickenFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ThickenFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ThickenFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_ThickenFeatureInput

    def _get_inputFaces(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""An ObjectCollection containing the face and/or patch bodies to thicken."""
        return _fusion.ThickenFeatureInput__get_inputFaces(self)

    def _set_inputFaces(self, value: "ObjectCollection") -> "bool":
        r"""An ObjectCollection containing the face and/or patch bodies to thicken."""
        return _fusion.ThickenFeatureInput__set_inputFaces(self, value)

    def _get_thickness(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""Gets and sets the ValueInput object that defines the thickness distance."""
        return _fusion.ThickenFeatureInput__get_thickness(self)

    def _set_thickness(self, value: "ValueInput") -> "bool":
        r"""Gets and sets the ValueInput object that defines the thickness distance."""
        return _fusion.ThickenFeatureInput__set_thickness(self, value)

    def _get_isSymmetric(self) -> "bool":
        r"""Gets and sets whether to add thickness symetrically or only on one side of the face/s to thicken"""
        return _fusion.ThickenFeatureInput__get_isSymmetric(self)

    def _set_isSymmetric(self, value: "bool") -> "bool":
        r"""Gets and sets whether to add thickness symetrically or only on one side of the face/s to thicken"""
        return _fusion.ThickenFeatureInput__set_isSymmetric(self, value)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations":
        r"""Gets and sets the feature operation to perform."""
        return _fusion.ThickenFeatureInput__get_operation(self)

    def _set_operation(self, value: "FeatureOperations") -> "bool":
        r"""Gets and sets the feature operation to perform."""
        return _fusion.ThickenFeatureInput__set_operation(self, value)

    def _get_isChainSelection(self) -> "bool":
        r"""Get and sets whether faces that are tangentially connected to the input faces will be included in the thicken feature."""
        return _fusion.ThickenFeatureInput__get_isChainSelection(self)

    def _set_isChainSelection(self, value: "bool") -> "bool":
        r"""Get and sets whether faces that are tangentially connected to the input faces will be included in the thicken feature."""
        return _fusion.ThickenFeatureInput__set_isChainSelection(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ThickenFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ThickenFeatureInput__set_targetBaseFeature(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.ThickenFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ThickenFeatureInput__get_isValid(self)

# Register ThickenFeatureInput in _fusion:
_fusion.ThickenFeatureInput_swigregister(ThickenFeatureInput)

def ThickenFeatureInput_classType() -> "char const *":
    return _fusion.ThickenFeatureInput_classType()


ThickenFeatureInput.inputFaces = property(ThickenFeatureInput._get_inputFaces, ThickenFeatureInput._set_inputFaces, doc="An ObjectCollection containing the face and/or patch bodies to thicken.")


ThickenFeatureInput.thickness = property(ThickenFeatureInput._get_thickness, ThickenFeatureInput._set_thickness, doc="Gets and sets the ValueInput object that defines the thickness distance.")


ThickenFeatureInput.isSymmetric = property(ThickenFeatureInput._get_isSymmetric, ThickenFeatureInput._set_isSymmetric, doc="Gets and sets whether to add thickness symetrically or only on one side of the face/s to thicken")


ThickenFeatureInput.operation = property(ThickenFeatureInput._get_operation, ThickenFeatureInput._set_operation, doc="Gets and sets the feature operation to perform.")


ThickenFeatureInput.isChainSelection = property(ThickenFeatureInput._get_isChainSelection, ThickenFeatureInput._set_isChainSelection, doc="Get and sets whether faces that are tangentially connected to the input faces will be included in the thicken feature.")


ThickenFeatureInput.targetBaseFeature = property(ThickenFeatureInput._get_targetBaseFeature, ThickenFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


ThickenFeatureInput.cast = lambda arg: arg if isinstance(arg, ThickenFeatureInput) else None

class ThickenFeatures(Base):
    r"""
    Collection that provides access to all of the existing Thicken features in a component
    and supports the ability to create new Thicken features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ThickenFeatures *":
        return _fusion.ThickenFeatures___deref__(self)

    def __eq__(self, rhs: "ThickenFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ThickenFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "ThickenFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ThickenFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.ThickenFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::ThickenFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.ThickenFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ThickenFeatures_classType()
    __swig_destroy__ = _fusion.delete_ThickenFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::ThickenFeature >":
        r"""
        Function that returns the specified Thicken feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ThickenFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of Thicken features in the collection."""
        return _fusion.ThickenFeatures__get_count(self)

    def createInput(self, inputFaces: "ObjectCollection", thickness: "ValueInput", isSymmetric: "bool", operation: "FeatureOperations", isChainSelection: "bool"=True) -> "adsk::core::Ptr< adsk::fusion::ThickenFeatureInput >":
        r"""
        Creates a ThickenFeatureInput object. Use properties and methods on this object
        to define the Thicken feature you want to create and then use the Add method, passing in 
        the ThickenFeatureInput object to create the feature. 
        inputFaces : The faces or patch bodies to thicken. Faces need not be from the same component or body, nor do they need to be 
        connected or touching one another. 
        thickness : ValueInput object that defines the thickness. 
        isSymmetric : A boolean value for setting whether to add thickness symetrically or only on one side of the face/s to thicken 
        operation : The feature operation to perform. 
        isChainSelection : A boolean value for setting whether or not faces that are tangentially connected to 
        the input faces (if any) will be included in the thicken. The default value is true. 
        Returns the newly created ThickenFeatureInput object or null if the creation failed.
        """
        return _fusion.ThickenFeatures_createInput(self, inputFaces, thickness, isSymmetric, operation, isChainSelection)

    def add(self, input: "ThickenFeatureInput") -> "adsk::core::Ptr< adsk::fusion::ThickenFeature >":
        r"""
        Creates a new Thicken feature. 
        input : A FeatureInput object that defines the desired Thicken feature. Use the createInput 
        method to create a new ThickenFeatureInput object and then use methods on it 
        (the ThickenFeatureInput object) to define the Thicken feature. 
        Returns the newly created ThickenFeature object or null if the creation failed.
        """
        return _fusion.ThickenFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::ThickenFeature >":
        r"""
        Function that returns the specified thicken feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.ThickenFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.ThickenFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ThickenFeatures__get_isValid(self)

# Register ThickenFeatures in _fusion:
_fusion.ThickenFeatures_swigregister(ThickenFeatures)

def ThickenFeatures_classType() -> "char const *":
    return _fusion.ThickenFeatures_classType()


ThickenFeatures.count = property(ThickenFeatures._get_count, doc="The number of Thicken features in the collection.")


ThickenFeatures.cast = lambda arg: arg if isinstance(arg, ThickenFeatures) else None

class ThreadDataQuery(Base):
    r"""
    This object provides methods to query the thread data contained in the XML files in ThreadData folder within the
    Fusion 360 install folder. You can use the queried values to create a ThreadInfo object that is then used to 
    create a thread feature.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ThreadDataQuery *":
        return _fusion.ThreadDataQuery___deref__(self)

    def __eq__(self, rhs: "ThreadDataQuery") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ThreadDataQuery___eq__(self, rhs)


    def __ne__(self, rhs: "ThreadDataQuery") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ThreadDataQuery___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ThreadDataQuery_classType()
    __swig_destroy__ = _fusion.delete_ThreadDataQuery

    def _get_allThreadTypes(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""Returns an array/list of all the available thread types (families)."""
        return _fusion.ThreadDataQuery__get_allThreadTypes(self)

    def allSizes(self, threadType: "std::string const &") -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Returns an array/list of all the available thread sizes for a given thread type. You can
        use the allThreadTypes property to get the available thread types. 
        threadType : Specify the thread type. 
        Returns the specified thread sizes or an empty array/list if an invalid thread type was specified.
        """
        return _fusion.ThreadDataQuery_allSizes(self, threadType)

    def allDesignations(self, threadType: "std::string const &", size: "std::string const &") -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        returns an array/list of all the available thread designations for a thread type of a given size. Valid
        thread types and sizes and be obtained by using the allThreadTypes and allSizes functions. 
        threadType : The thread type of the designation you want. 
        size : Thre thread size of the designation you want. 
        Returns the specified thread designations or empty array/list if an invalid thread type or size was specified.
        """
        return _fusion.ThreadDataQuery_allDesignations(self, threadType, size)

    def allClasses(self, isInternal: "bool", threadType: "std::string const &", designation: "std::string const &") -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Returns and array/list of all the available classes for a thread type of a given thread designation. 
        isInternal : Indicates if the thread is an internal or external thread. 
        threadType : The thread type of the thread class you want. 
        designation : The thread designation of the thread class you want. 
        Returns the specified thread classes or empty array/list if an invalid thread type or designation was specified.
        """
        return _fusion.ThreadDataQuery_allClasses(self, isInternal, threadType, designation)

    def threadTypeCustomName(self, threadType: "std::string const &") -> "std::string":
        r"""
        Method that returns the custom name for a given thread type. 
        threadType : The thread type you want to get the custom name for. 
        Returns the specified custom name or an empty string if an invalid thread type was specified.
        """
        return _fusion.ThreadDataQuery_threadTypeCustomName(self, threadType)

    def threadTypeUnit(self, threadType: "std::string const &") -> "std::string":
        r"""
        Method that returns the unit for a given thread type. 
        threadType : The thread type you want to get the thread unit type for. 
        Returns the specified unit or an empty string if an invalid thread type was specified.
        """
        return _fusion.ThreadDataQuery_threadTypeUnit(self, threadType)

    def recommendThreadData(self, modelDiameter: "double", isInternal: "bool", threadType: "std::string const &") -> "bool":
        r"""
        Method that gets the recommended thread data for a given model diameter. 
        modelDiameter : The diameter of the cylinder the thread will be placed on. The units are centimeters. 
        isInternal : Indicates if the thread is an internal or external thread. 
        threadType : Specifies the thread type to query the thread data. 
        designation : The output thread designation. 
        threadClass : The output thread class. 
        Returns true if successful.
        """
        return _fusion.ThreadDataQuery_recommendThreadData(self, modelDiameter, isInternal, threadType)

    def _get_defaultInchThreadType(self) -> "std::string":
        r"""Gets the default thread type for inch threads."""
        return _fusion.ThreadDataQuery__get_defaultInchThreadType(self)

    def _get_defaultMetricThreadType(self) -> "std::string":
        r"""Gets the default thread type for metric threads."""
        return _fusion.ThreadDataQuery__get_defaultMetricThreadType(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ThreadDataQuery__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ThreadDataQuery__get_isValid(self)

# Register ThreadDataQuery in _fusion:
_fusion.ThreadDataQuery_swigregister(ThreadDataQuery)

def ThreadDataQuery_classType() -> "char const *":
    return _fusion.ThreadDataQuery_classType()


ThreadDataQuery.allThreadTypes = property(ThreadDataQuery._get_allThreadTypes, doc="Returns an array/list of all the available thread types (families).")


ThreadDataQuery.defaultInchThreadType = property(ThreadDataQuery._get_defaultInchThreadType, doc="Gets the default thread type for inch threads.")


ThreadDataQuery.defaultMetricThreadType = property(ThreadDataQuery._get_defaultMetricThreadType, doc="Gets the default thread type for metric threads.")


ThreadDataQuery.cast = lambda arg: arg if isinstance(arg, ThreadDataQuery) else None

class ThreadFeatureInput(Base):
    r"""
    This class defines the methods and properties that pertain to the definition of a thread 
    feature.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ThreadFeatureInput *":
        return _fusion.ThreadFeatureInput___deref__(self)

    def __eq__(self, rhs: "ThreadFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ThreadFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "ThreadFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ThreadFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ThreadFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_ThreadFeatureInput

    def _get_inputCylindricalFace(self) -> "adsk::core::Ptr< adsk::fusion::BRepFace >":
        r"""
        Gets and sets the threaded face. In the case where there are multiple faces, only the first one is returned.
        Setting this results in a thread being applied to only a single face.
        It is recommended that you use the inputCylindricalfaces property in order to have full access to the collection of faces
        to be threaded.
        """
        return _fusion.ThreadFeatureInput__get_inputCylindricalFace(self)

    def _set_inputCylindricalFace(self, value: "BRepFace") -> "bool":
        r"""
        Gets and sets the threaded face. In the case where there are multiple faces, only the first one is returned.
        Setting this results in a thread being applied to only a single face.
        It is recommended that you use the inputCylindricalfaces property in order to have full access to the collection of faces
        to be threaded.
        """
        return _fusion.ThreadFeatureInput__set_inputCylindricalFace(self, value)

    def _get_isModeled(self) -> "bool":
        r"""
        Gets and sets if the thread is physical or cosmetic thread. A value of true indicates a physical thread.
        It defaults to false.
        """
        return _fusion.ThreadFeatureInput__get_isModeled(self)

    def _set_isModeled(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the thread is physical or cosmetic thread. A value of true indicates a physical thread.
        It defaults to false.
        """
        return _fusion.ThreadFeatureInput__set_isModeled(self, value)

    def _get_isFullLength(self) -> "bool":
        r"""
        Gets and sets if this thread is the full length of the cylinder.
        It defaults to true.
        """
        return _fusion.ThreadFeatureInput__get_isFullLength(self)

    def _set_isFullLength(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this thread is the full length of the cylinder.
        It defaults to true.
        """
        return _fusion.ThreadFeatureInput__set_isFullLength(self, value)

    def _get_threadLength(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Gets and sets the thread length. 
        It is only used in the case where the isFullLength property is false.
        """
        return _fusion.ThreadFeatureInput__get_threadLength(self)

    def _set_threadLength(self, value: "ValueInput") -> "bool":
        r"""
        Gets and sets the thread length. 
        It is only used in the case where the isFullLength property is false.
        """
        return _fusion.ThreadFeatureInput__set_threadLength(self, value)

    def _get_threadOffset(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Gets and sets the thread offset. 
        The offset is the distance along the axis of the cylinder from the edge to the start of the thread.
        It is only used in the case where the isFullLength property is false.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ThreadFeatureInput__get_threadOffset(self)

    def _set_threadOffset(self, value: "ValueInput") -> "bool":
        r"""
        Gets and sets the thread offset. 
        The offset is the distance along the axis of the cylinder from the edge to the start of the thread.
        It is only used in the case where the isFullLength property is false.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ThreadFeatureInput__set_threadOffset(self, value)

    def _get_threadLocation(self) -> "adsk::fusion::ThreadLocations":
        r"""
        Gets and sets where the thread length is measured from.
        This property is only used in the case where the isFullLength property is false.
        """
        return _fusion.ThreadFeatureInput__get_threadLocation(self)

    def _set_threadLocation(self, value: "ThreadLocations") -> "bool":
        r"""
        Gets and sets where the thread length is measured from.
        This property is only used in the case where the isFullLength property is false.
        """
        return _fusion.ThreadFeatureInput__set_threadLocation(self, value)

    def _get_threadInfo(self) -> "adsk::core::Ptr< adsk::fusion::ThreadInfo >":
        r"""Gets and sets the thread data."""
        return _fusion.ThreadFeatureInput__get_threadInfo(self)

    def _set_threadInfo(self, value: "ThreadInfo") -> "bool":
        r"""Gets and sets the thread data."""
        return _fusion.ThreadFeatureInput__set_threadInfo(self, value)

    def _get_isRightHanded(self) -> "bool":
        r"""
        Gets and sets if the thread is right or left-handed thread. A value of true indicates a right-handed thread.
        It defaults to true.
        """
        return _fusion.ThreadFeatureInput__get_isRightHanded(self)

    def _set_isRightHanded(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the thread is right or left-handed thread. A value of true indicates a right-handed thread.
        It defaults to true.
        """
        return _fusion.ThreadFeatureInput__set_isRightHanded(self, value)

    def _get_inputCylindricalFaces(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""Gets and sets the cylindrical input faces."""
        return _fusion.ThreadFeatureInput__get_inputCylindricalFaces(self)

    def _set_inputCylindricalFaces(self, value: "ObjectCollection") -> "bool":
        r"""Gets and sets the cylindrical input faces."""
        return _fusion.ThreadFeatureInput__set_inputCylindricalFaces(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ThreadFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ThreadFeatureInput__set_targetBaseFeature(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.ThreadFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ThreadFeatureInput__get_isValid(self)

# Register ThreadFeatureInput in _fusion:
_fusion.ThreadFeatureInput_swigregister(ThreadFeatureInput)

def ThreadFeatureInput_classType() -> "char const *":
    return _fusion.ThreadFeatureInput_classType()


ThreadFeatureInput.inputCylindricalFace = property(ThreadFeatureInput._get_inputCylindricalFace, ThreadFeatureInput._set_inputCylindricalFace, doc="Gets and sets the threaded face. In the case where there are multiple faces, only the first one is returned.\nSetting this results in a thread being applied to only a single face.\nIt is recommended that you use the inputCylindricalfaces property in order to have full access to the collection of faces\nto be threaded.")


ThreadFeatureInput.isModeled = property(ThreadFeatureInput._get_isModeled, ThreadFeatureInput._set_isModeled, doc="Gets and sets if the thread is physical or cosmetic thread. A value of true indicates a physical thread.\nIt defaults to false.")


ThreadFeatureInput.isFullLength = property(ThreadFeatureInput._get_isFullLength, ThreadFeatureInput._set_isFullLength, doc="Gets and sets if this thread is the full length of the cylinder.\nIt defaults to true.")


ThreadFeatureInput.threadLength = property(ThreadFeatureInput._get_threadLength, ThreadFeatureInput._set_threadLength, doc="Gets and sets the thread length.\nIt is only used in the case where the isFullLength property is false.")


ThreadFeatureInput.threadOffset = property(ThreadFeatureInput._get_threadOffset, ThreadFeatureInput._set_threadOffset, doc="Gets and sets the thread offset.\nThe offset is the distance along the axis of the cylinder from the edge to the start of the thread.\nIt is only used in the case where the isFullLength property is false.\nReturns nothing in the case where the feature is non-parametric.")


ThreadFeatureInput.threadLocation = property(ThreadFeatureInput._get_threadLocation, ThreadFeatureInput._set_threadLocation, doc="Gets and sets where the thread length is measured from.\nThis property is only used in the case where the isFullLength property is false.")


ThreadFeatureInput.threadInfo = property(ThreadFeatureInput._get_threadInfo, ThreadFeatureInput._set_threadInfo, doc="Gets and sets the thread data.")


ThreadFeatureInput.isRightHanded = property(ThreadFeatureInput._get_isRightHanded, ThreadFeatureInput._set_isRightHanded, doc="Gets and sets if the thread is right or left-handed thread. A value of true indicates a right-handed thread.\nIt defaults to true.")


ThreadFeatureInput.inputCylindricalFaces = property(ThreadFeatureInput._get_inputCylindricalFaces, ThreadFeatureInput._set_inputCylindricalFaces, doc="Gets and sets the cylindrical input faces.")


ThreadFeatureInput.targetBaseFeature = property(ThreadFeatureInput._get_targetBaseFeature, ThreadFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


ThreadFeatureInput.cast = lambda arg: arg if isinstance(arg, ThreadFeatureInput) else None

class ThreadFeatures(Base):
    r"""
    Collection that provides access to all of the existing thread features in a component
    and supports the ability to create new thread features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ThreadFeatures *":
        return _fusion.ThreadFeatures___deref__(self)

    def __eq__(self, rhs: "ThreadFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ThreadFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "ThreadFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ThreadFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.ThreadFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::ThreadFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.ThreadFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ThreadFeatures_classType()
    __swig_destroy__ = _fusion.delete_ThreadFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::ThreadFeature >":
        r"""
        Function that returns the specified thread feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ThreadFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of thread features in the collection."""
        return _fusion.ThreadFeatures__get_count(self)

    def _get_threadDataQuery(self) -> "adsk::core::Ptr< adsk::fusion::ThreadDataQuery >":
        r"""
        Property that returns the ThreadDataQuery object. When creating a thread, the type and size of the thread
        is specified by referencing thread information defined in one of the XML files in the ThreadData folder.
        The ThreadDataQuery is an object that supports methods to query the existing threads defined in these files.
        """
        return _fusion.ThreadFeatures__get_threadDataQuery(self)

    def createInput(self, inputCylindricalFaces: "Base", threadInfo: "ThreadInfo") -> "adsk::core::Ptr< adsk::fusion::ThreadFeatureInput >":
        r"""
        Creates a ThreadFeatureInput object. This object is the API equivalent of the Thread feature dialog. It collects
        the required input and once fully defined you can pass this object to the ThreadFeatures.add method to create
        the thread feature. 
        inputCylindricalFaces : A single cylindrical BRep face or a collection of cylindrical BRep faces to thread.
        A collection of faces must all be from either holes (for internal threading) or all from cylinders (for external threading).
        Both internal and external threads cannot be created in the same feature.
        The faces in a collection can come from different bodies or components. 
        threadInfo : The ThreadInfo object that defines the type and size of the thread to create. When creating a thread, the type and size 
        of the thread is specified by referencing thread information defined in one of the XML files in the ThreadData folder within
        the Fusion 360 install folder. You can use the ThreadDataQuery object to query these XML files to find the specific thread you 
        want to create. The ThreadDataQuery object can be obtained by using the ThreadFeatures.threadDataQuery property. You then use 
        this information to create a ThreadInfo object using the ThreadFeatures.createThreadInfo method. 
        Returns the newly created ThreadFeatureInput object or null/None if the creation failed.
        """
        return _fusion.ThreadFeatures_createInput(self, inputCylindricalFaces, threadInfo)

    def createThreadInfo(self, isInternal: "bool", threadType: "std::string const &", threadDesignation: "std::string const &", threadClass: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::ThreadInfo >":
        r"""
        Method that creates a new ThreadInfo object that can be used in creating thread features.
        The ThreadInfo object that defines the type and size of the thread to create. When creating a thread, the type and size 
        of the thread is specified by referencing thread information defined in one of the XML files in the ThreadData folder within
        the Fusion 360 install folder. You can use the ThreadDataQuery object to query these XML files to find the specific thread you 
        want to create. The ThreadDataQuery object can be obtained by using the ThreadFeatures.threadDataQuery property. 
        isInternal : Input Boolean that indicates if the thread is an internal or external thread. A value of true indicates an internal thread. 
        threadType : Input string that defines the thread type. 
        threadDesignation : Input string that contains the thread designation.
        This is input as the full thread designation that will be used in a drawing for the thread callout.
        The nominal size and pitch information are extracted from the designation. 
        threadClass : Input string that defines the thread class. 
        Returns the newly created ThreadInfo object or null if the creation failed.
        """
        return _fusion.ThreadFeatures_createThreadInfo(self, isInternal, threadType, threadDesignation, threadClass)

    def add(self, input: "ThreadFeatureInput") -> "adsk::core::Ptr< adsk::fusion::ThreadFeature >":
        r"""
        Creates a new thread feature. 
        input : A ThreadFeatureInput object that defines the desired thread. Use the createInput 
        method to create a new ThreadFeatureInput object and then use methods on it 
        (the ThreadFeatureInput object) to define the thread. 
        Returns the newly created ThreadFeature object or null if the creation failed.
        """
        return _fusion.ThreadFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::ThreadFeature >":
        r"""
        Function that returns the specified thread feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.ThreadFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.ThreadFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ThreadFeatures__get_isValid(self)

# Register ThreadFeatures in _fusion:
_fusion.ThreadFeatures_swigregister(ThreadFeatures)

def ThreadFeatures_classType() -> "char const *":
    return _fusion.ThreadFeatures_classType()


ThreadFeatures.count = property(ThreadFeatures._get_count, doc="The number of thread features in the collection.")


ThreadFeatures.threadDataQuery = property(ThreadFeatures._get_threadDataQuery, doc="Property that returns the ThreadDataQuery object. When creating a thread, the type and size of the thread\nis specified by referencing thread information defined in one of the XML files in the ThreadData folder.\nThe ThreadDataQuery is an object that supports methods to query the existing threads defined in these files.")


ThreadFeatures.cast = lambda arg: arg if isinstance(arg, ThreadFeatures) else None

class ThreadInfo(Base):
    r"""
    This class defines the methods and properties that define the type and size of a thread. This object is used
    to create new thread features and to query and edit existing thread features. A new ThreadInfo object is created
    by using the ThreadFeatures.createThreadInfo method. If the ThreadInfo object is obtained from an existing thread 
    feature, modifying properties on the ThreadInfo object will modify the feature.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ThreadInfo *":
        return _fusion.ThreadInfo___deref__(self)

    def __eq__(self, rhs: "ThreadInfo") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ThreadInfo___eq__(self, rhs)


    def __ne__(self, rhs: "ThreadInfo") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ThreadInfo___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ThreadInfo_classType()
    __swig_destroy__ = _fusion.delete_ThreadInfo

    def _get_threadType(self) -> "std::string":
        r"""Returns and sets the string that defines the thread type."""
        return _fusion.ThreadInfo__get_threadType(self)

    def _set_threadType(self, value: "std::string const &") -> "bool":
        r"""Returns and sets the string that defines the thread type."""
        return _fusion.ThreadInfo__set_threadType(self, value)

    def _get_threadSize(self) -> "std::string":
        r"""Returns the string that defines the thread size. This is"""
        return _fusion.ThreadInfo__get_threadSize(self)

    def _get_threadDesignation(self) -> "std::string":
        r"""Returns and sets the string that defines the thread designation."""
        return _fusion.ThreadInfo__get_threadDesignation(self)

    def _set_threadDesignation(self, value: "std::string const &") -> "bool":
        r"""Returns and sets the string that defines the thread designation."""
        return _fusion.ThreadInfo__set_threadDesignation(self, value)

    def _get_threadClass(self) -> "std::string":
        r"""Returns and sets the string that defines the thread class."""
        return _fusion.ThreadInfo__get_threadClass(self)

    def _set_threadClass(self, value: "std::string const &") -> "bool":
        r"""Returns and sets the string that defines the thread class."""
        return _fusion.ThreadInfo__set_threadClass(self, value)

    def _get_isInternal(self) -> "bool":
        r"""
        Returns and sets if the thread is an internal or external thread. A value of true indicates an internal thread.
        It defaults to true.
        """
        return _fusion.ThreadInfo__get_isInternal(self)

    def _set_isInternal(self, value: "bool") -> "bool":
        r"""
        Returns and sets if the thread is an internal or external thread. A value of true indicates an internal thread.
        It defaults to true.
        """
        return _fusion.ThreadInfo__set_isInternal(self, value)

    def _get_threadAngle(self) -> "double":
        r"""Returns the value that defines the thread angle. The units are degrees."""
        return _fusion.ThreadInfo__get_threadAngle(self)

    def _get_threadPitch(self) -> "double":
        r"""Returns the value that defines the thread pitch. The units are centimeters."""
        return _fusion.ThreadInfo__get_threadPitch(self)

    def _get_majorDiameter(self) -> "double":
        r"""Returns the value that defines the major diameter. The units are centimeters."""
        return _fusion.ThreadInfo__get_majorDiameter(self)

    def _get_minorDiameter(self) -> "double":
        r"""Returns the value that defines the minor diameter. The units are centimeters."""
        return _fusion.ThreadInfo__get_minorDiameter(self)

    def _get_pitchDiameter(self) -> "double":
        r"""Returns the value that defines the pitch diameter. The units are centimeters."""
        return _fusion.ThreadInfo__get_pitchDiameter(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ThreadInfo__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ThreadInfo__get_isValid(self)

# Register ThreadInfo in _fusion:
_fusion.ThreadInfo_swigregister(ThreadInfo)

def ThreadInfo_classType() -> "char const *":
    return _fusion.ThreadInfo_classType()


ThreadInfo.threadType = property(ThreadInfo._get_threadType, ThreadInfo._set_threadType, doc="Returns and sets the string that defines the thread type.")


ThreadInfo.threadSize = property(ThreadInfo._get_threadSize, doc="Returns the string that defines the thread size. This is")


ThreadInfo.threadDesignation = property(ThreadInfo._get_threadDesignation, ThreadInfo._set_threadDesignation, doc="Returns and sets the string that defines the thread designation.")


ThreadInfo.threadClass = property(ThreadInfo._get_threadClass, ThreadInfo._set_threadClass, doc="Returns and sets the string that defines the thread class.")


ThreadInfo.isInternal = property(ThreadInfo._get_isInternal, ThreadInfo._set_isInternal, doc="Returns and sets if the thread is an internal or external thread. A value of true indicates an internal thread.\nIt defaults to true.")


ThreadInfo.threadAngle = property(ThreadInfo._get_threadAngle, doc="Returns the value that defines the thread angle. The units are degrees.")


ThreadInfo.threadPitch = property(ThreadInfo._get_threadPitch, doc="Returns the value that defines the thread pitch. The units are centimeters.")


ThreadInfo.majorDiameter = property(ThreadInfo._get_majorDiameter, doc="Returns the value that defines the major diameter. The units are centimeters.")


ThreadInfo.minorDiameter = property(ThreadInfo._get_minorDiameter, doc="Returns the value that defines the minor diameter. The units are centimeters.")


ThreadInfo.pitchDiameter = property(ThreadInfo._get_pitchDiameter, doc="Returns the value that defines the pitch diameter. The units are centimeters.")


ThreadInfo.cast = lambda arg: arg if isinstance(arg, ThreadInfo) else None

class Timeline(Base):
    r"""A collection of TimelineObjects in a parametric design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::Timeline *":
        return _fusion.Timeline___deref__(self)

    def __eq__(self, rhs: "Timeline") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.Timeline___eq__(self, rhs)


    def __ne__(self, rhs: "Timeline") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.Timeline___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.Timeline___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.Timeline___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.Timeline_classType()
    __swig_destroy__ = _fusion.delete_Timeline

    def moveToBeginning(self) -> "bool":
        r"""
        Moves the marker to the beginning of the timeline. 
        Returns true if the move is successful
        """
        return _fusion.Timeline_moveToBeginning(self)

    def moveToEnd(self) -> "bool":
        r"""
        Moves the marker to the end of the timeline. 
        Returns true if the move is successful
        """
        return _fusion.Timeline_moveToEnd(self)

    def movetoNextStep(self) -> "bool":
        r"""
        Moves the marker to the next step in the timeline. 
        Returns true if the move is successful
        """
        return _fusion.Timeline_movetoNextStep(self)

    def moveToPreviousStep(self) -> "bool":
        r"""
        Moves the marker to the previous step in the timeline. 
        Returns true if the move is successful
        """
        return _fusion.Timeline_moveToPreviousStep(self)

    def play(self) -> "bool":
        r"""
        Plays the timeline beginning at the current position of the marker. 
        Returns true if playing the timeline was successful
        """
        return _fusion.Timeline_play(self)

    def _get_markerPosition(self) -> "int":
        r"""
        Gets and sets the current position of the marker where
        0 is at the beginning of the timeline and the value of Timeline.count is the end of the
        timeline.
        """
        return _fusion.Timeline__get_markerPosition(self)

    def _set_markerPosition(self, value: "int") -> "bool":
        r"""
        Gets and sets the current position of the marker where
        0 is at the beginning of the timeline and the value of Timeline.count is the end of the
        timeline.
        """
        return _fusion.Timeline__set_markerPosition(self, value)

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""
        Function that returns the specified item in the timeline using an index into the collection.
        The items are returned in the order they appear in the timeline. 
        index : The index of the item within the collection to return. The first item in the collection
        has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.Timeline_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of items in the collection."""
        return _fusion.Timeline__get_count(self)

    def _get_timelineGroups(self) -> "adsk::core::Ptr< adsk::fusion::TimelineGroups >":
        r"""Returns the collection of groups within the timeline."""
        return _fusion.Timeline__get_timelineGroups(self)

    def deleteAllAfterMarker(self) -> "bool":
        r"""
        Deletes all objects in the timeline that are after the current position of the marker. 
        Returns true if successful.
        """
        return _fusion.Timeline_deleteAllAfterMarker(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.Timeline__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.Timeline__get_isValid(self)

# Register Timeline in _fusion:
_fusion.Timeline_swigregister(Timeline)

def Timeline_classType() -> "char const *":
    return _fusion.Timeline_classType()


Timeline.markerPosition = property(Timeline._get_markerPosition, Timeline._set_markerPosition, doc="Gets and sets the current position of the marker where\n0 is at the beginning of the timeline and the value of Timeline.count is the end of the\ntimeline.")


Timeline.count = property(Timeline._get_count, doc="Returns the number of items in the collection.")


Timeline.timelineGroups = property(Timeline._get_timelineGroups, doc="Returns the collection of groups within the timeline.")


Timeline.cast = lambda arg: arg if isinstance(arg, Timeline) else None

class TimelineGroups(Base):
    r"""
    Provides access to the time line groups within a design and provides 
    methods to create new groups.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::TimelineGroups *":
        return _fusion.TimelineGroups___deref__(self)

    def __eq__(self, rhs: "TimelineGroups") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.TimelineGroups___eq__(self, rhs)


    def __ne__(self, rhs: "TimelineGroups") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.TimelineGroups___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.TimelineGroups___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::TimelineGroup >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.TimelineGroups___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.TimelineGroups_classType()
    __swig_destroy__ = _fusion.delete_TimelineGroups

    def add(self, startIndex: "int", endIndex: "int") -> "adsk::core::Ptr< adsk::fusion::TimelineGroup >":
        r"""
        Creates a new group within the timeline. The sequential set of items defined
        by the start and end indices will be included in the group. A group cannot contains
        another group so none of the items being grouped can be a group of this will fail. 
        startIndex : The index of the first item in the timeline that will be added to the group. 
        endIndex : The index of the last item in the timeline that will be added to the group. 
        Returns the created TimelineGroup object or null in the case of failure.
        """
        return _fusion.TimelineGroups_add(self, startIndex, endIndex)

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::TimelineGroup >":
        r"""
        Function that returns the specified timeline group using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.TimelineGroups_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of items in the collection."""
        return _fusion.TimelineGroups__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.TimelineGroups__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.TimelineGroups__get_isValid(self)

# Register TimelineGroups in _fusion:
_fusion.TimelineGroups_swigregister(TimelineGroups)

def TimelineGroups_classType() -> "char const *":
    return _fusion.TimelineGroups_classType()


TimelineGroups.count = property(TimelineGroups._get_count, doc="Returns the number of items in the collection.")


TimelineGroups.cast = lambda arg: arg if isinstance(arg, TimelineGroups) else None

class TimelineObject(Base):
    r"""Represents an object in the timeline."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::TimelineObject *":
        return _fusion.TimelineObject___deref__(self)

    def __eq__(self, rhs: "TimelineObject") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.TimelineObject___eq__(self, rhs)


    def __ne__(self, rhs: "TimelineObject") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.TimelineObject___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.TimelineObject_classType()
    __swig_destroy__ = _fusion.delete_TimelineObject

    def _get_isSuppressed(self) -> "bool":
        r"""Gets and sets if this object is suppressed."""
        return _fusion.TimelineObject__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""Gets and sets if this object is suppressed."""
        return _fusion.TimelineObject__set_isSuppressed(self, value)

    def _get_parentGroup(self) -> "adsk::core::Ptr< adsk::fusion::TimelineGroup >":
        r"""
        Returns the parent group, if this object is part of a group.
        Returns null if this object is not part of a group.
        """
        return _fusion.TimelineObject__get_parentGroup(self)

    def _get_index(self) -> "int":
        r"""
        Returns the position of this item within the timeline where
        the first item has an index of 0.
        This property can return -1 in the two cases where this object
        is not currently represented in the timeline. The two cases are:
        1. When this is a TimelineGroup object and the group is expanded.
        2. When this object is part of a group and the group is collapsed.
        """
        return _fusion.TimelineObject__get_index(self)

    def _get_isRolledBack(self) -> "bool":
        r"""
        Indicates if this item is currently not being computed
        because it has been rolled back.
        If this is a timelineGroup object and the group is expanded
        the value of this property should be ignored.
        """
        return _fusion.TimelineObject__get_isRolledBack(self)

    def rollTo(self, rollBefore: "bool") -> "bool":
        r"""
        Rolls the timeline by repositioning the marker to either before or after this object.
        This method will fail if this is a timelineGroup object and the group is expanded. 
        rollBefore : Set rollBefore to true to reposition the marker before this object or to false to
        reposition the marker after this object 
        Returns true if the move was successful
        """
        return _fusion.TimelineObject_rollTo(self, rollBefore)

    def _get_entity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the entity associated with this timeline object.
        Edit operations can be performed by getting the object
        representing the associated entity and using the methods
        and properties on that entity to make changes.
        Returns null if this is a TimelineGroup object
        """
        return _fusion.TimelineObject__get_entity(self)

    def canReorder(self, beforeIndex: "int"=-1) -> "bool":
        r"""
        Checks to see if this object can be reordered to the specified position.
        The default value of -1 indicates the end of the timeline.
        This method will fail if this is a timelineGroup object and the group is expanded. 
        beforeIndex : The index number of the position in the timeline to check 
        Returns true if the object can be reordered to the specified position
        """
        return _fusion.TimelineObject_canReorder(self, beforeIndex)

    def reorder(self, beforeIndex: "int"=-1) -> "bool":
        r"""
        Reorders this object to the position specified.
        The default value of -1 indicates the end of the timeline. 
        beforeIndex : The index number of the position in the timeline to place this object before 
        Returns true if the reorder operation was successful
        This method will fail and return false if this is a timelineGroup object and the 
        group is expanded.
        """
        return _fusion.TimelineObject_reorder(self, beforeIndex)

    def _get_isGroup(self) -> "bool":
        r"""
        Indicates if this TimelineObject represents a group. If True you can
        operate on this object as a TimelineGroup object.
        """
        return _fusion.TimelineObject__get_isGroup(self)

    def _get_name(self) -> "std::string":
        r"""
        Gets and sets the name of this timeline object. This name is shared by the object
        the timeline object represents. For example, if the TimelineObject represents a Sketch
        and you change the name using the TimelineObject, the name of the sketch in the browser
        is also changed. The reverse is also true. Setting the name of an object; sketch, feature
        construction geometry, etc, will also change the name of the associated node in the timeline.
        """
        return _fusion.TimelineObject__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the name of this timeline object. This name is shared by the object
        the timeline object represents. For example, if the TimelineObject represents a Sketch
        and you change the name using the TimelineObject, the name of the sketch in the browser
        is also changed. The reverse is also true. Setting the name of an object; sketch, feature
        construction geometry, etc, will also change the name of the associated node in the timeline.
        """
        return _fusion.TimelineObject__set_name(self, value)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the object associated with this TimelineObject."""
        return _fusion.TimelineObject__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.TimelineObject__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.TimelineObject__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.TimelineObject__get_isValid(self)

# Register TimelineObject in _fusion:
_fusion.TimelineObject_swigregister(TimelineObject)

def TimelineObject_classType() -> "char const *":
    return _fusion.TimelineObject_classType()


TimelineObject.isSuppressed = property(TimelineObject._get_isSuppressed, TimelineObject._set_isSuppressed, doc="Gets and sets if this object is suppressed.")


TimelineObject.parentGroup = property(TimelineObject._get_parentGroup, doc="Returns the parent group, if this object is part of a group.\nReturns null if this object is not part of a group.")


TimelineObject.index = property(TimelineObject._get_index, doc="Returns the position of this item within the timeline where\nthe first item has an index of 0.\nThis property can return -1 in the two cases where this object\nis not currently represented in the timeline. The two cases are:\n1. When this is a TimelineGroup object and the group is expanded.\n2. When this object is part of a group and the group is collapsed.")


TimelineObject.isRolledBack = property(TimelineObject._get_isRolledBack, doc="Indicates if this item is currently not being computed\nbecause it has been rolled back.\nIf this is a timelineGroup object and the group is expanded\nthe value of this property should be ignored.")


TimelineObject.entity = property(TimelineObject._get_entity, doc="Returns the entity associated with this timeline object.\nEdit operations can be performed by getting the object\nrepresenting the associated entity and using the methods\nand properties on that entity to make changes.\nReturns null if this is a TimelineGroup object")


TimelineObject.isGroup = property(TimelineObject._get_isGroup, doc="Indicates if this TimelineObject represents a group. If True you can\noperate on this object as a TimelineGroup object.")


TimelineObject.name = property(TimelineObject._get_name, TimelineObject._set_name, doc="Gets and sets the name of this timeline object. This name is shared by the object\nthe timeline object represents. For example, if the TimelineObject represents a Sketch\nand you change the name using the TimelineObject, the name of the sketch in the browser\nis also changed. The reverse is also true. Setting the name of an object; sketch, feature\nconstruction geometry, etc, will also change the name of the associated node in the timeline.")


TimelineObject.healthState = property(TimelineObject._get_healthState, doc="Returns the current health state of the object associated with this TimelineObject.")


TimelineObject.errorOrWarningMessage = property(TimelineObject._get_errorOrWarningMessage, doc="Returns the error or warning message in the case where the healthState property returns either\nWarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.")


TimelineObject.cast = lambda arg: arg if isinstance(arg, TimelineObject) else None

class TorusFeatures(Base):
    r"""Collection that provides access to all of the existing torus features in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::TorusFeatures *":
        return _fusion.TorusFeatures___deref__(self)

    def __eq__(self, rhs: "TorusFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.TorusFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "TorusFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.TorusFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.TorusFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::TorusFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.TorusFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.TorusFeatures_classType()
    __swig_destroy__ = _fusion.delete_TorusFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::TorusFeature >":
        r"""
        Function that returns the specified torus feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.TorusFeatures_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::TorusFeature >":
        r"""
        Function that returns the specified torus feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.TorusFeatures_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of torus features in the collection."""
        return _fusion.TorusFeatures__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.TorusFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.TorusFeatures__get_isValid(self)

# Register TorusFeatures in _fusion:
_fusion.TorusFeatures_swigregister(TorusFeatures)

def TorusFeatures_classType() -> "char const *":
    return _fusion.TorusFeatures_classType()


TorusFeatures.count = property(TorusFeatures._get_count, doc="The number of torus features in the collection.")


TorusFeatures.cast = lambda arg: arg if isinstance(arg, TorusFeatures) else None

class TriangleMesh(Base):
    r"""
    The TriangleMesh object represents all of the data defining
    a triangular mesh.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::TriangleMesh *":
        return _fusion.TriangleMesh___deref__(self)

    def __eq__(self, rhs: "TriangleMesh") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.TriangleMesh___eq__(self, rhs)


    def __ne__(self, rhs: "TriangleMesh") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.TriangleMesh___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.TriangleMesh_classType()
    __swig_destroy__ = _fusion.delete_TriangleMesh

    def _get_nodeCount(self) -> "int":
        r"""Returns the total number of nodes in the mesh."""
        return _fusion.TriangleMesh__get_nodeCount(self)

    def _get_nodeCoordinatesAsDouble(self) -> "std::vector< double,std::allocator< double > >":
        r"""
        Returns the node coordinates as an array of doubles where
        they are the x, y, z components of each coordinate.
        """
        return _fusion.TriangleMesh__get_nodeCoordinatesAsDouble(self)

    def _get_nodeCoordinatesAsFloat(self) -> "std::vector< float,std::allocator< float > >":
        r"""
        Returns the node coordinates as an array of floats where
        they are the x, y, z components of each coordinate.
        """
        return _fusion.TriangleMesh__get_nodeCoordinatesAsFloat(self)

    def _get_nodeCoordinates(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D >,std::allocator< adsk::core::Ptr< adsk::core::Point3D > > >":
        r"""Returns the node coordinates as an array of Point3D objects."""
        return _fusion.TriangleMesh__get_nodeCoordinates(self)

    def _get_triangleCount(self) -> "int":
        r"""Returns the number of triangles in the mesh."""
        return _fusion.TriangleMesh__get_triangleCount(self)

    def _get_normalVectorsAsDouble(self) -> "std::vector< double,std::allocator< double > >":
        r"""
        Returns the normal vectors of the mesh where there is a normal
        vector at each node. The normals are returned as an array
        of doubles where they are the x, y, z components of each vector.
        """
        return _fusion.TriangleMesh__get_normalVectorsAsDouble(self)

    def _get_normalVectorsAsFloat(self) -> "std::vector< float,std::allocator< float > >":
        r"""
        Returns the normal vectors of the mesh where there is a normal
        vector at each node. The normals are returned as an array
        of floats where they are the x, y, z components of each vector.
        """
        return _fusion.TriangleMesh__get_normalVectorsAsFloat(self)

    def _get_normalVectors(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D >,std::allocator< adsk::core::Ptr< adsk::core::Vector3D > > >":
        r"""
        Returns the normal vectors of the mesh where there is a normal
        vector at each node. The normals are returned as an array
        of Vector3D objects.
        """
        return _fusion.TriangleMesh__get_normalVectors(self)

    def _get_nodeIndices(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        Returns an array of indices that define which nodes are used
        for each triangle. This is used to look-up the coordinates in the
        NodeCoordinates array to get the three coordinates of each triangle.
        """
        return _fusion.TriangleMesh__get_nodeIndices(self)

    def _get_textureCoordinatesAsDouble(self) -> "std::vector< double,std::allocator< double > >":
        r"""
        Returns the texture coordinates used when mapping a texture to
        this face. The coordinates are returned as an array of
        doubles where they are the u and v components of each
        coordinate as defined in parametric space. There is a texture
        coordinate for each vertex in the face mesh.
        """
        return _fusion.TriangleMesh__get_textureCoordinatesAsDouble(self)

    def _get_textureCoordinatesAsFloat(self) -> "std::vector< float,std::allocator< float > >":
        r"""
        Returns the texture coordinates used when mapping a texture to
        this face. The coordinates are returned as an array of
        floats where they are the u and v components of each
        coordinate as defined in parametric space. There is a texture
        coordinate for each vertex in the face mesh.
        """
        return _fusion.TriangleMesh__get_textureCoordinatesAsFloat(self)

    def _get_textureCoordinates(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D >,std::allocator< adsk::core::Ptr< adsk::core::Point2D > > >":
        r"""
        Returns the texture coordinates used when mapping a texture to
        this face. The coordinates are returned as an array of
        Point2D objects where the x and y properties of the point are
        u and v coordinates as defined in parametric space. There is 
        a texture coordinate for each vertex in the face mesh.
        """
        return _fusion.TriangleMesh__get_textureCoordinates(self)

    def _get_surfaceTolerance(self) -> "double":
        r"""
        Returns the surface tolerance that was used to generate this mesh.
        This is most useful when using display meshes that have already
        been calculated.
        """
        return _fusion.TriangleMesh__get_surfaceTolerance(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.TriangleMesh__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.TriangleMesh__get_isValid(self)

# Register TriangleMesh in _fusion:
_fusion.TriangleMesh_swigregister(TriangleMesh)

def TriangleMesh_classType() -> "char const *":
    return _fusion.TriangleMesh_classType()


TriangleMesh.nodeCount = property(TriangleMesh._get_nodeCount, doc="Returns the total number of nodes in the mesh.")


TriangleMesh.nodeCoordinatesAsDouble = property(TriangleMesh._get_nodeCoordinatesAsDouble, doc="Returns the node coordinates as an array of doubles where\nthey are the x, y, z components of each coordinate.")


TriangleMesh.nodeCoordinatesAsFloat = property(TriangleMesh._get_nodeCoordinatesAsFloat, doc="Returns the node coordinates as an array of floats where\nthey are the x, y, z components of each coordinate.")


TriangleMesh.nodeCoordinates = property(TriangleMesh._get_nodeCoordinates, doc="Returns the node coordinates as an array of Point3D objects.")


TriangleMesh.triangleCount = property(TriangleMesh._get_triangleCount, doc="Returns the number of triangles in the mesh.")


TriangleMesh.normalVectorsAsDouble = property(TriangleMesh._get_normalVectorsAsDouble, doc="Returns the normal vectors of the mesh where there is a normal\nvector at each node. The normals are returned as an array\nof doubles where they are the x, y, z components of each vector.")


TriangleMesh.normalVectorsAsFloat = property(TriangleMesh._get_normalVectorsAsFloat, doc="Returns the normal vectors of the mesh where there is a normal\nvector at each node. The normals are returned as an array\nof floats where they are the x, y, z components of each vector.")


TriangleMesh.normalVectors = property(TriangleMesh._get_normalVectors, doc="Returns the normal vectors of the mesh where there is a normal\nvector at each node. The normals are returned as an array\nof Vector3D objects.")


TriangleMesh.nodeIndices = property(TriangleMesh._get_nodeIndices, doc="Returns an array of indices that define which nodes are used\nfor each triangle. This is used to look-up the coordinates in the\nNodeCoordinates array to get the three coordinates of each triangle.")


TriangleMesh.textureCoordinatesAsDouble = property(TriangleMesh._get_textureCoordinatesAsDouble, doc="Returns the texture coordinates used when mapping a texture to\nthis face. The coordinates are returned as an array of\ndoubles where they are the u and v components of each\ncoordinate as defined in parametric space. There is a texture\ncoordinate for each vertex in the face mesh.")


TriangleMesh.textureCoordinatesAsFloat = property(TriangleMesh._get_textureCoordinatesAsFloat, doc="Returns the texture coordinates used when mapping a texture to\nthis face. The coordinates are returned as an array of\nfloats where they are the u and v components of each\ncoordinate as defined in parametric space. There is a texture\ncoordinate for each vertex in the face mesh.")


TriangleMesh.textureCoordinates = property(TriangleMesh._get_textureCoordinates, doc="Returns the texture coordinates used when mapping a texture to\nthis face. The coordinates are returned as an array of\nPoint2D objects where the x and y properties of the point are\nu and v coordinates as defined in parametric space. There is\na texture coordinate for each vertex in the face mesh.")


TriangleMesh.surfaceTolerance = property(TriangleMesh._get_surfaceTolerance, doc="Returns the surface tolerance that was used to generate this mesh.\nThis is most useful when using display meshes that have already\nbeen calculated.")


TriangleMesh.cast = lambda arg: arg if isinstance(arg, TriangleMesh) else None

class TriangleMeshCalculator(Base):
    r"""Used to calculate new meshes for a B-Rep or T-Spline using defined criteria."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::TriangleMeshCalculator *":
        return _fusion.TriangleMeshCalculator___deref__(self)

    def __eq__(self, rhs: "TriangleMeshCalculator") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.TriangleMeshCalculator___eq__(self, rhs)


    def __ne__(self, rhs: "TriangleMeshCalculator") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.TriangleMeshCalculator___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.TriangleMeshCalculator_classType()
    __swig_destroy__ = _fusion.delete_TriangleMeshCalculator

    def setQuality(self, triangleMeshQuality: "TriangleMeshQualityOptions") -> "bool":
        r"""
        This is a simplified way to set the various settings that control the resulting mesh. When used it automatically 
        adjusts all of the property values appropriately. It does this for the given geometry by computing its bounding 
        box diameter. Then the surface tolerance is calculated as shown below where the meshLOD is the 'Level of Detail' and
        is described in more detail below. The diameter is the bounding box diameter.
        double nodeApproximateSize = std::pow(2.0, meshLOD); 
        double fracTol = 1.0 / nodeApproximateSize; 
        surfaceTolerance = fracTol * diameter; 
        triangleMeshQuality : The mesh quality is specified by using an item from the enum list where the following items result
        in a corresponding mesh LOD that's used in the equation above.
        LowQualityTriangleMesh: 8 
        NormalQualityTriangleMesh: 11
        HighQualityTriangleMesh: 13 
        VeryHighQualityTriangleMesh: 15 
        Returns true if setting the quality was successful.
        """
        return _fusion.TriangleMeshCalculator_setQuality(self, triangleMeshQuality)

    def _get_surfaceTolerance(self) -> "double":
        r"""
        Specifies the maximum distance that the mesh can deviate from the smooth surface. 
        The value is in centimeters. Smaller values can result in a much greater number 
        of facets being returned and will require more processing time to calculate.
        """
        return _fusion.TriangleMeshCalculator__get_surfaceTolerance(self)

    def _set_surfaceTolerance(self, value: "double") -> "bool":
        r"""
        Specifies the maximum distance that the mesh can deviate from the smooth surface. 
        The value is in centimeters. Smaller values can result in a much greater number 
        of facets being returned and will require more processing time to calculate.
        """
        return _fusion.TriangleMeshCalculator__set_surfaceTolerance(self, value)

    def _get_maxSideLength(self) -> "double":
        r"""
        Specifies the maximum side of any triangle in the mesh. A value of 0 (the default) 
        indicates that no maximum length is specified. The value is specified in centimeters.
        """
        return _fusion.TriangleMeshCalculator__get_maxSideLength(self)

    def _set_maxSideLength(self, value: "double") -> "bool":
        r"""
        Specifies the maximum side of any triangle in the mesh. A value of 0 (the default) 
        indicates that no maximum length is specified. The value is specified in centimeters.
        """
        return _fusion.TriangleMeshCalculator__set_maxSideLength(self, value)

    def _get_maxAspectRatio(self) -> "double":
        r"""
        Specifies the maximum length to height ratio that a triangle can have. 
        This helps to avoid long skinny triangles. A value of 0 (the default) 
        indicates that no maximum aspect ratio is specified.
        """
        return _fusion.TriangleMeshCalculator__get_maxAspectRatio(self)

    def _set_maxAspectRatio(self, value: "double") -> "bool":
        r"""
        Specifies the maximum length to height ratio that a triangle can have. 
        This helps to avoid long skinny triangles. A value of 0 (the default) 
        indicates that no maximum aspect ratio is specified.
        """
        return _fusion.TriangleMeshCalculator__set_maxAspectRatio(self, value)

    def _get_maxNormalDeviation(self) -> "double":
        r"""
        Specifies the maximum deviation between adjacent vertex normals. 
        This value is the maximum angle allowed between normals and is 
        specified in radians. A value of 0 (the default) indicates that no normal deviation is specified.
        """
        return _fusion.TriangleMeshCalculator__get_maxNormalDeviation(self)

    def _set_maxNormalDeviation(self, value: "double") -> "bool":
        r"""
        Specifies the maximum deviation between adjacent vertex normals. 
        This value is the maximum angle allowed between normals and is 
        specified in radians. A value of 0 (the default) indicates that no normal deviation is specified.
        """
        return _fusion.TriangleMeshCalculator__set_maxNormalDeviation(self, value)

    def calculate(self) -> "adsk::core::Ptr< adsk::fusion::TriangleMesh >":
        r"""
        Calculates a new triangle mesh based on the current settings. 
        Returns the new TriangleMesh object or null in the case where the calculation failed.
        """
        return _fusion.TriangleMeshCalculator_calculate(self)

    def _get_parentMeshManager(self) -> "adsk::core::Ptr< adsk::fusion::MeshManager >":
        r"""Returns the parent MeshManager object."""
        return _fusion.TriangleMeshCalculator__get_parentMeshManager(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.TriangleMeshCalculator__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.TriangleMeshCalculator__get_isValid(self)

# Register TriangleMeshCalculator in _fusion:
_fusion.TriangleMeshCalculator_swigregister(TriangleMeshCalculator)

def TriangleMeshCalculator_classType() -> "char const *":
    return _fusion.TriangleMeshCalculator_classType()


TriangleMeshCalculator.surfaceTolerance = property(TriangleMeshCalculator._get_surfaceTolerance, TriangleMeshCalculator._set_surfaceTolerance, doc="Specifies the maximum distance that the mesh can deviate from the smooth surface.\nThe value is in centimeters. Smaller values can result in a much greater number\nof facets being returned and will require more processing time to calculate.")


TriangleMeshCalculator.maxSideLength = property(TriangleMeshCalculator._get_maxSideLength, TriangleMeshCalculator._set_maxSideLength, doc="Specifies the maximum side of any triangle in the mesh. A value of 0 (the default)\nindicates that no maximum length is specified. The value is specified in centimeters.")


TriangleMeshCalculator.maxAspectRatio = property(TriangleMeshCalculator._get_maxAspectRatio, TriangleMeshCalculator._set_maxAspectRatio, doc="Specifies the maximum length to height ratio that a triangle can have.\nThis helps to avoid long skinny triangles. A value of 0 (the default)\nindicates that no maximum aspect ratio is specified.")


TriangleMeshCalculator.maxNormalDeviation = property(TriangleMeshCalculator._get_maxNormalDeviation, TriangleMeshCalculator._set_maxNormalDeviation, doc="Specifies the maximum deviation between adjacent vertex normals.\nThis value is the maximum angle allowed between normals and is\nspecified in radians. A value of 0 (the default) indicates that no normal deviation is specified.")


TriangleMeshCalculator.parentMeshManager = property(TriangleMeshCalculator._get_parentMeshManager, doc="Returns the parent MeshManager object.")


TriangleMeshCalculator.cast = lambda arg: arg if isinstance(arg, TriangleMeshCalculator) else None

class TriangleMeshList(Base):
    r"""Provides access to a set of triangle meshes."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::TriangleMeshList *":
        return _fusion.TriangleMeshList___deref__(self)

    def __eq__(self, rhs: "TriangleMeshList") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.TriangleMeshList___eq__(self, rhs)


    def __ne__(self, rhs: "TriangleMeshList") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.TriangleMeshList___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.TriangleMeshList___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::TriangleMesh >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.TriangleMeshList___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.TriangleMeshList_classType()
    __swig_destroy__ = _fusion.delete_TriangleMeshList

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::TriangleMesh >":
        r"""
        Returns the specified triangle meshes. 
        index : The index of the mesh to return where the first item has an index of 0. 
        Returns the specified mesh or null in the case of invalid index.
        """
        return _fusion.TriangleMeshList_item(self, index)

    def _get_bestMesh(self) -> "adsk::core::Ptr< adsk::fusion::TriangleMesh >":
        r"""
        Returns the mesh with the tightest surface tolerance. This can return null
        in the case the list is empty, ie. Count is 0.
        """
        return _fusion.TriangleMeshList__get_bestMesh(self)

    def _get_count(self) -> "size_t":
        r"""Returns the number of meshes in the collection."""
        return _fusion.TriangleMeshList__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.TriangleMeshList__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.TriangleMeshList__get_isValid(self)

# Register TriangleMeshList in _fusion:
_fusion.TriangleMeshList_swigregister(TriangleMeshList)

def TriangleMeshList_classType() -> "char const *":
    return _fusion.TriangleMeshList_classType()


TriangleMeshList.bestMesh = property(TriangleMeshList._get_bestMesh, doc="Returns the mesh with the tightest surface tolerance. This can return null\nin the case the list is empty, ie. Count is 0.")


TriangleMeshList.count = property(TriangleMeshList._get_count, doc="Returns the number of meshes in the collection.")


TriangleMeshList.cast = lambda arg: arg if isinstance(arg, TriangleMeshList) else None

class TrimFeatureInput(Base):
    r"""This class defines the methods and properties that pertain to the definition of a TrimFeatureInput."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::TrimFeatureInput *":
        return _fusion.TrimFeatureInput___deref__(self)

    def __eq__(self, rhs: "TrimFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.TrimFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "TrimFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.TrimFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.TrimFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_TrimFeatureInput

    def _get_bRepCells(self) -> "adsk::core::Ptr< adsk::fusion::BRepCells >":
        r"""
        Returns the collection of the valid cells that have been calculated based on the trim tool.
        Use this collection to specify which cells to trim away.
        """
        return _fusion.TrimFeatureInput__get_bRepCells(self)

    def _get_trimTool(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets and sets the entity (a patch body, B-Rep face, construction plane or sketch curve) that intersects the trim tool"""
        return _fusion.TrimFeatureInput__get_trimTool(self)

    def _set_trimTool(self, value: "Base") -> "bool":
        r"""Gets and sets the entity (a patch body, B-Rep face, construction plane or sketch curve) that intersects the trim tool"""
        return _fusion.TrimFeatureInput__set_trimTool(self, value)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.TrimFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, value: "BaseFeature") -> "bool":
        r"""
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.TrimFeatureInput__set_targetBaseFeature(self, value)

    def cancel(self) -> "bool":
        r"""
        To determine the possible boundaries and allow you to choose which cells to keep, the trim 
        feature does a partial compute when the input object is created. To do this it starts a trim
        feature transaction and completes the transaction when you call the add method. If you don't 
        call the add method it leaves Fusion 360 in a bad state and there will be undo problems and it 
        will possibly crash. If you have created a TrimFeatureInput object and don't want to finish
        the feature creation, you need to call the cancel method on the TrimFeatureInput object to 
        safely abort the current trim feature transaction.
        """
        return _fusion.TrimFeatureInput_cancel(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.TrimFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.TrimFeatureInput__get_isValid(self)

# Register TrimFeatureInput in _fusion:
_fusion.TrimFeatureInput_swigregister(TrimFeatureInput)

def TrimFeatureInput_classType() -> "char const *":
    return _fusion.TrimFeatureInput_classType()


TrimFeatureInput.bRepCells = property(TrimFeatureInput._get_bRepCells, doc="Returns the collection of the valid cells that have been calculated based on the trim tool.\nUse this collection to specify which cells to trim away.")


TrimFeatureInput.trimTool = property(TrimFeatureInput._get_trimTool, TrimFeatureInput._set_trimTool, doc="Gets and sets the entity (a patch body, B-Rep face, construction plane or sketch curve) that intersects the trim tool")


TrimFeatureInput.targetBaseFeature = property(TrimFeatureInput._get_targetBaseFeature, TrimFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")


TrimFeatureInput.cast = lambda arg: arg if isinstance(arg, TrimFeatureInput) else None

class TrimFeatures(Base):
    r"""
    Collection that provides access to all of the existing trim features in a component
    and supports the ability to create new trim features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::TrimFeatures *":
        return _fusion.TrimFeatures___deref__(self)

    def __eq__(self, rhs: "TrimFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.TrimFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "TrimFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.TrimFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.TrimFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::TrimFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.TrimFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.TrimFeatures_classType()
    __swig_destroy__ = _fusion.delete_TrimFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::TrimFeature >":
        r"""
        Function that returns the specified trim feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.TrimFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of trim features in the collection."""
        return _fusion.TrimFeatures__get_count(self)

    def createInput(self, trimTool: "Base") -> "adsk::core::Ptr< adsk::fusion::TrimFeatureInput >":
        r"""
        Creates a TrimFeatureInput object. Use properties and methods on this object
        to define the trim feature you want to create and then use the Add method, passing in 
        the TrimFeatureInput object.
        To determine the possible boundaries and allow you to choose which cells to keep, the trim
        feature does a partial compute when the input object is created. To do this it starts a trim
        feature transaction and completes the transaction when you call the add method. If you don't call
        the add method to finish the transaction it leaves Fusion 360 in a bad state and there will be undo
        problems and possibly a crash. If you have created a TrimFeatureInput object and don't want to 
        finish the feature creation, you need to call the cancel method on the TrimFeatureInput object to 
        safely abort the current boundary fill transaction. 
        trimTool : A patch body, B-Rep face, construction plane or sketch curve that intersects the surface or surfaces to be trimmed 
        Returns the newly created TrimFeatureInput object or null if the creation failed.
        """
        return _fusion.TrimFeatures_createInput(self, trimTool)

    def add(self, input: "TrimFeatureInput") -> "adsk::core::Ptr< adsk::fusion::TrimFeature >":
        r"""
        Creates a new trim feature. 
        input : A TrimFeatureInput object that defines the desired trim feature. Use the createInput 
        method to create a new TrimFeatureInput object and then use methods on it 
        (the TrimFeatureInput object) to define the trim feature. 
        Returns the newly created TrimFeature object or null if the creation failed.
        """
        return _fusion.TrimFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::TrimFeature >":
        r"""
        Function that returns the specified trim feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.TrimFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.TrimFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.TrimFeatures__get_isValid(self)

# Register TrimFeatures in _fusion:
_fusion.TrimFeatures_swigregister(TrimFeatures)

def TrimFeatures_classType() -> "char const *":
    return _fusion.TrimFeatures_classType()


TrimFeatures.count = property(TrimFeatures._get_count, doc="The number of trim features in the collection.")


TrimFeatures.cast = lambda arg: arg if isinstance(arg, TrimFeatures) else None

class TSplineBodies(Base):
    r"""A collection of TSpline bodies."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::TSplineBodies *":
        return _fusion.TSplineBodies___deref__(self)

    def __eq__(self, rhs: "TSplineBodies") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.TSplineBodies___eq__(self, rhs)


    def __ne__(self, rhs: "TSplineBodies") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.TSplineBodies___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.TSplineBodies___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::TSplineBody >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.TSplineBodies___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.TSplineBodies_classType()
    __swig_destroy__ = _fusion.delete_TSplineBodies

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::TSplineBody >":
        r"""
        Function that returns the specified T-Spline body using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.TSplineBodies_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of bodies in the collection."""
        return _fusion.TSplineBodies__get_count(self)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::TSplineBody >":
        r"""
        Returns a TSplineBody by specifying the name of the body as seen in the browser. 
        name : The name of the body, as seen in the browser. This is case sensitive. 
        Returns the specified item or null if a body with that name was not found.
        """
        return _fusion.TSplineBodies_itemByName(self, name)

    def addByTSMFile(self, tsmFilename: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::TSplineBody >":
        r"""
        Creates a new TSplineBody by reading in a TSM file from disk. 
        tsmFilename : The full filename of the TSM file on disk. 
        Returns the newly created TSplineBody if successful or null in the case of failure.
        """
        return _fusion.TSplineBodies_addByTSMFile(self, tsmFilename)

    def addByTSMDescription(self, tsmDescription: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::TSplineBody >":
        r"""
        Creates a new TSplineBody using the T-Spline description provided by the input
        string which contains TSM formatted text. 
        tsmDescription : A string that contains a T-Spline description in TSM form. 
        Returns the newly created TSplineBody if successful or null in the case of failure.
        """
        return _fusion.TSplineBodies_addByTSMDescription(self, tsmDescription)

    def _get_objectType(self) -> "char const *":
        return _fusion.TSplineBodies__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.TSplineBodies__get_isValid(self)

# Register TSplineBodies in _fusion:
_fusion.TSplineBodies_swigregister(TSplineBodies)

def TSplineBodies_classType() -> "char const *":
    return _fusion.TSplineBodies_classType()


TSplineBodies.count = property(TSplineBodies._get_count, doc="The number of bodies in the collection.")


TSplineBodies.cast = lambda arg: arg if isinstance(arg, TSplineBodies) else None

class TSplineBody(Base):
    r"""A TSpline body."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::TSplineBody *":
        return _fusion.TSplineBody___deref__(self)

    def __eq__(self, rhs: "TSplineBody") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.TSplineBody___eq__(self, rhs)


    def __ne__(self, rhs: "TSplineBody") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.TSplineBody___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.TSplineBody_classType()
    __swig_destroy__ = _fusion.delete_TSplineBody

    def _get_name(self) -> "std::string":
        r"""
        Gets and sets the name of the body. If setting this property, there is the side-effect
        that the B-Rep body created from this T-Spline body is also renamed.
        """
        return _fusion.TSplineBody__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the name of the body. If setting this property, there is the side-effect
        that the B-Rep body created from this T-Spline body is also renamed.
        """
        return _fusion.TSplineBody__set_name(self, value)

    def getTSMDescription(self) -> "std::string":
        r"""
        Returns the T-Spline body as a string in the form of a TSM description. 
        Returns the string formatted using the TSM format.
        """
        return _fusion.TSplineBody_getTSMDescription(self)

    def saveAsTSMFile(self, filename: "std::string const &") -> "bool":
        r"""
        Saves the body as a TSM file. 
        filename : The full filename of the file to save the body to. If the file already exists,
        it will be overwritten. 
        Returns true if the file was successfully created.
        """
        return _fusion.TSplineBody_saveAsTSMFile(self, filename)

    def _get_parentFormFeature(self) -> "adsk::core::Ptr< adsk::fusion::FormFeature >":
        r"""Returns the owning form feature."""
        return _fusion.TSplineBody__get_parentFormFeature(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the TSplineBody object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same T-Spline body.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.TSplineBody__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.TSplineBody__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.TSplineBody__get_isValid(self)

# Register TSplineBody in _fusion:
_fusion.TSplineBody_swigregister(TSplineBody)

def TSplineBody_classType() -> "char const *":
    return _fusion.TSplineBody_classType()


TSplineBody.name = property(TSplineBody._get_name, TSplineBody._set_name, doc="Gets and sets the name of the body. If setting this property, there is the side-effect\nthat the B-Rep body created from this T-Spline body is also renamed.")


TSplineBody.parentFormFeature = property(TSplineBody._get_parentFormFeature, doc="Returns the owning form feature.")


TSplineBody.entityToken = property(TSplineBody._get_entityToken, doc="Returns a token for the TSplineBody object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same T-Spline body.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.")


TSplineBody.cast = lambda arg: arg if isinstance(arg, TSplineBody) else None

class UnfoldFeatures(Base):
    r"""Collection that provides access to all of the existing unfold features in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::UnfoldFeatures *":
        return _fusion.UnfoldFeatures___deref__(self)

    def __eq__(self, rhs: "UnfoldFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.UnfoldFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "UnfoldFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.UnfoldFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.UnfoldFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::UnfoldFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.UnfoldFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.UnfoldFeatures_classType()
    __swig_destroy__ = _fusion.delete_UnfoldFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::UnfoldFeature >":
        r"""
        Function that returns the specified unfold feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.UnfoldFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of unfold features in the collection."""
        return _fusion.UnfoldFeatures__get_count(self)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::UnfoldFeature >":
        r"""
        Function that returns the specified unfold feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.UnfoldFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.UnfoldFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.UnfoldFeatures__get_isValid(self)

# Register UnfoldFeatures in _fusion:
_fusion.UnfoldFeatures_swigregister(UnfoldFeatures)

def UnfoldFeatures_classType() -> "char const *":
    return _fusion.UnfoldFeatures_classType()


UnfoldFeatures.count = property(UnfoldFeatures._get_count, doc="The number of unfold features in the collection.")


UnfoldFeatures.cast = lambda arg: arg if isinstance(arg, UnfoldFeatures) else None

class UnstitchFeatures(Base):
    r"""
    Collection that provides access to all of the existing Unstitch features in a component
    and supports the ability to create new Unstitch features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::UnstitchFeatures *":
        return _fusion.UnstitchFeatures___deref__(self)

    def __eq__(self, rhs: "UnstitchFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.UnstitchFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "UnstitchFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.UnstitchFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.UnstitchFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::UnstitchFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.UnstitchFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.UnstitchFeatures_classType()
    __swig_destroy__ = _fusion.delete_UnstitchFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::UnstitchFeature >":
        r"""
        Function that returns the specified Unstitch feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.UnstitchFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of Unstitch features in the collection."""
        return _fusion.UnstitchFeatures__get_count(self)

    def add(self, faces: "ObjectCollection", isChainSelection: "bool"=True) -> "adsk::core::Ptr< adsk::fusion::UnstitchFeature >":
        r"""
        Creates a new Unstitch feature. 
        faces : The faces and/or bodies to Unstitch. Individual faces can be unstitched from solid and/or patch bodies. The faces being unstitched
        need not all come from the same body. 
        isChainSelection : A boolean value for setting whether or not faces that are connected and adjacent to 
        the input faces will be included in the selection. The default value is true. 
        Returns the newly created UnstitchFeature object or null if the creation failed.
        """
        return _fusion.UnstitchFeatures_add(self, faces, isChainSelection)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::UnstitchFeature >":
        r"""
        Function that returns the specified unstitch feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.UnstitchFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.UnstitchFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.UnstitchFeatures__get_isValid(self)

# Register UnstitchFeatures in _fusion:
_fusion.UnstitchFeatures_swigregister(UnstitchFeatures)

def UnstitchFeatures_classType() -> "char const *":
    return _fusion.UnstitchFeatures_classType()


UnstitchFeatures.count = property(UnstitchFeatures._get_count, doc="The number of Unstitch features in the collection.")


UnstitchFeatures.cast = lambda arg: arg if isinstance(arg, UnstitchFeatures) else None

class UntrimFeatureInput(Base):
    r"""This class defines the methods and properties that pertain to the definition of a Untrim feature."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::UntrimFeatureInput *":
        return _fusion.UntrimFeatureInput___deref__(self)

    def __eq__(self, rhs: "UntrimFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.UntrimFeatureInput___eq__(self, rhs)


    def __ne__(self, rhs: "UntrimFeatureInput") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.UntrimFeatureInput___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.UntrimFeatureInput_classType()
    __swig_destroy__ = _fusion.delete_UntrimFeatureInput

    def _get_untrimLoopType(self) -> "adsk::fusion::UntrimLoopTypes":
        r"""Gets the loop type to be untrimmed. This is only used when faces are being untrimmed and is ignored for loops."""
        return _fusion.UntrimFeatureInput__get_untrimLoopType(self)

    def _get_facesToUntrim(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepFace > > >":
        r"""
        Gets the face objects to untrim.
        Returns null/None in the case where loops are specified instead of faces.
        """
        return _fusion.UntrimFeatureInput__get_facesToUntrim(self)

    def setLoopsFromFaces(self, faces: "BRepFaceVector", untrimLoopType: "UntrimLoopTypes") -> "bool":
        r"""
        Set the loops to be removed from a set of faces. 
        faces : An array of BRepFace objects that will have the loops of the specified types removed.
        Only loops that do not have a connected face can be removed (the edges in the loop have a single face).
        The array can only contain faces from surface bodies, (the isSolid property of the BRepBody returns false). 
        untrimLoopType : The loop type to be untrimmed (AllLoopUntrimType, InternalLoopUntrimType, or ExternalLoopUntrimType). 
        Returns whether the operation was successful
        """
        return _fusion.UntrimFeatureInput_setLoopsFromFaces(self, faces, untrimLoopType)

    def _get_loopsToUntrim(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepLoop >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepLoop > > >":
        r"""
        Gets the loop objects to untrim.
        Returns null/None in the case where faces are specified instead of loops
        """
        return _fusion.UntrimFeatureInput__get_loopsToUntrim(self)

    def setLoops(self, loops: "BRepLoopVector") -> "bool":
        r"""
        Set the loops to be removed. 
        loops : Redefines this input to remove loops from the body. If faces were previously defined, that information will be lost.
        Only loops that do not have a connected face can be removed (the edges in the loop have a single face)
        The array can only contain loops from surface bodies, (the isSolid property of the BRepBody returns false). 
        Returns whether the operation was successful
        """
        return _fusion.UntrimFeatureInput_setLoops(self, loops)

    def _get_extensionDistance(self) -> "adsk::core::Ptr< adsk::core::ValueInput >":
        r"""
        Gets and sets the ValueInput object that defines the extension distance applied to faces when an
        external boundary is removed.
        """
        return _fusion.UntrimFeatureInput__get_extensionDistance(self)

    def _set_extensionDistance(self, value: "ValueInput") -> "bool":
        r"""
        Gets and sets the ValueInput object that defines the extension distance applied to faces when an
        external boundary is removed.
        """
        return _fusion.UntrimFeatureInput__set_extensionDistance(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.UntrimFeatureInput__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.UntrimFeatureInput__get_isValid(self)

# Register UntrimFeatureInput in _fusion:
_fusion.UntrimFeatureInput_swigregister(UntrimFeatureInput)

def UntrimFeatureInput_classType() -> "char const *":
    return _fusion.UntrimFeatureInput_classType()


UntrimFeatureInput.untrimLoopType = property(UntrimFeatureInput._get_untrimLoopType, doc="Gets the loop type to be untrimmed. This is only used when faces are being untrimmed and is ignored for loops.")


UntrimFeatureInput.facesToUntrim = property(UntrimFeatureInput._get_facesToUntrim, doc="Gets the face objects to untrim.\nReturns null/None in the case where loops are specified instead of faces.")


UntrimFeatureInput.loopsToUntrim = property(UntrimFeatureInput._get_loopsToUntrim, doc="Gets the loop objects to untrim.\nReturns null/None in the case where faces are specified instead of loops")


UntrimFeatureInput.extensionDistance = property(UntrimFeatureInput._get_extensionDistance, UntrimFeatureInput._set_extensionDistance, doc="Gets and sets the ValueInput object that defines the extension distance applied to faces when an\nexternal boundary is removed.")


UntrimFeatureInput.cast = lambda arg: arg if isinstance(arg, UntrimFeatureInput) else None

class UntrimFeatures(Base):
    r"""
    Collection that provides access to all of the existing Untrim features in a component
    and supports the ability to create new Untrim features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::UntrimFeatures *":
        return _fusion.UntrimFeatures___deref__(self)

    def __eq__(self, rhs: "UntrimFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.UntrimFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "UntrimFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.UntrimFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.UntrimFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::UntrimFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.UntrimFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.UntrimFeatures_classType()
    __swig_destroy__ = _fusion.delete_UntrimFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::UntrimFeature >":
        r"""
        Function that returns the specified Untrim feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.UntrimFeatures_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of Untrim features in the collection."""
        return _fusion.UntrimFeatures__get_count(self)

    def createInputFromFaces(self, *args) -> "adsk::core::Ptr< adsk::fusion::UntrimFeatureInput >":
        r"""
        Creates a UntrimFeatureInput object that defines the input needed to create a untrim feature. Use the input
        object to define the input to create the desired feature and then use the Add method, passing in the UntrimFeatureInput object. 
        faces : An array of BRepFace objects that will have the loops of the specified type removed.
        Only loops that do not have a connected face can be removed (the edges in the loop have a single face).
        The array can only contain faces from surface bodies, (the isSolid property of the BRepBody returns false). 
        untrimLoopType : The loop type to be untrimmed (AllLoopUntrimType, InternalLoopUntrimType, or ExternalLoopUntrimType). 
        extensionDistance : If the untrim loop type is AllLoopUntrimType or ExternalLoopUntrimType the untrimmed faces can be extended by a specified distance. 
        Returns the newly created UntrimFeatureInput object or null if the creation failed.
        """
        return _fusion.UntrimFeatures_createInputFromFaces(self, *args)

    def createInputFromLoops(self, *args) -> "adsk::core::Ptr< adsk::fusion::UntrimFeatureInput >":
        r"""
        Creates a UntrimFeatureInput object that defines the input needed to create a untrim feature. Use the input
        object to define the input to create the desired feature and then use the Add method, passing in the UntrimFeatureInput object. 
        loops : Input the entities that define loops to remove.
        Only loops that do not have a connected face can be removed (the edges in the loop have a single face)
        The array can only contain loops from surface bodies, (the isSolid property of the BRepBody returns false). 
        extensionDistance : If an external boundary is removed the the untrimed face can be extended by a specified distance. 
        Returns the newly created UntrimFeatureInput object or null if the creation failed.
        """
        return _fusion.UntrimFeatures_createInputFromLoops(self, *args)

    def add(self, input: "UntrimFeatureInput") -> "adsk::core::Ptr< adsk::fusion::UntrimFeature >":
        r"""
        Creates a new Untrim feature. 
        input : An UntrimFeatureInput object that defines the desired Untrim feature. Use the createInput 
        method to create a new UntrimFeatureInput object and then use methods on it 
        (the UntrimFeatureInput object) to define the desired options for the Untrim feature. 
        Returns the newly created UntrimFeature object or null if the creation failed.
        """
        return _fusion.UntrimFeatures_add(self, input)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::UntrimFeature >":
        r"""
        Function that returns the specified Untrim feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.UntrimFeatures_itemByName(self, name)

    def _get_objectType(self) -> "char const *":
        return _fusion.UntrimFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.UntrimFeatures__get_isValid(self)

# Register UntrimFeatures in _fusion:
_fusion.UntrimFeatures_swigregister(UntrimFeatures)

def UntrimFeatures_classType() -> "char const *":
    return _fusion.UntrimFeatures_classType()


UntrimFeatures.count = property(UntrimFeatures._get_count, doc="The number of Untrim features in the collection.")


UntrimFeatures.cast = lambda arg: arg if isinstance(arg, UntrimFeatures) else None

class UserParameters(Base):
    r"""
    Provides access to the User Parameters within a design and provides 
    methods to create new user parameters.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::UserParameters *":
        return _fusion.UserParameters___deref__(self)

    def __eq__(self, rhs: "UserParameters") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.UserParameters___eq__(self, rhs)


    def __ne__(self, rhs: "UserParameters") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.UserParameters___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.UserParameters___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::UserParameter >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.UserParameters___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.UserParameters_classType()
    __swig_destroy__ = _fusion.delete_UserParameters

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::UserParameter >":
        r"""
        Function that returns the specified User Parameter using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection 
        has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.UserParameters_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::UserParameter >":
        r"""
        Function that returns the specified User Parameter using the name of the parameter 
        as it is displayed in the parameters dialog. 
        name : The name of the User Parameter as it is displayed in the parameters dialog 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.UserParameters_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""Returns the number of parameters in the collection."""
        return _fusion.UserParameters__get_count(self)

    def _get_design(self) -> "adsk::core::Ptr< adsk::fusion::Design >":
        r"""Returns the design that owns the user parameters collection."""
        return _fusion.UserParameters__get_design(self)

    def add(self, name: "std::string const &", value: "ValueInput", units: "std::string const &", comment: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::UserParameter >":
        r"""
        Adds a new user parameter to the collection. 
        name : The name of the parameter. This is the name shown in the parameters dialog 
        value : ValueInput object that specifies the value of the parameter. If the ValueInput was created using a real, 
        the value will be interpreted using the internal unit for the unit type specified by the 'units' argument. 
        For example, if the ValueInput was created using the real value 5 and the input to the 'units' argument is 
        any valid length unit, the value will be interpreted as 5 centimeters since centimeters is the internal unit
        for lengths. If the 'units' argument is a valid angle unit the value will be interpreted as 5 radians.
        If the ValueInput was created using a string, the string is used as-is for the expression of the parameter.
        This means if there are units as part of the string it must evaluate to the same unit type as that specified 
        by the 'units' argument and if no units are specified it will use the current default units specified for 
        the current document. For example, if the ValueInput was created with the string '5 in', then the 'units' 
        argument must define any valid length so they are compatible. If the ValueInput was created with the string '5',
        any unit type can be used and the result will be 5 of that unit.
        When using a ValueInput created using a string, it's the same as creating a parameter in the user-interface.
        You can specify any valid expression, i.e. '5', '5 in', '5 in / 2', '5 + Length', etc. and you can choose 
        from many different types of units. The only requirement is that the units must match in type. For example, 
        they must both be lengths, or they must both be angles. 
        units : The units to use for the value of the parameter. 
        Units specified must match the units specified (if any) in the ValueInput object.
        To create a parameter with no units you can specify either an empty string. 
        comment : The comment to display in the parameters dialog. Specify an empty string ('') for no comment 
        Returns the newly created UserParameter or null if the creation failed.
        """
        return _fusion.UserParameters_add(self, name, value, units, comment)

    def _get_objectType(self) -> "char const *":
        return _fusion.UserParameters__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.UserParameters__get_isValid(self)

# Register UserParameters in _fusion:
_fusion.UserParameters_swigregister(UserParameters)

def UserParameters_classType() -> "char const *":
    return _fusion.UserParameters_classType()


UserParameters.count = property(UserParameters._get_count, doc="Returns the number of parameters in the collection.")


UserParameters.design = property(UserParameters._get_design, doc="Returns the design that owns the user parameters collection.")


UserParameters.cast = lambda arg: arg if isinstance(arg, UserParameters) else None

class WebFeatures(Base):
    r"""Collection that provides access to all of the existing web features in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::WebFeatures *":
        return _fusion.WebFeatures___deref__(self)

    def __eq__(self, rhs: "WebFeatures") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.WebFeatures___eq__(self, rhs)


    def __ne__(self, rhs: "WebFeatures") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.WebFeatures___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.WebFeatures___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::WebFeature >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.WebFeatures___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.WebFeatures_classType()
    __swig_destroy__ = _fusion.delete_WebFeatures

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::WebFeature >":
        r"""
        Function that returns the specified web feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.WebFeatures_item(self, index)

    def itemByName(self, name: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::WebFeature >":
        r"""
        Function that returns the specified web feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.WebFeatures_itemByName(self, name)

    def _get_count(self) -> "size_t":
        r"""The number of web features in the collection."""
        return _fusion.WebFeatures__get_count(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.WebFeatures__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.WebFeatures__get_isValid(self)

# Register WebFeatures in _fusion:
_fusion.WebFeatures_swigregister(WebFeatures)

def WebFeatures_classType() -> "char const *":
    return _fusion.WebFeatures_classType()


WebFeatures.count = property(WebFeatures._get_count, doc="The number of web features in the collection.")


WebFeatures.cast = lambda arg: arg if isinstance(arg, WebFeatures) else None

class AllExtentDefinition(ExtentDefinition):
    r"""
    Defines the inputs for a AllExtentDefinition object. 
    This defines a feature extent where the direction can be positive, negative, or symmetric. 
    Setting the direction to Symmetric specifies that the extrusion is through-all, 
    and goes in both directions.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::AllExtentDefinition *":
        return _fusion.AllExtentDefinition___deref__(self)

    def __eq__(self, rhs: "AllExtentDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.AllExtentDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "AllExtentDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.AllExtentDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.AllExtentDefinition_classType()
    __swig_destroy__ = _fusion.delete_AllExtentDefinition

    def _get_direction(self) -> "adsk::fusion::ExtentDirections":
        r"""Gets and sets the direction of the extent."""
        return _fusion.AllExtentDefinition__get_direction(self)

    def _set_direction(self, value: "ExtentDirections") -> "bool":
        r"""Gets and sets the direction of the extent."""
        return _fusion.AllExtentDefinition__set_direction(self, value)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >":
        r"""
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.AllExtentDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.AllExtentDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.AllExtentDefinition__get_isValid(self)

# Register AllExtentDefinition in _fusion:
_fusion.AllExtentDefinition_swigregister(AllExtentDefinition)

def AllExtentDefinition_classType() -> "char const *":
    return _fusion.AllExtentDefinition_classType()


AllExtentDefinition.direction = property(AllExtentDefinition._get_direction, AllExtentDefinition._set_direction, doc="Gets and sets the direction of the extent.")


AllExtentDefinition.cast = lambda arg: arg if isinstance(arg, AllExtentDefinition) else None

class AlongPathTextDefinition(SketchTextDefinition):
    r"""Defines the information for text that follows along a path."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::AlongPathTextDefinition *":
        return _fusion.AlongPathTextDefinition___deref__(self)

    def __eq__(self, rhs: "AlongPathTextDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.AlongPathTextDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "AlongPathTextDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.AlongPathTextDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.AlongPathTextDefinition_classType()
    __swig_destroy__ = _fusion.delete_AlongPathTextDefinition

    def _get_path(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Get and sets the entity that defines the path for the text. This can be a SketchCurve or BRepEdge object."""
        return _fusion.AlongPathTextDefinition__get_path(self)

    def _set_path(self, value: "Base") -> "bool":
        r"""Get and sets the entity that defines the path for the text. This can be a SketchCurve or BRepEdge object."""
        return _fusion.AlongPathTextDefinition__set_path(self, value)

    def _get_isAbovePath(self) -> "bool":
        r"""Gets and sets if the text should be positioned above or below the path entity."""
        return _fusion.AlongPathTextDefinition__get_isAbovePath(self)

    def _set_isAbovePath(self, value: "bool") -> "bool":
        r"""Gets and sets if the text should be positioned above or below the path entity."""
        return _fusion.AlongPathTextDefinition__set_isAbovePath(self, value)

    def _get_horizontalAlignment(self) -> "adsk::core::HorizontalAlignments":
        r"""Gets and sets the horizontal alignment of the text with respect to the path curve."""
        return _fusion.AlongPathTextDefinition__get_horizontalAlignment(self)

    def _set_horizontalAlignment(self, value: "HorizontalAlignments") -> "bool":
        r"""Gets and sets the horizontal alignment of the text with respect to the path curve."""
        return _fusion.AlongPathTextDefinition__set_horizontalAlignment(self, value)

    def _get_characterSpacing(self) -> "double":
        r"""
        Gets and sets the spacing between the characters. This is an additional spacing to apply 
        that is defined as a percentage of the default spacing. A spacing of 0 indicates no
        additional spacing. A spacing of 50 indicates to use the default plus 50% of the default.
        """
        return _fusion.AlongPathTextDefinition__get_characterSpacing(self)

    def _set_characterSpacing(self, value: "double") -> "bool":
        r"""
        Gets and sets the spacing between the characters. This is an additional spacing to apply 
        that is defined as a percentage of the default spacing. A spacing of 0 indicates no
        additional spacing. A spacing of 50 indicates to use the default plus 50% of the default.
        """
        return _fusion.AlongPathTextDefinition__set_characterSpacing(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.AlongPathTextDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.AlongPathTextDefinition__get_isValid(self)

# Register AlongPathTextDefinition in _fusion:
_fusion.AlongPathTextDefinition_swigregister(AlongPathTextDefinition)

def AlongPathTextDefinition_classType() -> "char const *":
    return _fusion.AlongPathTextDefinition_classType()


AlongPathTextDefinition.path = property(AlongPathTextDefinition._get_path, AlongPathTextDefinition._set_path, doc="Get and sets the entity that defines the path for the text. This can be a SketchCurve or BRepEdge object.")


AlongPathTextDefinition.isAbovePath = property(AlongPathTextDefinition._get_isAbovePath, AlongPathTextDefinition._set_isAbovePath, doc="Gets and sets if the text should be positioned above or below the path entity.")


AlongPathTextDefinition.horizontalAlignment = property(AlongPathTextDefinition._get_horizontalAlignment, AlongPathTextDefinition._set_horizontalAlignment, doc="Gets and sets the horizontal alignment of the text with respect to the path curve.")


AlongPathTextDefinition.characterSpacing = property(AlongPathTextDefinition._get_characterSpacing, AlongPathTextDefinition._set_characterSpacing, doc="Gets and sets the spacing between the characters. This is an additional spacing to apply\nthat is defined as a percentage of the default spacing. A spacing of 0 indicates no\nadditional spacing. A spacing of 50 indicates to use the default plus 50% of the default.")


AlongPathTextDefinition.cast = lambda arg: arg if isinstance(arg, AlongPathTextDefinition) else None

class AngleExtentDefinition(ExtentDefinition):
    r"""
    Defines the inputs for a AngleExtentDefinition object.
    This feature extent is defined by an angle as well as whether the extent is symmetric or only in one direction.
    If the extent is not symmetric, a positive or negative angle can be used to control the direction.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::AngleExtentDefinition *":
        return _fusion.AngleExtentDefinition___deref__(self)

    def __eq__(self, rhs: "AngleExtentDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.AngleExtentDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "AngleExtentDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.AngleExtentDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.AngleExtentDefinition_classType()
    __swig_destroy__ = _fusion.delete_AngleExtentDefinition

    def _get_isSymmetric(self) -> "bool":
        r"""
        Gets and sets if the angle extent is in one direction or symmetric.
        For a hole this property will always return false and setting it is ignored.
        """
        return _fusion.AngleExtentDefinition__get_isSymmetric(self)

    def _set_isSymmetric(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the angle extent is in one direction or symmetric.
        For a hole this property will always return false and setting it is ignored.
        """
        return _fusion.AngleExtentDefinition__set_isSymmetric(self, value)

    def _get_angle(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the ModelParameter that defines the angle. The value of the angle can be edited
        by using the properties on the ModelParameter object to edit the parameter.
        """
        return _fusion.AngleExtentDefinition__get_angle(self)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >":
        r"""
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.AngleExtentDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.AngleExtentDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.AngleExtentDefinition__get_isValid(self)

# Register AngleExtentDefinition in _fusion:
_fusion.AngleExtentDefinition_swigregister(AngleExtentDefinition)

def AngleExtentDefinition_classType() -> "char const *":
    return _fusion.AngleExtentDefinition_classType()


AngleExtentDefinition.isSymmetric = property(AngleExtentDefinition._get_isSymmetric, AngleExtentDefinition._set_isSymmetric, doc="Gets and sets if the angle extent is in one direction or symmetric.\nFor a hole this property will always return false and setting it is ignored.")


AngleExtentDefinition.angle = property(AngleExtentDefinition._get_angle, doc="Gets the ModelParameter that defines the angle. The value of the angle can be edited\nby using the properties on the ModelParameter object to edit the parameter.")


AngleExtentDefinition.cast = lambda arg: arg if isinstance(arg, AngleExtentDefinition) else None

class AtCenterHolePositionDefinition(HolePositionDefinition):
    r"""
    Provides positioning information for a hole that is positioned at the center of a 
    circular or elliptical edge.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::AtCenterHolePositionDefinition *":
        return _fusion.AtCenterHolePositionDefinition___deref__(self)

    def __eq__(self, rhs: "AtCenterHolePositionDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.AtCenterHolePositionDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "AtCenterHolePositionDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.AtCenterHolePositionDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.AtCenterHolePositionDefinition_classType()
    __swig_destroy__ = _fusion.delete_AtCenterHolePositionDefinition

    def _get_planarEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the plane that defines the orientation and start of the hole."""
        return _fusion.AtCenterHolePositionDefinition__get_planarEntity(self)

    def _get_centerEdge(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdge >":
        r"""Returns the circular or elliptical edge the hole is centered at."""
        return _fusion.AtCenterHolePositionDefinition__get_centerEdge(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.AtCenterHolePositionDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.AtCenterHolePositionDefinition__get_isValid(self)

# Register AtCenterHolePositionDefinition in _fusion:
_fusion.AtCenterHolePositionDefinition_swigregister(AtCenterHolePositionDefinition)

def AtCenterHolePositionDefinition_classType() -> "char const *":
    return _fusion.AtCenterHolePositionDefinition_classType()


AtCenterHolePositionDefinition.planarEntity = property(AtCenterHolePositionDefinition._get_planarEntity, doc="Returns the plane that defines the orientation and start of the hole.")


AtCenterHolePositionDefinition.centerEdge = property(AtCenterHolePositionDefinition._get_centerEdge, doc="Returns the circular or elliptical edge the hole is centered at.")


AtCenterHolePositionDefinition.cast = lambda arg: arg if isinstance(arg, AtCenterHolePositionDefinition) else None

class BallJointMotion(JointMotion):
    r"""Represents the set of information specific to a ball joint."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BallJointMotion *":
        return _fusion.BallJointMotion___deref__(self)

    def __eq__(self, rhs: "BallJointMotion") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BallJointMotion___eq__(self, rhs)


    def __ne__(self, rhs: "BallJointMotion") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BallJointMotion___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BallJointMotion_classType()
    __swig_destroy__ = _fusion.delete_BallJointMotion

    def _get_pitchDirection(self) -> "adsk::fusion::JointDirections":
        r"""
        Gets and sets the direction that the pitch is measured from.
        This can only be set to ZAxisJointDirection and can return ZAxisJointDirection
        or CustomJointDirection. If this returns CustomJointDirection then the 
        customNormalDirectionEntity will return an entity that defines the direction. 
        If there is a custom direction defined and this property is set to ZAxisJointDirection,
        the custom direction will be removed and customNormalDirectionEntity will return null.
        """
        return _fusion.BallJointMotion__get_pitchDirection(self)

    def _set_pitchDirection(self, value: "JointDirections") -> "bool":
        r"""
        Gets and sets the direction that the pitch is measured from.
        This can only be set to ZAxisJointDirection and can return ZAxisJointDirection
        or CustomJointDirection. If this returns CustomJointDirection then the 
        customNormalDirectionEntity will return an entity that defines the direction. 
        If there is a custom direction defined and this property is set to ZAxisJointDirection,
        the custom direction will be removed and customNormalDirectionEntity will return null.
        """
        return _fusion.BallJointMotion__set_pitchDirection(self, value)

    def _get_customPitchDirectionEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        This property defines a custom pitch direction and can be set using various types 
        of entities that can infer a direction. For example, a linear edge, sketch line, 
        planar face, and cylindrical face.This property is only valid in the case where the 
        pitchDirection property returns CustomJointDirection. Setting this property will 
        automatically set the pitchDirection property to CustomJointDirection.
        """
        return _fusion.BallJointMotion__get_customPitchDirectionEntity(self)

    def _set_customPitchDirectionEntity(self, value: "Base") -> "bool":
        r"""
        This property defines a custom pitch direction and can be set using various types 
        of entities that can infer a direction. For example, a linear edge, sketch line, 
        planar face, and cylindrical face.This property is only valid in the case where the 
        pitchDirection property returns CustomJointDirection. Setting this property will 
        automatically set the pitchDirection property to CustomJointDirection.
        """
        return _fusion.BallJointMotion__set_customPitchDirectionEntity(self, value)

    def _get_pitchDirectionVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Returns the direction that the pitch angle is measured from. This property will return null in the case
        where the BallJointMotion object was obtained from a JointInput object.
        """
        return _fusion.BallJointMotion__get_pitchDirectionVector(self)

    def _get_yawDirection(self) -> "adsk::fusion::JointDirections":
        r"""
        Gets and sets the direction that the pitch is measured from.
        This can only be set to XAxisJointDirection and can return XAxisJointDirection
        or CustomJointDirection. If this returns CustomJointDirection then the 
        customYawDirectionEntity will return an entity that defines the direction. 
        If there is a custom direction defined and this property is set to XAxisJointDirection,
        the custom direction will be removed and customYawDirectionEntity will return null.
        """
        return _fusion.BallJointMotion__get_yawDirection(self)

    def _set_yawDirection(self, value: "JointDirections") -> "bool":
        r"""
        Gets and sets the direction that the pitch is measured from.
        This can only be set to XAxisJointDirection and can return XAxisJointDirection
        or CustomJointDirection. If this returns CustomJointDirection then the 
        customYawDirectionEntity will return an entity that defines the direction. 
        If there is a custom direction defined and this property is set to XAxisJointDirection,
        the custom direction will be removed and customYawDirectionEntity will return null.
        """
        return _fusion.BallJointMotion__set_yawDirection(self, value)

    def _get_customYawDirectionEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        This property defines a custom yaw direction and can be set using various types 
        of entities that can infer a direction. For example, a linear edge, sketch line, 
        planar face, and cylindrical face.This property is only valid in the case where the 
        yawDirection property returns CustomJointDirection. Setting this property will 
        automatically set the yawDirection property to CustomJointDirection.
        """
        return _fusion.BallJointMotion__get_customYawDirectionEntity(self)

    def _set_customYawDirectionEntity(self, value: "Base") -> "bool":
        r"""
        This property defines a custom yaw direction and can be set using various types 
        of entities that can infer a direction. For example, a linear edge, sketch line, 
        planar face, and cylindrical face.This property is only valid in the case where the 
        yawDirection property returns CustomJointDirection. Setting this property will 
        automatically set the yawDirection property to CustomJointDirection.
        """
        return _fusion.BallJointMotion__set_customYawDirectionEntity(self, value)

    def _get_yawDirectionVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Returns the direction that the yaw angle is measured from. This property will return null in the case
        where the BallJointMotion object was obtained from a JointInput object.
        """
        return _fusion.BallJointMotion__get_yawDirectionVector(self)

    def _get_rollDirectionVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Returns the direction that the roll angle is measured from. This property will return null in the case
        where the BallJointMotion object was obtained from a JointInput object.
        """
        return _fusion.BallJointMotion__get_rollDirectionVector(self)

    def _get_pitchValue(self) -> "double":
        r"""
        Gets and sets the pitch value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.BallJointMotion__get_pitchValue(self)

    def _set_pitchValue(self, value: "double") -> "bool":
        r"""
        Gets and sets the pitch value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.BallJointMotion__set_pitchValue(self, value)

    def _get_pitchLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >":
        r"""
        Returns a JointLimits object that defines the limits of rotation for the pitch.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.BallJointMotion__get_pitchLimits(self)

    def _get_yawValue(self) -> "double":
        r"""
        Gets and sets the yaw value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.BallJointMotion__get_yawValue(self)

    def _set_yawValue(self, value: "double") -> "bool":
        r"""
        Gets and sets the yaw value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.BallJointMotion__set_yawValue(self, value)

    def _get_yawLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >":
        r"""
        Returns a JointLimits object that defines the limits of rotation for the yaw.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.BallJointMotion__get_yawLimits(self)

    def _get_rollValue(self) -> "double":
        r"""
        Gets and sets the roll value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.BallJointMotion__get_rollValue(self)

    def _set_rollValue(self, value: "double") -> "bool":
        r"""
        Gets and sets the roll value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.BallJointMotion__set_rollValue(self, value)

    def _get_rollLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >":
        r"""
        Returns a JointLimits object that defines the limits of rotation for the roll.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.BallJointMotion__get_rollLimits(self)

    def _get_jointType(self) -> "adsk::fusion::JointTypes":
        r"""Returns an enum value indicating the type of joint this joint represents."""
        return _fusion.BallJointMotion__get_jointType(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BallJointMotion__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BallJointMotion__get_isValid(self)

# Register BallJointMotion in _fusion:
_fusion.BallJointMotion_swigregister(BallJointMotion)

def BallJointMotion_classType() -> "char const *":
    return _fusion.BallJointMotion_classType()


BallJointMotion.pitchDirection = property(BallJointMotion._get_pitchDirection, BallJointMotion._set_pitchDirection, doc="Gets and sets the direction that the pitch is measured from.\nThis can only be set to ZAxisJointDirection and can return ZAxisJointDirection\nor CustomJointDirection. If this returns CustomJointDirection then the\ncustomNormalDirectionEntity will return an entity that defines the direction.\nIf there is a custom direction defined and this property is set to ZAxisJointDirection,\nthe custom direction will be removed and customNormalDirectionEntity will return null.")


BallJointMotion.customPitchDirectionEntity = property(BallJointMotion._get_customPitchDirectionEntity, BallJointMotion._set_customPitchDirectionEntity, doc="This property defines a custom pitch direction and can be set using various types\nof entities that can infer a direction. For example, a linear edge, sketch line,\nplanar face, and cylindrical face.This property is only valid in the case where the\npitchDirection property returns CustomJointDirection. Setting this property will\nautomatically set the pitchDirection property to CustomJointDirection.")


BallJointMotion.pitchDirectionVector = property(BallJointMotion._get_pitchDirectionVector, doc="Returns the direction that the pitch angle is measured from. This property will return null in the case\nwhere the BallJointMotion object was obtained from a JointInput object.")


BallJointMotion.yawDirection = property(BallJointMotion._get_yawDirection, BallJointMotion._set_yawDirection, doc="Gets and sets the direction that the pitch is measured from.\nThis can only be set to XAxisJointDirection and can return XAxisJointDirection\nor CustomJointDirection. If this returns CustomJointDirection then the\ncustomYawDirectionEntity will return an entity that defines the direction.\nIf there is a custom direction defined and this property is set to XAxisJointDirection,\nthe custom direction will be removed and customYawDirectionEntity will return null.")


BallJointMotion.customYawDirectionEntity = property(BallJointMotion._get_customYawDirectionEntity, BallJointMotion._set_customYawDirectionEntity, doc="This property defines a custom yaw direction and can be set using various types\nof entities that can infer a direction. For example, a linear edge, sketch line,\nplanar face, and cylindrical face.This property is only valid in the case where the\nyawDirection property returns CustomJointDirection. Setting this property will\nautomatically set the yawDirection property to CustomJointDirection.")


BallJointMotion.yawDirectionVector = property(BallJointMotion._get_yawDirectionVector, doc="Returns the direction that the yaw angle is measured from. This property will return null in the case\nwhere the BallJointMotion object was obtained from a JointInput object.")


BallJointMotion.rollDirectionVector = property(BallJointMotion._get_rollDirectionVector, doc="Returns the direction that the roll angle is measured from. This property will return null in the case\nwhere the BallJointMotion object was obtained from a JointInput object.")


BallJointMotion.pitchValue = property(BallJointMotion._get_pitchValue, BallJointMotion._set_pitchValue, doc="Gets and sets the pitch value. This is in radians. Setting this value is\nthe equivalent of using the Drive Joints command.")


BallJointMotion.pitchLimits = property(BallJointMotion._get_pitchLimits, doc="Returns a JointLimits object that defines the limits of rotation for the pitch.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")


BallJointMotion.yawValue = property(BallJointMotion._get_yawValue, BallJointMotion._set_yawValue, doc="Gets and sets the yaw value. This is in radians. Setting this value is\nthe equivalent of using the Drive Joints command.")


BallJointMotion.yawLimits = property(BallJointMotion._get_yawLimits, doc="Returns a JointLimits object that defines the limits of rotation for the yaw.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")


BallJointMotion.rollValue = property(BallJointMotion._get_rollValue, BallJointMotion._set_rollValue, doc="Gets and sets the roll value. This is in radians. Setting this value is\nthe equivalent of using the Drive Joints command.")


BallJointMotion.rollLimits = property(BallJointMotion._get_rollLimits, doc="Returns a JointLimits object that defines the limits of rotation for the roll.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")


BallJointMotion.cast = lambda arg: arg if isinstance(arg, BallJointMotion) else None

class BaseFeature(Feature):
    r"""The BaseFeature class represents a direct edit feature within a parametric design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BaseFeature *":
        return _fusion.BaseFeature___deref__(self)

    def __eq__(self, rhs: "BaseFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BaseFeature___eq__(self, rhs)


    def __ne__(self, rhs: "BaseFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BaseFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BaseFeature_classType()
    __swig_destroy__ = _fusion.delete_BaseFeature

    def _get_constructionPlanes(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane >,std::allocator< adsk::core::Ptr< adsk::fusion::ConstructionPlane > > >":
        r"""Returns an array of the construction planes associated with this base feature."""
        return _fusion.BaseFeature__get_constructionPlanes(self)

    def _get_constructionAxes(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis >,std::allocator< adsk::core::Ptr< adsk::fusion::ConstructionAxis > > >":
        r"""Returns an array of the construction axes associated with this base feature."""
        return _fusion.BaseFeature__get_constructionAxes(self)

    def _get_constructionPoints(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint >,std::allocator< adsk::core::Ptr< adsk::fusion::ConstructionPoint > > >":
        r"""Returns an array of the construction points associated with this base feature."""
        return _fusion.BaseFeature__get_constructionPoints(self)

    def _get_sketches(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch >,std::allocator< adsk::core::Ptr< adsk::fusion::Sketch > > >":
        r"""Returns an array of the sketches associated with this base feature."""
        return _fusion.BaseFeature__get_sketches(self)

    def _get_meshBodies(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody >,std::allocator< adsk::core::Ptr< adsk::fusion::MeshBody > > >":
        r"""Returns an array of the mesh bodies associated with this base feature."""
        return _fusion.BaseFeature__get_meshBodies(self)

    def startEdit(self) -> "bool":
        r"""
        Set the user-interface so that the base body is in edit mode. 
        Returns true if successful.
        """
        return _fusion.BaseFeature_startEdit(self)

    def finishEdit(self) -> "bool":
        r"""
        Exits from edit mode in the user-interface. If this base feature in not
        in edit mode, then nothing happens. 
        Returns true if successful.
        """
        return _fusion.BaseFeature_finishEdit(self)

    def updateBody(self, sourceBody: "BRepBody", newBody: "BRepBody") -> "bool":
        r"""
        Update an existing source BRepBody created by this BaseFeature.
        The input BRepBody definition will be copied into the existing BRepBody. 
        sourceBody : The source BRepBody to update. The source bodies of a BaseFeature are only available
        from the bodies collection of the BaseFeature when the BaseFeature is in edit mode. 
        newBody : The BRepBody whose definition will be used to replace the existing source body's definition. 
        Returns true if the body was updated, or false if the update failed.
        """
        return _fusion.BaseFeature_updateBody(self, sourceBody, newBody)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.BaseFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.BaseFeature_createForAssemblyContext(self, occurrence)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.BaseFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.BaseFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.BaseFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.BaseFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.BaseFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.BaseFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.BaseFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.BaseFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.BaseFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.BaseFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.BaseFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.BaseFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.BaseFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.BaseFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.BaseFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.BaseFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.BaseFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.BaseFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BaseFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BaseFeature__get_isValid(self)

# Register BaseFeature in _fusion:
_fusion.BaseFeature_swigregister(BaseFeature)

def BaseFeature_classType() -> "char const *":
    return _fusion.BaseFeature_classType()


BaseFeature.constructionPlanes = property(BaseFeature._get_constructionPlanes, doc="Returns an array of the construction planes associated with this base feature.")


BaseFeature.constructionAxes = property(BaseFeature._get_constructionAxes, doc="Returns an array of the construction axes associated with this base feature.")


BaseFeature.constructionPoints = property(BaseFeature._get_constructionPoints, doc="Returns an array of the construction points associated with this base feature.")


BaseFeature.sketches = property(BaseFeature._get_sketches, doc="Returns an array of the sketches associated with this base feature.")


BaseFeature.meshBodies = property(BaseFeature._get_meshBodies, doc="Returns an array of the mesh bodies associated with this base feature.")


BaseFeature.nativeObject = property(BaseFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


BaseFeature.cast = lambda arg: arg if isinstance(arg, BaseFeature) else None

class BoundaryFillFeature(Feature):
    r"""Object that represents an existing boundary fill feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BoundaryFillFeature *":
        return _fusion.BoundaryFillFeature___deref__(self)

    def __eq__(self, rhs: "BoundaryFillFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BoundaryFillFeature___eq__(self, rhs)


    def __ne__(self, rhs: "BoundaryFillFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BoundaryFillFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BoundaryFillFeature_classType()
    __swig_destroy__ = _fusion.delete_BoundaryFillFeature

    def _get_tools(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        A collection of construction planes and open or closed BRepBody objects that define the 
        set of boundaries that have been used in the calculation of available closed boundaries.
        Setting this property will clear all currently selected tools.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.BoundaryFillFeature__get_tools(self)

    def _set_tools(self, value: "ObjectCollection") -> "bool":
        r"""
        A collection of construction planes and open or closed BRepBody objects that define the 
        set of boundaries that have been used in the calculation of available closed boundaries.
        Setting this property will clear all currently selected tools.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.BoundaryFillFeature__set_tools(self, value)

    def _get_bRepCells(self) -> "adsk::core::Ptr< adsk::fusion::BRepCells >":
        r"""
        Gets the set of closed boundaries that have been calculated based on the current set of
        tools. To get this collection the model must be in the state it was when the feature
        was initially computed, which means the timeline marker must be positioned to immediately
        before this feature. 
        After changing any selected cells you must call the applyCellChanges method to update
        the feature with the changes.
        """
        return _fusion.BoundaryFillFeature__get_bRepCells(self)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations":
        r"""Gets and sets the type of operation performed by the boundary fill feature."""
        return _fusion.BoundaryFillFeature__get_operation(self)

    def _set_operation(self, value: "FeatureOperations") -> "bool":
        r"""Gets and sets the type of operation performed by the boundary fill feature."""
        return _fusion.BoundaryFillFeature__set_operation(self, value)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::BoundaryFillFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.BoundaryFillFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::BoundaryFillFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.BoundaryFillFeature_createForAssemblyContext(self, occurrence)

    def applyCellChanges(self) -> "bool":
        r"""
        After making any changes to the set of selected cells you must call this method to 
        indicate all changes have been made and to apply those changes to the feature. 
        Returns true if the apply was successful.
        """
        return _fusion.BoundaryFillFeature_applyCellChanges(self)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.BoundaryFillFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.BoundaryFillFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.BoundaryFillFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.BoundaryFillFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.BoundaryFillFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.BoundaryFillFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.BoundaryFillFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.BoundaryFillFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.BoundaryFillFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.BoundaryFillFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.BoundaryFillFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.BoundaryFillFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.BoundaryFillFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.BoundaryFillFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.BoundaryFillFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.BoundaryFillFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.BoundaryFillFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.BoundaryFillFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BoundaryFillFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BoundaryFillFeature__get_isValid(self)

# Register BoundaryFillFeature in _fusion:
_fusion.BoundaryFillFeature_swigregister(BoundaryFillFeature)

def BoundaryFillFeature_classType() -> "char const *":
    return _fusion.BoundaryFillFeature_classType()


BoundaryFillFeature.tools = property(BoundaryFillFeature._get_tools, BoundaryFillFeature._set_tools, doc="A collection of construction planes and open or closed BRepBody objects that define the\nset of boundaries that have been used in the calculation of available closed boundaries.\nSetting this property will clear all currently selected tools.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


BoundaryFillFeature.bRepCells = property(BoundaryFillFeature._get_bRepCells, doc="Gets the set of closed boundaries that have been calculated based on the current set of\ntools. To get this collection the model must be in the state it was when the feature\nwas initially computed, which means the timeline marker must be positioned to immediately\nbefore this feature.\nAfter changing any selected cells you must call the applyCellChanges method to update\nthe feature with the changes.")


BoundaryFillFeature.operation = property(BoundaryFillFeature._get_operation, BoundaryFillFeature._set_operation, doc="Gets and sets the type of operation performed by the boundary fill feature.")


BoundaryFillFeature.nativeObject = property(BoundaryFillFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


BoundaryFillFeature.cast = lambda arg: arg if isinstance(arg, BoundaryFillFeature) else None

class BoxFeature(Feature):
    r"""Object that represents an existing box feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::BoxFeature *":
        return _fusion.BoxFeature___deref__(self)

    def __eq__(self, rhs: "BoxFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.BoxFeature___eq__(self, rhs)


    def __ne__(self, rhs: "BoxFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.BoxFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.BoxFeature_classType()
    __swig_destroy__ = _fusion.delete_BoxFeature

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.BoxFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.BoxFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.BoxFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.BoxFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.BoxFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.BoxFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.BoxFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.BoxFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.BoxFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.BoxFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.BoxFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.BoxFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.BoxFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.BoxFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.BoxFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.BoxFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.BoxFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.BoxFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.BoxFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.BoxFeature__get_isValid(self)

# Register BoxFeature in _fusion:
_fusion.BoxFeature_swigregister(BoxFeature)

def BoxFeature_classType() -> "char const *":
    return _fusion.BoxFeature_classType()


BoxFeature.cast = lambda arg: arg if isinstance(arg, BoxFeature) else None

class ChamferFeature(Feature):
    r"""Object that represents an existing chamfer feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ChamferFeature *":
        return _fusion.ChamferFeature___deref__(self)

    def __eq__(self, rhs: "ChamferFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ChamferFeature___eq__(self, rhs)


    def __ne__(self, rhs: "ChamferFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ChamferFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ChamferFeature_classType()
    __swig_destroy__ = _fusion.delete_ChamferFeature

    def _get_edges(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the edges being chamfered. Specific edges can be defined using one or more BRepEdge
        objects or BRepFace objects can be used to chamfer all edges of the face or Feature objects can
        be used to chamfer all edges associated with the input features. If BRepEdge objects are provided 
        and the isTangentChain argument is true additional edges may also get chamfered if they are 
        tangentially connected to any of the input edges. When getting the property, your
        code should check for the different types in the returned collection and handle it appropriately.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ChamferFeature__get_edges(self)

    def _set_edges(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the edges being chamfered. Specific edges can be defined using one or more BRepEdge
        objects or BRepFace objects can be used to chamfer all edges of the face or Feature objects can
        be used to chamfer all edges associated with the input features. If BRepEdge objects are provided 
        and the isTangentChain argument is true additional edges may also get chamfered if they are 
        tangentially connected to any of the input edges. When getting the property, your
        code should check for the different types in the returned collection and handle it appropriately.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ChamferFeature__set_edges(self, value)

    def _get_isTangentChain(self) -> "bool":
        r"""
        Gets and sets whether or not edges that are tangentially connected to 
        the input edges (if any) will also be chamfered.
        """
        return _fusion.ChamferFeature__get_isTangentChain(self)

    def _set_isTangentChain(self, value: "bool") -> "bool":
        r"""
        Gets and sets whether or not edges that are tangentially connected to 
        the input edges (if any) will also be chamfered.
        """
        return _fusion.ChamferFeature__set_isTangentChain(self, value)

    def _get_chamferType(self) -> "adsk::fusion::ChamferTypes":
        r"""
        Gets an enum indicating how the chamfer was defined. The valid return values are 
        EqualDistanceType, TwoDistancesType and DistanceAndAngleType. 
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ChamferFeature__get_chamferType(self)

    def _get_chamferTypeDefinition(self) -> "adsk::core::Ptr< adsk::fusion::ChamferTypeDefinition >":
        r"""
        Gets the definition object that is defining the type of chamfer. Modifying the
        definition object will cause the chamfer to recompute. Various types of definition objects can
        be returned depending on how the chamfer is defined. The ChamferType property can
        be used to determine which type of definition will be returned.
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ChamferFeature__get_chamferTypeDefinition(self)

    def setEqualDistance(self, distance: "ValueInput") -> "bool":
        r"""
        Changes the type of chamfer to be an equal distance chamfer. 
        distance : A ValueInput object that defines the distance of the chamfer. If the ValueInput uses
        a real then it is interpreted as centimeters. If it is a string then the units
        can be defined as part of the string (i.e. '2 in'). If no units are specified
        it is interpreted using the current default units for length. 
        Returns true if the feature is successfully changed
        """
        return _fusion.ChamferFeature_setEqualDistance(self, distance)

    def setTwoDistances(self, distanceOne: "ValueInput", distanceTwo: "ValueInput") -> "bool":
        r"""
        Changes the type of chamfer to be a two distances chamfer. 
        distanceOne : A ValueInput object that defines the distanceOne of the chamfer. This distance 
        is along the face which is on the left of the selected edge.
        If the ValueInput uses a real then it is interpreted as centimeters.
        If it is a string then the units can be defined as part of the string (i.e. '2 in').
        If no units are specified it is interpreted using the current default units for length. 
        distanceTwo : A ValueInput object that defines the distanceTwo of the chamfer. This distance 
        is along the face which is on the right of the selected edge.
        If the ValueInput uses a real then it is interpreted as centimeters.
        If it is a string then the units can be defined as part of the string (i.e. '2 in').
        If no units are specified it is interpreted using the current default units for length. 
        Returns true if the feature is successfully changed
        """
        return _fusion.ChamferFeature_setTwoDistances(self, distanceOne, distanceTwo)

    def setDistanceAndAngle(self, distance: "ValueInput", angle: "ValueInput") -> "bool":
        r"""
        Changes the type of chamfer to be a distance and angle chamfer. 
        distance : A ValueInput object that defines the distance of the chamfer. This distance 
        is along the face which is on the right of the selected edge.
        If the ValueInput uses a real then it is interpreted as centimeters.
        If it is a string then the units can be defined as part of the string (i.e. '2 in').
        If no units are specified it is interpreted using the current default units for length. 
        angle : A valueInput object that defines the angle. The direction will be towards to the face 
        which is on the left of the selected edge. This can be a string or a value.
        If it's a string it is interpreted using the current document units and can include
        equations. For example all of the following are valid as long as they result in
        angle units; '45', '45 deg', 'a1 / 2'. If a value is input it is interpreted
        as radians. 
        It cannot be negative. 
        Returns true if the feature is successfully changed
        """
        return _fusion.ChamferFeature_setDistanceAndAngle(self, distance, angle)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ChamferFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ChamferFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::ChamferFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ChamferFeature_createForAssemblyContext(self, occurrence)

    def _get_cornerType(self) -> "adsk::fusion::ChamferCornerTypes":
        r"""Gets and sets the type of corner to be modeled when multiple edges connect at a vertex."""
        return _fusion.ChamferFeature__get_cornerType(self)

    def _set_cornerType(self, value: "ChamferCornerTypes") -> "bool":
        r"""Gets and sets the type of corner to be modeled when multiple edges connect at a vertex."""
        return _fusion.ChamferFeature__set_cornerType(self, value)

    def _get_edgeSets(self) -> "adsk::core::Ptr< adsk::fusion::ChamferEdgeSets >":
        r"""Returns the edge sets associated with this chamfer."""
        return _fusion.ChamferFeature__get_edgeSets(self)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ChamferFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ChamferFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ChamferFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.ChamferFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ChamferFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ChamferFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.ChamferFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.ChamferFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.ChamferFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.ChamferFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ChamferFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.ChamferFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.ChamferFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.ChamferFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ChamferFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.ChamferFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ChamferFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.ChamferFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ChamferFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ChamferFeature__get_isValid(self)

# Register ChamferFeature in _fusion:
_fusion.ChamferFeature_swigregister(ChamferFeature)

def ChamferFeature_classType() -> "char const *":
    return _fusion.ChamferFeature_classType()


ChamferFeature.edges = property(ChamferFeature._get_edges, ChamferFeature._set_edges, doc="Gets and sets the edges being chamfered. Specific edges can be defined using one or more BRepEdge\nobjects or BRepFace objects can be used to chamfer all edges of the face or Feature objects can\nbe used to chamfer all edges associated with the input features. If BRepEdge objects are provided\nand the isTangentChain argument is true additional edges may also get chamfered if they are\ntangentially connected to any of the input edges. When getting the property, your\ncode should check for the different types in the returned collection and handle it appropriately.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)\nThis property returns nothing in the case where the feature is non-parametric.")


ChamferFeature.isTangentChain = property(ChamferFeature._get_isTangentChain, ChamferFeature._set_isTangentChain, doc="Gets and sets whether or not edges that are tangentially connected to\nthe input edges (if any) will also be chamfered.")


ChamferFeature.chamferType = property(ChamferFeature._get_chamferType, doc="Gets an enum indicating how the chamfer was defined. The valid return values are\nEqualDistanceType, TwoDistancesType and DistanceAndAngleType.\nThis property returns nothing in the case where the feature is non-parametric.")


ChamferFeature.chamferTypeDefinition = property(ChamferFeature._get_chamferTypeDefinition, doc="Gets the definition object that is defining the type of chamfer. Modifying the\ndefinition object will cause the chamfer to recompute. Various types of definition objects can\nbe returned depending on how the chamfer is defined. The ChamferType property can\nbe used to determine which type of definition will be returned.\nThis property returns nothing in the case where the feature is non-parametric.")


ChamferFeature.nativeObject = property(ChamferFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


ChamferFeature.cornerType = property(ChamferFeature._get_cornerType, ChamferFeature._set_cornerType, doc="Gets and sets the type of corner to be modeled when multiple edges connect at a vertex.")


ChamferFeature.edgeSets = property(ChamferFeature._get_edgeSets, doc="Returns the edge sets associated with this chamfer.")


ChamferFeature.cast = lambda arg: arg if isinstance(arg, ChamferFeature) else None

class ChordLengthFilletEdgeSet(FilletEdgeSet):
    r"""Provides access to the edges and the parameter associated with a chord length fillet."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ChordLengthFilletEdgeSet *":
        return _fusion.ChordLengthFilletEdgeSet___deref__(self)

    def __eq__(self, rhs: "ChordLengthFilletEdgeSet") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ChordLengthFilletEdgeSet___eq__(self, rhs)


    def __ne__(self, rhs: "ChordLengthFilletEdgeSet") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ChordLengthFilletEdgeSet___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ChordLengthFilletEdgeSet_classType()
    __swig_destroy__ = _fusion.delete_ChordLengthFilletEdgeSet

    def _get_edges(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the edges that will be filleted. 
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ChordLengthFilletEdgeSet__get_edges(self)

    def _set_edges(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the edges that will be filleted. 
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ChordLengthFilletEdgeSet__set_edges(self, value)

    def _get_chordLength(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the model parameter that controls the chord length of the fillet. You can edit
        the chord length by using the properties on the returned ModelParameter object.
        """
        return _fusion.ChordLengthFilletEdgeSet__get_chordLength(self)

    def _get_isTangentChain(self) -> "bool":
        r"""Gets and sets the Tangent chain for fillet. This enables tangent chain option for fillet."""
        return _fusion.ChordLengthFilletEdgeSet__get_isTangentChain(self)

    def _set_isTangentChain(self, value: "bool") -> "bool":
        r"""Gets and sets the Tangent chain for fillet. This enables tangent chain option for fillet."""
        return _fusion.ChordLengthFilletEdgeSet__set_isTangentChain(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.ChordLengthFilletEdgeSet__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ChordLengthFilletEdgeSet__get_isValid(self)

# Register ChordLengthFilletEdgeSet in _fusion:
_fusion.ChordLengthFilletEdgeSet_swigregister(ChordLengthFilletEdgeSet)

def ChordLengthFilletEdgeSet_classType() -> "char const *":
    return _fusion.ChordLengthFilletEdgeSet_classType()


ChordLengthFilletEdgeSet.edges = property(ChordLengthFilletEdgeSet._get_edges, ChordLengthFilletEdgeSet._set_edges, doc="Gets and sets the edges that will be filleted.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ChordLengthFilletEdgeSet.chordLength = property(ChordLengthFilletEdgeSet._get_chordLength, doc="Returns the model parameter that controls the chord length of the fillet. You can edit\nthe chord length by using the properties on the returned ModelParameter object.")


ChordLengthFilletEdgeSet.cast = lambda arg: arg if isinstance(arg, ChordLengthFilletEdgeSet) else None

class CircularPatternConstraint(GeometricConstraint):
    r"""A circular pattern constraint in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CircularPatternConstraint *":
        return _fusion.CircularPatternConstraint___deref__(self)

    def __eq__(self, rhs: "CircularPatternConstraint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CircularPatternConstraint___eq__(self, rhs)


    def __ne__(self, rhs: "CircularPatternConstraint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CircularPatternConstraint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CircularPatternConstraint_classType()
    __swig_destroy__ = _fusion.delete_CircularPatternConstraint

    def deleteMe(self) -> "bool":
        r"""
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.CircularPatternConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this constraint is deletable."""
        return _fusion.CircularPatternConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.CircularPatternConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.CircularPatternConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.CircularPatternConstraint__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the GeometricConstraint object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same geometric constraint.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.CircularPatternConstraint__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.CircularPatternConstraint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CircularPatternConstraint__get_isValid(self)

# Register CircularPatternConstraint in _fusion:
_fusion.CircularPatternConstraint_swigregister(CircularPatternConstraint)

def CircularPatternConstraint_classType() -> "char const *":
    return _fusion.CircularPatternConstraint_classType()


CircularPatternConstraint.cast = lambda arg: arg if isinstance(arg, CircularPatternConstraint) else None

class CircularPatternFeature(Feature):
    r"""Object that represents an existing circular pattern feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CircularPatternFeature *":
        return _fusion.CircularPatternFeature___deref__(self)

    def __eq__(self, rhs: "CircularPatternFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CircularPatternFeature___eq__(self, rhs)


    def __ne__(self, rhs: "CircularPatternFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CircularPatternFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CircularPatternFeature_classType()
    __swig_destroy__ = _fusion.delete_CircularPatternFeature

    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.CircularPatternFeature__get_inputEntities(self)

    def _set_inputEntities(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.CircularPatternFeature__set_inputEntities(self, value)

    def _get_axis(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the axis of circular pattern. This can be a sketch line, linear edge,
        construction axis, an edge/sketch curve that defines an axis (circle, etc.) or a face that defines an axis (cylinder, cone, torus, etc.).
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.CircularPatternFeature__get_axis(self)

    def _set_axis(self, value: "Base") -> "bool":
        r"""
        Gets and sets the axis of circular pattern. This can be a sketch line, linear edge,
        construction axis, an edge/sketch curve that defines an axis (circle, etc.) or a face that defines an axis (cylinder, cone, torus, etc.).
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.CircularPatternFeature__set_axis(self, value)

    def _get_totalAngle(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the parameter controlling the total angle.
        To edit the angle use properties on the parameter to edit its value.
        This property returns null in the case where the feature is non-parametric.
        A negative value can be used to change the direction of the pattern.
        """
        return _fusion.CircularPatternFeature__get_totalAngle(self)

    def _get_isSymmetric(self) -> "bool":
        r"""
        Gets and sets if the angle extent is in one direction or symmetric.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.CircularPatternFeature__get_isSymmetric(self)

    def _set_isSymmetric(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the angle extent is in one direction or symmetric.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.CircularPatternFeature__set_isSymmetric(self, value)

    def _get_quantity(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the parameter controlling the number of pattern elements, including any suppressed elements.
        To edit the quantity use properties on the parameter to edit its value.
        This property returns null in the case where the feature is non-parametric.
        """
        return _fusion.CircularPatternFeature__get_quantity(self)

    def _get_suppressedElementsIds(self) -> "std::vector< size_t,std::allocator< size_t > >":
        r"""
        Gets and sets the id's of the elements to suppress.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.CircularPatternFeature__get_suppressedElementsIds(self)

    def _set_suppressedElementsIds(self, value: "UintVector") -> "bool":
        r"""
        Gets and sets the id's of the elements to suppress.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.CircularPatternFeature__set_suppressedElementsIds(self, value)

    def _get_patternElements(self) -> "adsk::core::Ptr< adsk::fusion::PatternElements >":
        r"""Gets the PatternElements collection that contains the elements created by this pattern."""
        return _fusion.CircularPatternFeature__get_patternElements(self)

    def _get_resultFeatures(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Returns the features that were created as a result of this pattern.
        This is only valid for a direct edit model and this returns null 
        in the case where the feature is parametric.
        """
        return _fusion.CircularPatternFeature__get_resultFeatures(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::CircularPatternFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.CircularPatternFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::CircularPatternFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.CircularPatternFeature_createForAssemblyContext(self, occurrence)

    def _get_patternEntityType(self) -> "adsk::fusion::PatternEntityTypes":
        r"""
        Returns the type of entities the pattern consists of. This can be used to help
        determine the type of results that will be found in the pattern elements.
        """
        return _fusion.CircularPatternFeature__get_patternEntityType(self)

    def _get_patternComputeOption(self) -> "adsk::fusion::PatternComputeOptions":
        r"""
        Gets and sets the compute option for this pattern feature.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.CircularPatternFeature__get_patternComputeOption(self)

    def _set_patternComputeOption(self, value: "PatternComputeOptions") -> "bool":
        r"""
        Gets and sets the compute option for this pattern feature.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.CircularPatternFeature__set_patternComputeOption(self, value)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CircularPatternFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CircularPatternFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.CircularPatternFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.CircularPatternFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CircularPatternFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CircularPatternFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.CircularPatternFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.CircularPatternFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.CircularPatternFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.CircularPatternFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.CircularPatternFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.CircularPatternFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.CircularPatternFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.CircularPatternFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.CircularPatternFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.CircularPatternFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.CircularPatternFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.CircularPatternFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.CircularPatternFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CircularPatternFeature__get_isValid(self)

# Register CircularPatternFeature in _fusion:
_fusion.CircularPatternFeature_swigregister(CircularPatternFeature)

def CircularPatternFeature_classType() -> "char const *":
    return _fusion.CircularPatternFeature_classType()


CircularPatternFeature.inputEntities = property(CircularPatternFeature._get_inputEntities, CircularPatternFeature._set_inputEntities, doc="Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.\nAll of the entities must be of a single type. For example, it can't contain features and occurrences\nbut only features or occurrences.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


CircularPatternFeature.axis = property(CircularPatternFeature._get_axis, CircularPatternFeature._set_axis, doc="Gets and sets the axis of circular pattern. This can be a sketch line, linear edge,\nconstruction axis, an edge/sketch curve that defines an axis (circle, etc.) or a face that defines an axis (cylinder, cone, torus, etc.).\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


CircularPatternFeature.totalAngle = property(CircularPatternFeature._get_totalAngle, doc="Returns the parameter controlling the total angle.\nTo edit the angle use properties on the parameter to edit its value.\nThis property returns null in the case where the feature is non-parametric.\nA negative value can be used to change the direction of the pattern.")


CircularPatternFeature.isSymmetric = property(CircularPatternFeature._get_isSymmetric, CircularPatternFeature._set_isSymmetric, doc="Gets and sets if the angle extent is in one direction or symmetric.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


CircularPatternFeature.quantity = property(CircularPatternFeature._get_quantity, doc="Returns the parameter controlling the number of pattern elements, including any suppressed elements.\nTo edit the quantity use properties on the parameter to edit its value.\nThis property returns null in the case where the feature is non-parametric.")


CircularPatternFeature.suppressedElementsIds = property(CircularPatternFeature._get_suppressedElementsIds, CircularPatternFeature._set_suppressedElementsIds, doc="Gets and sets the id's of the elements to suppress.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


CircularPatternFeature.patternElements = property(CircularPatternFeature._get_patternElements, doc="Gets the PatternElements collection that contains the elements created by this pattern.")


CircularPatternFeature.resultFeatures = property(CircularPatternFeature._get_resultFeatures, doc="Returns the features that were created as a result of this pattern.\nThis is only valid for a direct edit model and this returns null\nin the case where the feature is parametric.")


CircularPatternFeature.nativeObject = property(CircularPatternFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


CircularPatternFeature.patternEntityType = property(CircularPatternFeature._get_patternEntityType, doc="Returns the type of entities the pattern consists of. This can be used to help\ndetermine the type of results that will be found in the pattern elements.")


CircularPatternFeature.patternComputeOption = property(CircularPatternFeature._get_patternComputeOption, CircularPatternFeature._set_patternComputeOption, doc="Gets and sets the compute option for this pattern feature.\nThis property only applies when patterning features and is ignored in the direct modeling environment.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


CircularPatternFeature.cast = lambda arg: arg if isinstance(arg, CircularPatternFeature) else None

class CoilFeature(Feature):
    r"""Object that represents an existing coil primitive feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CoilFeature *":
        return _fusion.CoilFeature___deref__(self)

    def __eq__(self, rhs: "CoilFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CoilFeature___eq__(self, rhs)


    def __ne__(self, rhs: "CoilFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CoilFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CoilFeature_classType()
    __swig_destroy__ = _fusion.delete_CoilFeature

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CoilFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CoilFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.CoilFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.CoilFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CoilFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CoilFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.CoilFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.CoilFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.CoilFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.CoilFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.CoilFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.CoilFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.CoilFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.CoilFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.CoilFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.CoilFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.CoilFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.CoilFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.CoilFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CoilFeature__get_isValid(self)

# Register CoilFeature in _fusion:
_fusion.CoilFeature_swigregister(CoilFeature)

def CoilFeature_classType() -> "char const *":
    return _fusion.CoilFeature_classType()


CoilFeature.cast = lambda arg: arg if isinstance(arg, CoilFeature) else None

class CoincidentConstraint(GeometricConstraint):
    r"""A coincident constraint in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CoincidentConstraint *":
        return _fusion.CoincidentConstraint___deref__(self)

    def __eq__(self, rhs: "CoincidentConstraint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CoincidentConstraint___eq__(self, rhs)


    def __ne__(self, rhs: "CoincidentConstraint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CoincidentConstraint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CoincidentConstraint_classType()
    __swig_destroy__ = _fusion.delete_CoincidentConstraint

    def _get_point(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""Returns the sketch point that is constrained."""
        return _fusion.CoincidentConstraint__get_point(self)

    def _get_entity(self) -> "adsk::core::Ptr< adsk::fusion::SketchEntity >":
        r"""The sketch curve or point the point is constrained to."""
        return _fusion.CoincidentConstraint__get_entity(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::CoincidentConstraint >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.CoincidentConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::CoincidentConstraint >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.CoincidentConstraint_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.CoincidentConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this constraint is deletable."""
        return _fusion.CoincidentConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.CoincidentConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.CoincidentConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.CoincidentConstraint__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the GeometricConstraint object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same geometric constraint.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.CoincidentConstraint__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.CoincidentConstraint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CoincidentConstraint__get_isValid(self)

# Register CoincidentConstraint in _fusion:
_fusion.CoincidentConstraint_swigregister(CoincidentConstraint)

def CoincidentConstraint_classType() -> "char const *":
    return _fusion.CoincidentConstraint_classType()


CoincidentConstraint.point = property(CoincidentConstraint._get_point, doc="Returns the sketch point that is constrained.")


CoincidentConstraint.entity = property(CoincidentConstraint._get_entity, doc="The sketch curve or point the point is constrained to.")


CoincidentConstraint.nativeObject = property(CoincidentConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


CoincidentConstraint.cast = lambda arg: arg if isinstance(arg, CoincidentConstraint) else None

class CollinearConstraint(GeometricConstraint):
    r"""A collinear constraint in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CollinearConstraint *":
        return _fusion.CollinearConstraint___deref__(self)

    def __eq__(self, rhs: "CollinearConstraint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CollinearConstraint___eq__(self, rhs)


    def __ne__(self, rhs: "CollinearConstraint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CollinearConstraint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CollinearConstraint_classType()
    __swig_destroy__ = _fusion.delete_CollinearConstraint

    def _get_lineOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""Returns the first line."""
        return _fusion.CollinearConstraint__get_lineOne(self)

    def _get_lineTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""Returns the second line."""
        return _fusion.CollinearConstraint__get_lineTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::CollinearConstraint >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.CollinearConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::CollinearConstraint >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.CollinearConstraint_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.CollinearConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this constraint is deletable."""
        return _fusion.CollinearConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.CollinearConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.CollinearConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.CollinearConstraint__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the GeometricConstraint object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same geometric constraint.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.CollinearConstraint__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.CollinearConstraint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CollinearConstraint__get_isValid(self)

# Register CollinearConstraint in _fusion:
_fusion.CollinearConstraint_swigregister(CollinearConstraint)

def CollinearConstraint_classType() -> "char const *":
    return _fusion.CollinearConstraint_classType()


CollinearConstraint.lineOne = property(CollinearConstraint._get_lineOne, doc="Returns the first line.")


CollinearConstraint.lineTwo = property(CollinearConstraint._get_lineTwo, doc="Returns the second line.")


CollinearConstraint.nativeObject = property(CollinearConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


CollinearConstraint.cast = lambda arg: arg if isinstance(arg, CollinearConstraint) else None

class CombineFeature(Feature):
    r"""
    Object that represents an existing Combine feature in a design. 
    In non-parametric environment this object does not exist.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CombineFeature *":
        return _fusion.CombineFeature___deref__(self)

    def __eq__(self, rhs: "CombineFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CombineFeature___eq__(self, rhs)


    def __ne__(self, rhs: "CombineFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CombineFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CombineFeature_classType()
    __swig_destroy__ = _fusion.delete_CombineFeature

    def _get_targetBody(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Gets and sets the BRep Body object that represents the blank body.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.CombineFeature__get_targetBody(self)

    def _set_targetBody(self, value: "BRepBody") -> "bool":
        r"""
        Gets and sets the BRep Body object that represents the blank body.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.CombineFeature__set_targetBody(self, value)

    def _get_toolBodies(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the BRep Body objects that represent the tool bodies.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.CombineFeature__get_toolBodies(self)

    def _set_toolBodies(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the BRep Body objects that represent the tool bodies.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.CombineFeature__set_toolBodies(self, value)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations":
        r"""
        Gets and sets the type of operation performed by the combine.
        The valid values are JoinFeatureOperation, CutFeatureOperation and IntersectFeatureOperation.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.CombineFeature__get_operation(self)

    def _set_operation(self, value: "FeatureOperations") -> "bool":
        r"""
        Gets and sets the type of operation performed by the combine.
        The valid values are JoinFeatureOperation, CutFeatureOperation and IntersectFeatureOperation.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.CombineFeature__set_operation(self, value)

    def _get_isNewComponent(self) -> "bool":
        r"""Gets a boolean value for whether or not a new component was created when this feature was created."""
        return _fusion.CombineFeature__get_isNewComponent(self)

    def _get_isKeepToolBodies(self) -> "bool":
        r"""
        Gets and sets a boolean value for whether or not the tool bodies are retrained after the combine results.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.CombineFeature__get_isKeepToolBodies(self)

    def _set_isKeepToolBodies(self, value: "bool") -> "bool":
        r"""
        Gets and sets a boolean value for whether or not the tool bodies are retrained after the combine results.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.CombineFeature__set_isKeepToolBodies(self, value)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::CombineFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.CombineFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::CombineFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.CombineFeature_createForAssemblyContext(self, occurrence)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CombineFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CombineFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.CombineFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.CombineFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CombineFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CombineFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.CombineFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.CombineFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.CombineFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.CombineFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.CombineFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.CombineFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.CombineFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.CombineFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.CombineFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.CombineFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.CombineFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.CombineFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.CombineFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CombineFeature__get_isValid(self)

# Register CombineFeature in _fusion:
_fusion.CombineFeature_swigregister(CombineFeature)

def CombineFeature_classType() -> "char const *":
    return _fusion.CombineFeature_classType()


CombineFeature.targetBody = property(CombineFeature._get_targetBody, CombineFeature._set_targetBody, doc="Gets and sets the BRep Body object that represents the blank body.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


CombineFeature.toolBodies = property(CombineFeature._get_toolBodies, CombineFeature._set_toolBodies, doc="Gets and sets the BRep Body objects that represent the tool bodies.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


CombineFeature.operation = property(CombineFeature._get_operation, CombineFeature._set_operation, doc="Gets and sets the type of operation performed by the combine.\nThe valid values are JoinFeatureOperation, CutFeatureOperation and IntersectFeatureOperation.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


CombineFeature.isNewComponent = property(CombineFeature._get_isNewComponent, doc="Gets a boolean value for whether or not a new component was created when this feature was created.")


CombineFeature.isKeepToolBodies = property(CombineFeature._get_isKeepToolBodies, CombineFeature._set_isKeepToolBodies, doc="Gets and sets a boolean value for whether or not the tool bodies are retrained after the combine results.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


CombineFeature.nativeObject = property(CombineFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


CombineFeature.cast = lambda arg: arg if isinstance(arg, CombineFeature) else None

class Component(BaseComponent):
    r"""
    Represents a component in the data model.
    A component represents a set of geometry, features, and parameters that make up an item in the design.
    A component can be referenced multiple times into a design with a Occurrence object.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::Component *":
        return _fusion.Component___deref__(self)

    def __eq__(self, rhs: "Component") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.Component___eq__(self, rhs)


    def __ne__(self, rhs: "Component") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.Component___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.Component_classType()
    __swig_destroy__ = _fusion.delete_Component

    def _get_sketches(self) -> "adsk::core::Ptr< adsk::fusion::Sketches >":
        r"""
        Returns the sketches collection associated with this component.
        This provides access to the existing sketches and supports
        the creation of new sketches.
        """
        return _fusion.Component__get_sketches(self)

    def _get_features(self) -> "adsk::core::Ptr< adsk::fusion::Features >":
        r"""
        Returns the collection that provides access to all of the features
        associated with this component.
        """
        return _fusion.Component__get_features(self)

    def _get_meshBodies(self) -> "adsk::core::Ptr< adsk::fusion::MeshBodies >":
        r"""Returns the mesh bodies collection associated with this component."""
        return _fusion.Component__get_meshBodies(self)

    def _get_modelParameters(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameters >":
        r"""Returns the collection of model parameters in the Component."""
        return _fusion.Component__get_modelParameters(self)

    def _get_isOriginFolderLightBulbOn(self) -> "bool":
        r"""
        Gets and sets if the light bulb of the origin folder as seen in the browser is on or off.
        This controls the visibility of the origin construction geometry.
        """
        return _fusion.Component__get_isOriginFolderLightBulbOn(self)

    def _set_isOriginFolderLightBulbOn(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the light bulb of the origin folder as seen in the browser is on or off.
        This controls the visibility of the origin construction geometry.
        """
        return _fusion.Component__set_isOriginFolderLightBulbOn(self, value)

    def _get_isConstructionFolderLightBulbOn(self) -> "bool":
        r"""
        Gets and sets if the light bulb of the construction folder as seen in the browser is on or off.
        This controls the visibility of the (non-origin) construction geometry 
        (i.e. planes, points, axes).
        """
        return _fusion.Component__get_isConstructionFolderLightBulbOn(self)

    def _set_isConstructionFolderLightBulbOn(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the light bulb of the construction folder as seen in the browser is on or off.
        This controls the visibility of the (non-origin) construction geometry 
        (i.e. planes, points, axes).
        """
        return _fusion.Component__set_isConstructionFolderLightBulbOn(self, value)

    def _get_isSketchFolderLightBulbOn(self) -> "bool":
        r"""
        Gets and sets if the light bulb of the sketch folder as seen in the browser is on or off.
        This controls the visibility of the sketches in this component.
        """
        return _fusion.Component__get_isSketchFolderLightBulbOn(self)

    def _set_isSketchFolderLightBulbOn(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the light bulb of the sketch folder as seen in the browser is on or off.
        This controls the visibility of the sketches in this component.
        """
        return _fusion.Component__set_isSketchFolderLightBulbOn(self, value)

    def _get_xYConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >":
        r"""Returns the XY origin construction plane."""
        return _fusion.Component__get_xYConstructionPlane(self)

    def _get_xZConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >":
        r"""Returns the XZ origin construction plane."""
        return _fusion.Component__get_xZConstructionPlane(self)

    def _get_yZConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >":
        r"""Returns the YZ origin construction plane."""
        return _fusion.Component__get_yZConstructionPlane(self)

    def _get_xConstructionAxis(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >":
        r"""Returns the X origin construction axis."""
        return _fusion.Component__get_xConstructionAxis(self)

    def _get_yConstructionAxis(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >":
        r"""Returns the Y origin construction axis."""
        return _fusion.Component__get_yConstructionAxis(self)

    def _get_zConstructionAxis(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >":
        r"""Returns the Z origin construction axis."""
        return _fusion.Component__get_zConstructionAxis(self)

    def _get_originConstructionPoint(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >":
        r"""Returns the origin construction point."""
        return _fusion.Component__get_originConstructionPoint(self)

    def _get_partNumber(self) -> "std::string":
        r"""
        Gets and sets the part number associated with this component. Setting this
        to an empty string will reset it to be the same as the component name.
        """
        return _fusion.Component__get_partNumber(self)

    def _set_partNumber(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the part number associated with this component. Setting this
        to an empty string will reset it to be the same as the component name.
        """
        return _fusion.Component__set_partNumber(self, value)

    def _get_description(self) -> "std::string":
        r"""Gets and sets the description associated with this component."""
        return _fusion.Component__get_description(self)

    def _set_description(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the description associated with this component."""
        return _fusion.Component__set_description(self, value)

    def createOpenProfile(self, curves: "Base", chainCurves: "bool"=True) -> "adsk::core::Ptr< adsk::fusion::Profile >":
        r"""
        Creates an open profile based on the input curve(s). 
        curves : A SketchCurve or an ObjectCollection containing multiple sketch entities. If a single sketch curve
        is input the chainCurves argument is checked to determine if connected curves (they do not need to be tangent)
        should be automatically found. If multiple curves are provided the chainCurves argument is always
        treated as false so you must provide all of the curves in the object collection that you want included in the profile.
        The provided curves must all connect together in a single path.
        The input curves do not need to be in the same sketch, but they do need to geometrically connect for
        a valid profile to be created. 
        chainCurves : If true, this finds any curves within the same sketch that connect to the single input curve and automatically includes them in the profile. If 
        false, only the curves provided will be used to define the profile. This argument is ignored and treated as false if multiple curves are input. 
        Returns the new Profile object or null in the case of a failure.
        """
        return _fusion.Component_createOpenProfile(self, curves, chainCurves)

    def createBRepEdgeProfile(self, edges: "Base", chainEdges: "bool"=True) -> "adsk::core::Ptr< adsk::fusion::Profile >":
        r"""
        Creates a profile based on the outside open edges of a BRepFace. 
        edges : A single BRepEdge object or an ObjectCollection containing multiple BRepEdge objects, or a BRepLoop object. If a single edge
        is input, the chainEdges argument is checked to determine if connected edges (they do not need to be tangent)
        should be automatically found. If multiple edges are provided the chainEdges argument is always
        treated as false so you must provide all of the edges in the object collection that you want included in the profile. 
        and the edges must all connect together in a single path. if a BRepLoop object is provided, all of the edges in the loop
        are included in the profile and the chainEdges argument is ignored. 
        chainEdges : If true, this finds any edges that connect to the single input edge and automatically includes them in the profile. If 
        false, only the edges provided will be used to define the profile. This argument is ignored and treated as false if multipled edges 
        or a BRepLoop is input. 
        Returns the new Profile object or null in the case of a failure.
        """
        return _fusion.Component_createBRepEdgeProfile(self, edges, chainEdges)

    def _get_joints(self) -> "adsk::core::Ptr< adsk::fusion::Joints >":
        r"""Returns the collection of joints associated with this component."""
        return _fusion.Component__get_joints(self)

    def _get_jointOrgins(self) -> "adsk::core::Ptr< adsk::fusion::JointOrigins >":
        r"""
        This property was incorrectly spelled and has been replaced with the JointOrigins property.
        However, this needs to remain in the implementation to continue to support programs that
        already used it, but it will be hidden in the documentation.
        """
        return _fusion.Component__get_jointOrgins(self)

    def _get_asBuiltJoints(self) -> "adsk::core::Ptr< adsk::fusion::AsBuiltJoints >":
        r"""Returns the collection of as-built joints associated with this component."""
        return _fusion.Component__get_asBuiltJoints(self)

    def _get_rigidGroups(self) -> "adsk::core::Ptr< adsk::fusion::RigidGroups >":
        r"""Returns the collection of rigid groups associated with this component."""
        return _fusion.Component__get_rigidGroups(self)

    def _get_material(self) -> "adsk::core::Ptr< adsk::core::Material >":
        r"""Gets and sets the physical material assigned to this component."""
        return _fusion.Component__get_material(self)

    def _set_material(self, value: "Material") -> "bool":
        r"""Gets and sets the physical material assigned to this component."""
        return _fusion.Component__set_material(self, value)

    def _get_physicalProperties(self) -> "adsk::core::Ptr< adsk::fusion::PhysicalProperties >":
        r"""
        Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc 
        of this component. Property values will be calulated using the 'LowCalculationAccuracy' setting when using this property
        to get the PhysicalProperties object. To specify a higher calculation tolerance, use the getPhysicalProperties method instead.
        """
        return _fusion.Component__get_physicalProperties(self)

    def saveCopyAs(self, name: "std::string const &", dataFolder: "DataFolder", description: "std::string const &", tag: "std::string const &") -> "adsk::core::Ptr< adsk::core::DataFileFuture >":
        r"""
        Performs a Save Copy As on this component. This saves the specified component as a new document 
        in the specified location. 
        name : The name to use for the new document. If this is an empty string, Fusion 360 will use the 
        name of the component being saved. 
        dataFolder : The data folder to save the new document to. 
        description : The description string of the document. This can be an empty string. 
        tag : The tag string of the document. This can be an empty string. 
        Returns a DataFileFuture object that can be used to track the progress of the upload and get the
        resulting DataFile once it's available on A360.
        """
        return _fusion.Component_saveCopyAs(self, name, dataFolder, description, tag)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the bounding box of this component. This is always in world space of the component."""
        return _fusion.Component__get_boundingBox(self)

    def _get_isJointsFolderLightBulbOn(self) -> "bool":
        r"""
        Gets and sets if the light bulb of the joints folder as seen in the browser is on or off.
        This controls the visibility of the joints in this occurrence. The light bulb for the 
        folder is component specific and will turn off the joints for all occurrences referencing 
        the component.
        """
        return _fusion.Component__get_isJointsFolderLightBulbOn(self)

    def _set_isJointsFolderLightBulbOn(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the light bulb of the joints folder as seen in the browser is on or off.
        This controls the visibility of the joints in this occurrence. The light bulb for the 
        folder is component specific and will turn off the joints for all occurrences referencing 
        the component.
        """
        return _fusion.Component__set_isJointsFolderLightBulbOn(self, value)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.Component__get_attributes(self)

    def _get_isBodiesFolderLightBulbOn(self) -> "bool":
        r"""
        Gets and sets if the light bulb of the bodies folder as seen in the browser is on or off.
        This controls the visibility of the solid/surface bodies and the mesh bodies in this component.
        """
        return _fusion.Component__get_isBodiesFolderLightBulbOn(self)

    def _set_isBodiesFolderLightBulbOn(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the light bulb of the bodies folder as seen in the browser is on or off.
        This controls the visibility of the solid/surface bodies and the mesh bodies in this component.
        """
        return _fusion.Component__set_isBodiesFolderLightBulbOn(self, value)

    def getPhysicalProperties(self, *args) -> "adsk::core::Ptr< adsk::fusion::PhysicalProperties >":
        r"""
        Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc 
        of this component. 
        accuracy : Specifies the desired level of computational accuracy of the property calculations.
        The default value of 'LowCalculationAccuracy' returns results within a +/- 1% error margin.
        """
        return _fusion.Component_getPhysicalProperties(self, *args)

    def transformOccurrences(self, occurrences: "OccurrenceVector", transforms: "Matrix3DVector", ignoreJoints: "bool") -> "bool":
        r"""
        Transforms a set of occurrences in one step. This provides better performance than transforming them one at a time.
        This method is only valid when called on the root component because Fusion 360 flattens the entire assembly structure
        when manipulating the assembly so all transforms are relative to the root component. 
        occurrences : An array of Occurrence objects that you want to transform. These must all be in the context of the root component which
        means proxies must be used for occurrences that are in sub-components. 
        transforms : An array of Matrix3D objects that defines the transform to apply to each occurrence. This array must be the same size
        as the array provided for the occurrences argument and the transform will be applied to the occurrence at the same index
        in the occurrences array. 
        ignoreJoints : Specifies if the joints are to be ignored and the occurrences are to be positioned based on then specified transform or if
        the joints should be used and the occurrence is transformed the best it can while still honoring the joints. 
        Returns true if the transform was successful.
        """
        return _fusion.Component_transformOccurrences(self, occurrences, transforms, ignoreJoints)

    def _get_allJoints(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint >,std::allocator< adsk::core::Ptr< adsk::fusion::Joint > > >":
        r"""
        Returns all joints in this component and any sub components. The joints returned are all in the context
        of this component so any joints in sub components will be proxies. This is primarily useful when used
        from the root component because Fusion 360 flattens the assembly structure, including joints, when manipulating
        an assembly.
        """
        return _fusion.Component__get_allJoints(self)

    def _get_allAsBuiltJoints(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint >,std::allocator< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > > >":
        r"""
        Returns all joint origins in this component and any sub components. The joint origins returned are all in the context
        of this component so any joint origins in sub components will be proxies. This is primarily useful when used
        from the root component because Fusion 360 flattens the assembly structure, including joint origins, when manipulating
        an assembly.
        """
        return _fusion.Component__get_allAsBuiltJoints(self)

    def _get_allJointOrigins(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin >,std::allocator< adsk::core::Ptr< adsk::fusion::JointOrigin > > >":
        r"""
        Returns all as-built joints in this component and any sub components. The as-built joints returned are all in the context
        of this component so any as-built joints in sub components will be proxies. This is primarily useful when used
        from the root component because Fusion 360 flattens the assembly structure, including as-built joints, when manipulating
        an assembly.
        """
        return _fusion.Component__get_allJointOrigins(self)

    def _get_allRigidGroups(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup >,std::allocator< adsk::core::Ptr< adsk::fusion::RigidGroup > > >":
        r"""
        Returns all rigid groups in this component and any sub components. The rigid groups returned are all in the context
        of this component so any rigid groups in sub components will be proxies. This is primarily useful when used
        from the root component because Fusion 360 flattens the assembly structure, including rigid groups, when manipulating
        an assembly.
        """
        return _fusion.Component__get_allRigidGroups(self)

    def _get_opacity(self) -> "double":
        r"""
        Gets and sets the opacity override assigned to this component. A value of 1.0 specifies
        that is it completely opaque and a value of 0.0 specifies that is it completely transparent.
        This is only applicable for a non-root local component.
        This value is not necessarily related to what the user sees because the opacity is inherited.
        For example, if you have TopComponent and it has a component in it called SubComponent and you 
        set the opacity of TopComponent to be 0.5, SubComponent will also be shown as slightly transparent
        even though the opacity property for it will return 1.0. Because a component can be referenced as
        an occurrence in other components and they can have different opacity settings, it's possible that
        different instances of the same component can display using different opacity levels. To get the
        opacity that it is being displayed with use the Occurrence.visibleOpacity property.
        """
        return _fusion.Component__get_opacity(self)

    def _set_opacity(self, value: "double") -> "bool":
        r"""
        Gets and sets the opacity override assigned to this component. A value of 1.0 specifies
        that is it completely opaque and a value of 0.0 specifies that is it completely transparent.
        This is only applicable for a non-root local component.
        This value is not necessarily related to what the user sees because the opacity is inherited.
        For example, if you have TopComponent and it has a component in it called SubComponent and you 
        set the opacity of TopComponent to be 0.5, SubComponent will also be shown as slightly transparent
        even though the opacity property for it will return 1.0. Because a component can be referenced as
        an occurrence in other components and they can have different opacity settings, it's possible that
        different instances of the same component can display using different opacity levels. To get the
        opacity that it is being displayed with use the Occurrence.visibleOpacity property.
        """
        return _fusion.Component__set_opacity(self, value)

    def _get_jointOrigins(self) -> "adsk::core::Ptr< adsk::fusion::JointOrigins >":
        r"""Returns the collection of joint origins associated with this component."""
        return _fusion.Component__get_jointOrigins(self)

    def _get_customGraphicsGroups(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsGroups >":
        r"""Returns the customGraphicsGroups object in this component."""
        return _fusion.Component__get_customGraphicsGroups(self)

    def _get_revisionId(self) -> "std::string":
        r"""
        Returns the current revision ID of the component. This ID changes any time the component is modified in any way. By getting
        and saving the ID when you create any data that is dependent on the component, you can then compare the saved
        ID with the current ID to determine if the component has changed to know if you should update your data.
        """
        return _fusion.Component__get_revisionId(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Component object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same component.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.Component__get_entityToken(self)

    def _get_id(self) -> "std::string":
        r"""
        Returns the persistent ID of the component. This ID is created with the component and does not change.
        Because this ID does not change, different revisions of the same design or copies of the design asset/file
        will retain this ID. If components from different designs have the same ID, it indicates they are either 
        different revisions or a copiy of the design was made. Therefore, this ID will always be unique within a 
        single design, but may not be unique in an assembly where externally referenced designs include different 
        revisions or copies of a design.
        The ID is also the same ID used by PIM (Product Information Model).
        """
        return _fusion.Component__get_id(self)

    def _get_name(self) -> "std::string":
        r"""
        Property that gets and sets the name of this component. This is the name
        shown in the browser for each occurrence referencing this component.
        """
        return _fusion.Component__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""
        Property that gets and sets the name of this component. This is the name
        shown in the browser for each occurrence referencing this component.
        """
        return _fusion.Component__set_name(self, value)

    def _get_occurrences(self) -> "adsk::core::Ptr< adsk::fusion::Occurrences >":
        r"""
        Property that returns the Occurrences collection associated with this component.
        This provides access to the occurrences at the top-level of this component and provides
        the functionality to add new occurrences.
        """
        return _fusion.Component__get_occurrences(self)

    def occurrencesByComponent(self, component: "Component") -> "adsk::core::Ptr< adsk::fusion::OccurrenceList >":
        r"""
        Returns all occurrences at the top-level of this component that reference the specified component.
        The returned list is read-only. 
        component : The component that is being referenced by the occurrences that will be returned. 
        The occurrences referenced by the specified component.
        """
        return _fusion.Component_occurrencesByComponent(self, component)

    def _get_allOccurrences(self) -> "adsk::core::Ptr< adsk::fusion::OccurrenceList >":
        r"""
        Returns all of the occurrences in the assembly regardless of their level within the assembly structure.
        The returned list is read-only.
        """
        return _fusion.Component__get_allOccurrences(self)

    def allOccurrencesByComponent(self, component: "Component") -> "adsk::core::Ptr< adsk::fusion::OccurrenceList >":
        r"""
        Returns all occurrences, at any level of the assembly, that reference the specified component.
        The returned list is read-only. 
        component : The component that is being referenced by the occurrences that will be returned. 
        The occurrences referenced by the specified component.
        """
        return _fusion.Component_allOccurrencesByComponent(self, component)

    def _get_constructionPlanes(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlanes >":
        r"""
        Returns the construction planes collection associated with this component.
        This provides access to the existing construction planes and supports
        the creation of new construction planes.
        """
        return _fusion.Component__get_constructionPlanes(self)

    def _get_constructionAxes(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxes >":
        r"""
        Returns the construction axes collection associated with this component.
        This provides access to the existing construction axes and supports
        the creation of new construction axes.
        """
        return _fusion.Component__get_constructionAxes(self)

    def _get_constructionPoints(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoints >":
        r"""
        Returns the construction points collection associated with this component.
        This provides access to the existing construction points and supports
        the creation of new construction points.
        """
        return _fusion.Component__get_constructionPoints(self)

    def _get_bRepBodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""Returns the B-Rep bodies collection associated with this component."""
        return _fusion.Component__get_bRepBodies(self)

    def _get_parentDesign(self) -> "adsk::core::Ptr< adsk::fusion::Design >":
        r"""Returns the parent product this component is owned by."""
        return _fusion.Component__get_parentDesign(self)

    def findBRepUsingRay(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Finds all the B-Rep entities that are intersected by the specified ray. This can return BRepFace, BrepEdge,
        and BRepVertex objects. 
        originPoint : Input point that defines the origin of the ray. The search for entities begins at this point. 
        rayDirection : Input vector that defines the direction of the ray. The ray is infinite so the length of the vector is ignored. 
        entityType : The type of B-Rep entity wanted. You can also take advantage of B-Rep topology to infer other intersections. For example,
        If you get a BRepEdge it implies that the faces the edge connects were also intersected. If a BRepVertex is returned it 
        implies the edges that the vertex connects were intersected and the faces that the edges connect were intersected. 
        proximityTolerance : Optional argument that specifies the tolerance for the search. All entities within this distance from the ray and of the specified type will be returned. If not specified a default small tolerance is used. 
        visibleEntitiesOnly : Optional argument that indicates whether or not invisible entities should be included in the search. Defaults to True indicating that invisible entities will be ignored. 
        hitPoints : An ObjectCollection of Point3D objects that represent the coordinates where the ray hit the found entity. There will be the same number of hit points as returned entities
        and they will be in the collections in the same order. In other words, hit point 1 corresponds with found entity 1, hit point 2 corresponds with found entity 2, and so on.
        Because of the proximity tolerance the hitPoint may not actually lie on the entity but will be within the proximity tolerance to it.
        It's an optional out argument, returns the hit points if an existing ObjectCollection is input. You can create a new ObjectCollection by using
        the static create method on the ObjectCollection class. 
        Returns an ObjectCollection containing the entities found. The returned collection can be empty indicating nothing was found. The points are returned
        in an order where they are arranged based on their distance from the origin point where the closest point is first. If an entity is hit more than
        once, the entity is returned once for the first intersection.
        """
        return _fusion.Component_findBRepUsingRay(self, *args)

    def findBRepUsingPoint(self, point: "Point3D", entityType: "BRepEntityTypes", proximityTolerance: "double"=-1, visibleEntitiesOnly: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Finds all the entities of the specified type at the specified location. 
        point : Input coordinate that specifies the component space point at which to find the entities. 
        entityType : The type of B-Rep entity wanted. You can also take advantage of B-Rep topology to infer other that other entities were found. For example,
        If you get a BRepEdge it implies that the faces the edge connects were also found. If a BRepVertex is returned it 
        implies the edges that the vertex connects were found and the faces that the edges connect were found. 
        proximityTolerance : Specifies the tolerance for the search. All entities within this distance from the search point that match the filter will be returned. If not specified a default tolerance is used. 
        visibleEntitiesOnly : indicates whether or not invisible objects should be included in the search. Defaults to True indicating that invisible objects will be ignored. 
        Returns an ObjectCollection containing the entities found. The returned collection can be empty indicating nothing was found.
        """
        return _fusion.Component_findBRepUsingPoint(self, point, entityType, proximityTolerance, visibleEntitiesOnly)

    def _get_objectType(self) -> "char const *":
        return _fusion.Component__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.Component__get_isValid(self)

# Register Component in _fusion:
_fusion.Component_swigregister(Component)

def Component_classType() -> "char const *":
    return _fusion.Component_classType()


Component.sketches = property(Component._get_sketches, doc="Returns the sketches collection associated with this component.\nThis provides access to the existing sketches and supports\nthe creation of new sketches.")


Component.features = property(Component._get_features, doc="Returns the collection that provides access to all of the features\nassociated with this component.")


Component.meshBodies = property(Component._get_meshBodies, doc="Returns the mesh bodies collection associated with this component.")


Component.modelParameters = property(Component._get_modelParameters, doc="Returns the collection of model parameters in the Component.")


Component.isOriginFolderLightBulbOn = property(Component._get_isOriginFolderLightBulbOn, Component._set_isOriginFolderLightBulbOn, doc="Gets and sets if the light bulb of the origin folder as seen in the browser is on or off.\nThis controls the visibility of the origin construction geometry.")


Component.isConstructionFolderLightBulbOn = property(Component._get_isConstructionFolderLightBulbOn, Component._set_isConstructionFolderLightBulbOn, doc="Gets and sets if the light bulb of the construction folder as seen in the browser is on or off.\nThis controls the visibility of the (non-origin) construction geometry\n(i.e. planes, points, axes).")


Component.isSketchFolderLightBulbOn = property(Component._get_isSketchFolderLightBulbOn, Component._set_isSketchFolderLightBulbOn, doc="Gets and sets if the light bulb of the sketch folder as seen in the browser is on or off.\nThis controls the visibility of the sketches in this component.")


Component.xYConstructionPlane = property(Component._get_xYConstructionPlane, doc="Returns the XY origin construction plane.")


Component.xZConstructionPlane = property(Component._get_xZConstructionPlane, doc="Returns the XZ origin construction plane.")


Component.yZConstructionPlane = property(Component._get_yZConstructionPlane, doc="Returns the YZ origin construction plane.")


Component.xConstructionAxis = property(Component._get_xConstructionAxis, doc="Returns the X origin construction axis.")


Component.yConstructionAxis = property(Component._get_yConstructionAxis, doc="Returns the Y origin construction axis.")


Component.zConstructionAxis = property(Component._get_zConstructionAxis, doc="Returns the Z origin construction axis.")


Component.originConstructionPoint = property(Component._get_originConstructionPoint, doc="Returns the origin construction point.")


Component.partNumber = property(Component._get_partNumber, Component._set_partNumber, doc="Gets and sets the part number associated with this component. Setting this\nto an empty string will reset it to be the same as the component name.")


Component.description = property(Component._get_description, Component._set_description, doc="Gets and sets the description associated with this component.")


Component.joints = property(Component._get_joints, doc="Returns the collection of joints associated with this component.")


Component.jointOrgins = property(Component._get_jointOrgins, doc="This property was incorrectly spelled and has been replaced with the JointOrigins property.\nHowever, this needs to remain in the implementation to continue to support programs that\nalready used it, but it will be hidden in the documentation.")


Component.asBuiltJoints = property(Component._get_asBuiltJoints, doc="Returns the collection of as-built joints associated with this component.")


Component.rigidGroups = property(Component._get_rigidGroups, doc="Returns the collection of rigid groups associated with this component.")


Component.material = property(Component._get_material, Component._set_material, doc="Gets and sets the physical material assigned to this component.")


Component.physicalProperties = property(Component._get_physicalProperties, doc="Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc\nof this component. Property values will be calulated using the 'LowCalculationAccuracy' setting when using this property\nto get the PhysicalProperties object. To specify a higher calculation tolerance, use the getPhysicalProperties method instead.")


Component.boundingBox = property(Component._get_boundingBox, doc="Returns the bounding box of this component. This is always in world space of the component.")


Component.isJointsFolderLightBulbOn = property(Component._get_isJointsFolderLightBulbOn, Component._set_isJointsFolderLightBulbOn, doc="Gets and sets if the light bulb of the joints folder as seen in the browser is on or off.\nThis controls the visibility of the joints in this occurrence. The light bulb for the\nfolder is component specific and will turn off the joints for all occurrences referencing\nthe component.")


Component.attributes = property(Component._get_attributes, doc="Returns the collection of attributes associated with this face.")


Component.isBodiesFolderLightBulbOn = property(Component._get_isBodiesFolderLightBulbOn, Component._set_isBodiesFolderLightBulbOn, doc="Gets and sets if the light bulb of the bodies folder as seen in the browser is on or off.\nThis controls the visibility of the solid/surface bodies and the mesh bodies in this component.")


Component.allJoints = property(Component._get_allJoints, doc="Returns all joints in this component and any sub components. The joints returned are all in the context\nof this component so any joints in sub components will be proxies. This is primarily useful when used\nfrom the root component because Fusion 360 flattens the assembly structure, including joints, when manipulating\nan assembly.")


Component.allAsBuiltJoints = property(Component._get_allAsBuiltJoints, doc="Returns all joint origins in this component and any sub components. The joint origins returned are all in the context\nof this component so any joint origins in sub components will be proxies. This is primarily useful when used\nfrom the root component because Fusion 360 flattens the assembly structure, including joint origins, when manipulating\nan assembly.")


Component.allJointOrigins = property(Component._get_allJointOrigins, doc="Returns all as-built joints in this component and any sub components. The as-built joints returned are all in the context\nof this component so any as-built joints in sub components will be proxies. This is primarily useful when used\nfrom the root component because Fusion 360 flattens the assembly structure, including as-built joints, when manipulating\nan assembly.")


Component.allRigidGroups = property(Component._get_allRigidGroups, doc="Returns all rigid groups in this component and any sub components. The rigid groups returned are all in the context\nof this component so any rigid groups in sub components will be proxies. This is primarily useful when used\nfrom the root component because Fusion 360 flattens the assembly structure, including rigid groups, when manipulating\nan assembly.")


Component.opacity = property(Component._get_opacity, Component._set_opacity, doc="Gets and sets the opacity override assigned to this component. A value of 1.0 specifies\nthat is it completely opaque and a value of 0.0 specifies that is it completely transparent.\nThis is only applicable for a non-root local component.\nThis value is not necessarily related to what the user sees because the opacity is inherited.\nFor example, if you have TopComponent and it has a component in it called SubComponent and you\nset the opacity of TopComponent to be 0.5, SubComponent will also be shown as slightly transparent\neven though the opacity property for it will return 1.0. Because a component can be referenced as\nan occurrence in other components and they can have different opacity settings, it's possible that\ndifferent instances of the same component can display using different opacity levels. To get the\nopacity that it is being displayed with use the Occurrence.visibleOpacity property.")


Component.jointOrigins = property(Component._get_jointOrigins, doc="Returns the collection of joint origins associated with this component.")


Component.customGraphicsGroups = property(Component._get_customGraphicsGroups, doc="Returns the customGraphicsGroups object in this component.")


Component.revisionId = property(Component._get_revisionId, doc="Returns the current revision ID of the component. This ID changes any time the component is modified in any way. By getting\nand saving the ID when you create any data that is dependent on the component, you can then compare the saved\nID with the current ID to determine if the component has changed to know if you should update your data.")


Component.entityToken = property(Component._get_entityToken, doc="Returns a token for the Component object. This can be saved and used at a later\ntime with the Design.findEntityByToken method to get back the same component.\nWhen using entity tokens it's important to understand that the token string returned for a\nspecific entity can be different over time. However, even if you have two different token\nstrings that were obtained from the same entity, when you use findEntityByToken they\nwill both return the same entity. Because of that you should never compare entity tokens\nas way to determine what the token represents. Instead, you need to use the findEntityByToken\nmethod to get the two entities identified by the tokens and then compare them.")


Component.id = property(Component._get_id, doc="Returns the persistent ID of the component. This ID is created with the component and does not change.\nBecause this ID does not change, different revisions of the same design or copies of the design asset/file\nwill retain this ID. If components from different designs have the same ID, it indicates they are either\ndifferent revisions or a copiy of the design was made. Therefore, this ID will always be unique within a\nsingle design, but may not be unique in an assembly where externally referenced designs include different\nrevisions or copies of a design.\nThe ID is also the same ID used by PIM (Product Information Model).")


Component.cast = lambda arg: arg if isinstance(arg, Component) else None

class ConcentricConstraint(GeometricConstraint):
    r"""A concentric constraint in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConcentricConstraint *":
        return _fusion.ConcentricConstraint___deref__(self)

    def __eq__(self, rhs: "ConcentricConstraint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConcentricConstraint___eq__(self, rhs)


    def __ne__(self, rhs: "ConcentricConstraint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConcentricConstraint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConcentricConstraint_classType()
    __swig_destroy__ = _fusion.delete_ConcentricConstraint

    def _get_entityOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >":
        r"""Returns the first curve."""
        return _fusion.ConcentricConstraint__get_entityOne(self)

    def _get_entityTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >":
        r"""Returns the second curve."""
        return _fusion.ConcentricConstraint__get_entityTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ConcentricConstraint >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ConcentricConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::ConcentricConstraint >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ConcentricConstraint_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.ConcentricConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this constraint is deletable."""
        return _fusion.ConcentricConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.ConcentricConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ConcentricConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.ConcentricConstraint__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the GeometricConstraint object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same geometric constraint.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.ConcentricConstraint__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConcentricConstraint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConcentricConstraint__get_isValid(self)

# Register ConcentricConstraint in _fusion:
_fusion.ConcentricConstraint_swigregister(ConcentricConstraint)

def ConcentricConstraint_classType() -> "char const *":
    return _fusion.ConcentricConstraint_classType()


ConcentricConstraint.entityOne = property(ConcentricConstraint._get_entityOne, doc="Returns the first curve.")


ConcentricConstraint.entityTwo = property(ConcentricConstraint._get_entityTwo, doc="Returns the second curve.")


ConcentricConstraint.nativeObject = property(ConcentricConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


ConcentricConstraint.cast = lambda arg: arg if isinstance(arg, ConcentricConstraint) else None

class ConstantRadiusFilletEdgeSet(FilletEdgeSet):
    r"""Provides access to the edges and the parameter associated with a constant radius fillet."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstantRadiusFilletEdgeSet *":
        return _fusion.ConstantRadiusFilletEdgeSet___deref__(self)

    def __eq__(self, rhs: "ConstantRadiusFilletEdgeSet") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstantRadiusFilletEdgeSet___eq__(self, rhs)


    def __ne__(self, rhs: "ConstantRadiusFilletEdgeSet") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstantRadiusFilletEdgeSet___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstantRadiusFilletEdgeSet_classType()
    __swig_destroy__ = _fusion.delete_ConstantRadiusFilletEdgeSet

    def _get_edges(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the edges that will be filleted.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ConstantRadiusFilletEdgeSet__get_edges(self)

    def _set_edges(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the edges that will be filleted.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ConstantRadiusFilletEdgeSet__set_edges(self, value)

    def _get_radius(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the model parameter that controls the radius of the fillet. You can edit
        the radius by using the properties on the returned ModelParameter object.
        """
        return _fusion.ConstantRadiusFilletEdgeSet__get_radius(self)

    def _get_isTangentChain(self) -> "bool":
        r"""Gets and sets the Tangent chain for fillet. This enables tangent chain option for fillet."""
        return _fusion.ConstantRadiusFilletEdgeSet__get_isTangentChain(self)

    def _set_isTangentChain(self, value: "bool") -> "bool":
        r"""Gets and sets the Tangent chain for fillet. This enables tangent chain option for fillet."""
        return _fusion.ConstantRadiusFilletEdgeSet__set_isTangentChain(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstantRadiusFilletEdgeSet__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstantRadiusFilletEdgeSet__get_isValid(self)

# Register ConstantRadiusFilletEdgeSet in _fusion:
_fusion.ConstantRadiusFilletEdgeSet_swigregister(ConstantRadiusFilletEdgeSet)

def ConstantRadiusFilletEdgeSet_classType() -> "char const *":
    return _fusion.ConstantRadiusFilletEdgeSet_classType()


ConstantRadiusFilletEdgeSet.edges = property(ConstantRadiusFilletEdgeSet._get_edges, ConstantRadiusFilletEdgeSet._set_edges, doc="Gets and sets the edges that will be filleted.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ConstantRadiusFilletEdgeSet.radius = property(ConstantRadiusFilletEdgeSet._get_radius, doc="Returns the model parameter that controls the radius of the fillet. You can edit\nthe radius by using the properties on the returned ModelParameter object.")


ConstantRadiusFilletEdgeSet.cast = lambda arg: arg if isinstance(arg, ConstantRadiusFilletEdgeSet) else None

class ConstructionAxisByLineDefinition(ConstructionAxisDefinition):
    r"""
    The definition for a non-parametric construction axis. In a non-parametric design
    all construction planes will return this type of definition regardless of how they
    were initially created.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionAxisByLineDefinition *":
        return _fusion.ConstructionAxisByLineDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionAxisByLineDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionAxisByLineDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionAxisByLineDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionAxisByLineDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionAxisByLineDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionAxisByLineDefinition

    def _get_axis(self) -> "adsk::core::Ptr< adsk::core::InfiniteLine3D >":
        r"""Gets and sets the infinite line that defines the position and direction of the axis"""
        return _fusion.ConstructionAxisByLineDefinition__get_axis(self)

    def _set_axis(self, value: "InfiniteLine3D") -> "bool":
        r"""Gets and sets the infinite line that defines the position and direction of the axis"""
        return _fusion.ConstructionAxisByLineDefinition__set_axis(self, value)

    def _get_parentConstructionAxis(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >":
        r"""Returns the ConstructionAxis object"""
        return _fusion.ConstructionAxisByLineDefinition__get_parentConstructionAxis(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionAxisByLineDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionAxisByLineDefinition__get_isValid(self)

# Register ConstructionAxisByLineDefinition in _fusion:
_fusion.ConstructionAxisByLineDefinition_swigregister(ConstructionAxisByLineDefinition)

def ConstructionAxisByLineDefinition_classType() -> "char const *":
    return _fusion.ConstructionAxisByLineDefinition_classType()


ConstructionAxisByLineDefinition.axis = property(ConstructionAxisByLineDefinition._get_axis, ConstructionAxisByLineDefinition._set_axis, doc="Gets and sets the infinite line that defines the position and direction of the axis")


ConstructionAxisByLineDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionAxisByLineDefinition) else None

class ConstructionAxisCircularFaceDefinition(ConstructionAxisDefinition):
    r"""The definition for a parametric construction axis created using the SetbyCircularFace method"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionAxisCircularFaceDefinition *":
        return _fusion.ConstructionAxisCircularFaceDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionAxisCircularFaceDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionAxisCircularFaceDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionAxisCircularFaceDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionAxisCircularFaceDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionAxisCircularFaceDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionAxisCircularFaceDefinition

    def _get_circularFace(self) -> "adsk::core::Ptr< adsk::fusion::BRepFace >":
        r"""
        Gets and sets the cylinder, cone, or torus this work axis 
        is parametrically dependent on.
        """
        return _fusion.ConstructionAxisCircularFaceDefinition__get_circularFace(self)

    def _set_circularFace(self, value: "BRepFace") -> "bool":
        r"""
        Gets and sets the cylinder, cone, or torus this work axis 
        is parametrically dependent on.
        """
        return _fusion.ConstructionAxisCircularFaceDefinition__set_circularFace(self, value)

    def _get_parentConstructionAxis(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >":
        r"""Returns the ConstructionAxis object"""
        return _fusion.ConstructionAxisCircularFaceDefinition__get_parentConstructionAxis(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionAxisCircularFaceDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionAxisCircularFaceDefinition__get_isValid(self)

# Register ConstructionAxisCircularFaceDefinition in _fusion:
_fusion.ConstructionAxisCircularFaceDefinition_swigregister(ConstructionAxisCircularFaceDefinition)

def ConstructionAxisCircularFaceDefinition_classType() -> "char const *":
    return _fusion.ConstructionAxisCircularFaceDefinition_classType()


ConstructionAxisCircularFaceDefinition.circularFace = property(ConstructionAxisCircularFaceDefinition._get_circularFace, ConstructionAxisCircularFaceDefinition._set_circularFace, doc="Gets and sets the cylinder, cone, or torus this work axis\nis parametrically dependent on.")


ConstructionAxisCircularFaceDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionAxisCircularFaceDefinition) else None

class ConstructionAxisEdgeDefinition(ConstructionAxisDefinition):
    r"""The definition for a parametric construction axis created using the SetbyEdge method"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionAxisEdgeDefinition *":
        return _fusion.ConstructionAxisEdgeDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionAxisEdgeDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionAxisEdgeDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionAxisEdgeDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionAxisEdgeDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionAxisEdgeDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionAxisEdgeDefinition

    def _get_edgeEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the linear edge, construction line, or sketch line that defines 
        the construction axis.
        """
        return _fusion.ConstructionAxisEdgeDefinition__get_edgeEntity(self)

    def _set_edgeEntity(self, value: "Base") -> "bool":
        r"""
        Gets and sets the linear edge, construction line, or sketch line that defines 
        the construction axis.
        """
        return _fusion.ConstructionAxisEdgeDefinition__set_edgeEntity(self, value)

    def _get_parentConstructionAxis(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >":
        r"""Returns the ConstructionAxis object"""
        return _fusion.ConstructionAxisEdgeDefinition__get_parentConstructionAxis(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionAxisEdgeDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionAxisEdgeDefinition__get_isValid(self)

# Register ConstructionAxisEdgeDefinition in _fusion:
_fusion.ConstructionAxisEdgeDefinition_swigregister(ConstructionAxisEdgeDefinition)

def ConstructionAxisEdgeDefinition_classType() -> "char const *":
    return _fusion.ConstructionAxisEdgeDefinition_classType()


ConstructionAxisEdgeDefinition.edgeEntity = property(ConstructionAxisEdgeDefinition._get_edgeEntity, ConstructionAxisEdgeDefinition._set_edgeEntity, doc="Gets and sets the linear edge, construction line, or sketch line that defines\nthe construction axis.")


ConstructionAxisEdgeDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionAxisEdgeDefinition) else None

class ConstructionAxisNormalToFaceAtPointDefinition(ConstructionAxisDefinition):
    r"""
    The definition for a parametric construction axis created using the 
    SetByNormalToFaceAtPoint method
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionAxisNormalToFaceAtPointDefinition *":
        return _fusion.ConstructionAxisNormalToFaceAtPointDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionAxisNormalToFaceAtPointDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionAxisNormalToFaceAtPointDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionAxisNormalToFaceAtPointDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionAxisNormalToFaceAtPointDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionAxisNormalToFaceAtPointDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionAxisNormalToFaceAtPointDefinition

    def _get_face(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets the face the axis is normal to"""
        return _fusion.ConstructionAxisNormalToFaceAtPointDefinition__get_face(self)

    def _get_pointEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets the point that positions the axis"""
        return _fusion.ConstructionAxisNormalToFaceAtPointDefinition__get_pointEntity(self)

    def redefine(self, face: "Base", pointEntity: "Base") -> "bool":
        r"""
        Redefines the input geometry of the construction axis. 
        face : The face the axis is normal to 
        pointEntity : The point that positions the axis 
        Returns true if the redefinition of the construction axis is successful.
        """
        return _fusion.ConstructionAxisNormalToFaceAtPointDefinition_redefine(self, face, pointEntity)

    def _get_parentConstructionAxis(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >":
        r"""Returns the ConstructionAxis object"""
        return _fusion.ConstructionAxisNormalToFaceAtPointDefinition__get_parentConstructionAxis(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionAxisNormalToFaceAtPointDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionAxisNormalToFaceAtPointDefinition__get_isValid(self)

# Register ConstructionAxisNormalToFaceAtPointDefinition in _fusion:
_fusion.ConstructionAxisNormalToFaceAtPointDefinition_swigregister(ConstructionAxisNormalToFaceAtPointDefinition)

def ConstructionAxisNormalToFaceAtPointDefinition_classType() -> "char const *":
    return _fusion.ConstructionAxisNormalToFaceAtPointDefinition_classType()


ConstructionAxisNormalToFaceAtPointDefinition.face = property(ConstructionAxisNormalToFaceAtPointDefinition._get_face, doc="Gets the face the axis is normal to")


ConstructionAxisNormalToFaceAtPointDefinition.pointEntity = property(ConstructionAxisNormalToFaceAtPointDefinition._get_pointEntity, doc="Gets the point that positions the axis")


ConstructionAxisNormalToFaceAtPointDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionAxisNormalToFaceAtPointDefinition) else None

class ConstructionAxisPerpendicularAtPointDefinition(ConstructionAxisDefinition):
    r"""
    The definition for a parametric construction axis created using the 
    SetByPerpendicularAtPoint method
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionAxisPerpendicularAtPointDefinition *":
        return _fusion.ConstructionAxisPerpendicularAtPointDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionAxisPerpendicularAtPointDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionAxisPerpendicularAtPointDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionAxisPerpendicularAtPointDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionAxisPerpendicularAtPointDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionAxisPerpendicularAtPointDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionAxisPerpendicularAtPointDefinition

    def _get_face(self) -> "adsk::core::Ptr< adsk::fusion::BRepFace >":
        r"""Returns the face the construction axis is perpendicular to."""
        return _fusion.ConstructionAxisPerpendicularAtPointDefinition__get_face(self)

    def _get_point(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the point (construction or sketch point) that positions the axis."""
        return _fusion.ConstructionAxisPerpendicularAtPointDefinition__get_point(self)

    def redefine(self, face: "BRepFace", pointEntity: "Base") -> "bool":
        r"""
        Redefines the input geometry of the construction axis. 
        face : The face (BRepFace object) to create the axis perpendicular to. 
        pointEntity : The point (sketch point, vertex, construction point) used to position the axis. 
        Returns true if the redefinition of the axis is successful.
        """
        return _fusion.ConstructionAxisPerpendicularAtPointDefinition_redefine(self, face, pointEntity)

    def _get_parentConstructionAxis(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >":
        r"""Returns the ConstructionAxis object"""
        return _fusion.ConstructionAxisPerpendicularAtPointDefinition__get_parentConstructionAxis(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionAxisPerpendicularAtPointDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionAxisPerpendicularAtPointDefinition__get_isValid(self)

# Register ConstructionAxisPerpendicularAtPointDefinition in _fusion:
_fusion.ConstructionAxisPerpendicularAtPointDefinition_swigregister(ConstructionAxisPerpendicularAtPointDefinition)

def ConstructionAxisPerpendicularAtPointDefinition_classType() -> "char const *":
    return _fusion.ConstructionAxisPerpendicularAtPointDefinition_classType()


ConstructionAxisPerpendicularAtPointDefinition.face = property(ConstructionAxisPerpendicularAtPointDefinition._get_face, doc="Returns the face the construction axis is perpendicular to.")


ConstructionAxisPerpendicularAtPointDefinition.point = property(ConstructionAxisPerpendicularAtPointDefinition._get_point, doc="Returns the point (construction or sketch point) that positions the axis.")


ConstructionAxisPerpendicularAtPointDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionAxisPerpendicularAtPointDefinition) else None

class ConstructionAxisTwoPlaneDefinition(ConstructionAxisDefinition):
    r"""The definition for a parametric construction axis created using the SetByTwoPlanes method"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionAxisTwoPlaneDefinition *":
        return _fusion.ConstructionAxisTwoPlaneDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionAxisTwoPlaneDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionAxisTwoPlaneDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionAxisTwoPlaneDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionAxisTwoPlaneDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionAxisTwoPlaneDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionAxisTwoPlaneDefinition

    def _get_planarEntityOne(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets the first planar face or construction plane"""
        return _fusion.ConstructionAxisTwoPlaneDefinition__get_planarEntityOne(self)

    def _get_planarEntityTwo(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets the second planar face or construction plane"""
        return _fusion.ConstructionAxisTwoPlaneDefinition__get_planarEntityTwo(self)

    def redefine(self, planarEntityOne: "Base", planarEntityTwo: "Base") -> "bool":
        r"""
        Redefines the input geometry of the construction axis. 
        planarEntityOne : The first planar face or construction plane 
        planarEntityTwo : The second planar face or construction plane 
        Returns true if the redefinition of the axis is successful.
        """
        return _fusion.ConstructionAxisTwoPlaneDefinition_redefine(self, planarEntityOne, planarEntityTwo)

    def _get_parentConstructionAxis(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >":
        r"""Returns the ConstructionAxis object"""
        return _fusion.ConstructionAxisTwoPlaneDefinition__get_parentConstructionAxis(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionAxisTwoPlaneDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionAxisTwoPlaneDefinition__get_isValid(self)

# Register ConstructionAxisTwoPlaneDefinition in _fusion:
_fusion.ConstructionAxisTwoPlaneDefinition_swigregister(ConstructionAxisTwoPlaneDefinition)

def ConstructionAxisTwoPlaneDefinition_classType() -> "char const *":
    return _fusion.ConstructionAxisTwoPlaneDefinition_classType()


ConstructionAxisTwoPlaneDefinition.planarEntityOne = property(ConstructionAxisTwoPlaneDefinition._get_planarEntityOne, doc="Gets the first planar face or construction plane")


ConstructionAxisTwoPlaneDefinition.planarEntityTwo = property(ConstructionAxisTwoPlaneDefinition._get_planarEntityTwo, doc="Gets the second planar face or construction plane")


ConstructionAxisTwoPlaneDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionAxisTwoPlaneDefinition) else None

class ConstructionAxisTwoPointDefinition(ConstructionAxisDefinition):
    r"""The definition for a parametric construction axis created using the SetbyTwoPoints method"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionAxisTwoPointDefinition *":
        return _fusion.ConstructionAxisTwoPointDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionAxisTwoPointDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionAxisTwoPointDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionAxisTwoPointDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionAxisTwoPointDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionAxisTwoPointDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionAxisTwoPointDefinition

    def _get_pointEntityOne(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets the first point."""
        return _fusion.ConstructionAxisTwoPointDefinition__get_pointEntityOne(self)

    def _get_pointEntityTwo(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets the second point."""
        return _fusion.ConstructionAxisTwoPointDefinition__get_pointEntityTwo(self)

    def redefine(self, pointEntityOne: "Base", pointEntityTwo: "Base") -> "bool":
        r"""
        Redefines the input geometry of the construction axis. 
        pointEntityOne : The first point 
        pointEntityTwo : The second point 
        Returns true if the redefinition of the construction axis is successful.
        """
        return _fusion.ConstructionAxisTwoPointDefinition_redefine(self, pointEntityOne, pointEntityTwo)

    def _get_parentConstructionAxis(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >":
        r"""Returns the ConstructionAxis object"""
        return _fusion.ConstructionAxisTwoPointDefinition__get_parentConstructionAxis(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionAxisTwoPointDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionAxisTwoPointDefinition__get_isValid(self)

# Register ConstructionAxisTwoPointDefinition in _fusion:
_fusion.ConstructionAxisTwoPointDefinition_swigregister(ConstructionAxisTwoPointDefinition)

def ConstructionAxisTwoPointDefinition_classType() -> "char const *":
    return _fusion.ConstructionAxisTwoPointDefinition_classType()


ConstructionAxisTwoPointDefinition.pointEntityOne = property(ConstructionAxisTwoPointDefinition._get_pointEntityOne, doc="Gets the first point.")


ConstructionAxisTwoPointDefinition.pointEntityTwo = property(ConstructionAxisTwoPointDefinition._get_pointEntityTwo, doc="Gets the second point.")


ConstructionAxisTwoPointDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionAxisTwoPointDefinition) else None

class ConstructionPlaneAtAngleDefinition(ConstructionPlaneDefinition):
    r"""ConstructionPlaneAtAngleDefinition defines a ConstructionPlane by..."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionPlaneAtAngleDefinition *":
        return _fusion.ConstructionPlaneAtAngleDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionPlaneAtAngleDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionPlaneAtAngleDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionPlaneAtAngleDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionPlaneAtAngleDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionPlaneAtAngleDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionPlaneAtAngleDefinition

    def _get_angle(self) -> "adsk::core::Ptr< adsk::fusion::Parameter >":
        r"""
        Returns a Value object that for a transient definition provides the current
        assigned value. For a definition associated with a construction plane, this
        provides access to the associated parameter controlling the angle.
        """
        return _fusion.ConstructionPlaneAtAngleDefinition__get_angle(self)

    def _get_linearEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets the linear edge, construction line, or sketch line that defines 
        the axis of rotation for the construction plane.
        """
        return _fusion.ConstructionPlaneAtAngleDefinition__get_linearEntity(self)

    def _get_planarEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets the planar face or construction plane the angle for this 
        construction plane is measured from and is parametrically dependent on.
        """
        return _fusion.ConstructionPlaneAtAngleDefinition__get_planarEntity(self)

    def redefine(self, angle: "ValueInput", linearEntity: "Base", planarEntity: "Base") -> "bool":
        r"""
        Redefines the input geometry of the construction plane. 
        angle : A ValueInput object that defines the angle at which to create the construction plane 
        linearEntity : The linear edge, construction line, or sketch line that defines the axis of rotation to
        measure the angle about 
        planarEntity : A plane, planar face or construction plane the angle of the construction plane is
        measured from 
        Returns true if the redefinition of the plane is successful.
        """
        return _fusion.ConstructionPlaneAtAngleDefinition_redefine(self, angle, linearEntity, planarEntity)

    def _get_parentConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >":
        r"""Returns the ConstructionPlane object"""
        return _fusion.ConstructionPlaneAtAngleDefinition__get_parentConstructionPlane(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionPlaneAtAngleDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionPlaneAtAngleDefinition__get_isValid(self)

# Register ConstructionPlaneAtAngleDefinition in _fusion:
_fusion.ConstructionPlaneAtAngleDefinition_swigregister(ConstructionPlaneAtAngleDefinition)

def ConstructionPlaneAtAngleDefinition_classType() -> "char const *":
    return _fusion.ConstructionPlaneAtAngleDefinition_classType()


ConstructionPlaneAtAngleDefinition.angle = property(ConstructionPlaneAtAngleDefinition._get_angle, doc="Returns a Value object that for a transient definition provides the current\nassigned value. For a definition associated with a construction plane, this\nprovides access to the associated parameter controlling the angle.")


ConstructionPlaneAtAngleDefinition.linearEntity = property(ConstructionPlaneAtAngleDefinition._get_linearEntity, doc="Gets the linear edge, construction line, or sketch line that defines\nthe axis of rotation for the construction plane.")


ConstructionPlaneAtAngleDefinition.planarEntity = property(ConstructionPlaneAtAngleDefinition._get_planarEntity, doc="Gets the planar face or construction plane the angle for this\nconstruction plane is measured from and is parametrically dependent on.")


ConstructionPlaneAtAngleDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPlaneAtAngleDefinition) else None

class ConstructionPlaneByPlaneDefinition(ConstructionPlaneDefinition):
    r"""
    The definition for a non-parametric construction plane. All constructions planes will 
    return this type of definition regardless of method used to initially create them.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionPlaneByPlaneDefinition *":
        return _fusion.ConstructionPlaneByPlaneDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionPlaneByPlaneDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionPlaneByPlaneDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionPlaneByPlaneDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionPlaneByPlaneDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionPlaneByPlaneDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionPlaneByPlaneDefinition

    def _get_plane(self) -> "adsk::core::Ptr< adsk::core::Plane >":
        r"""Gets and sets the position of the construction plane."""
        return _fusion.ConstructionPlaneByPlaneDefinition__get_plane(self)

    def _set_plane(self, value: "Plane") -> "bool":
        r"""Gets and sets the position of the construction plane."""
        return _fusion.ConstructionPlaneByPlaneDefinition__set_plane(self, value)

    def _get_parentConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >":
        r"""Returns the ConstructionPlane object"""
        return _fusion.ConstructionPlaneByPlaneDefinition__get_parentConstructionPlane(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionPlaneByPlaneDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionPlaneByPlaneDefinition__get_isValid(self)

# Register ConstructionPlaneByPlaneDefinition in _fusion:
_fusion.ConstructionPlaneByPlaneDefinition_swigregister(ConstructionPlaneByPlaneDefinition)

def ConstructionPlaneByPlaneDefinition_classType() -> "char const *":
    return _fusion.ConstructionPlaneByPlaneDefinition_classType()


ConstructionPlaneByPlaneDefinition.plane = property(ConstructionPlaneByPlaneDefinition._get_plane, ConstructionPlaneByPlaneDefinition._set_plane, doc="Gets and sets the position of the construction plane.")


ConstructionPlaneByPlaneDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPlaneByPlaneDefinition) else None

class ConstructionPlaneDistanceOnPathDefinition(ConstructionPlaneDefinition):
    r"""
    ConstructionDistanceOnPathDefinition defines a ConstructionPlane normal to an edge or
    sketch profile at a specified position along the path defined by the edge or sketch profile.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionPlaneDistanceOnPathDefinition *":
        return _fusion.ConstructionPlaneDistanceOnPathDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionPlaneDistanceOnPathDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionPlaneDistanceOnPathDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionPlaneDistanceOnPathDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionPlaneDistanceOnPathDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionPlaneDistanceOnPathDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionPlaneDistanceOnPathDefinition

    def _get_pathEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets the sketch curve, edge, or a profile object."""
        return _fusion.ConstructionPlaneDistanceOnPathDefinition__get_pathEntity(self)

    def redefine(self, pathEntity: "Base", distance: "ValueInput") -> "bool":
        r"""
        Redefines the input defining the construction plane. 
        pathEntity : The sketch curve, edge, or a profile object 
        distance : The ValueInput object that defines the distance along the path 
        Returns true if the redefinition of the plane is successful.
        """
        return _fusion.ConstructionPlaneDistanceOnPathDefinition_redefine(self, pathEntity, distance)

    def _get_distance(self) -> "adsk::core::Ptr< adsk::fusion::Parameter >":
        r"""Gets the distance along the path."""
        return _fusion.ConstructionPlaneDistanceOnPathDefinition__get_distance(self)

    def _get_parentConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >":
        r"""Returns the ConstructionPlane object"""
        return _fusion.ConstructionPlaneDistanceOnPathDefinition__get_parentConstructionPlane(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionPlaneDistanceOnPathDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionPlaneDistanceOnPathDefinition__get_isValid(self)

# Register ConstructionPlaneDistanceOnPathDefinition in _fusion:
_fusion.ConstructionPlaneDistanceOnPathDefinition_swigregister(ConstructionPlaneDistanceOnPathDefinition)

def ConstructionPlaneDistanceOnPathDefinition_classType() -> "char const *":
    return _fusion.ConstructionPlaneDistanceOnPathDefinition_classType()


ConstructionPlaneDistanceOnPathDefinition.pathEntity = property(ConstructionPlaneDistanceOnPathDefinition._get_pathEntity, doc="Gets the sketch curve, edge, or a profile object.")


ConstructionPlaneDistanceOnPathDefinition.distance = property(ConstructionPlaneDistanceOnPathDefinition._get_distance, doc="Gets the distance along the path.")


ConstructionPlaneDistanceOnPathDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPlaneDistanceOnPathDefinition) else None

class ConstructionPlaneMidplaneDefinition(ConstructionPlaneDefinition):
    r"""ConstructionPlaneMidplaneDefinition defines a ConstructionPlane by..."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionPlaneMidplaneDefinition *":
        return _fusion.ConstructionPlaneMidplaneDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionPlaneMidplaneDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionPlaneMidplaneDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionPlaneMidplaneDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionPlaneMidplaneDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionPlaneMidplaneDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionPlaneMidplaneDefinition

    def _get_planarEntityOne(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets the first planar face or construction plane that defines this ConstructionPlane."""
        return _fusion.ConstructionPlaneMidplaneDefinition__get_planarEntityOne(self)

    def _get_planarEntityTwo(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets the second planar face or construction plane that defines this ConstructionPlane."""
        return _fusion.ConstructionPlaneMidplaneDefinition__get_planarEntityTwo(self)

    def redefine(self, planarEntityOne: "Base", planarEntityTwo: "Base") -> "bool":
        r"""
        Redefines the input geometry of the construction plane. 
        planarEntityOne : The first planar face or construction plane that defines this ConstructionPlane. 
        planarEntityTwo : The second planar face or construction plane that defines this ConstructionPlane. 
        Returns true if the redefinition of the plane is successful.
        """
        return _fusion.ConstructionPlaneMidplaneDefinition_redefine(self, planarEntityOne, planarEntityTwo)

    def _get_parentConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >":
        r"""Returns the ConstructionPlane object"""
        return _fusion.ConstructionPlaneMidplaneDefinition__get_parentConstructionPlane(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionPlaneMidplaneDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionPlaneMidplaneDefinition__get_isValid(self)

# Register ConstructionPlaneMidplaneDefinition in _fusion:
_fusion.ConstructionPlaneMidplaneDefinition_swigregister(ConstructionPlaneMidplaneDefinition)

def ConstructionPlaneMidplaneDefinition_classType() -> "char const *":
    return _fusion.ConstructionPlaneMidplaneDefinition_classType()


ConstructionPlaneMidplaneDefinition.planarEntityOne = property(ConstructionPlaneMidplaneDefinition._get_planarEntityOne, doc="Gets the first planar face or construction plane that defines this ConstructionPlane.")


ConstructionPlaneMidplaneDefinition.planarEntityTwo = property(ConstructionPlaneMidplaneDefinition._get_planarEntityTwo, doc="Gets the second planar face or construction plane that defines this ConstructionPlane.")


ConstructionPlaneMidplaneDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPlaneMidplaneDefinition) else None

class ConstructionPlaneOffsetDefinition(ConstructionPlaneDefinition):
    r"""ConstructionPlaneOffsetDefinition defines a ConstructionPlane by..."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionPlaneOffsetDefinition *":
        return _fusion.ConstructionPlaneOffsetDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionPlaneOffsetDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionPlaneOffsetDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionPlaneOffsetDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionPlaneOffsetDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionPlaneOffsetDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionPlaneOffsetDefinition

    def _get_offset(self) -> "adsk::core::Ptr< adsk::fusion::Parameter >":
        r"""
        Returns a Value object that for a transient definition that provides the current
        assigned value and for a definition associated with a construction plane
        Provides access to the associated parameter controlling the offset.
        """
        return _fusion.ConstructionPlaneOffsetDefinition__get_offset(self)

    def _get_planarEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets the planar face or construction plane this construction plane
        is parametrically dependent on.
        """
        return _fusion.ConstructionPlaneOffsetDefinition__get_planarEntity(self)

    def redefine(self, offset: "ValueInput", planarEntity: "Base") -> "bool":
        r"""
        Redefines the input geometry of the construction plane. 
        offset : ValueInput object that specifies the offset distance 
        planarEntity : A plane, planar face or construction plane from which to measure the offset from 
        Returns true is the operation is successful
        """
        return _fusion.ConstructionPlaneOffsetDefinition_redefine(self, offset, planarEntity)

    def _get_parentConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >":
        r"""Returns the ConstructionPlane object"""
        return _fusion.ConstructionPlaneOffsetDefinition__get_parentConstructionPlane(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionPlaneOffsetDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionPlaneOffsetDefinition__get_isValid(self)

# Register ConstructionPlaneOffsetDefinition in _fusion:
_fusion.ConstructionPlaneOffsetDefinition_swigregister(ConstructionPlaneOffsetDefinition)

def ConstructionPlaneOffsetDefinition_classType() -> "char const *":
    return _fusion.ConstructionPlaneOffsetDefinition_classType()


ConstructionPlaneOffsetDefinition.offset = property(ConstructionPlaneOffsetDefinition._get_offset, doc="Returns a Value object that for a transient definition that provides the current\nassigned value and for a definition associated with a construction plane\nProvides access to the associated parameter controlling the offset.")


ConstructionPlaneOffsetDefinition.planarEntity = property(ConstructionPlaneOffsetDefinition._get_planarEntity, doc="Gets the planar face or construction plane this construction plane\nis parametrically dependent on.")


ConstructionPlaneOffsetDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPlaneOffsetDefinition) else None

class ConstructionPlaneTangentAtPointDefinition(ConstructionPlaneDefinition):
    r"""
    ConstructionPlaneTangentAtPointDefinition defines a ConstructionPlane tangent to a 
    face and aligned to a point.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionPlaneTangentAtPointDefinition *":
        return _fusion.ConstructionPlaneTangentAtPointDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionPlaneTangentAtPointDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionPlaneTangentAtPointDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionPlaneTangentAtPointDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionPlaneTangentAtPointDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionPlaneTangentAtPointDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionPlaneTangentAtPointDefinition

    def _get_tangentFace(self) -> "adsk::core::Ptr< adsk::fusion::BRepFace >":
        r"""Gets the tangent face."""
        return _fusion.ConstructionPlaneTangentAtPointDefinition__get_tangentFace(self)

    def _get_pointEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets the point (sketch point, vertex, construction point) used to align the plane."""
        return _fusion.ConstructionPlaneTangentAtPointDefinition__get_pointEntity(self)

    def redefine(self, tangentFace: "Base", pointEntity: "Base") -> "bool":
        r"""
        Redefines the input geometry of the construction plane. 
        tangentFace : The face to create the plane tangent to 
        pointEntity : The point (sketch point, vertex, construction point) used to align the plane. 
        Returns true if the redefinition of the plane is successful.
        """
        return _fusion.ConstructionPlaneTangentAtPointDefinition_redefine(self, tangentFace, pointEntity)

    def _get_parentConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >":
        r"""Returns the ConstructionPlane object"""
        return _fusion.ConstructionPlaneTangentAtPointDefinition__get_parentConstructionPlane(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionPlaneTangentAtPointDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionPlaneTangentAtPointDefinition__get_isValid(self)

# Register ConstructionPlaneTangentAtPointDefinition in _fusion:
_fusion.ConstructionPlaneTangentAtPointDefinition_swigregister(ConstructionPlaneTangentAtPointDefinition)

def ConstructionPlaneTangentAtPointDefinition_classType() -> "char const *":
    return _fusion.ConstructionPlaneTangentAtPointDefinition_classType()


ConstructionPlaneTangentAtPointDefinition.tangentFace = property(ConstructionPlaneTangentAtPointDefinition._get_tangentFace, doc="Gets the tangent face.")


ConstructionPlaneTangentAtPointDefinition.pointEntity = property(ConstructionPlaneTangentAtPointDefinition._get_pointEntity, doc="Gets the point (sketch point, vertex, construction point) used to align the plane.")


ConstructionPlaneTangentAtPointDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPlaneTangentAtPointDefinition) else None

class ConstructionPlaneTangentDefinition(ConstructionPlaneDefinition):
    r"""
    ConstructionPlaneTangentDefinition defines a ConstructionPlane tangent to a cylindrical or conical
    face at a point.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionPlaneTangentDefinition *":
        return _fusion.ConstructionPlaneTangentDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionPlaneTangentDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionPlaneTangentDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionPlaneTangentDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionPlaneTangentDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionPlaneTangentDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionPlaneTangentDefinition

    def _get_angle(self) -> "adsk::core::Ptr< adsk::fusion::Parameter >":
        r"""
        Returns a Value object that for a transient definition provides the current
        assigned value. For a definition associated with a construction plane, it
        provides access to the associated parameter controlling the angle.
        """
        return _fusion.ConstructionPlaneTangentDefinition__get_angle(self)

    def _get_tangentFace(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets the cylindrical or conical face that the construction plane
        is tangent to.
        """
        return _fusion.ConstructionPlaneTangentDefinition__get_tangentFace(self)

    def _get_planarEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets the planar face or construction plane the angle for this 
        construction plane is measured from and is parametrically dependent on.
        """
        return _fusion.ConstructionPlaneTangentDefinition__get_planarEntity(self)

    def redefine(self, angle: "ValueInput", tangentFace: "Base", planarEntity: "Base") -> "bool":
        r"""
        Redefines the input geometry of the construction plane. 
        angle : A Value object that defines the angle of the construction plane 
        tangentFace : The cylindrical or conical face that the construction plane is tangent to. 
        planarEntity : The planar face or construction plane the angle for this 
        construction plane is measured from 
        Returns true if the redefinition of the plane is successful.
        """
        return _fusion.ConstructionPlaneTangentDefinition_redefine(self, angle, tangentFace, planarEntity)

    def _get_parentConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >":
        r"""Returns the ConstructionPlane object"""
        return _fusion.ConstructionPlaneTangentDefinition__get_parentConstructionPlane(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionPlaneTangentDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionPlaneTangentDefinition__get_isValid(self)

# Register ConstructionPlaneTangentDefinition in _fusion:
_fusion.ConstructionPlaneTangentDefinition_swigregister(ConstructionPlaneTangentDefinition)

def ConstructionPlaneTangentDefinition_classType() -> "char const *":
    return _fusion.ConstructionPlaneTangentDefinition_classType()


ConstructionPlaneTangentDefinition.angle = property(ConstructionPlaneTangentDefinition._get_angle, doc="Returns a Value object that for a transient definition provides the current\nassigned value. For a definition associated with a construction plane, it\nprovides access to the associated parameter controlling the angle.")


ConstructionPlaneTangentDefinition.tangentFace = property(ConstructionPlaneTangentDefinition._get_tangentFace, doc="Gets the cylindrical or conical face that the construction plane\nis tangent to.")


ConstructionPlaneTangentDefinition.planarEntity = property(ConstructionPlaneTangentDefinition._get_planarEntity, doc="Gets the planar face or construction plane the angle for this\nconstruction plane is measured from and is parametrically dependent on.")


ConstructionPlaneTangentDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPlaneTangentDefinition) else None

class ConstructionPlaneThreePointsDefinition(ConstructionPlaneDefinition):
    r"""
    ConstructionPlaneThreePointDefinition defines a ConstructionPlane by 3 point entities 
    (e.g. (sketch points, vertices or construction points) that form a triangle (i.e.
    no two points the same and they aren't collinear).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionPlaneThreePointsDefinition *":
        return _fusion.ConstructionPlaneThreePointsDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionPlaneThreePointsDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionPlaneThreePointsDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionPlaneThreePointsDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionPlaneThreePointsDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionPlaneThreePointsDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionPlaneThreePointsDefinition

    def _get_pointEntityOne(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets the first construction point, sketch point or vertex."""
        return _fusion.ConstructionPlaneThreePointsDefinition__get_pointEntityOne(self)

    def _get_pointEntityTwo(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets the second construction point, sketch point or vertex."""
        return _fusion.ConstructionPlaneThreePointsDefinition__get_pointEntityTwo(self)

    def _get_pointEntityThree(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets the third construction point, sketch point or vertex."""
        return _fusion.ConstructionPlaneThreePointsDefinition__get_pointEntityThree(self)

    def redefine(self, pointEntityOne: "Base", pointEntityTwo: "Base", pointEntityThree: "Base") -> "bool":
        r"""
        Redefines the input geometry of the construction plane. 
        pointEntityOne : Gets the first construction point, sketch point or vertex. 
        pointEntityTwo : Gets the second construction point, sketch point or vertex. 
        pointEntityThree : Gets the third construction point, sketch point or vertex. 
        Returns true if the redefinition of the plane is successful.
        """
        return _fusion.ConstructionPlaneThreePointsDefinition_redefine(self, pointEntityOne, pointEntityTwo, pointEntityThree)

    def _get_parentConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >":
        r"""Returns the ConstructionPlane object"""
        return _fusion.ConstructionPlaneThreePointsDefinition__get_parentConstructionPlane(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionPlaneThreePointsDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionPlaneThreePointsDefinition__get_isValid(self)

# Register ConstructionPlaneThreePointsDefinition in _fusion:
_fusion.ConstructionPlaneThreePointsDefinition_swigregister(ConstructionPlaneThreePointsDefinition)

def ConstructionPlaneThreePointsDefinition_classType() -> "char const *":
    return _fusion.ConstructionPlaneThreePointsDefinition_classType()


ConstructionPlaneThreePointsDefinition.pointEntityOne = property(ConstructionPlaneThreePointsDefinition._get_pointEntityOne, doc="Gets the first construction point, sketch point or vertex.")


ConstructionPlaneThreePointsDefinition.pointEntityTwo = property(ConstructionPlaneThreePointsDefinition._get_pointEntityTwo, doc="Gets the second construction point, sketch point or vertex.")


ConstructionPlaneThreePointsDefinition.pointEntityThree = property(ConstructionPlaneThreePointsDefinition._get_pointEntityThree, doc="Gets the third construction point, sketch point or vertex.")


ConstructionPlaneThreePointsDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPlaneThreePointsDefinition) else None

class ConstructionPlaneTwoEdgesDefinition(ConstructionPlaneDefinition):
    r"""
    ConstructionPlaneTwoEdgesDefinition defines a ConstructionPlane by two co-planar
    linear entities like edges, sketch lines or construction axis.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionPlaneTwoEdgesDefinition *":
        return _fusion.ConstructionPlaneTwoEdgesDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionPlaneTwoEdgesDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionPlaneTwoEdgesDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionPlaneTwoEdgesDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionPlaneTwoEdgesDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionPlaneTwoEdgesDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionPlaneTwoEdgesDefinition

    def _get_linearEntityOne(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets the first linear edge, construction line, or sketch line that defines 
        the construction plane.
        """
        return _fusion.ConstructionPlaneTwoEdgesDefinition__get_linearEntityOne(self)

    def _get_linearEntityTwo(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets the second linear edge, construction line, or sketch line that defines 
        the construction plane.
        """
        return _fusion.ConstructionPlaneTwoEdgesDefinition__get_linearEntityTwo(self)

    def redefine(self, linearEntityOne: "Base", linearEntityTwo: "Base") -> "bool":
        r"""
        Redefines the input geometry of the construction plane. 
        linearEntityOne : The first linear edge, construction line, or sketch line that defines 
        the construction plane. 
        linearEntityTwo : The second linear edge, construction line, or sketch line that defines 
        the construction plane.
        """
        return _fusion.ConstructionPlaneTwoEdgesDefinition_redefine(self, linearEntityOne, linearEntityTwo)

    def _get_parentConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >":
        r"""Returns the ConstructionPlane object"""
        return _fusion.ConstructionPlaneTwoEdgesDefinition__get_parentConstructionPlane(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionPlaneTwoEdgesDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionPlaneTwoEdgesDefinition__get_isValid(self)

# Register ConstructionPlaneTwoEdgesDefinition in _fusion:
_fusion.ConstructionPlaneTwoEdgesDefinition_swigregister(ConstructionPlaneTwoEdgesDefinition)

def ConstructionPlaneTwoEdgesDefinition_classType() -> "char const *":
    return _fusion.ConstructionPlaneTwoEdgesDefinition_classType()


ConstructionPlaneTwoEdgesDefinition.linearEntityOne = property(ConstructionPlaneTwoEdgesDefinition._get_linearEntityOne, doc="Gets the first linear edge, construction line, or sketch line that defines\nthe construction plane.")


ConstructionPlaneTwoEdgesDefinition.linearEntityTwo = property(ConstructionPlaneTwoEdgesDefinition._get_linearEntityTwo, doc="Gets the second linear edge, construction line, or sketch line that defines\nthe construction plane.")


ConstructionPlaneTwoEdgesDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPlaneTwoEdgesDefinition) else None

class ConstructionPointCenterDefinition(ConstructionPointDefinition):
    r"""The definition for a parametric construction point created using the SetbyCenter method"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionPointCenterDefinition *":
        return _fusion.ConstructionPointCenterDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionPointCenterDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionPointCenterDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionPointCenterDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionPointCenterDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionPointCenterDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionPointCenterDefinition

    def _get_circularEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the spherical face (sphere or torus), circular edge or sketch arc/circle
        whose center defines the location for the construction point.
        """
        return _fusion.ConstructionPointCenterDefinition__get_circularEntity(self)

    def _set_circularEntity(self, value: "Base") -> "bool":
        r"""
        Gets and sets the spherical face (sphere or torus), circular edge or sketch arc/circle
        whose center defines the location for the construction point.
        """
        return _fusion.ConstructionPointCenterDefinition__set_circularEntity(self, value)

    def _get_parentConstructionPoint(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >":
        r"""Returns the ConstructionPoint object"""
        return _fusion.ConstructionPointCenterDefinition__get_parentConstructionPoint(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionPointCenterDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionPointCenterDefinition__get_isValid(self)

# Register ConstructionPointCenterDefinition in _fusion:
_fusion.ConstructionPointCenterDefinition_swigregister(ConstructionPointCenterDefinition)

def ConstructionPointCenterDefinition_classType() -> "char const *":
    return _fusion.ConstructionPointCenterDefinition_classType()


ConstructionPointCenterDefinition.circularEntity = property(ConstructionPointCenterDefinition._get_circularEntity, ConstructionPointCenterDefinition._set_circularEntity, doc="Gets and sets the spherical face (sphere or torus), circular edge or sketch arc/circle\nwhose center defines the location for the construction point.")


ConstructionPointCenterDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPointCenterDefinition) else None

class ConstructionPointEdgePlaneDefinition(ConstructionPointDefinition):
    r"""The definition for a parametric construction point created using the SetbyEdgePlane method"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionPointEdgePlaneDefinition *":
        return _fusion.ConstructionPointEdgePlaneDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionPointEdgePlaneDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionPointEdgePlaneDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionPointEdgePlaneDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionPointEdgePlaneDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionPointEdgePlaneDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionPointEdgePlaneDefinition

    def _get_edge(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""A linear B-Rep edge, construction axis or sketch line."""
        return _fusion.ConstructionPointEdgePlaneDefinition__get_edge(self)

    def _get_plane(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""A plane, planar B-Rep face or construction plane."""
        return _fusion.ConstructionPointEdgePlaneDefinition__get_plane(self)

    def redefine(self, edge: "Base", plane: "Base") -> "bool":
        r"""
        Redefines the input geometry of the construction point. 
        edge : A linear B-Rep edge, construction axis or sketch line. 
        plane : A plane, planar B-Rep face or construction plane. 
        Returns true if the redefinition of the Construction Point is successful.
        """
        return _fusion.ConstructionPointEdgePlaneDefinition_redefine(self, edge, plane)

    def _get_parentConstructionPoint(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >":
        r"""Returns the ConstructionPoint object"""
        return _fusion.ConstructionPointEdgePlaneDefinition__get_parentConstructionPoint(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionPointEdgePlaneDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionPointEdgePlaneDefinition__get_isValid(self)

# Register ConstructionPointEdgePlaneDefinition in _fusion:
_fusion.ConstructionPointEdgePlaneDefinition_swigregister(ConstructionPointEdgePlaneDefinition)

def ConstructionPointEdgePlaneDefinition_classType() -> "char const *":
    return _fusion.ConstructionPointEdgePlaneDefinition_classType()


ConstructionPointEdgePlaneDefinition.edge = property(ConstructionPointEdgePlaneDefinition._get_edge, doc="A linear B-Rep edge, construction axis or sketch line.")


ConstructionPointEdgePlaneDefinition.plane = property(ConstructionPointEdgePlaneDefinition._get_plane, doc="A plane, planar B-Rep face or construction plane.")


ConstructionPointEdgePlaneDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPointEdgePlaneDefinition) else None

class ConstructionPointPointDefinition(ConstructionPointDefinition):
    r"""
    The definition for a parametric construction point created using the SetbyPoint method
    All non-parametric constructions points will return this type of definition regardless 
    of the method used to initially create them.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionPointPointDefinition *":
        return _fusion.ConstructionPointPointDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionPointPointDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionPointPointDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionPointPointDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionPointPointDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionPointPointDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionPointPointDefinition

    def _get_pointEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the position of the point using a construction point, sketch point or
        vertex.
        Non-parametric points will always return a Point3D object
        """
        return _fusion.ConstructionPointPointDefinition__get_pointEntity(self)

    def _set_pointEntity(self, value: "Base") -> "bool":
        r"""
        Gets and sets the position of the point using a construction point, sketch point or
        vertex.
        Non-parametric points will always return a Point3D object
        """
        return _fusion.ConstructionPointPointDefinition__set_pointEntity(self, value)

    def _get_parentConstructionPoint(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >":
        r"""Returns the ConstructionPoint object"""
        return _fusion.ConstructionPointPointDefinition__get_parentConstructionPoint(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionPointPointDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionPointPointDefinition__get_isValid(self)

# Register ConstructionPointPointDefinition in _fusion:
_fusion.ConstructionPointPointDefinition_swigregister(ConstructionPointPointDefinition)

def ConstructionPointPointDefinition_classType() -> "char const *":
    return _fusion.ConstructionPointPointDefinition_classType()


ConstructionPointPointDefinition.pointEntity = property(ConstructionPointPointDefinition._get_pointEntity, ConstructionPointPointDefinition._set_pointEntity, doc="Gets and sets the position of the point using a construction point, sketch point or\nvertex.\nNon-parametric points will always return a Point3D object")


ConstructionPointPointDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPointPointDefinition) else None

class ConstructionPointThreePlanesDefinition(ConstructionPointDefinition):
    r"""The definition for a parametric construction point created using the SetbyThreePlanes method"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionPointThreePlanesDefinition *":
        return _fusion.ConstructionPointThreePlanesDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionPointThreePlanesDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionPointThreePlanesDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionPointThreePlanesDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionPointThreePlanesDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionPointThreePlanesDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionPointThreePlanesDefinition

    def _get_planeOne(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""The first plane or planar face"""
        return _fusion.ConstructionPointThreePlanesDefinition__get_planeOne(self)

    def _get_planeTwo(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""The second plane or planar face"""
        return _fusion.ConstructionPointThreePlanesDefinition__get_planeTwo(self)

    def _get_planeThree(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""The third plane or planar face"""
        return _fusion.ConstructionPointThreePlanesDefinition__get_planeThree(self)

    def redefine(self, planeOne: "Base", planeTwo: "Base", planeThree: "Base") -> "bool":
        r"""
        Redefines the input geometry of the construction point. 
        planeOne : The first plane or planar face to intersect 
        planeTwo : The second plane or planar face to intersect 
        planeThree : The third plane or planar face to intersect 
        Returns true if the redefinition of the Construction Point is successful.
        """
        return _fusion.ConstructionPointThreePlanesDefinition_redefine(self, planeOne, planeTwo, planeThree)

    def _get_parentConstructionPoint(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >":
        r"""Returns the ConstructionPoint object"""
        return _fusion.ConstructionPointThreePlanesDefinition__get_parentConstructionPoint(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionPointThreePlanesDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionPointThreePlanesDefinition__get_isValid(self)

# Register ConstructionPointThreePlanesDefinition in _fusion:
_fusion.ConstructionPointThreePlanesDefinition_swigregister(ConstructionPointThreePlanesDefinition)

def ConstructionPointThreePlanesDefinition_classType() -> "char const *":
    return _fusion.ConstructionPointThreePlanesDefinition_classType()


ConstructionPointThreePlanesDefinition.planeOne = property(ConstructionPointThreePlanesDefinition._get_planeOne, doc="The first plane or planar face")


ConstructionPointThreePlanesDefinition.planeTwo = property(ConstructionPointThreePlanesDefinition._get_planeTwo, doc="The second plane or planar face")


ConstructionPointThreePlanesDefinition.planeThree = property(ConstructionPointThreePlanesDefinition._get_planeThree, doc="The third plane or planar face")


ConstructionPointThreePlanesDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPointThreePlanesDefinition) else None

class ConstructionPointTwoEdgesDefinition(ConstructionPointDefinition):
    r"""The definition for a parametric construction point created using the SetbyTwoEdges method"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ConstructionPointTwoEdgesDefinition *":
        return _fusion.ConstructionPointTwoEdgesDefinition___deref__(self)

    def __eq__(self, rhs: "ConstructionPointTwoEdgesDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ConstructionPointTwoEdgesDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ConstructionPointTwoEdgesDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ConstructionPointTwoEdgesDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ConstructionPointTwoEdgesDefinition_classType()
    __swig_destroy__ = _fusion.delete_ConstructionPointTwoEdgesDefinition

    def _get_edgeOne(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns a B-Rep edge or sketch line"""
        return _fusion.ConstructionPointTwoEdgesDefinition__get_edgeOne(self)

    def _get_edgeTwo(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns a B-Rep edge or sketch line"""
        return _fusion.ConstructionPointTwoEdgesDefinition__get_edgeTwo(self)

    def redefine(self, edgeOne: "Base", edgeTwo: "Base") -> "bool":
        r"""
        Redefines the input geometry of the construction point. 
        edgeOne : The first B-Rep edge or sketch line 
        edgeTwo : The second B-Rep edge or sketch line 
        Returns true if the redefinition of the Construction Point is successful.
        """
        return _fusion.ConstructionPointTwoEdgesDefinition_redefine(self, edgeOne, edgeTwo)

    def _get_parentConstructionPoint(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >":
        r"""Returns the ConstructionPoint object"""
        return _fusion.ConstructionPointTwoEdgesDefinition__get_parentConstructionPoint(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ConstructionPointTwoEdgesDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ConstructionPointTwoEdgesDefinition__get_isValid(self)

# Register ConstructionPointTwoEdgesDefinition in _fusion:
_fusion.ConstructionPointTwoEdgesDefinition_swigregister(ConstructionPointTwoEdgesDefinition)

def ConstructionPointTwoEdgesDefinition_classType() -> "char const *":
    return _fusion.ConstructionPointTwoEdgesDefinition_classType()


ConstructionPointTwoEdgesDefinition.edgeOne = property(ConstructionPointTwoEdgesDefinition._get_edgeOne, doc="Returns a B-Rep edge or sketch line")


ConstructionPointTwoEdgesDefinition.edgeTwo = property(ConstructionPointTwoEdgesDefinition._get_edgeTwo, doc="Returns a B-Rep edge or sketch line")


ConstructionPointTwoEdgesDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPointTwoEdgesDefinition) else None

class CopyPasteBody(Feature):
    r"""Object that represents an existing Copy/Paste Body feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CopyPasteBody *":
        return _fusion.CopyPasteBody___deref__(self)

    def __eq__(self, rhs: "CopyPasteBody") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CopyPasteBody___eq__(self, rhs)


    def __ne__(self, rhs: "CopyPasteBody") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CopyPasteBody___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CopyPasteBody_classType()
    __swig_destroy__ = _fusion.delete_CopyPasteBody

    def _get_sourceBody(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Returns the bodies that were copied to create the result bodies of this feature. An ObjectCollection
        is returned that will contain the original bodies. It's possible that the collection can be empty
        or contain less than the number of bodies originally copied. This happens in the case where a body 
        has been deleted or consumed by some other operation.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.CopyPasteBody__get_sourceBody(self)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CopyPasteBody__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CopyPasteBody__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.CopyPasteBody_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.CopyPasteBody_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CopyPasteBody__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CopyPasteBody__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.CopyPasteBody__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.CopyPasteBody__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.CopyPasteBody__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.CopyPasteBody__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.CopyPasteBody__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.CopyPasteBody__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.CopyPasteBody__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.CopyPasteBody__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.CopyPasteBody__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.CopyPasteBody__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.CopyPasteBody__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.CopyPasteBody__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.CopyPasteBody__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CopyPasteBody__get_isValid(self)

# Register CopyPasteBody in _fusion:
_fusion.CopyPasteBody_swigregister(CopyPasteBody)

def CopyPasteBody_classType() -> "char const *":
    return _fusion.CopyPasteBody_classType()


CopyPasteBody.sourceBody = property(CopyPasteBody._get_sourceBody, doc="Returns the bodies that were copied to create the result bodies of this feature. An ObjectCollection\nis returned that will contain the original bodies. It's possible that the collection can be empty\nor contain less than the number of bodies originally copied. This happens in the case where a body\nhas been deleted or consumed by some other operation.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


CopyPasteBody.cast = lambda arg: arg if isinstance(arg, CopyPasteBody) else None

class CustomFeature(Feature):
    r"""Object that represents an existing CustomFeature feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomFeature *":
        return _fusion.CustomFeature___deref__(self)

    def __eq__(self, rhs: "CustomFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomFeature___eq__(self, rhs)


    def __ne__(self, rhs: "CustomFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomFeature_classType()
    __swig_destroy__ = _fusion.delete_CustomFeature

    def _get_definition(self) -> "adsk::core::Ptr< adsk::fusion::CustomFeatureDefinition >":
        r"""
        Gets the CustomFeatureDefinition object associated with this custom feature.
        null/None is returned in the case where the definition does not exist, which is
        typically a result of the owning add-in not being loaded.
        """
        return _fusion.CustomFeature__get_definition(self)

    def _get_dependencies(self) -> "adsk::core::Ptr< adsk::fusion::CustomFeatureDependencies >":
        r"""
        Returns the collection of dependencies for this custom feature. You can
        use the collection to query, add, and remove dependencies.
        """
        return _fusion.CustomFeature__get_dependencies(self)

    def _get_parameters(self) -> "adsk::core::Ptr< adsk::fusion::CustomFeatureParameters >":
        r"""Returns the list of parameters associated with this custom feature."""
        return _fusion.CustomFeature__get_parameters(self)

    def _get_startFeature(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets and sets the first feature owned by this custom feature."""
        return _fusion.CustomFeature__get_startFeature(self)

    def _set_startFeature(self, value: "Base") -> "bool":
        r"""Gets and sets the first feature owned by this custom feature."""
        return _fusion.CustomFeature__set_startFeature(self, value)

    def _get_endFeature(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets and sets the last feature owned by this custom feature."""
        return _fusion.CustomFeature__get_endFeature(self)

    def _set_endFeature(self, value: "Base") -> "bool":
        r"""Gets and sets the last feature owned by this custom feature."""
        return _fusion.CustomFeature__set_endFeature(self, value)

    def _get_features(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base >,std::allocator< adsk::core::Ptr< adsk::core::Base > > >":
        r"""
        Returns the features combined by this custom feature. The start and end features and all of
        the features between them in the timeline are returned.
        """
        return _fusion.CustomFeature__get_features(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::CustomFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of
        an assembly but is already the native object.
        """
        return _fusion.CustomFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::CustomFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.CustomFeature_createForAssemblyContext(self, occurrence)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CustomFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CustomFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.CustomFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.CustomFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CustomFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CustomFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.CustomFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.CustomFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.CustomFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.CustomFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.CustomFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.CustomFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.CustomFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.CustomFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.CustomFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.CustomFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.CustomFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.CustomFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomFeature__get_isValid(self)

# Register CustomFeature in _fusion:
_fusion.CustomFeature_swigregister(CustomFeature)

def CustomFeature_classType() -> "char const *":
    return _fusion.CustomFeature_classType()


CustomFeature.definition = property(CustomFeature._get_definition, doc="Gets the CustomFeatureDefinition object associated with this custom feature.\nnull/None is returned in the case where the definition does not exist, which is\ntypically a result of the owning add-in not being loaded.")


CustomFeature.dependencies = property(CustomFeature._get_dependencies, doc="Returns the collection of dependencies for this custom feature. You can\nuse the collection to query, add, and remove dependencies.")


CustomFeature.parameters = property(CustomFeature._get_parameters, doc="Returns the list of parameters associated with this custom feature.")


CustomFeature.startFeature = property(CustomFeature._get_startFeature, CustomFeature._set_startFeature, doc="Gets and sets the first feature owned by this custom feature.")


CustomFeature.endFeature = property(CustomFeature._get_endFeature, CustomFeature._set_endFeature, doc="Gets and sets the last feature owned by this custom feature.")


CustomFeature.features = property(CustomFeature._get_features, doc="Returns the features combined by this custom feature. The start and end features and all of\nthe features between them in the timeline are returned.")


CustomFeature.nativeObject = property(CustomFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


CustomFeature.cast = lambda arg: arg if isinstance(arg, CustomFeature) else None

class CustomGraphicsAppearanceColorEffect(CustomGraphicsColorEffect):
    r"""
    One of the types of color effects that can be applied to a custom graphics entity. With this 
    type of effect, the graphics entity will display using a Fusion appearance.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomGraphicsAppearanceColorEffect *":
        return _fusion.CustomGraphicsAppearanceColorEffect___deref__(self)

    def __eq__(self, rhs: "CustomGraphicsAppearanceColorEffect") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomGraphicsAppearanceColorEffect___eq__(self, rhs)


    def __ne__(self, rhs: "CustomGraphicsAppearanceColorEffect") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomGraphicsAppearanceColorEffect___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomGraphicsAppearanceColorEffect_classType()

    @staticmethod
    def create(appearance: "Appearance") -> "adsk::core::Ptr< adsk::core::Appearance > const &":
        return _fusion.CustomGraphicsAppearanceColorEffect_create(appearance)
    __swig_destroy__ = _fusion.delete_CustomGraphicsAppearanceColorEffect

    def _get_appearance(self) -> "adsk::core::Ptr< adsk::core::Appearance >":
        r"""
        Gets and sets the appearance to use. The appearance assigned must be available in the 
        design where the graphics will be drawn.
        """
        return _fusion.CustomGraphicsAppearanceColorEffect__get_appearance(self)

    def _set_appearance(self, value: "Appearance") -> "bool":
        r"""
        Gets and sets the appearance to use. The appearance assigned must be available in the 
        design where the graphics will be drawn.
        """
        return _fusion.CustomGraphicsAppearanceColorEffect__set_appearance(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomGraphicsAppearanceColorEffect__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomGraphicsAppearanceColorEffect__get_isValid(self)

# Register CustomGraphicsAppearanceColorEffect in _fusion:
_fusion.CustomGraphicsAppearanceColorEffect_swigregister(CustomGraphicsAppearanceColorEffect)

def CustomGraphicsAppearanceColorEffect_classType() -> "char const *":
    return _fusion.CustomGraphicsAppearanceColorEffect_classType()

def CustomGraphicsAppearanceColorEffect_create(appearance: "Appearance") -> "adsk::core::Ptr< adsk::core::Appearance > const &":
    return _fusion.CustomGraphicsAppearanceColorEffect_create(appearance)


CustomGraphicsAppearanceColorEffect.appearance = property(CustomGraphicsAppearanceColorEffect._get_appearance, CustomGraphicsAppearanceColorEffect._set_appearance, doc="Gets and sets the appearance to use. The appearance assigned must be available in the\ndesign where the graphics will be drawn.")


CustomGraphicsAppearanceColorEffect.cast = lambda arg: arg if isinstance(arg, CustomGraphicsAppearanceColorEffect) else None

class CustomGraphicsBasicMaterialColorEffect(CustomGraphicsColorEffect):
    r"""
    One of the types of color effects that can be applied to a custom graphics entity. With this type
    of effect, basic phong shading and lighting techniques are used so give the entity a 3-dimensional
    appearance.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomGraphicsBasicMaterialColorEffect *":
        return _fusion.CustomGraphicsBasicMaterialColorEffect___deref__(self)

    def __eq__(self, rhs: "CustomGraphicsBasicMaterialColorEffect") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomGraphicsBasicMaterialColorEffect___eq__(self, rhs)


    def __ne__(self, rhs: "CustomGraphicsBasicMaterialColorEffect") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomGraphicsBasicMaterialColorEffect___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomGraphicsBasicMaterialColorEffect_classType()

    @staticmethod
    def create(*args) -> "adsk::core::Ptr< adsk::core::Color > const &":
        return _fusion.CustomGraphicsBasicMaterialColorEffect_create(*args)
    __swig_destroy__ = _fusion.delete_CustomGraphicsBasicMaterialColorEffect

    def _get_emissiveColor(self) -> "adsk::core::Ptr< adsk::core::Color >":
        r"""
        Gets and sets the emissiveColor associated with this CustomGraphicsBasicMaterialColorEffect object.
        The emissive color is the primary color of the entity
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__get_emissiveColor(self)

    def _set_emissiveColor(self, value: "Color") -> "bool":
        r"""
        Gets and sets the emissiveColor associated with this CustomGraphicsBasicMaterialColorEffect object.
        The emissive color is the primary color of the entity
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__set_emissiveColor(self, value)

    def _get_ambientColor(self) -> "adsk::core::Ptr< adsk::core::Color >":
        r"""
        Gets and sets the ambientColor associated with this CustomGraphicsBasicMaterialColorEffect object.
        The ambient color is the color of the light anywhere there's not a specific light source.
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__get_ambientColor(self)

    def _set_ambientColor(self, value: "Color") -> "bool":
        r"""
        Gets and sets the ambientColor associated with this CustomGraphicsBasicMaterialColorEffect object.
        The ambient color is the color of the light anywhere there's not a specific light source.
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__set_ambientColor(self, value)

    def _get_diffuseColor(self) -> "adsk::core::Ptr< adsk::core::Color >":
        r"""
        Gets and sets the diffuseColor associated with this CustomGraphicsBasicMaterialColorEffect object.
        The diffuse color is the color of reflected light as it scatters off of a rough surface.
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__get_diffuseColor(self)

    def _set_diffuseColor(self, value: "Color") -> "bool":
        r"""
        Gets and sets the diffuseColor associated with this CustomGraphicsBasicMaterialColorEffect object.
        The diffuse color is the color of reflected light as it scatters off of a rough surface.
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__set_diffuseColor(self, value)

    def _get_specularColor(self) -> "adsk::core::Ptr< adsk::core::Color >":
        r"""
        Gets and sets the specularColor associated with this CustomGraphicsBasicMaterialColorEffect object.
        The specular color is the color of reflected light (highlights) as it is reflected off of a shiny surface. This is 
        commonly white or a lighter shade of the emissive color.
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__get_specularColor(self)

    def _set_specularColor(self, value: "Color") -> "bool":
        r"""
        Gets and sets the specularColor associated with this CustomGraphicsBasicMaterialColorEffect object.
        The specular color is the color of reflected light (highlights) as it is reflected off of a shiny surface. This is 
        commonly white or a lighter shade of the emissive color.
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__set_specularColor(self, value)

    def _get_glossiness(self) -> "double":
        r"""
        Gets and sets the glossiness associated with this CustomGraphicsBasicMaterialColorEffect object.
        The glossiness determines the size of highlights, and thus the apparent shininess of the material.
        A value of 0.0 will result in very large hightlights like you would see with a rough surface.
        A maximum valaue of 128.0 will result in very small highlight as from a smooth surface.
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__get_glossiness(self)

    def _set_glossiness(self, value: "double") -> "bool":
        r"""
        Gets and sets the glossiness associated with this CustomGraphicsBasicMaterialColorEffect object.
        The glossiness determines the size of highlights, and thus the apparent shininess of the material.
        A value of 0.0 will result in very large hightlights like you would see with a rough surface.
        A maximum valaue of 128.0 will result in very small highlight as from a smooth surface.
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__set_glossiness(self, value)

    def _get_opacity(self) -> "double":
        r"""
        Gets and sets the opacity associated with this CustomGraphicsBasicMaterialColorEffect object. 
        A value of 1.0 is completely opaque and 0.0 is completely transparent.
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__get_opacity(self)

    def _set_opacity(self, value: "double") -> "bool":
        r"""
        Gets and sets the opacity associated with this CustomGraphicsBasicMaterialColorEffect object. 
        A value of 1.0 is completely opaque and 0.0 is completely transparent.
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__set_opacity(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomGraphicsBasicMaterialColorEffect__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomGraphicsBasicMaterialColorEffect__get_isValid(self)

# Register CustomGraphicsBasicMaterialColorEffect in _fusion:
_fusion.CustomGraphicsBasicMaterialColorEffect_swigregister(CustomGraphicsBasicMaterialColorEffect)

def CustomGraphicsBasicMaterialColorEffect_classType() -> "char const *":
    return _fusion.CustomGraphicsBasicMaterialColorEffect_classType()

def CustomGraphicsBasicMaterialColorEffect_create(*args) -> "adsk::core::Ptr< adsk::core::Color > const &":
    return _fusion.CustomGraphicsBasicMaterialColorEffect_create(*args)


CustomGraphicsBasicMaterialColorEffect.emissiveColor = property(CustomGraphicsBasicMaterialColorEffect._get_emissiveColor, CustomGraphicsBasicMaterialColorEffect._set_emissiveColor, doc="Gets and sets the emissiveColor associated with this CustomGraphicsBasicMaterialColorEffect object.\nThe emissive color is the primary color of the entity")


CustomGraphicsBasicMaterialColorEffect.ambientColor = property(CustomGraphicsBasicMaterialColorEffect._get_ambientColor, CustomGraphicsBasicMaterialColorEffect._set_ambientColor, doc="Gets and sets the ambientColor associated with this CustomGraphicsBasicMaterialColorEffect object.\nThe ambient color is the color of the light anywhere there's not a specific light source.")


CustomGraphicsBasicMaterialColorEffect.diffuseColor = property(CustomGraphicsBasicMaterialColorEffect._get_diffuseColor, CustomGraphicsBasicMaterialColorEffect._set_diffuseColor, doc="Gets and sets the diffuseColor associated with this CustomGraphicsBasicMaterialColorEffect object.\nThe diffuse color is the color of reflected light as it scatters off of a rough surface.")


CustomGraphicsBasicMaterialColorEffect.specularColor = property(CustomGraphicsBasicMaterialColorEffect._get_specularColor, CustomGraphicsBasicMaterialColorEffect._set_specularColor, doc="Gets and sets the specularColor associated with this CustomGraphicsBasicMaterialColorEffect object.\nThe specular color is the color of reflected light (highlights) as it is reflected off of a shiny surface. This is\ncommonly white or a lighter shade of the emissive color.")


CustomGraphicsBasicMaterialColorEffect.glossiness = property(CustomGraphicsBasicMaterialColorEffect._get_glossiness, CustomGraphicsBasicMaterialColorEffect._set_glossiness, doc="Gets and sets the glossiness associated with this CustomGraphicsBasicMaterialColorEffect object.\nThe glossiness determines the size of highlights, and thus the apparent shininess of the material.\nA value of 0.0 will result in very large hightlights like you would see with a rough surface.\nA maximum valaue of 128.0 will result in very small highlight as from a smooth surface.")


CustomGraphicsBasicMaterialColorEffect.opacity = property(CustomGraphicsBasicMaterialColorEffect._get_opacity, CustomGraphicsBasicMaterialColorEffect._set_opacity, doc="Gets and sets the opacity associated with this CustomGraphicsBasicMaterialColorEffect object.\nA value of 1.0 is completely opaque and 0.0 is completely transparent.")


CustomGraphicsBasicMaterialColorEffect.cast = lambda arg: arg if isinstance(arg, CustomGraphicsBasicMaterialColorEffect) else None

class CustomGraphicsBRepBody(CustomGraphicsEntity):
    r"""This represents custom graphics that are based on a BRepBody."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomGraphicsBRepBody *":
        return _fusion.CustomGraphicsBRepBody___deref__(self)

    def __eq__(self, rhs: "CustomGraphicsBRepBody") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomGraphicsBRepBody___eq__(self, rhs)


    def __ne__(self, rhs: "CustomGraphicsBRepBody") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomGraphicsBRepBody___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomGraphicsBRepBody_classType()
    __swig_destroy__ = _fusion.delete_CustomGraphicsBRepBody

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBRepFaces >":
        r"""Returns the collection of CustomGraphicsBRepFace objects in the CustomGraphicsBRepBody."""
        return _fusion.CustomGraphicsBRepBody__get_faces(self)

    def _get_edges(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBRepEdges >":
        r"""Returns the collection of CustomGraphicsBRepEdge objects in the CustomGraphicsBRepBody."""
        return _fusion.CustomGraphicsBRepBody__get_edges(self)

    def _get_vertices(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBRepVertices >":
        r"""Returns the collection of CustomGraphicsBRepVertex objects in the CustomGraphicsBRepBody."""
        return _fusion.CustomGraphicsBRepBody__get_vertices(self)

    def _get_bRepBody(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""Returns a transient BRepBody that is being displayed as custom graphics."""
        return _fusion.CustomGraphicsBRepBody__get_bRepBody(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the entity from the custom graphics group. 
        Returns true if the deletion was successful.
        """
        return _fusion.CustomGraphicsBRepBody_deleteMe(self)

    def _get_isVisible(self) -> "bool":
        r"""
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsBRepBody__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsBRepBody__set_isVisible(self, value)

    def _get_isSelectable(self) -> "bool":
        r"""
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsBRepBody__get_isSelectable(self)

    def _set_isSelectable(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsBRepBody__set_isSelectable(self, value)

    def setOpacity(self, opacity: "double", isOverride: "bool") -> "bool":
        r"""
        Sets the opacity of the graphics entity. By default, when a new entity is it is
        completely opaque and does not override the opacity defined by the material. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if setting the opacity information was successful.
        """
        return _fusion.CustomGraphicsBRepBody_setOpacity(self, opacity, isOverride)

    def getOpacity(self) -> "bool":
        r"""
        Gets the opacity of the graphics entity. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if getting the opacity information was successful.
        """
        return _fusion.CustomGraphicsBRepBody_getOpacity(self)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >":
        r"""
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsBRepBody__get_transform(self)

    def _set_transform(self, value: "Matrix3D") -> "bool":
        r"""
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsBRepBody__set_transform(self, value)

    def _get_depthPriority(self) -> "int":
        r"""
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsBRepBody__get_depthPriority(self)

    def _set_depthPriority(self, value: "int") -> "bool":
        r"""
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsBRepBody__set_depthPriority(self, value)

    def _get_cullMode(self) -> "adsk::fusion::CustomGraphicsCullModes":
        r"""
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsBRepBody__get_cullMode(self)

    def _set_cullMode(self, value: "CustomGraphicsCullModes") -> "bool":
        r"""
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsBRepBody__set_cullMode(self, value)

    def _get_color(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsColorEffect >":
        r"""
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsBRepBody__get_color(self)

    def _set_color(self, value: "CustomGraphicsColorEffect") -> "bool":
        r"""
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsBRepBody__set_color(self, value)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the parent Component for a top-level group or the CustomGraphicsGroup object for 
        graphics entities and child groups.
        """
        return _fusion.CustomGraphicsBRepBody__get_parent(self)

    def _get_id(self) -> "std::string":
        r"""
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsBRepBody__get_id(self)

    def _set_id(self, value: "std::string const &") -> "bool":
        r"""
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsBRepBody__set_id(self, value)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""
        Returns a box oriented parallel to the world x-y-x axes that contains the graphics entity.
        Depending on whether the graphics are drawn in model space or screen space this will return
        the bounding box in either centimeters (model) or pixels (screen). In the case where it
        returns the bounding box in pixel space, the Z coordinates of the box will be 0 and can be ignored.
        """
        return _fusion.CustomGraphicsBRepBody__get_boundingBox(self)

    def _get_billBoarding(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBillBoard >":
        r"""
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsBRepBody__get_billBoarding(self)

    def _set_billBoarding(self, value: "CustomGraphicsBillBoard") -> "bool":
        r"""
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsBRepBody__set_billBoarding(self, value)

    def _get_viewPlacement(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewPlacement >":
        r"""
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsBRepBody__get_viewPlacement(self)

    def _set_viewPlacement(self, value: "CustomGraphicsViewPlacement") -> "bool":
        r"""
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsBRepBody__set_viewPlacement(self, value)

    def _get_viewScale(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewScale >":
        r"""
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsBRepBody__get_viewScale(self)

    def _set_viewScale(self, value: "CustomGraphicsViewScale") -> "bool":
        r"""
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsBRepBody__set_viewScale(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomGraphicsBRepBody__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomGraphicsBRepBody__get_isValid(self)

# Register CustomGraphicsBRepBody in _fusion:
_fusion.CustomGraphicsBRepBody_swigregister(CustomGraphicsBRepBody)

def CustomGraphicsBRepBody_classType() -> "char const *":
    return _fusion.CustomGraphicsBRepBody_classType()


CustomGraphicsBRepBody.faces = property(CustomGraphicsBRepBody._get_faces, doc="Returns the collection of CustomGraphicsBRepFace objects in the CustomGraphicsBRepBody.")


CustomGraphicsBRepBody.edges = property(CustomGraphicsBRepBody._get_edges, doc="Returns the collection of CustomGraphicsBRepEdge objects in the CustomGraphicsBRepBody.")


CustomGraphicsBRepBody.vertices = property(CustomGraphicsBRepBody._get_vertices, doc="Returns the collection of CustomGraphicsBRepVertex objects in the CustomGraphicsBRepBody.")


CustomGraphicsBRepBody.bRepBody = property(CustomGraphicsBRepBody._get_bRepBody, doc="Returns a transient BRepBody that is being displayed as custom graphics.")


CustomGraphicsBRepBody.cast = lambda arg: arg if isinstance(arg, CustomGraphicsBRepBody) else None

class CustomGraphicsCurve(CustomGraphicsEntity):
    r"""
    This represents custom graphics that are based on any object derived from Curve3D (except InfiniteLine3D).
    This is useful when drawing curved geometry where the alternative is to stroke the smooth curve and draw
    it as a series of lines. Using this you can directly use the curve and Fusion 360 will automatically take care
    of creating the correct display for the current level of detail.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomGraphicsCurve *":
        return _fusion.CustomGraphicsCurve___deref__(self)

    def __eq__(self, rhs: "CustomGraphicsCurve") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomGraphicsCurve___eq__(self, rhs)


    def __ne__(self, rhs: "CustomGraphicsCurve") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomGraphicsCurve___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomGraphicsCurve_classType()
    __swig_destroy__ = _fusion.delete_CustomGraphicsCurve

    def _get_curve(self) -> "adsk::core::Ptr< adsk::core::Curve3D >":
        r"""
        Gets and sets the curve associated with this graphics entity. Any of the curve types derived from Curve3D
        is valid except for InfiniteLine3D.
        """
        return _fusion.CustomGraphicsCurve__get_curve(self)

    def _set_curve(self, value: "Curve3D") -> "bool":
        r"""
        Gets and sets the curve associated with this graphics entity. Any of the curve types derived from Curve3D
        is valid except for InfiniteLine3D.
        """
        return _fusion.CustomGraphicsCurve__set_curve(self, value)

    def _get_weight(self) -> "double":
        r"""Defines the thickness of the curve in pixels."""
        return _fusion.CustomGraphicsCurve__get_weight(self)

    def _set_weight(self, value: "double") -> "bool":
        r"""Defines the thickness of the curve in pixels."""
        return _fusion.CustomGraphicsCurve__set_weight(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the entity from the custom graphics group. 
        Returns true if the deletion was successful.
        """
        return _fusion.CustomGraphicsCurve_deleteMe(self)

    def _get_isVisible(self) -> "bool":
        r"""
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsCurve__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsCurve__set_isVisible(self, value)

    def _get_isSelectable(self) -> "bool":
        r"""
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsCurve__get_isSelectable(self)

    def _set_isSelectable(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsCurve__set_isSelectable(self, value)

    def setOpacity(self, opacity: "double", isOverride: "bool") -> "bool":
        r"""
        Sets the opacity of the graphics entity. By default, when a new entity is it is
        completely opaque and does not override the opacity defined by the material. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if setting the opacity information was successful.
        """
        return _fusion.CustomGraphicsCurve_setOpacity(self, opacity, isOverride)

    def getOpacity(self) -> "bool":
        r"""
        Gets the opacity of the graphics entity. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if getting the opacity information was successful.
        """
        return _fusion.CustomGraphicsCurve_getOpacity(self)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >":
        r"""
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsCurve__get_transform(self)

    def _set_transform(self, value: "Matrix3D") -> "bool":
        r"""
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsCurve__set_transform(self, value)

    def _get_depthPriority(self) -> "int":
        r"""
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsCurve__get_depthPriority(self)

    def _set_depthPriority(self, value: "int") -> "bool":
        r"""
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsCurve__set_depthPriority(self, value)

    def _get_cullMode(self) -> "adsk::fusion::CustomGraphicsCullModes":
        r"""
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsCurve__get_cullMode(self)

    def _set_cullMode(self, value: "CustomGraphicsCullModes") -> "bool":
        r"""
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsCurve__set_cullMode(self, value)

    def _get_color(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsColorEffect >":
        r"""
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsCurve__get_color(self)

    def _set_color(self, value: "CustomGraphicsColorEffect") -> "bool":
        r"""
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsCurve__set_color(self, value)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the parent Component for a top-level group or the CustomGraphicsGroup object for 
        graphics entities and child groups.
        """
        return _fusion.CustomGraphicsCurve__get_parent(self)

    def _get_id(self) -> "std::string":
        r"""
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsCurve__get_id(self)

    def _set_id(self, value: "std::string const &") -> "bool":
        r"""
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsCurve__set_id(self, value)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""
        Returns a box oriented parallel to the world x-y-x axes that contains the graphics entity.
        Depending on whether the graphics are drawn in model space or screen space this will return
        the bounding box in either centimeters (model) or pixels (screen). In the case where it
        returns the bounding box in pixel space, the Z coordinates of the box will be 0 and can be ignored.
        """
        return _fusion.CustomGraphicsCurve__get_boundingBox(self)

    def _get_billBoarding(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBillBoard >":
        r"""
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsCurve__get_billBoarding(self)

    def _set_billBoarding(self, value: "CustomGraphicsBillBoard") -> "bool":
        r"""
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsCurve__set_billBoarding(self, value)

    def _get_viewPlacement(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewPlacement >":
        r"""
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsCurve__get_viewPlacement(self)

    def _set_viewPlacement(self, value: "CustomGraphicsViewPlacement") -> "bool":
        r"""
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsCurve__set_viewPlacement(self, value)

    def _get_viewScale(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewScale >":
        r"""
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsCurve__get_viewScale(self)

    def _set_viewScale(self, value: "CustomGraphicsViewScale") -> "bool":
        r"""
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsCurve__set_viewScale(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomGraphicsCurve__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomGraphicsCurve__get_isValid(self)

# Register CustomGraphicsCurve in _fusion:
_fusion.CustomGraphicsCurve_swigregister(CustomGraphicsCurve)

def CustomGraphicsCurve_classType() -> "char const *":
    return _fusion.CustomGraphicsCurve_classType()


CustomGraphicsCurve.curve = property(CustomGraphicsCurve._get_curve, CustomGraphicsCurve._set_curve, doc="Gets and sets the curve associated with this graphics entity. Any of the curve types derived from Curve3D\nis valid except for InfiniteLine3D.")


CustomGraphicsCurve.weight = property(CustomGraphicsCurve._get_weight, CustomGraphicsCurve._set_weight, doc="Defines the thickness of the curve in pixels.")


CustomGraphicsCurve.cast = lambda arg: arg if isinstance(arg, CustomGraphicsCurve) else None

class CustomGraphicsGroup(CustomGraphicsEntity):
    r"""Represents of group of custom graphics entities. A group can also own other graphics groups."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomGraphicsGroup *":
        return _fusion.CustomGraphicsGroup___deref__(self)

    def __eq__(self, rhs: "CustomGraphicsGroup") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomGraphicsGroup___eq__(self, rhs)


    def __ne__(self, rhs: "CustomGraphicsGroup") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomGraphicsGroup___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.CustomGraphicsGroup___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsEntity >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.CustomGraphicsGroup___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomGraphicsGroup_classType()
    __swig_destroy__ = _fusion.delete_CustomGraphicsGroup

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsEntity >":
        r"""
        Function that returns the specified custom graphics entity within this group. This also includes
        any child graphics groups. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.CustomGraphicsGroup_item(self, index)

    def _get_count(self) -> "size_t":
        r"""Returns the number of graphics entities within the group."""
        return _fusion.CustomGraphicsGroup__get_count(self)

    def addGroup(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsGroup >":
        r"""
        Creates a new, empty CustomGraphicsGroup that is owned by this CustomGraphicsGroup. 
        Returns the new CustomGraphicsGroup object or null in the case of a failure.
        """
        return _fusion.CustomGraphicsGroup_addGroup(self)

    def addMesh(self, coordinates: "CustomGraphicsCoordinates", coordinateIndexList: "IntVector", normalVectors: "DoubleVector", normalIndexList: "IntVector") -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsMesh >":
        r"""
        Adds a new CustomGraphicsMesh entity to this group. 
        coordinates : The CustomGraphicsCoordinates object that defines the coordinates of the vertices of the mesh.
        A CustomGrahpicsCoordinates object can be created using the static create method of the CustomGraphicsCoordinates class. 
        coordinateIndexList : An array of integers that represent indices into the coordinates to define the vertices of the triangles. If an empty
        array is provided, then it's assumed that the first three coordinates defines the first triangle, the next three define
        the second triangle, and so on. 
        normalVectors : An array of doubles that represent the x, y, z components of the normals at each coordinate. There should be a normal defined
        for each coordinate. If an empty array is provided for the normal vectors, Fusion 360 will automatically calculate normal vectors
        that are 90 degrees to the face of the triangle, making it appear flat. 
        normalIndexList : An array of integers that represent indices into the normal vectors to define the which vector corresponds to which vertex. This
        should be the same size as the vertex index list. If an empty array is input and normal vectors are provided, it is assumed that
        the normals match up one-to-one to each coordinate. 
        Returns the new CustomGraphicsMesh object or null in the case of a failure.
        """
        return _fusion.CustomGraphicsGroup_addMesh(self, coordinates, coordinateIndexList, normalVectors, normalIndexList)

    def addLines(self, *args) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsLines >":
        r"""
        Adds a new CustomGraphicsLines entity to this group. 
        coordinates : The CustomGraphicsCoordinates object that defines the coordinates of the vertices of the lines.
        A CustomGraphicsCoordinates object can be created using the static create method of the CustomGraphicsCoordinates class. 
        indexList : An array of integers that represent indices into the coordinates to define the order the coordinates are used to draw the lines.
        If an empty array is provided, the coordinates are used in the order they're provided in the provided CustomGraphicsCoordinates object. 
        isLineStrip : A boolean indicating if a series of individual lines or a connected set of lines (a line strip) is to be drawn. If individual lines
        are drawn, (this argument is false), each pair of coordinates defines a single line. If a line strip is drawn, (this argument is true), 
        the first pair of coordinates define the first line and the third coordinate defines a line that connects to the second coordinate. 
        The fourth coordinate creates a line connecting to the third coordinate, and so on. 
        lineStripLengths : If isLineStrip is true, this argument is used to define the number of coordinates to use in each line strip. It is an array of integers 
        that defines the number of coordinates for each line strip. For example, if the array [4,10] is input, 4 coordinates are connected for
        the first line strip and 10 are used to create a second line strip. If an empty array is provided, a single line strip is created. If
        isLineStrip is False, this argument is ignored. 
        Returns the new CustomGraphicsLines object or null in the case of a failure.
        """
        return _fusion.CustomGraphicsGroup_addLines(self, *args)

    def addCurve(self, curve: "Curve3D") -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsCurve >":
        r"""
        Adds a new CustomGraphicsCurve entity to this group. A CustomGraphicsCurve is a wireframe graphic 
        that is based on any object derived from Curve3D (except InfiniteLine3D). This is useful when 
        drawing curved geometry where the alternative is to stroke the smooth curve and draw it as a series 
        of lines. Using this you can directly use the curve and Fusion 360 will automatically take care of creating 
        the correct display for the current level of detail. 
        curve : The curve that defines the shape of the graphics entity. Any of the curve types derived from Curve3D
        are valid except for InfiniteLine3D. 
        Returns the newly created CustomGraphicsCurve object or null in the case of failure.
        """
        return _fusion.CustomGraphicsGroup_addCurve(self, curve)

    def addPointSet(self, coordinates: "CustomGraphicsCoordinates", indexList: "IntVector", pointType: "CustomGraphicsPointTypes", pointImage: "std::string const &") -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsPointSet >":
        r"""
        Adds a new CustomGraphicsPointSet entity to this group. This will be displayed as one or more points where
        all of the points will display using the same image. 
        coordinates : The CustomGraphicsCoordinates object that defines the coordinates where the points will be displayed.
        A CustomGraphicsCoordinates object can be created using the static create method of the CustomGraphicsCoordinates class. 
        indexList : An array of integers that represent indices into the coordinates to define which coordinates to use when drawing points.
        If an empty array is provided, a point is drawn for every coordinate. 
        pointType : Specifies the type of point to display. Currently there are two choices; UserDefinedCustomGraphicsPointType and 
        PointCloudCustomGraphicsPointType. When set to PointCloudCustomGraphicsPointType, each point displays as a single pixel and is 
        the most efficient point display type for displaying sets that contain very large quantities of points. When
        set to UserDefinedCustomGraphicsPointType, you specify the image to display as the point. This can be any png image and is
        centered on the point. 
        pointImage : If the pointType is PointCloudCustomGraphicsPointType this argument is ignored and can be an empty string. This argument
        must be specified if the pointType is UserDefinedCustomGraphicsPointType. This is the path to the png image file that will be
        displayed as the point. It can be either a full path to the file or a relative path that is respect to the .py, dll, or dylib
        file being run. There is no restriction on the size of the image, but generally very small images would be used for points. 
        Returns the newly created CustomGraphicsPointSet object or null in the case of failure.
        """
        return _fusion.CustomGraphicsGroup_addPointSet(self, coordinates, indexList, pointType, pointImage)

    def addText(self, formattedText: "std::string const &", font: "std::string const &", size: "double", transform: "Matrix3D") -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsText >":
        r"""
        Adds a new CustomGraphicsText entity to this group. This will be displayed as a single line of text.
        It is placed so that the upper-left corner is at the point defined and the text will be parallel
        to the X-Y plane of the world coordinate system and in the X direction. To change it's position relative
        to the input point you can change the horizontal and vertical justification on the returnsed CustomGrahicsText
        object. You can also reorient the text by changing the transform of the returned CustomGraphicsText object. 
        formattedText : The text string to be displayed. Overall formatting can be defined using properties on the returned
        CustomGraphicsText object. Formatting overrides can be defined within the string using formatting codes. 
        font : The name of the font to use when displaying the text. 
        size : The size of the text in centimeters. 
        transform : Transformation matrix that specifies the position and orientation of the text in model space. The origin of the text
        is the upper-left corner. 
        Returns the newly created CustomGraphicsText object or null in the case of failure.
        """
        return _fusion.CustomGraphicsGroup_addText(self, formattedText, font, size, transform)

    def addBRepBody(self, body: "BRepBody") -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBRepBody >":
        r"""
        Adds a new CustomGraphicsBRepBody object to this group. This displays a real or transient BRepBody
        object as custom graphics. No relationship exists back to the original input body so if it is
        changed, the custom graphics will not change.
        The body associated with the CustomGraphicsBRep body is a copy of the original input body. Equivalent
        Faces, Edges, and vertices can be found by using the indexes in the collection. For example if you have
        a face of the original body and find that it is at index 24 in the BRepFaces collection of that body,
        the equivalent face in the custom graphics body will also be at index 24. This works as long as the original
        body is not modified in any way. 
        body : The real or transient BRepBody object to draw using custom graphics. 
        Returns the newly created CustomGraphicsBRepBody object or null in the case of failure.
        """
        return _fusion.CustomGraphicsGroup_addBRepBody(self, body)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the entity from the custom graphics group. 
        Returns true if the deletion was successful.
        """
        return _fusion.CustomGraphicsGroup_deleteMe(self)

    def _get_isVisible(self) -> "bool":
        r"""
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsGroup__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsGroup__set_isVisible(self, value)

    def _get_isSelectable(self) -> "bool":
        r"""
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsGroup__get_isSelectable(self)

    def _set_isSelectable(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsGroup__set_isSelectable(self, value)

    def setOpacity(self, opacity: "double", isOverride: "bool") -> "bool":
        r"""
        Sets the opacity of the graphics entity. By default, when a new entity is it is
        completely opaque and does not override the opacity defined by the material. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if setting the opacity information was successful.
        """
        return _fusion.CustomGraphicsGroup_setOpacity(self, opacity, isOverride)

    def getOpacity(self) -> "bool":
        r"""
        Gets the opacity of the graphics entity. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if getting the opacity information was successful.
        """
        return _fusion.CustomGraphicsGroup_getOpacity(self)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >":
        r"""
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsGroup__get_transform(self)

    def _set_transform(self, value: "Matrix3D") -> "bool":
        r"""
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsGroup__set_transform(self, value)

    def _get_depthPriority(self) -> "int":
        r"""
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsGroup__get_depthPriority(self)

    def _set_depthPriority(self, value: "int") -> "bool":
        r"""
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsGroup__set_depthPriority(self, value)

    def _get_cullMode(self) -> "adsk::fusion::CustomGraphicsCullModes":
        r"""
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsGroup__get_cullMode(self)

    def _set_cullMode(self, value: "CustomGraphicsCullModes") -> "bool":
        r"""
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsGroup__set_cullMode(self, value)

    def _get_color(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsColorEffect >":
        r"""
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsGroup__get_color(self)

    def _set_color(self, value: "CustomGraphicsColorEffect") -> "bool":
        r"""
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsGroup__set_color(self, value)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the parent Component for a top-level group or the CustomGraphicsGroup object for 
        graphics entities and child groups.
        """
        return _fusion.CustomGraphicsGroup__get_parent(self)

    def _get_id(self) -> "std::string":
        r"""
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsGroup__get_id(self)

    def _set_id(self, value: "std::string const &") -> "bool":
        r"""
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsGroup__set_id(self, value)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""
        Returns a box oriented parallel to the world x-y-x axes that contains the graphics entity.
        Depending on whether the graphics are drawn in model space or screen space this will return
        the bounding box in either centimeters (model) or pixels (screen). In the case where it
        returns the bounding box in pixel space, the Z coordinates of the box will be 0 and can be ignored.
        """
        return _fusion.CustomGraphicsGroup__get_boundingBox(self)

    def _get_billBoarding(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBillBoard >":
        r"""
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsGroup__get_billBoarding(self)

    def _set_billBoarding(self, value: "CustomGraphicsBillBoard") -> "bool":
        r"""
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsGroup__set_billBoarding(self, value)

    def _get_viewPlacement(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewPlacement >":
        r"""
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsGroup__get_viewPlacement(self)

    def _set_viewPlacement(self, value: "CustomGraphicsViewPlacement") -> "bool":
        r"""
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsGroup__set_viewPlacement(self, value)

    def _get_viewScale(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewScale >":
        r"""
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsGroup__get_viewScale(self)

    def _set_viewScale(self, value: "CustomGraphicsViewScale") -> "bool":
        r"""
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsGroup__set_viewScale(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomGraphicsGroup__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomGraphicsGroup__get_isValid(self)

# Register CustomGraphicsGroup in _fusion:
_fusion.CustomGraphicsGroup_swigregister(CustomGraphicsGroup)

def CustomGraphicsGroup_classType() -> "char const *":
    return _fusion.CustomGraphicsGroup_classType()


CustomGraphicsGroup.count = property(CustomGraphicsGroup._get_count, doc="Returns the number of graphics entities within the group.")


CustomGraphicsGroup.cast = lambda arg: arg if isinstance(arg, CustomGraphicsGroup) else None

class CustomGraphicsLines(CustomGraphicsEntity):
    r"""Represents lines drawn in the graphics window."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomGraphicsLines *":
        return _fusion.CustomGraphicsLines___deref__(self)

    def __eq__(self, rhs: "CustomGraphicsLines") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomGraphicsLines___eq__(self, rhs)


    def __ne__(self, rhs: "CustomGraphicsLines") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomGraphicsLines___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomGraphicsLines_classType()
    __swig_destroy__ = _fusion.delete_CustomGraphicsLines

    def _get_coordinates(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsCoordinates >":
        r"""
        Gets and sets the CustomGraphicsCoordinates object that defines the coordinates of the vertices of the lines.
        A CustomGraphicsCoordinates object can be created using the static create method of the CustomGraphicsCoordinates class.
        """
        return _fusion.CustomGraphicsLines__get_coordinates(self)

    def _set_coordinates(self, value: "CustomGraphicsCoordinates") -> "bool":
        r"""
        Gets and sets the CustomGraphicsCoordinates object that defines the coordinates of the vertices of the lines.
        A CustomGraphicsCoordinates object can be created using the static create method of the CustomGraphicsCoordinates class.
        """
        return _fusion.CustomGraphicsLines__set_coordinates(self, value)

    def _get_indexList(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        Gets and sets an array of integers that represent indices into the coordinates to define the order the coordinates are used to draw the lines.
        An empty array indicates that no index list is used and coordinates are used in the order they're provided in the provided CustomGraphicsCoordinates object.
        """
        return _fusion.CustomGraphicsLines__get_indexList(self)

    def _set_indexList(self, value: "IntVector") -> "bool":
        r"""
        Gets and sets an array of integers that represent indices into the coordinates to define the order the coordinates are used to draw the lines.
        An empty array indicates that no index list is used and coordinates are used in the order they're provided in the provided CustomGraphicsCoordinates object.
        """
        return _fusion.CustomGraphicsLines__set_indexList(self, value)

    def _get_isLineStrip(self) -> "bool":
        r"""
        Defines if the coordinates are used to define a series of individual lines or a connected set of lines (line strip). If individual lines
        are drawn (this property is false), each pair of coordinates define a single line. If a line strip is drawn (this property is true), 
        the first pair of coordinates define the first line and the third coordinate defines a line that connects to the second coordinate. 
        The fourth coordinate creates a line connecting to the third coordinate, and so on.
        """
        return _fusion.CustomGraphicsLines__get_isLineStrip(self)

    def _set_isLineStrip(self, value: "bool") -> "bool":
        r"""
        Defines if the coordinates are used to define a series of individual lines or a connected set of lines (line strip). If individual lines
        are drawn (this property is false), each pair of coordinates define a single line. If a line strip is drawn (this property is true), 
        the first pair of coordinates define the first line and the third coordinate defines a line that connects to the second coordinate. 
        The fourth coordinate creates a line connecting to the third coordinate, and so on.
        """
        return _fusion.CustomGraphicsLines__set_isLineStrip(self, value)

    def _get_lineStripLengths(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        If isLineStrip is true, this property defines the number of coordinates to use in the line strips. It is an array of integers 
        that defines the number of coordinates for each line strip. An empty array indicates that a single line strip is to be drawn.
        """
        return _fusion.CustomGraphicsLines__get_lineStripLengths(self)

    def _set_lineStripLengths(self, value: "IntVector") -> "bool":
        r"""
        If isLineStrip is true, this property defines the number of coordinates to use in the line strips. It is an array of integers 
        that defines the number of coordinates for each line strip. An empty array indicates that a single line strip is to be drawn.
        """
        return _fusion.CustomGraphicsLines__set_lineStripLengths(self, value)

    def _get_weight(self) -> "double":
        r"""Defines the thickness of the line in pixels."""
        return _fusion.CustomGraphicsLines__get_weight(self)

    def _set_weight(self, value: "double") -> "bool":
        r"""Defines the thickness of the line in pixels."""
        return _fusion.CustomGraphicsLines__set_weight(self, value)

    def _get_lineStyleScale(self) -> "double":
        r"""
        Defines the scale as it relates to how the line style is applied. The effect is to 
        shrink or expand the line style as it is applied to the line. This does not affect the line width.
        """
        return _fusion.CustomGraphicsLines__get_lineStyleScale(self)

    def _set_lineStyleScale(self, value: "double") -> "bool":
        r"""
        Defines the scale as it relates to how the line style is applied. The effect is to 
        shrink or expand the line style as it is applied to the line. This does not affect the line width.
        """
        return _fusion.CustomGraphicsLines__set_lineStyleScale(self, value)

    def _get_isScreenSpaceLineStyle(self) -> "bool":
        r"""
        Specifies if the line style is computed based on the screen or model space. The default is
        based on the screen which means the style is drawn the same regardless of how you zoom in
        or out of the view. That is the length of lines and spaces are based on pixels. If it
        is drawn relative to model space then the lines and spaces are defined in centimeters and
        will zooming in and out will change the apparent spacing.
        """
        return _fusion.CustomGraphicsLines__get_isScreenSpaceLineStyle(self)

    def _set_isScreenSpaceLineStyle(self, value: "bool") -> "bool":
        r"""
        Specifies if the line style is computed based on the screen or model space. The default is
        based on the screen which means the style is drawn the same regardless of how you zoom in
        or out of the view. That is the length of lines and spaces are based on pixels. If it
        is drawn relative to model space then the lines and spaces are defined in centimeters and
        will zooming in and out will change the apparent spacing.
        """
        return _fusion.CustomGraphicsLines__set_isScreenSpaceLineStyle(self, value)

    def _get_lineStylePattern(self) -> "adsk::fusion::LineStylePatterns":
        r"""The line style to apply to the line. The default is to draw a continuous line."""
        return _fusion.CustomGraphicsLines__get_lineStylePattern(self)

    def _set_lineStylePattern(self, value: "LineStylePatterns") -> "bool":
        r"""The line style to apply to the line. The default is to draw a continuous line."""
        return _fusion.CustomGraphicsLines__set_lineStylePattern(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the entity from the custom graphics group. 
        Returns true if the deletion was successful.
        """
        return _fusion.CustomGraphicsLines_deleteMe(self)

    def _get_isVisible(self) -> "bool":
        r"""
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsLines__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsLines__set_isVisible(self, value)

    def _get_isSelectable(self) -> "bool":
        r"""
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsLines__get_isSelectable(self)

    def _set_isSelectable(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsLines__set_isSelectable(self, value)

    def setOpacity(self, opacity: "double", isOverride: "bool") -> "bool":
        r"""
        Sets the opacity of the graphics entity. By default, when a new entity is it is
        completely opaque and does not override the opacity defined by the material. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if setting the opacity information was successful.
        """
        return _fusion.CustomGraphicsLines_setOpacity(self, opacity, isOverride)

    def getOpacity(self) -> "bool":
        r"""
        Gets the opacity of the graphics entity. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if getting the opacity information was successful.
        """
        return _fusion.CustomGraphicsLines_getOpacity(self)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >":
        r"""
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsLines__get_transform(self)

    def _set_transform(self, value: "Matrix3D") -> "bool":
        r"""
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsLines__set_transform(self, value)

    def _get_depthPriority(self) -> "int":
        r"""
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsLines__get_depthPriority(self)

    def _set_depthPriority(self, value: "int") -> "bool":
        r"""
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsLines__set_depthPriority(self, value)

    def _get_cullMode(self) -> "adsk::fusion::CustomGraphicsCullModes":
        r"""
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsLines__get_cullMode(self)

    def _set_cullMode(self, value: "CustomGraphicsCullModes") -> "bool":
        r"""
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsLines__set_cullMode(self, value)

    def _get_color(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsColorEffect >":
        r"""
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsLines__get_color(self)

    def _set_color(self, value: "CustomGraphicsColorEffect") -> "bool":
        r"""
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsLines__set_color(self, value)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the parent Component for a top-level group or the CustomGraphicsGroup object for 
        graphics entities and child groups.
        """
        return _fusion.CustomGraphicsLines__get_parent(self)

    def _get_id(self) -> "std::string":
        r"""
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsLines__get_id(self)

    def _set_id(self, value: "std::string const &") -> "bool":
        r"""
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsLines__set_id(self, value)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""
        Returns a box oriented parallel to the world x-y-x axes that contains the graphics entity.
        Depending on whether the graphics are drawn in model space or screen space this will return
        the bounding box in either centimeters (model) or pixels (screen). In the case where it
        returns the bounding box in pixel space, the Z coordinates of the box will be 0 and can be ignored.
        """
        return _fusion.CustomGraphicsLines__get_boundingBox(self)

    def _get_billBoarding(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBillBoard >":
        r"""
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsLines__get_billBoarding(self)

    def _set_billBoarding(self, value: "CustomGraphicsBillBoard") -> "bool":
        r"""
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsLines__set_billBoarding(self, value)

    def _get_viewPlacement(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewPlacement >":
        r"""
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsLines__get_viewPlacement(self)

    def _set_viewPlacement(self, value: "CustomGraphicsViewPlacement") -> "bool":
        r"""
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsLines__set_viewPlacement(self, value)

    def _get_viewScale(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewScale >":
        r"""
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsLines__get_viewScale(self)

    def _set_viewScale(self, value: "CustomGraphicsViewScale") -> "bool":
        r"""
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsLines__set_viewScale(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomGraphicsLines__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomGraphicsLines__get_isValid(self)

# Register CustomGraphicsLines in _fusion:
_fusion.CustomGraphicsLines_swigregister(CustomGraphicsLines)

def CustomGraphicsLines_classType() -> "char const *":
    return _fusion.CustomGraphicsLines_classType()


CustomGraphicsLines.coordinates = property(CustomGraphicsLines._get_coordinates, CustomGraphicsLines._set_coordinates, doc="Gets and sets the CustomGraphicsCoordinates object that defines the coordinates of the vertices of the lines.\nA CustomGraphicsCoordinates object can be created using the static create method of the CustomGraphicsCoordinates class.")


CustomGraphicsLines.indexList = property(CustomGraphicsLines._get_indexList, CustomGraphicsLines._set_indexList, doc="Gets and sets an array of integers that represent indices into the coordinates to define the order the coordinates are used to draw the lines.\nAn empty array indicates that no index list is used and coordinates are used in the order they're provided in the provided CustomGraphicsCoordinates object.")


CustomGraphicsLines.isLineStrip = property(CustomGraphicsLines._get_isLineStrip, CustomGraphicsLines._set_isLineStrip, doc="Defines if the coordinates are used to define a series of individual lines or a connected set of lines (line strip). If individual lines\nare drawn (this property is false), each pair of coordinates define a single line. If a line strip is drawn (this property is true),\nthe first pair of coordinates define the first line and the third coordinate defines a line that connects to the second coordinate.\nThe fourth coordinate creates a line connecting to the third coordinate, and so on.")


CustomGraphicsLines.lineStripLengths = property(CustomGraphicsLines._get_lineStripLengths, CustomGraphicsLines._set_lineStripLengths, doc="If isLineStrip is true, this property defines the number of coordinates to use in the line strips. It is an array of integers\nthat defines the number of coordinates for each line strip. An empty array indicates that a single line strip is to be drawn.")


CustomGraphicsLines.weight = property(CustomGraphicsLines._get_weight, CustomGraphicsLines._set_weight, doc="Defines the thickness of the line in pixels.")


CustomGraphicsLines.lineStyleScale = property(CustomGraphicsLines._get_lineStyleScale, CustomGraphicsLines._set_lineStyleScale, doc="Defines the scale as it relates to how the line style is applied. The effect is to\nshrink or expand the line style as it is applied to the line. This does not affect the line width.")


CustomGraphicsLines.isScreenSpaceLineStyle = property(CustomGraphicsLines._get_isScreenSpaceLineStyle, CustomGraphicsLines._set_isScreenSpaceLineStyle, doc="Specifies if the line style is computed based on the screen or model space. The default is\nbased on the screen which means the style is drawn the same regardless of how you zoom in\nor out of the view. That is the length of lines and spaces are based on pixels. If it\nis drawn relative to model space then the lines and spaces are defined in centimeters and\nwill zooming in and out will change the apparent spacing.")


CustomGraphicsLines.lineStylePattern = property(CustomGraphicsLines._get_lineStylePattern, CustomGraphicsLines._set_lineStylePattern, doc="The line style to apply to the line. The default is to draw a continuous line.")


CustomGraphicsLines.cast = lambda arg: arg if isinstance(arg, CustomGraphicsLines) else None

class CustomGraphicsMesh(CustomGraphicsEntity):
    r"""Represents a custom triangle mesh drawn in the graphics window."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomGraphicsMesh *":
        return _fusion.CustomGraphicsMesh___deref__(self)

    def __eq__(self, rhs: "CustomGraphicsMesh") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomGraphicsMesh___eq__(self, rhs)


    def __ne__(self, rhs: "CustomGraphicsMesh") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomGraphicsMesh___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomGraphicsMesh_classType()
    __swig_destroy__ = _fusion.delete_CustomGraphicsMesh

    def _get_coordinates(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsCoordinates >":
        r"""Gets and sets the coordinates associated with this CustomGraphicsMesh."""
        return _fusion.CustomGraphicsMesh__get_coordinates(self)

    def _set_coordinates(self, value: "CustomGraphicsCoordinates") -> "bool":
        r"""Gets and sets the coordinates associated with this CustomGraphicsMesh."""
        return _fusion.CustomGraphicsMesh__set_coordinates(self, value)

    def _get_normalVectors(self) -> "std::vector< double,std::allocator< double > >":
        r"""
        Gets and sets the normal vectors of the mesh where there is a normal
        vector at each node. The normals are defined as an array
        of floats where they are the x, y, z components of each vector.
        """
        return _fusion.CustomGraphicsMesh__get_normalVectors(self)

    def _set_normalVectors(self, value: "DoubleVector") -> "bool":
        r"""
        Gets and sets the normal vectors of the mesh where there is a normal
        vector at each node. The normals are defined as an array
        of floats where they are the x, y, z components of each vector.
        """
        return _fusion.CustomGraphicsMesh__set_normalVectors(self, value)

    def _get_vertexIndexList(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        Gets and sets an array of indices that define which coordinate in the
        coordinate list is used for each vertex in the mesh. Each set of three
        indices defines a triagle. For example: 
        Indices 0, 1, and 2 define the coordinates to use for the first triangle and
        indices 3, 4, and 5 define the coordinates for the second triangle, and so on.
        """
        return _fusion.CustomGraphicsMesh__get_vertexIndexList(self)

    def _set_vertexIndexList(self, value: "IntVector") -> "bool":
        r"""
        Gets and sets an array of indices that define which coordinate in the
        coordinate list is used for each vertex in the mesh. Each set of three
        indices defines a triagle. For example: 
        Indices 0, 1, and 2 define the coordinates to use for the first triangle and
        indices 3, 4, and 5 define the coordinates for the second triangle, and so on.
        """
        return _fusion.CustomGraphicsMesh__set_vertexIndexList(self, value)

    def _get_normalIndexList(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        Gets and sets an array of indices that define which normal is associated
        with each vertex in the mesh. This is used to look-up the normal in the
        normalVectors array.
        """
        return _fusion.CustomGraphicsMesh__get_normalIndexList(self)

    def _set_normalIndexList(self, value: "IntVector") -> "bool":
        r"""
        Gets and sets an array of indices that define which normal is associated
        with each vertex in the mesh. This is used to look-up the normal in the
        normalVectors array.
        """
        return _fusion.CustomGraphicsMesh__set_normalIndexList(self, value)

    def _get_textureCoordinates(self) -> "std::vector< double,std::allocator< double > >":
        r"""
        Gets and sets the texture coordinates as an array of floats where
        they are the u,v components at each node. They are defined as an
        array of doubles where they are the u, v coordinates of each node.
        Defining texture coordinates for a mesh is optional.
        """
        return _fusion.CustomGraphicsMesh__get_textureCoordinates(self)

    def _set_textureCoordinates(self, value: "DoubleVector") -> "bool":
        r"""
        Gets and sets the texture coordinates as an array of floats where
        they are the u,v components at each node. They are defined as an
        array of doubles where they are the u, v coordinates of each node.
        Defining texture coordinates for a mesh is optional.
        """
        return _fusion.CustomGraphicsMesh__set_textureCoordinates(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the entity from the custom graphics group. 
        Returns true if the deletion was successful.
        """
        return _fusion.CustomGraphicsMesh_deleteMe(self)

    def _get_isVisible(self) -> "bool":
        r"""
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsMesh__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsMesh__set_isVisible(self, value)

    def _get_isSelectable(self) -> "bool":
        r"""
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsMesh__get_isSelectable(self)

    def _set_isSelectable(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsMesh__set_isSelectable(self, value)

    def setOpacity(self, opacity: "double", isOverride: "bool") -> "bool":
        r"""
        Sets the opacity of the graphics entity. By default, when a new entity is it is
        completely opaque and does not override the opacity defined by the material. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if setting the opacity information was successful.
        """
        return _fusion.CustomGraphicsMesh_setOpacity(self, opacity, isOverride)

    def getOpacity(self) -> "bool":
        r"""
        Gets the opacity of the graphics entity. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if getting the opacity information was successful.
        """
        return _fusion.CustomGraphicsMesh_getOpacity(self)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >":
        r"""
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsMesh__get_transform(self)

    def _set_transform(self, value: "Matrix3D") -> "bool":
        r"""
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsMesh__set_transform(self, value)

    def _get_depthPriority(self) -> "int":
        r"""
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsMesh__get_depthPriority(self)

    def _set_depthPriority(self, value: "int") -> "bool":
        r"""
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsMesh__set_depthPriority(self, value)

    def _get_cullMode(self) -> "adsk::fusion::CustomGraphicsCullModes":
        r"""
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsMesh__get_cullMode(self)

    def _set_cullMode(self, value: "CustomGraphicsCullModes") -> "bool":
        r"""
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsMesh__set_cullMode(self, value)

    def _get_color(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsColorEffect >":
        r"""
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsMesh__get_color(self)

    def _set_color(self, value: "CustomGraphicsColorEffect") -> "bool":
        r"""
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsMesh__set_color(self, value)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the parent Component for a top-level group or the CustomGraphicsGroup object for 
        graphics entities and child groups.
        """
        return _fusion.CustomGraphicsMesh__get_parent(self)

    def _get_id(self) -> "std::string":
        r"""
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsMesh__get_id(self)

    def _set_id(self, value: "std::string const &") -> "bool":
        r"""
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsMesh__set_id(self, value)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""
        Returns a box oriented parallel to the world x-y-x axes that contains the graphics entity.
        Depending on whether the graphics are drawn in model space or screen space this will return
        the bounding box in either centimeters (model) or pixels (screen). In the case where it
        returns the bounding box in pixel space, the Z coordinates of the box will be 0 and can be ignored.
        """
        return _fusion.CustomGraphicsMesh__get_boundingBox(self)

    def _get_billBoarding(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBillBoard >":
        r"""
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsMesh__get_billBoarding(self)

    def _set_billBoarding(self, value: "CustomGraphicsBillBoard") -> "bool":
        r"""
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsMesh__set_billBoarding(self, value)

    def _get_viewPlacement(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewPlacement >":
        r"""
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsMesh__get_viewPlacement(self)

    def _set_viewPlacement(self, value: "CustomGraphicsViewPlacement") -> "bool":
        r"""
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsMesh__set_viewPlacement(self, value)

    def _get_viewScale(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewScale >":
        r"""
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsMesh__get_viewScale(self)

    def _set_viewScale(self, value: "CustomGraphicsViewScale") -> "bool":
        r"""
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsMesh__set_viewScale(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomGraphicsMesh__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomGraphicsMesh__get_isValid(self)

# Register CustomGraphicsMesh in _fusion:
_fusion.CustomGraphicsMesh_swigregister(CustomGraphicsMesh)

def CustomGraphicsMesh_classType() -> "char const *":
    return _fusion.CustomGraphicsMesh_classType()


CustomGraphicsMesh.coordinates = property(CustomGraphicsMesh._get_coordinates, CustomGraphicsMesh._set_coordinates, doc="Gets and sets the coordinates associated with this CustomGraphicsMesh.")


CustomGraphicsMesh.normalVectors = property(CustomGraphicsMesh._get_normalVectors, CustomGraphicsMesh._set_normalVectors, doc="Gets and sets the normal vectors of the mesh where there is a normal\nvector at each node. The normals are defined as an array\nof floats where they are the x, y, z components of each vector.")


CustomGraphicsMesh.vertexIndexList = property(CustomGraphicsMesh._get_vertexIndexList, CustomGraphicsMesh._set_vertexIndexList, doc="Gets and sets an array of indices that define which coordinate in the\ncoordinate list is used for each vertex in the mesh. Each set of three\nindices defines a triagle. For example:\nIndices 0, 1, and 2 define the coordinates to use for the first triangle and\nindices 3, 4, and 5 define the coordinates for the second triangle, and so on.")


CustomGraphicsMesh.normalIndexList = property(CustomGraphicsMesh._get_normalIndexList, CustomGraphicsMesh._set_normalIndexList, doc="Gets and sets an array of indices that define which normal is associated\nwith each vertex in the mesh. This is used to look-up the normal in the\nnormalVectors array.")


CustomGraphicsMesh.textureCoordinates = property(CustomGraphicsMesh._get_textureCoordinates, CustomGraphicsMesh._set_textureCoordinates, doc="Gets and sets the texture coordinates as an array of floats where\nthey are the u,v components at each node. They are defined as an\narray of doubles where they are the u, v coordinates of each node.\nDefining texture coordinates for a mesh is optional.")


CustomGraphicsMesh.cast = lambda arg: arg if isinstance(arg, CustomGraphicsMesh) else None

class CustomGraphicsPointSet(CustomGraphicsEntity):
    r"""Represents a set of one or more custom graphics points all of the same style."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomGraphicsPointSet *":
        return _fusion.CustomGraphicsPointSet___deref__(self)

    def __eq__(self, rhs: "CustomGraphicsPointSet") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomGraphicsPointSet___eq__(self, rhs)


    def __ne__(self, rhs: "CustomGraphicsPointSet") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomGraphicsPointSet___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomGraphicsPointSet_classType()
    __swig_destroy__ = _fusion.delete_CustomGraphicsPointSet

    def _get_coordinates(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsCoordinates >":
        r"""
        Gets and sets the coordinates used to define the position of the custom graphics points.
        If no indexList is specified, every coordinate will be drawn using a custom graphics point,
        """
        return _fusion.CustomGraphicsPointSet__get_coordinates(self)

    def _set_coordinates(self, value: "CustomGraphicsCoordinates") -> "bool":
        r"""
        Gets and sets the coordinates used to define the position of the custom graphics points.
        If no indexList is specified, every coordinate will be drawn using a custom graphics point,
        """
        return _fusion.CustomGraphicsPointSet__set_coordinates(self, value)

    def _get_indexList(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        An list of indices that specify which coordinates from the coordinate list to draw points for.
        If this is an empty array, then all of the coordinates are used.
        """
        return _fusion.CustomGraphicsPointSet__get_indexList(self)

    def _set_indexList(self, value: "IntVector") -> "bool":
        r"""
        An list of indices that specify which coordinates from the coordinate list to draw points for.
        If this is an empty array, then all of the coordinates are used.
        """
        return _fusion.CustomGraphicsPointSet__set_indexList(self, value)

    def _get_pointImage(self) -> "std::string":
        r"""
        Gets and sets the image that will be used to display the point if the point type
        is a custom image. The image will always be be billboarded. The file should be 
        a png image and can use transparency. The filename can be a full path or a 
        relative path that is relative to your runtime file. Setting this will automatically
        set the pointType to UserDefinedCustomGraphicsPointType. This property can also
        return an empty string in the case where a user defined image point is not being used.
        """
        return _fusion.CustomGraphicsPointSet__get_pointImage(self)

    def _set_pointImage(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the image that will be used to display the point if the point type
        is a custom image. The image will always be be billboarded. The file should be 
        a png image and can use transparency. The filename can be a full path or a 
        relative path that is relative to your runtime file. Setting this will automatically
        set the pointType to UserDefinedCustomGraphicsPointType. This property can also
        return an empty string in the case where a user defined image point is not being used.
        """
        return _fusion.CustomGraphicsPointSet__set_pointImage(self, value)

    def _get_pointType(self) -> "adsk::fusion::CustomGraphicsPointTypes":
        r"""
        Specifies which of the pre-defined point images to use. Attempting to set this property
        to UserDefinedCustomGraphicsPointType will fail. To change to a user defined point type
        you must set use the pointImage property to specify the image to use and this will have
        the side-effect of changing the value of this property to UserDefinedCustomGraphicsPointType.
        """
        return _fusion.CustomGraphicsPointSet__get_pointType(self)

    def _set_pointType(self, value: "CustomGraphicsPointTypes") -> "bool":
        r"""
        Specifies which of the pre-defined point images to use. Attempting to set this property
        to UserDefinedCustomGraphicsPointType will fail. To change to a user defined point type
        you must set use the pointImage property to specify the image to use and this will have
        the side-effect of changing the value of this property to UserDefinedCustomGraphicsPointType.
        """
        return _fusion.CustomGraphicsPointSet__set_pointType(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the entity from the custom graphics group. 
        Returns true if the deletion was successful.
        """
        return _fusion.CustomGraphicsPointSet_deleteMe(self)

    def _get_isVisible(self) -> "bool":
        r"""
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsPointSet__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsPointSet__set_isVisible(self, value)

    def _get_isSelectable(self) -> "bool":
        r"""
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsPointSet__get_isSelectable(self)

    def _set_isSelectable(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsPointSet__set_isSelectable(self, value)

    def setOpacity(self, opacity: "double", isOverride: "bool") -> "bool":
        r"""
        Sets the opacity of the graphics entity. By default, when a new entity is it is
        completely opaque and does not override the opacity defined by the material. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if setting the opacity information was successful.
        """
        return _fusion.CustomGraphicsPointSet_setOpacity(self, opacity, isOverride)

    def getOpacity(self) -> "bool":
        r"""
        Gets the opacity of the graphics entity. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if getting the opacity information was successful.
        """
        return _fusion.CustomGraphicsPointSet_getOpacity(self)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >":
        r"""
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsPointSet__get_transform(self)

    def _set_transform(self, value: "Matrix3D") -> "bool":
        r"""
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsPointSet__set_transform(self, value)

    def _get_depthPriority(self) -> "int":
        r"""
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsPointSet__get_depthPriority(self)

    def _set_depthPriority(self, value: "int") -> "bool":
        r"""
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsPointSet__set_depthPriority(self, value)

    def _get_cullMode(self) -> "adsk::fusion::CustomGraphicsCullModes":
        r"""
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsPointSet__get_cullMode(self)

    def _set_cullMode(self, value: "CustomGraphicsCullModes") -> "bool":
        r"""
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsPointSet__set_cullMode(self, value)

    def _get_color(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsColorEffect >":
        r"""
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsPointSet__get_color(self)

    def _set_color(self, value: "CustomGraphicsColorEffect") -> "bool":
        r"""
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsPointSet__set_color(self, value)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the parent Component for a top-level group or the CustomGraphicsGroup object for 
        graphics entities and child groups.
        """
        return _fusion.CustomGraphicsPointSet__get_parent(self)

    def _get_id(self) -> "std::string":
        r"""
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsPointSet__get_id(self)

    def _set_id(self, value: "std::string const &") -> "bool":
        r"""
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsPointSet__set_id(self, value)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""
        Returns a box oriented parallel to the world x-y-x axes that contains the graphics entity.
        Depending on whether the graphics are drawn in model space or screen space this will return
        the bounding box in either centimeters (model) or pixels (screen). In the case where it
        returns the bounding box in pixel space, the Z coordinates of the box will be 0 and can be ignored.
        """
        return _fusion.CustomGraphicsPointSet__get_boundingBox(self)

    def _get_billBoarding(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBillBoard >":
        r"""
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsPointSet__get_billBoarding(self)

    def _set_billBoarding(self, value: "CustomGraphicsBillBoard") -> "bool":
        r"""
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsPointSet__set_billBoarding(self, value)

    def _get_viewPlacement(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewPlacement >":
        r"""
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsPointSet__get_viewPlacement(self)

    def _set_viewPlacement(self, value: "CustomGraphicsViewPlacement") -> "bool":
        r"""
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsPointSet__set_viewPlacement(self, value)

    def _get_viewScale(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewScale >":
        r"""
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsPointSet__get_viewScale(self)

    def _set_viewScale(self, value: "CustomGraphicsViewScale") -> "bool":
        r"""
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsPointSet__set_viewScale(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomGraphicsPointSet__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomGraphicsPointSet__get_isValid(self)

# Register CustomGraphicsPointSet in _fusion:
_fusion.CustomGraphicsPointSet_swigregister(CustomGraphicsPointSet)

def CustomGraphicsPointSet_classType() -> "char const *":
    return _fusion.CustomGraphicsPointSet_classType()


CustomGraphicsPointSet.coordinates = property(CustomGraphicsPointSet._get_coordinates, CustomGraphicsPointSet._set_coordinates, doc="Gets and sets the coordinates used to define the position of the custom graphics points.\nIf no indexList is specified, every coordinate will be drawn using a custom graphics point,")


CustomGraphicsPointSet.indexList = property(CustomGraphicsPointSet._get_indexList, CustomGraphicsPointSet._set_indexList, doc="An list of indices that specify which coordinates from the coordinate list to draw points for.\nIf this is an empty array, then all of the coordinates are used.")


CustomGraphicsPointSet.pointImage = property(CustomGraphicsPointSet._get_pointImage, CustomGraphicsPointSet._set_pointImage, doc="Gets and sets the image that will be used to display the point if the point type\nis a custom image. The image will always be be billboarded. The file should be\na png image and can use transparency. The filename can be a full path or a\nrelative path that is relative to your runtime file. Setting this will automatically\nset the pointType to UserDefinedCustomGraphicsPointType. This property can also\nreturn an empty string in the case where a user defined image point is not being used.")


CustomGraphicsPointSet.pointType = property(CustomGraphicsPointSet._get_pointType, CustomGraphicsPointSet._set_pointType, doc="Specifies which of the pre-defined point images to use. Attempting to set this property\nto UserDefinedCustomGraphicsPointType will fail. To change to a user defined point type\nyou must set use the pointImage property to specify the image to use and this will have\nthe side-effect of changing the value of this property to UserDefinedCustomGraphicsPointType.")


CustomGraphicsPointSet.cast = lambda arg: arg if isinstance(arg, CustomGraphicsPointSet) else None

class CustomGraphicsShowThroughColorEffect(CustomGraphicsColorEffect):
    r"""
    One of the types of color effects that can be applied to a custom graphics entity. With this 
    type of effect, the graphics entity will display using the specified color and will show through
    other graphics that are in front of it.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomGraphicsShowThroughColorEffect *":
        return _fusion.CustomGraphicsShowThroughColorEffect___deref__(self)

    def __eq__(self, rhs: "CustomGraphicsShowThroughColorEffect") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomGraphicsShowThroughColorEffect___eq__(self, rhs)


    def __ne__(self, rhs: "CustomGraphicsShowThroughColorEffect") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomGraphicsShowThroughColorEffect___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomGraphicsShowThroughColorEffect_classType()

    @staticmethod
    def create(color: "Color", opacity: "double") -> "adsk::core::Ptr< adsk::core::Color > const &":
        return _fusion.CustomGraphicsShowThroughColorEffect_create(color, opacity)
    __swig_destroy__ = _fusion.delete_CustomGraphicsShowThroughColorEffect

    def _get_color(self) -> "adsk::core::Ptr< adsk::core::Color >":
        r"""
        Gets and sets the color associated with this CustomGraphicsShowThroughColorEffect object. The color that will be used to render 
        the portion of the entity that is covered by other objects in the scene.
        """
        return _fusion.CustomGraphicsShowThroughColorEffect__get_color(self)

    def _set_color(self, value: "Color") -> "bool":
        r"""
        Gets and sets the color associated with this CustomGraphicsShowThroughColorEffect object. The color that will be used to render 
        the portion of the entity that is covered by other objects in the scene.
        """
        return _fusion.CustomGraphicsShowThroughColorEffect__set_color(self, value)

    def _get_opacity(self) -> "double":
        r"""
        Gets and sets the opacity value associated with this CustomGraphicsShowThroughColorEffect object. The opacity is used when rendering 
        the portion of the entity that is covered by other objects in the scene. This can be a value between 0 and 1, where 1 is 
        fully opaque and will completely cover any other entities.
        """
        return _fusion.CustomGraphicsShowThroughColorEffect__get_opacity(self)

    def _set_opacity(self, value: "double") -> "bool":
        r"""
        Gets and sets the opacity value associated with this CustomGraphicsShowThroughColorEffect object. The opacity is used when rendering 
        the portion of the entity that is covered by other objects in the scene. This can be a value between 0 and 1, where 1 is 
        fully opaque and will completely cover any other entities.
        """
        return _fusion.CustomGraphicsShowThroughColorEffect__set_opacity(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomGraphicsShowThroughColorEffect__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomGraphicsShowThroughColorEffect__get_isValid(self)

# Register CustomGraphicsShowThroughColorEffect in _fusion:
_fusion.CustomGraphicsShowThroughColorEffect_swigregister(CustomGraphicsShowThroughColorEffect)

def CustomGraphicsShowThroughColorEffect_classType() -> "char const *":
    return _fusion.CustomGraphicsShowThroughColorEffect_classType()

def CustomGraphicsShowThroughColorEffect_create(color: "Color", opacity: "double") -> "adsk::core::Ptr< adsk::core::Color > const &":
    return _fusion.CustomGraphicsShowThroughColorEffect_create(color, opacity)


CustomGraphicsShowThroughColorEffect.color = property(CustomGraphicsShowThroughColorEffect._get_color, CustomGraphicsShowThroughColorEffect._set_color, doc="Gets and sets the color associated with this CustomGraphicsShowThroughColorEffect object. The color that will be used to render\nthe portion of the entity that is covered by other objects in the scene.")


CustomGraphicsShowThroughColorEffect.opacity = property(CustomGraphicsShowThroughColorEffect._get_opacity, CustomGraphicsShowThroughColorEffect._set_opacity, doc="Gets and sets the opacity value associated with this CustomGraphicsShowThroughColorEffect object. The opacity is used when rendering\nthe portion of the entity that is covered by other objects in the scene. This can be a value between 0 and 1, where 1 is\nfully opaque and will completely cover any other entities.")


CustomGraphicsShowThroughColorEffect.cast = lambda arg: arg if isinstance(arg, CustomGraphicsShowThroughColorEffect) else None

class CustomGraphicsSolidColorEffect(CustomGraphicsColorEffect):
    r"""
    One of the types of color effects that can be applied to a custom graphics entity. With this 
    type of effect, the graphics entity will display as the single color without any lighting 
    effects. For example, a sphere will display as a solid filled circle without any shading 
    indicating it is actually spherical.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomGraphicsSolidColorEffect *":
        return _fusion.CustomGraphicsSolidColorEffect___deref__(self)

    def __eq__(self, rhs: "CustomGraphicsSolidColorEffect") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomGraphicsSolidColorEffect___eq__(self, rhs)


    def __ne__(self, rhs: "CustomGraphicsSolidColorEffect") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomGraphicsSolidColorEffect___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomGraphicsSolidColorEffect_classType()

    @staticmethod
    def create(color: "Color") -> "adsk::core::Ptr< adsk::core::Color > const &":
        return _fusion.CustomGraphicsSolidColorEffect_create(color)
    __swig_destroy__ = _fusion.delete_CustomGraphicsSolidColorEffect

    def _get_color(self) -> "adsk::core::Ptr< adsk::core::Color >":
        r"""
        The color to use for the solid color display. The opacity component of the color is ignored 
        because the opacity of custom graphics is controlled seperately using an opacity attribute.
        """
        return _fusion.CustomGraphicsSolidColorEffect__get_color(self)

    def _set_color(self, value: "Color") -> "bool":
        r"""
        The color to use for the solid color display. The opacity component of the color is ignored 
        because the opacity of custom graphics is controlled seperately using an opacity attribute.
        """
        return _fusion.CustomGraphicsSolidColorEffect__set_color(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomGraphicsSolidColorEffect__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomGraphicsSolidColorEffect__get_isValid(self)

# Register CustomGraphicsSolidColorEffect in _fusion:
_fusion.CustomGraphicsSolidColorEffect_swigregister(CustomGraphicsSolidColorEffect)

def CustomGraphicsSolidColorEffect_classType() -> "char const *":
    return _fusion.CustomGraphicsSolidColorEffect_classType()

def CustomGraphicsSolidColorEffect_create(color: "Color") -> "adsk::core::Ptr< adsk::core::Color > const &":
    return _fusion.CustomGraphicsSolidColorEffect_create(color)


CustomGraphicsSolidColorEffect.color = property(CustomGraphicsSolidColorEffect._get_color, CustomGraphicsSolidColorEffect._set_color, doc="The color to use for the solid color display. The opacity component of the color is ignored\nbecause the opacity of custom graphics is controlled seperately using an opacity attribute.")


CustomGraphicsSolidColorEffect.cast = lambda arg: arg if isinstance(arg, CustomGraphicsSolidColorEffect) else None

class CustomGraphicsText(CustomGraphicsEntity):
    r"""
    Represents text drawn in the graphics window. The default position of the text is at (0,0,0) and 
    orientation is the text lying on the x-y plane. To reposition and reorient the text you can use
    the transformation property.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomGraphicsText *":
        return _fusion.CustomGraphicsText___deref__(self)

    def __eq__(self, rhs: "CustomGraphicsText") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomGraphicsText___eq__(self, rhs)


    def __ne__(self, rhs: "CustomGraphicsText") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomGraphicsText___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomGraphicsText_classType()
    __swig_destroy__ = _fusion.delete_CustomGraphicsText

    def _get_formattedText(self) -> "std::string":
        r"""
        Gets and sets the formatted text definition. This is the full string, including the 
        formatting information, that's used to define the displayed text.
        """
        return _fusion.CustomGraphicsText__get_formattedText(self)

    def _set_formattedText(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the formatted text definition. This is the full string, including the 
        formatting information, that's used to define the displayed text.
        """
        return _fusion.CustomGraphicsText__set_formattedText(self, value)

    def _get_font(self) -> "std::string":
        r"""
        Gets and sets the font used to display the text. This is the default font and applies to
        all of text unless there is a font override defined within the text.
        """
        return _fusion.CustomGraphicsText__get_font(self)

    def _set_font(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the font used to display the text. This is the default font and applies to
        all of text unless there is a font override defined within the text.
        """
        return _fusion.CustomGraphicsText__set_font(self, value)

    def _get_isItalic(self) -> "bool":
        r"""
        Specifies that the text displays using an italic style. This is the default italic style and applies to
        all of text unless there is a style override defined within the text.
        """
        return _fusion.CustomGraphicsText__get_isItalic(self)

    def _set_isItalic(self, value: "bool") -> "bool":
        r"""
        Specifies that the text displays using an italic style. This is the default italic style and applies to
        all of text unless there is a style override defined within the text.
        """
        return _fusion.CustomGraphicsText__set_isItalic(self, value)

    def _get_isBold(self) -> "bool":
        r"""
        Specifies that the text displays using a bold style. This is the default bold style and applies to
        all of text unless there is a style override defined within the text.
        """
        return _fusion.CustomGraphicsText__get_isBold(self)

    def _set_isBold(self, value: "bool") -> "bool":
        r"""
        Specifies that the text displays using a bold style. This is the default bold style and applies to
        all of text unless there is a style override defined within the text.
        """
        return _fusion.CustomGraphicsText__set_isBold(self, value)

    def _get_isUnderline(self) -> "bool":
        r"""
        Specifies that the text displays using an underline style. This is the default underline style and applies to
        all of text unless there is a style override defined within the text.
        """
        return _fusion.CustomGraphicsText__get_isUnderline(self)

    def _set_isUnderline(self, value: "bool") -> "bool":
        r"""
        Specifies that the text displays using an underline style. This is the default underline style and applies to
        all of text unless there is a style override defined within the text.
        """
        return _fusion.CustomGraphicsText__set_isUnderline(self, value)

    def _get_isStrikeThrough(self) -> "bool":
        r"""
        Specifies that the text displays using a strike through style. This is the default strike through style and applies to
        all of text unless there is a style override defined within the text.
        """
        return _fusion.CustomGraphicsText__get_isStrikeThrough(self)

    def _set_isStrikeThrough(self, value: "bool") -> "bool":
        r"""
        Specifies that the text displays using a strike through style. This is the default strike through style and applies to
        all of text unless there is a style override defined within the text.
        """
        return _fusion.CustomGraphicsText__set_isStrikeThrough(self, value)

    def _get_size(self) -> "double":
        r"""
        Gets and sets the size of the text in centimeters. This is the default size and applies to
        all of text unless there is a size override defined within the text.
        """
        return _fusion.CustomGraphicsText__get_size(self)

    def _set_size(self, value: "double") -> "bool":
        r"""
        Gets and sets the size of the text in centimeters. This is the default size and applies to
        all of text unless there is a size override defined within the text.
        """
        return _fusion.CustomGraphicsText__set_size(self, value)

    def _get_width(self) -> "double":
        r"""
        The actual width of the text in centimeters. This is useful when you want to position several
        GraphicsText objects together.
        """
        return _fusion.CustomGraphicsText__get_width(self)

    def _get_height(self) -> "double":
        r"""
        The actual height of the text in centimeters. This is useful when you want to position several
        GraphicsText objects together.
        """
        return _fusion.CustomGraphicsText__get_height(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the entity from the custom graphics group. 
        Returns true if the deletion was successful.
        """
        return _fusion.CustomGraphicsText_deleteMe(self)

    def _get_isVisible(self) -> "bool":
        r"""
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsText__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsText__set_isVisible(self, value)

    def _get_isSelectable(self) -> "bool":
        r"""
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsText__get_isSelectable(self)

    def _set_isSelectable(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsText__set_isSelectable(self, value)

    def setOpacity(self, opacity: "double", isOverride: "bool") -> "bool":
        r"""
        Sets the opacity of the graphics entity. By default, when a new entity is it is
        completely opaque and does not override the opacity defined by the material. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if setting the opacity information was successful.
        """
        return _fusion.CustomGraphicsText_setOpacity(self, opacity, isOverride)

    def getOpacity(self) -> "bool":
        r"""
        Gets the opacity of the graphics entity. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if getting the opacity information was successful.
        """
        return _fusion.CustomGraphicsText_getOpacity(self)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >":
        r"""
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsText__get_transform(self)

    def _set_transform(self, value: "Matrix3D") -> "bool":
        r"""
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsText__set_transform(self, value)

    def _get_depthPriority(self) -> "int":
        r"""
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsText__get_depthPriority(self)

    def _set_depthPriority(self, value: "int") -> "bool":
        r"""
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsText__set_depthPriority(self, value)

    def _get_cullMode(self) -> "adsk::fusion::CustomGraphicsCullModes":
        r"""
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsText__get_cullMode(self)

    def _set_cullMode(self, value: "CustomGraphicsCullModes") -> "bool":
        r"""
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsText__set_cullMode(self, value)

    def _get_color(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsColorEffect >":
        r"""
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsText__get_color(self)

    def _set_color(self, value: "CustomGraphicsColorEffect") -> "bool":
        r"""
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsText__set_color(self, value)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the parent Component for a top-level group or the CustomGraphicsGroup object for 
        graphics entities and child groups.
        """
        return _fusion.CustomGraphicsText__get_parent(self)

    def _get_id(self) -> "std::string":
        r"""
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsText__get_id(self)

    def _set_id(self, value: "std::string const &") -> "bool":
        r"""
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsText__set_id(self, value)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""
        Returns a box oriented parallel to the world x-y-x axes that contains the graphics entity.
        Depending on whether the graphics are drawn in model space or screen space this will return
        the bounding box in either centimeters (model) or pixels (screen). In the case where it
        returns the bounding box in pixel space, the Z coordinates of the box will be 0 and can be ignored.
        """
        return _fusion.CustomGraphicsText__get_boundingBox(self)

    def _get_billBoarding(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBillBoard >":
        r"""
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsText__get_billBoarding(self)

    def _set_billBoarding(self, value: "CustomGraphicsBillBoard") -> "bool":
        r"""
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsText__set_billBoarding(self, value)

    def _get_viewPlacement(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewPlacement >":
        r"""
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsText__get_viewPlacement(self)

    def _set_viewPlacement(self, value: "CustomGraphicsViewPlacement") -> "bool":
        r"""
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsText__set_viewPlacement(self, value)

    def _get_viewScale(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewScale >":
        r"""
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsText__get_viewScale(self)

    def _set_viewScale(self, value: "CustomGraphicsViewScale") -> "bool":
        r"""
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsText__set_viewScale(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomGraphicsText__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomGraphicsText__get_isValid(self)

# Register CustomGraphicsText in _fusion:
_fusion.CustomGraphicsText_swigregister(CustomGraphicsText)

def CustomGraphicsText_classType() -> "char const *":
    return _fusion.CustomGraphicsText_classType()


CustomGraphicsText.formattedText = property(CustomGraphicsText._get_formattedText, CustomGraphicsText._set_formattedText, doc="Gets and sets the formatted text definition. This is the full string, including the\nformatting information, that's used to define the displayed text.")


CustomGraphicsText.font = property(CustomGraphicsText._get_font, CustomGraphicsText._set_font, doc="Gets and sets the font used to display the text. This is the default font and applies to\nall of text unless there is a font override defined within the text.")


CustomGraphicsText.isItalic = property(CustomGraphicsText._get_isItalic, CustomGraphicsText._set_isItalic, doc="Specifies that the text displays using an italic style. This is the default italic style and applies to\nall of text unless there is a style override defined within the text.")


CustomGraphicsText.isBold = property(CustomGraphicsText._get_isBold, CustomGraphicsText._set_isBold, doc="Specifies that the text displays using a bold style. This is the default bold style and applies to\nall of text unless there is a style override defined within the text.")


CustomGraphicsText.isUnderline = property(CustomGraphicsText._get_isUnderline, CustomGraphicsText._set_isUnderline, doc="Specifies that the text displays using an underline style. This is the default underline style and applies to\nall of text unless there is a style override defined within the text.")


CustomGraphicsText.isStrikeThrough = property(CustomGraphicsText._get_isStrikeThrough, CustomGraphicsText._set_isStrikeThrough, doc="Specifies that the text displays using a strike through style. This is the default strike through style and applies to\nall of text unless there is a style override defined within the text.")


CustomGraphicsText.size = property(CustomGraphicsText._get_size, CustomGraphicsText._set_size, doc="Gets and sets the size of the text in centimeters. This is the default size and applies to\nall of text unless there is a size override defined within the text.")


CustomGraphicsText.width = property(CustomGraphicsText._get_width, doc="The actual width of the text in centimeters. This is useful when you want to position several\nGraphicsText objects together.")


CustomGraphicsText.height = property(CustomGraphicsText._get_height, doc="The actual height of the text in centimeters. This is useful when you want to position several\nGraphicsText objects together.")


CustomGraphicsText.cast = lambda arg: arg if isinstance(arg, CustomGraphicsText) else None

class CustomGraphicsVertexColorEffect(CustomGraphicsColorEffect):
    r"""
    One of the types of color effects that can be applied to a custom graphics entity. With this 
    type of effect, the graphics entity will display using the colors associated with the vertices
    of the mesh in the CustomGraphicsCoordinates object.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomGraphicsVertexColorEffect *":
        return _fusion.CustomGraphicsVertexColorEffect___deref__(self)

    def __eq__(self, rhs: "CustomGraphicsVertexColorEffect") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomGraphicsVertexColorEffect___eq__(self, rhs)


    def __ne__(self, rhs: "CustomGraphicsVertexColorEffect") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomGraphicsVertexColorEffect___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomGraphicsVertexColorEffect_classType()

    @staticmethod
    def create() -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsVertexColorEffect >":
        return _fusion.CustomGraphicsVertexColorEffect_create()
    __swig_destroy__ = _fusion.delete_CustomGraphicsVertexColorEffect

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomGraphicsVertexColorEffect__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomGraphicsVertexColorEffect__get_isValid(self)

# Register CustomGraphicsVertexColorEffect in _fusion:
_fusion.CustomGraphicsVertexColorEffect_swigregister(CustomGraphicsVertexColorEffect)

def CustomGraphicsVertexColorEffect_classType() -> "char const *":
    return _fusion.CustomGraphicsVertexColorEffect_classType()

def CustomGraphicsVertexColorEffect_create() -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsVertexColorEffect >":
    return _fusion.CustomGraphicsVertexColorEffect_create()


CustomGraphicsVertexColorEffect.cast = lambda arg: arg if isinstance(arg, CustomGraphicsVertexColorEffect) else None

class CutPasteBody(Feature):
    r"""Object that represents an existing Cut/Paste Body feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CutPasteBody *":
        return _fusion.CutPasteBody___deref__(self)

    def __eq__(self, rhs: "CutPasteBody") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CutPasteBody___eq__(self, rhs)


    def __ne__(self, rhs: "CutPasteBody") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CutPasteBody___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CutPasteBody_classType()
    __swig_destroy__ = _fusion.delete_CutPasteBody

    def _get_sourceBody(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Returns the bodies that were cut to create the result bodies of this feature. An ObjectCollection
        is returned that will contain the original bodies. It's possible that the collection can be empty
        or contain less than the number of bodies originally copied. This happens in the case where a body 
        has been deleted or consumed by some other operation. 
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.CutPasteBody__get_sourceBody(self)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CutPasteBody__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CutPasteBody__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.CutPasteBody_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.CutPasteBody_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CutPasteBody__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CutPasteBody__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.CutPasteBody__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.CutPasteBody__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.CutPasteBody__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.CutPasteBody__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.CutPasteBody__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.CutPasteBody__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.CutPasteBody__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.CutPasteBody__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.CutPasteBody__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.CutPasteBody__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.CutPasteBody__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.CutPasteBody__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.CutPasteBody__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CutPasteBody__get_isValid(self)

# Register CutPasteBody in _fusion:
_fusion.CutPasteBody_swigregister(CutPasteBody)

def CutPasteBody_classType() -> "char const *":
    return _fusion.CutPasteBody_classType()


CutPasteBody.sourceBody = property(CutPasteBody._get_sourceBody, doc="Returns the bodies that were cut to create the result bodies of this feature. An ObjectCollection\nis returned that will contain the original bodies. It's possible that the collection can be empty\nor contain less than the number of bodies originally copied. This happens in the case where a body\nhas been deleted or consumed by some other operation.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


CutPasteBody.cast = lambda arg: arg if isinstance(arg, CutPasteBody) else None

class CylinderFeature(Feature):
    r"""Object that represents an existing cylinder feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CylinderFeature *":
        return _fusion.CylinderFeature___deref__(self)

    def __eq__(self, rhs: "CylinderFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CylinderFeature___eq__(self, rhs)


    def __ne__(self, rhs: "CylinderFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CylinderFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CylinderFeature_classType()
    __swig_destroy__ = _fusion.delete_CylinderFeature

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CylinderFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CylinderFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.CylinderFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.CylinderFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CylinderFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CylinderFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.CylinderFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.CylinderFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.CylinderFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.CylinderFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.CylinderFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.CylinderFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.CylinderFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.CylinderFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.CylinderFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.CylinderFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.CylinderFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.CylinderFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.CylinderFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CylinderFeature__get_isValid(self)

# Register CylinderFeature in _fusion:
_fusion.CylinderFeature_swigregister(CylinderFeature)

def CylinderFeature_classType() -> "char const *":
    return _fusion.CylinderFeature_classType()


CylinderFeature.cast = lambda arg: arg if isinstance(arg, CylinderFeature) else None

class CylindricalJointMotion(JointMotion):
    r"""Represents the set of information specific to a cylindrical joint."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CylindricalJointMotion *":
        return _fusion.CylindricalJointMotion___deref__(self)

    def __eq__(self, rhs: "CylindricalJointMotion") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CylindricalJointMotion___eq__(self, rhs)


    def __ne__(self, rhs: "CylindricalJointMotion") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CylindricalJointMotion___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CylindricalJointMotion_classType()
    __swig_destroy__ = _fusion.delete_CylindricalJointMotion

    def _get_rotationAxis(self) -> "adsk::fusion::JointDirections":
        r"""
        Gets and sets the direction of the axis of rotation. This can be set to
        XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
        return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customRotationAxisEntity will return an entity
        that defines the axis. If there is a custom rotation axis defined and this
        property is set to one of the three standard axes, the custom rotation will
        be removed and customRotationAxisEntity will return null.
        """
        return _fusion.CylindricalJointMotion__get_rotationAxis(self)

    def _set_rotationAxis(self, value: "JointDirections") -> "bool":
        r"""
        Gets and sets the direction of the axis of rotation. This can be set to
        XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
        return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customRotationAxisEntity will return an entity
        that defines the axis. If there is a custom rotation axis defined and this
        property is set to one of the three standard axes, the custom rotation will
        be removed and customRotationAxisEntity will return null.
        """
        return _fusion.CylindricalJointMotion__set_rotationAxis(self, value)

    def _get_rotationAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Returns the direction of the rotation axis. This property will return null in the case
        where the CylindricalJointMotion object was obtained from a JointInput object.
        """
        return _fusion.CylindricalJointMotion__get_rotationAxisVector(self)

    def _get_customRotationAxisEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        This property can be set using various types of entities that can infer an
        axis. For example, a linear edge, sketch line, planar face, and cylindrical face.
        This property is only valid in the case where the rotationAxis property returns
        CustomJointDirection. Setting this property will automatically set
        the rotationAxis property to CustomJointDirection.
        """
        return _fusion.CylindricalJointMotion__get_customRotationAxisEntity(self)

    def _set_customRotationAxisEntity(self, value: "Base") -> "bool":
        r"""
        This property can be set using various types of entities that can infer an
        axis. For example, a linear edge, sketch line, planar face, and cylindrical face.
        This property is only valid in the case where the rotationAxis property returns
        CustomJointDirection. Setting this property will automatically set
        the rotationAxis property to CustomJointDirection.
        """
        return _fusion.CylindricalJointMotion__set_customRotationAxisEntity(self, value)

    def _get_rotationValue(self) -> "double":
        r"""
        Gets and sets the rotation value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.CylindricalJointMotion__get_rotationValue(self)

    def _set_rotationValue(self, value: "double") -> "bool":
        r"""
        Gets and sets the rotation value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.CylindricalJointMotion__set_rotationValue(self, value)

    def _get_rotationLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >":
        r"""
        Returns a JointLimits object that defines the rotation limits for this joint.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.CylindricalJointMotion__get_rotationLimits(self)

    def _get_slideValue(self) -> "double":
        r"""
        Gets and sets the slide value. This is in centimeters. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.CylindricalJointMotion__get_slideValue(self)

    def _set_slideValue(self, value: "double") -> "bool":
        r"""
        Gets and sets the slide value. This is in centimeters. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.CylindricalJointMotion__set_slideValue(self, value)

    def _get_slideLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >":
        r"""
        Returns a JointLimits object that defines the slide limits for this joint.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.CylindricalJointMotion__get_slideLimits(self)

    def _get_jointType(self) -> "adsk::fusion::JointTypes":
        r"""Returns an enum value indicating the type of joint this joint represents."""
        return _fusion.CylindricalJointMotion__get_jointType(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.CylindricalJointMotion__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CylindricalJointMotion__get_isValid(self)

# Register CylindricalJointMotion in _fusion:
_fusion.CylindricalJointMotion_swigregister(CylindricalJointMotion)

def CylindricalJointMotion_classType() -> "char const *":
    return _fusion.CylindricalJointMotion_classType()


CylindricalJointMotion.rotationAxis = property(CylindricalJointMotion._get_rotationAxis, CylindricalJointMotion._set_rotationAxis, doc="Gets and sets the direction of the axis of rotation. This can be set to\nXAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can\nreturn those three directions and CustomJointDirection. If this returns\nCustomJointDirection then the customRotationAxisEntity will return an entity\nthat defines the axis. If there is a custom rotation axis defined and this\nproperty is set to one of the three standard axes, the custom rotation will\nbe removed and customRotationAxisEntity will return null.")


CylindricalJointMotion.rotationAxisVector = property(CylindricalJointMotion._get_rotationAxisVector, doc="Returns the direction of the rotation axis. This property will return null in the case\nwhere the CylindricalJointMotion object was obtained from a JointInput object.")


CylindricalJointMotion.customRotationAxisEntity = property(CylindricalJointMotion._get_customRotationAxisEntity, CylindricalJointMotion._set_customRotationAxisEntity, doc="This property can be set using various types of entities that can infer an\naxis. For example, a linear edge, sketch line, planar face, and cylindrical face.\nThis property is only valid in the case where the rotationAxis property returns\nCustomJointDirection. Setting this property will automatically set\nthe rotationAxis property to CustomJointDirection.")


CylindricalJointMotion.rotationValue = property(CylindricalJointMotion._get_rotationValue, CylindricalJointMotion._set_rotationValue, doc="Gets and sets the rotation value. This is in radians. Setting this value is\nthe equivalent of using the Drive Joints command.")


CylindricalJointMotion.rotationLimits = property(CylindricalJointMotion._get_rotationLimits, doc="Returns a JointLimits object that defines the rotation limits for this joint.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")


CylindricalJointMotion.slideValue = property(CylindricalJointMotion._get_slideValue, CylindricalJointMotion._set_slideValue, doc="Gets and sets the slide value. This is in centimeters. Setting this value is\nthe equivalent of using the Drive Joints command.")


CylindricalJointMotion.slideLimits = property(CylindricalJointMotion._get_slideLimits, doc="Returns a JointLimits object that defines the slide limits for this joint.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")


CylindricalJointMotion.cast = lambda arg: arg if isinstance(arg, CylindricalJointMotion) else None

class DeleteFaceFeature(Feature):
    r"""
    Object that represents an existing DeleteFaceFeature object in a design.
    The SurfaceDeleteFaceFeature and DeleteFaceFeature differ in that the SurfaceDeleteFaceFeature
    can delete any face without any restrictions. If the body is a solid, it will become a surface
    when the first face is deleted. The specified face is deleted without any other changes being
    made to the body. The DeleteFaceFeature deletes the specified face and also modifies the other faces
    in the body to heal or fill in the area of the deleted face. This means that a solid body will
    remain solid.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::DeleteFaceFeature *":
        return _fusion.DeleteFaceFeature___deref__(self)

    def __eq__(self, rhs: "DeleteFaceFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.DeleteFaceFeature___eq__(self, rhs)


    def __ne__(self, rhs: "DeleteFaceFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.DeleteFaceFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.DeleteFaceFeature_classType()
    __swig_destroy__ = _fusion.delete_DeleteFaceFeature

    def _get_deletedFaces(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepFace > > >":
        r"""
        Gets and sets the set of faces that are deleted by this feature.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        Setting this property can fail if Fusion 360 is unable to heal the body after
        deleting the specified faces.
        """
        return _fusion.DeleteFaceFeature__get_deletedFaces(self)

    def _set_deletedFaces(self, value: "BRepFaceVector") -> "bool":
        r"""
        Gets and sets the set of faces that are deleted by this feature.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        Setting this property can fail if Fusion 360 is unable to heal the body after
        deleting the specified faces.
        """
        return _fusion.DeleteFaceFeature__set_deletedFaces(self, value)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::DeleteFaceFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.DeleteFaceFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::DeleteFaceFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.DeleteFaceFeature_createForAssemblyContext(self, occurrence)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.DeleteFaceFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.DeleteFaceFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.DeleteFaceFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.DeleteFaceFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.DeleteFaceFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.DeleteFaceFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.DeleteFaceFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.DeleteFaceFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.DeleteFaceFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.DeleteFaceFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.DeleteFaceFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.DeleteFaceFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.DeleteFaceFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.DeleteFaceFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.DeleteFaceFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.DeleteFaceFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.DeleteFaceFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.DeleteFaceFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.DeleteFaceFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.DeleteFaceFeature__get_isValid(self)

# Register DeleteFaceFeature in _fusion:
_fusion.DeleteFaceFeature_swigregister(DeleteFaceFeature)

def DeleteFaceFeature_classType() -> "char const *":
    return _fusion.DeleteFaceFeature_classType()


DeleteFaceFeature.deletedFaces = property(DeleteFaceFeature._get_deletedFaces, DeleteFaceFeature._set_deletedFaces, doc="Gets and sets the set of faces that are deleted by this feature.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)\nSetting this property can fail if Fusion 360 is unable to heal the body after\ndeleting the specified faces.")


DeleteFaceFeature.nativeObject = property(DeleteFaceFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


DeleteFaceFeature.cast = lambda arg: arg if isinstance(arg, DeleteFaceFeature) else None

class DistanceAndAngleChamferEdgeSet(ChamferEdgeSet):
    r"""Provides access to the edges and the parameter associated with a chord length fillet."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::DistanceAndAngleChamferEdgeSet *":
        return _fusion.DistanceAndAngleChamferEdgeSet___deref__(self)

    def __eq__(self, rhs: "DistanceAndAngleChamferEdgeSet") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.DistanceAndAngleChamferEdgeSet___eq__(self, rhs)


    def __ne__(self, rhs: "DistanceAndAngleChamferEdgeSet") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.DistanceAndAngleChamferEdgeSet___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.DistanceAndAngleChamferEdgeSet_classType()
    __swig_destroy__ = _fusion.delete_DistanceAndAngleChamferEdgeSet

    def _get_edges(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the edges that will be chamfered. This collection can contain BRepEdge, BRepFace,
        and Feature objects. If BRepFace or Feature are objects are provided, all of the edges associated
        with those objects will be chamfered.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.DistanceAndAngleChamferEdgeSet__get_edges(self)

    def _set_edges(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the edges that will be chamfered. This collection can contain BRepEdge, BRepFace,
        and Feature objects. If BRepFace or Feature are objects are provided, all of the edges associated
        with those objects will be chamfered.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.DistanceAndAngleChamferEdgeSet__set_edges(self, value)

    def _get_distance(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the model parameter that controls the offset distance of the chamfer.
        You can edit the distance by using the properties on the returned ModelParameter object.
        """
        return _fusion.DistanceAndAngleChamferEdgeSet__get_distance(self)

    def _get_angle(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the model parameter that controls the angle of the chamfer.
        You can edit the distance by using the properties on the returned ModelParameter object.
        """
        return _fusion.DistanceAndAngleChamferEdgeSet__get_angle(self)

    def _get_isFlipped(self) -> "bool":
        r"""
        Gets and sets if the chamfer is flipped. This swaps the directions for distance one and two.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.DistanceAndAngleChamferEdgeSet__get_isFlipped(self)

    def _set_isFlipped(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the chamfer is flipped. This swaps the directions for distance one and two.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.DistanceAndAngleChamferEdgeSet__set_isFlipped(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the chamfer edge set from the chamfer.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        Returns true if the operation was successful.
        """
        return _fusion.DistanceAndAngleChamferEdgeSet_deleteMe(self)

    def _get_isTangentChain(self) -> "bool":
        r"""Gets and sets the Tangent chain for chamfer. This enables tangent chain option for chamfer."""
        return _fusion.DistanceAndAngleChamferEdgeSet__get_isTangentChain(self)

    def _set_isTangentChain(self, value: "bool") -> "bool":
        r"""Gets and sets the Tangent chain for chamfer. This enables tangent chain option for chamfer."""
        return _fusion.DistanceAndAngleChamferEdgeSet__set_isTangentChain(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.DistanceAndAngleChamferEdgeSet__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.DistanceAndAngleChamferEdgeSet__get_isValid(self)

# Register DistanceAndAngleChamferEdgeSet in _fusion:
_fusion.DistanceAndAngleChamferEdgeSet_swigregister(DistanceAndAngleChamferEdgeSet)

def DistanceAndAngleChamferEdgeSet_classType() -> "char const *":
    return _fusion.DistanceAndAngleChamferEdgeSet_classType()


DistanceAndAngleChamferEdgeSet.edges = property(DistanceAndAngleChamferEdgeSet._get_edges, DistanceAndAngleChamferEdgeSet._set_edges, doc="Gets and sets the edges that will be chamfered. This collection can contain BRepEdge, BRepFace,\nand Feature objects. If BRepFace or Feature are objects are provided, all of the edges associated\nwith those objects will be chamfered.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


DistanceAndAngleChamferEdgeSet.distance = property(DistanceAndAngleChamferEdgeSet._get_distance, doc="Returns the model parameter that controls the offset distance of the chamfer.\nYou can edit the distance by using the properties on the returned ModelParameter object.")


DistanceAndAngleChamferEdgeSet.angle = property(DistanceAndAngleChamferEdgeSet._get_angle, doc="Returns the model parameter that controls the angle of the chamfer.\nYou can edit the distance by using the properties on the returned ModelParameter object.")


DistanceAndAngleChamferEdgeSet.isFlipped = property(DistanceAndAngleChamferEdgeSet._get_isFlipped, DistanceAndAngleChamferEdgeSet._set_isFlipped, doc="Gets and sets if the chamfer is flipped. This swaps the directions for distance one and two.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


DistanceAndAngleChamferEdgeSet.cast = lambda arg: arg if isinstance(arg, DistanceAndAngleChamferEdgeSet) else None

class DistanceAndAngleChamferTypeDefinition(ChamferTypeDefinition):
    r"""Provides information to create a chamfer that is defined by a distance from the edge and an angle."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::DistanceAndAngleChamferTypeDefinition *":
        return _fusion.DistanceAndAngleChamferTypeDefinition___deref__(self)

    def __eq__(self, rhs: "DistanceAndAngleChamferTypeDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.DistanceAndAngleChamferTypeDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "DistanceAndAngleChamferTypeDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.DistanceAndAngleChamferTypeDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.DistanceAndAngleChamferTypeDefinition_classType()
    __swig_destroy__ = _fusion.delete_DistanceAndAngleChamferTypeDefinition

    def _get_distance(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the parameter controlling the distance. You can edit the distance
        by editing the value of the parameter object.
        """
        return _fusion.DistanceAndAngleChamferTypeDefinition__get_distance(self)

    def _get_angle(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the parameter controlling the angle. You can edit the angle
        by editing the value of the parameter object.
        """
        return _fusion.DistanceAndAngleChamferTypeDefinition__get_angle(self)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::ChamferFeature >":
        r"""Returns the feature that owns this chamfer type definition"""
        return _fusion.DistanceAndAngleChamferTypeDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.DistanceAndAngleChamferTypeDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.DistanceAndAngleChamferTypeDefinition__get_isValid(self)

# Register DistanceAndAngleChamferTypeDefinition in _fusion:
_fusion.DistanceAndAngleChamferTypeDefinition_swigregister(DistanceAndAngleChamferTypeDefinition)

def DistanceAndAngleChamferTypeDefinition_classType() -> "char const *":
    return _fusion.DistanceAndAngleChamferTypeDefinition_classType()


DistanceAndAngleChamferTypeDefinition.distance = property(DistanceAndAngleChamferTypeDefinition._get_distance, doc="Returns the parameter controlling the distance. You can edit the distance\nby editing the value of the parameter object.")


DistanceAndAngleChamferTypeDefinition.angle = property(DistanceAndAngleChamferTypeDefinition._get_angle, doc="Returns the parameter controlling the angle. You can edit the angle\nby editing the value of the parameter object.")


DistanceAndAngleChamferTypeDefinition.cast = lambda arg: arg if isinstance(arg, DistanceAndAngleChamferTypeDefinition) else None

class DistanceExtentDefinition(ExtentDefinition):
    r"""
    Defines the inputs for a distance ExtentDefinition object. 
    This feature extent type defines the distance as well as whether the extent is symmetric
    or in only one direction. If the extent is not symmetric, a positive or negative distance 
    can be used to control the direction. 
    For a hole, the IsSymmetric property value will always be false.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::DistanceExtentDefinition *":
        return _fusion.DistanceExtentDefinition___deref__(self)

    def __eq__(self, rhs: "DistanceExtentDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.DistanceExtentDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "DistanceExtentDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.DistanceExtentDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.DistanceExtentDefinition_classType()

    @staticmethod
    def create(distance: "ValueInput") -> "adsk::core::Ptr< adsk::core::ValueInput > const &":
        return _fusion.DistanceExtentDefinition_create(distance)
    __swig_destroy__ = _fusion.delete_DistanceExtentDefinition

    def _get_isSymmetric(self) -> "bool":
        r"""
        Gets and sets if the distance extent is symmetric or not
        For a hole this property will always return false and setting it is ignored.
        """
        return _fusion.DistanceExtentDefinition__get_isSymmetric(self)

    def _set_isSymmetric(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the distance extent is symmetric or not
        For a hole this property will always return false and setting it is ignored.
        """
        return _fusion.DistanceExtentDefinition__set_isSymmetric(self, value)

    def _get_distance(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the parameter controlling the distance. You can edit the distance
        by editing the value of the parameter object.
        """
        return _fusion.DistanceExtentDefinition__get_distance(self)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >":
        r"""
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.DistanceExtentDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.DistanceExtentDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.DistanceExtentDefinition__get_isValid(self)

# Register DistanceExtentDefinition in _fusion:
_fusion.DistanceExtentDefinition_swigregister(DistanceExtentDefinition)

def DistanceExtentDefinition_classType() -> "char const *":
    return _fusion.DistanceExtentDefinition_classType()

def DistanceExtentDefinition_create(distance: "ValueInput") -> "adsk::core::Ptr< adsk::core::ValueInput > const &":
    return _fusion.DistanceExtentDefinition_create(distance)


DistanceExtentDefinition.isSymmetric = property(DistanceExtentDefinition._get_isSymmetric, DistanceExtentDefinition._set_isSymmetric, doc="Gets and sets if the distance extent is symmetric or not\nFor a hole this property will always return false and setting it is ignored.")


DistanceExtentDefinition.distance = property(DistanceExtentDefinition._get_distance, doc="Returns the parameter controlling the distance. You can edit the distance\nby editing the value of the parameter object.")


DistanceExtentDefinition.cast = lambda arg: arg if isinstance(arg, DistanceExtentDefinition) else None

class DraftFeature(Feature):
    r"""Object that represents an existing draft feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::DraftFeature *":
        return _fusion.DraftFeature___deref__(self)

    def __eq__(self, rhs: "DraftFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.DraftFeature___eq__(self, rhs)


    def __ne__(self, rhs: "DraftFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.DraftFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.DraftFeature_classType()
    __swig_destroy__ = _fusion.delete_DraftFeature

    def _get_inputFaces(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepFace > > >":
        r"""
        Gets and sets the input faces.
        If isTangentChain is true, all the faces that are tangentially connected to the input faces (if any) will also be included.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.DraftFeature__get_inputFaces(self)

    def _set_inputFaces(self, value: "BRepFaceVector") -> "bool":
        r"""
        Gets and sets the input faces.
        If isTangentChain is true, all the faces that are tangentially connected to the input faces (if any) will also be included.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.DraftFeature__set_inputFaces(self, value)

    def _get_plane(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the plane that defines the direction in which the draft is applied. This can be a planar BrepFace, or a ConstructionPlane.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.DraftFeature__get_plane(self)

    def _set_plane(self, value: "Base") -> "bool":
        r"""
        Gets and sets the plane that defines the direction in which the draft is applied. This can be a planar BrepFace, or a ConstructionPlane.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.DraftFeature__set_plane(self, value)

    def _get_isTangentChain(self) -> "bool":
        r"""
        Gets and sets if any faces that are tangentially connected to any of 
        the input faces will also be included in setting InputEntities. It defaults to true.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.DraftFeature__get_isTangentChain(self)

    def _set_isTangentChain(self, value: "bool") -> "bool":
        r"""
        Gets and sets if any faces that are tangentially connected to any of 
        the input faces will also be included in setting InputEntities. It defaults to true.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.DraftFeature__set_isTangentChain(self, value)

    def _get_isDirectionFlipped(self) -> "bool":
        r"""
        Gets and sets if the direction of the draft is flipped.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.DraftFeature__get_isDirectionFlipped(self)

    def _set_isDirectionFlipped(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the direction of the draft is flipped.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.DraftFeature__set_isDirectionFlipped(self, value)

    def _get_draftDefinition(self) -> "adsk::core::Ptr< adsk::fusion::ExtentDefinition >":
        r"""
        Gets the definition object that specifies how the draft is defined. Modifying the
        definition object will cause the draft to recompute. This can return either an
        AngleExtentDefinition or TwoSidesAngleExtentDefinition object. This property 
        returns nothing in the case where the feature is non-parametric. Use this property
        to access the parameters controlling the draft and whether the draft is symmetric or not.
        """
        return _fusion.DraftFeature__get_draftDefinition(self)

    def setSingleAngle(self, isSymmetric: "bool", angle: "ValueInput") -> "bool":
        r"""
        Changes the definition of the feature so that a single angle is used for all drafts.
        If the isSymmetric is true then the faces are split along the parting plane and drafted
        independently using the same angle.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        isSymmetric : Set to 'true' if the faces are to be split along the plane and drafted symmetrically. This 
        will have the side effect of setting the isSymmetric property to the same value. 
        angle : The ValueInput object that defines the angle of the draft. This can be a positive or negative
        value which will affect the direction of the draft along with the isDirectionFlipped property. 
        Returns true if successful
        """
        return _fusion.DraftFeature_setSingleAngle(self, isSymmetric, angle)

    def setTwoAngles(self, angleOne: "ValueInput", angleTwo: "ValueInput") -> "bool":
        r"""
        Changes the definition of the feature so that the surfaces are split along the draft plane and
        the faces on each side of the plane are drafted independently from the other side.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        angleOne : The ValueInput object that defines the angle for the faces on the first side of the draft plane. 
        angleTwo : The ValueInput object that defines the angle for the faces on the second side of the draft plane. 
        Returns true if successful
        """
        return _fusion.DraftFeature_setTwoAngles(self, angleOne, angleTwo)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::DraftFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.DraftFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::DraftFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.DraftFeature_createForAssemblyContext(self, occurrence)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.DraftFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.DraftFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.DraftFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.DraftFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.DraftFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.DraftFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.DraftFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.DraftFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.DraftFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.DraftFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.DraftFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.DraftFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.DraftFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.DraftFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.DraftFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.DraftFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.DraftFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.DraftFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.DraftFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.DraftFeature__get_isValid(self)

# Register DraftFeature in _fusion:
_fusion.DraftFeature_swigregister(DraftFeature)

def DraftFeature_classType() -> "char const *":
    return _fusion.DraftFeature_classType()


DraftFeature.inputFaces = property(DraftFeature._get_inputFaces, DraftFeature._set_inputFaces, doc="Gets and sets the input faces.\nIf isTangentChain is true, all the faces that are tangentially connected to the input faces (if any) will also be included.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


DraftFeature.plane = property(DraftFeature._get_plane, DraftFeature._set_plane, doc="Gets and sets the plane that defines the direction in which the draft is applied. This can be a planar BrepFace, or a ConstructionPlane.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


DraftFeature.isTangentChain = property(DraftFeature._get_isTangentChain, DraftFeature._set_isTangentChain, doc="Gets and sets if any faces that are tangentially connected to any of\nthe input faces will also be included in setting InputEntities. It defaults to true.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


DraftFeature.isDirectionFlipped = property(DraftFeature._get_isDirectionFlipped, DraftFeature._set_isDirectionFlipped, doc="Gets and sets if the direction of the draft is flipped.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


DraftFeature.draftDefinition = property(DraftFeature._get_draftDefinition, doc="Gets the definition object that specifies how the draft is defined. Modifying the\ndefinition object will cause the draft to recompute. This can return either an\nAngleExtentDefinition or TwoSidesAngleExtentDefinition object. This property\nreturns nothing in the case where the feature is non-parametric. Use this property\nto access the parameters controlling the draft and whether the draft is symmetric or not.")


DraftFeature.nativeObject = property(DraftFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


DraftFeature.cast = lambda arg: arg if isinstance(arg, DraftFeature) else None

class EqualConstraint(GeometricConstraint):
    r"""An equal constraint in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::EqualConstraint *":
        return _fusion.EqualConstraint___deref__(self)

    def __eq__(self, rhs: "EqualConstraint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.EqualConstraint___eq__(self, rhs)


    def __ne__(self, rhs: "EqualConstraint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.EqualConstraint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.EqualConstraint_classType()
    __swig_destroy__ = _fusion.delete_EqualConstraint

    def _get_curveOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >":
        r"""Returns the first curve."""
        return _fusion.EqualConstraint__get_curveOne(self)

    def _get_curveTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >":
        r"""Returns the second curve."""
        return _fusion.EqualConstraint__get_curveTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::EqualConstraint >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.EqualConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::EqualConstraint >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.EqualConstraint_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.EqualConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this constraint is deletable."""
        return _fusion.EqualConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.EqualConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.EqualConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.EqualConstraint__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the GeometricConstraint object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same geometric constraint.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.EqualConstraint__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.EqualConstraint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.EqualConstraint__get_isValid(self)

# Register EqualConstraint in _fusion:
_fusion.EqualConstraint_swigregister(EqualConstraint)

def EqualConstraint_classType() -> "char const *":
    return _fusion.EqualConstraint_classType()


EqualConstraint.curveOne = property(EqualConstraint._get_curveOne, doc="Returns the first curve.")


EqualConstraint.curveTwo = property(EqualConstraint._get_curveTwo, doc="Returns the second curve.")


EqualConstraint.nativeObject = property(EqualConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


EqualConstraint.cast = lambda arg: arg if isinstance(arg, EqualConstraint) else None

class EqualDistanceChamferEdgeSet(ChamferEdgeSet):
    r"""Provides access to the edges and the parameter associated with a equal distance offset chamfer."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::EqualDistanceChamferEdgeSet *":
        return _fusion.EqualDistanceChamferEdgeSet___deref__(self)

    def __eq__(self, rhs: "EqualDistanceChamferEdgeSet") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.EqualDistanceChamferEdgeSet___eq__(self, rhs)


    def __ne__(self, rhs: "EqualDistanceChamferEdgeSet") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.EqualDistanceChamferEdgeSet___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.EqualDistanceChamferEdgeSet_classType()
    __swig_destroy__ = _fusion.delete_EqualDistanceChamferEdgeSet

    def _get_edges(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the edges that will be chamfered. This collection can contain BRepEdge, BRepFace,
        and Feature objects. If BRepFace or Feature are objects are provided, all of the edges associated
        with those objects will be chamfered.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.EqualDistanceChamferEdgeSet__get_edges(self)

    def _set_edges(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the edges that will be chamfered. This collection can contain BRepEdge, BRepFace,
        and Feature objects. If BRepFace or Feature are objects are provided, all of the edges associated
        with those objects will be chamfered.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.EqualDistanceChamferEdgeSet__set_edges(self, value)

    def _get_distance(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the model parameter that controls the offset distance of the chamfer. You can edit
        the distance by using the properties on the returned ModelParameter object.
        """
        return _fusion.EqualDistanceChamferEdgeSet__get_distance(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the chamfer edge set from the chamfer.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        Returns true if the operation was successful.
        """
        return _fusion.EqualDistanceChamferEdgeSet_deleteMe(self)

    def _get_isTangentChain(self) -> "bool":
        r"""Gets and sets the Tangent chain for chamfer. This enables tangent chain option for chamfer."""
        return _fusion.EqualDistanceChamferEdgeSet__get_isTangentChain(self)

    def _set_isTangentChain(self, value: "bool") -> "bool":
        r"""Gets and sets the Tangent chain for chamfer. This enables tangent chain option for chamfer."""
        return _fusion.EqualDistanceChamferEdgeSet__set_isTangentChain(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.EqualDistanceChamferEdgeSet__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.EqualDistanceChamferEdgeSet__get_isValid(self)

# Register EqualDistanceChamferEdgeSet in _fusion:
_fusion.EqualDistanceChamferEdgeSet_swigregister(EqualDistanceChamferEdgeSet)

def EqualDistanceChamferEdgeSet_classType() -> "char const *":
    return _fusion.EqualDistanceChamferEdgeSet_classType()


EqualDistanceChamferEdgeSet.edges = property(EqualDistanceChamferEdgeSet._get_edges, EqualDistanceChamferEdgeSet._set_edges, doc="Gets and sets the edges that will be chamfered. This collection can contain BRepEdge, BRepFace,\nand Feature objects. If BRepFace or Feature are objects are provided, all of the edges associated\nwith those objects will be chamfered.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


EqualDistanceChamferEdgeSet.distance = property(EqualDistanceChamferEdgeSet._get_distance, doc="Returns the model parameter that controls the offset distance of the chamfer. You can edit\nthe distance by using the properties on the returned ModelParameter object.")


EqualDistanceChamferEdgeSet.cast = lambda arg: arg if isinstance(arg, EqualDistanceChamferEdgeSet) else None

class EqualDistanceChamferTypeDefinition(ChamferTypeDefinition):
    r"""Provides information to create a chamfer that is defined by a single distance and has an equal offset from the edge."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::EqualDistanceChamferTypeDefinition *":
        return _fusion.EqualDistanceChamferTypeDefinition___deref__(self)

    def __eq__(self, rhs: "EqualDistanceChamferTypeDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.EqualDistanceChamferTypeDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "EqualDistanceChamferTypeDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.EqualDistanceChamferTypeDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.EqualDistanceChamferTypeDefinition_classType()
    __swig_destroy__ = _fusion.delete_EqualDistanceChamferTypeDefinition

    def _get_distance(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the parameter controlling the distance. You can edit the distance
        by editing the value of the parameter object.
        """
        return _fusion.EqualDistanceChamferTypeDefinition__get_distance(self)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::ChamferFeature >":
        r"""Returns the feature that owns this chamfer type definition"""
        return _fusion.EqualDistanceChamferTypeDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.EqualDistanceChamferTypeDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.EqualDistanceChamferTypeDefinition__get_isValid(self)

# Register EqualDistanceChamferTypeDefinition in _fusion:
_fusion.EqualDistanceChamferTypeDefinition_swigregister(EqualDistanceChamferTypeDefinition)

def EqualDistanceChamferTypeDefinition_classType() -> "char const *":
    return _fusion.EqualDistanceChamferTypeDefinition_classType()


EqualDistanceChamferTypeDefinition.distance = property(EqualDistanceChamferTypeDefinition._get_distance, doc="Returns the parameter controlling the distance. You can edit the distance\nby editing the value of the parameter object.")


EqualDistanceChamferTypeDefinition.cast = lambda arg: arg if isinstance(arg, EqualDistanceChamferTypeDefinition) else None

class ExtendFeature(Feature):
    r"""Object that represents an existing extend feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ExtendFeature *":
        return _fusion.ExtendFeature___deref__(self)

    def __eq__(self, rhs: "ExtendFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ExtendFeature___eq__(self, rhs)


    def __ne__(self, rhs: "ExtendFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ExtendFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ExtendFeature_classType()
    __swig_destroy__ = _fusion.delete_ExtendFeature

    def setInputEntities(self, edges: "ObjectCollection", isChainingEnabled: "bool"=True) -> "bool":
        r"""
        Sets the edges for the extend feature.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        edges : The surface edges to extend.
        Only the surface edges from an open body can be extended.
        The edges must all be from the same open body. 
        isChainingEnabled : An optional boolean argument whose default is true. If this argument is set to true, all edges that are 
        tangent or curvature continuous, and end point connected, will be found automatically and extended. 
        Returns true if successful
        """
        return _fusion.ExtendFeature_setInputEntities(self, edges, isChainingEnabled)

    def _get_edges(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets the edges that were extended. In many cases the extend operation results in 
        the edges being consumed so they're no longer available after the feature is created.
        in this case you need to reposition the timeline marker to just before this feature
        when the edges do exist.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ExtendFeature__get_edges(self)

    def _get_distance(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the parameter controlling the extend distance. You can edit the distance
        by editing the value of the parameter object.
        """
        return _fusion.ExtendFeature__get_distance(self)

    def _get_extendType(self) -> "adsk::fusion::SurfaceExtendTypes":
        r"""
        Gets and sets surface extend type to use.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ExtendFeature__get_extendType(self)

    def _set_extendType(self, value: "SurfaceExtendTypes") -> "bool":
        r"""
        Gets and sets surface extend type to use.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ExtendFeature__set_extendType(self, value)

    def _get_isChainingEnabled(self) -> "bool":
        r"""
        Gets if all edges that are tangent or curvature continuous, and end point connected, will be found 
        automatically and extended.
        """
        return _fusion.ExtendFeature__get_isChainingEnabled(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ExtendFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ExtendFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::ExtendFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.ExtendFeature_createForAssemblyContext(self, occurrence)

    def _get_extendAlignment(self) -> "adsk::fusion::SurfaceExtendAlignment":
        r"""
        Gets and sets surface extend alignment to use.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ExtendFeature__get_extendAlignment(self)

    def _set_extendAlignment(self, value: "SurfaceExtendAlignment") -> "bool":
        r"""
        Gets and sets surface extend alignment to use.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ExtendFeature__set_extendAlignment(self, value)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ExtendFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ExtendFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ExtendFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.ExtendFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ExtendFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ExtendFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.ExtendFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.ExtendFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.ExtendFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.ExtendFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ExtendFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.ExtendFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.ExtendFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.ExtendFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ExtendFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.ExtendFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ExtendFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.ExtendFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ExtendFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ExtendFeature__get_isValid(self)

# Register ExtendFeature in _fusion:
_fusion.ExtendFeature_swigregister(ExtendFeature)

def ExtendFeature_classType() -> "char const *":
    return _fusion.ExtendFeature_classType()


ExtendFeature.edges = property(ExtendFeature._get_edges, doc="Gets the edges that were extended. In many cases the extend operation results in\nthe edges being consumed so they're no longer available after the feature is created.\nin this case you need to reposition the timeline marker to just before this feature\nwhen the edges do exist.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ExtendFeature.distance = property(ExtendFeature._get_distance, doc="Returns the parameter controlling the extend distance. You can edit the distance\nby editing the value of the parameter object.")


ExtendFeature.extendType = property(ExtendFeature._get_extendType, ExtendFeature._set_extendType, doc="Gets and sets surface extend type to use.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ExtendFeature.isChainingEnabled = property(ExtendFeature._get_isChainingEnabled, doc="Gets if all edges that are tangent or curvature continuous, and end point connected, will be found\nautomatically and extended.")


ExtendFeature.nativeObject = property(ExtendFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


ExtendFeature.extendAlignment = property(ExtendFeature._get_extendAlignment, ExtendFeature._set_extendAlignment, doc="Gets and sets surface extend alignment to use.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ExtendFeature.cast = lambda arg: arg if isinstance(arg, ExtendFeature) else None

class ExtrudeFeature(Feature):
    r"""Object that represents an existing extrude feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ExtrudeFeature *":
        return _fusion.ExtrudeFeature___deref__(self)

    def __eq__(self, rhs: "ExtrudeFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ExtrudeFeature___eq__(self, rhs)


    def __ne__(self, rhs: "ExtrudeFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ExtrudeFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ExtrudeFeature_classType()
    __swig_destroy__ = _fusion.delete_ExtrudeFeature

    def _get_profile(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the profiles or planar faces used to define the shape of the extrude.
        This property can return or be set with a single Profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        When setting this property of a surface (non-solid) extrusion, you can use the 
        createOpenProfile and createBRepEdgeProfile methods of the Component object to create
        an open profile.
        This property returns null in the case where the feature is non-parametric.
        """
        return _fusion.ExtrudeFeature__get_profile(self)

    def _set_profile(self, value: "Base") -> "bool":
        r"""
        Gets and sets the profiles or planar faces used to define the shape of the extrude.
        This property can return or be set with a single Profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        When setting this property of a surface (non-solid) extrusion, you can use the 
        createOpenProfile and createBRepEdgeProfile methods of the Component object to create
        an open profile.
        This property returns null in the case where the feature is non-parametric.
        """
        return _fusion.ExtrudeFeature__set_profile(self, value)

    def _get_taperAngle(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the parameter controlling the taper angle of the extrusion. To 
        edit the taper angle use properties on the parameter to edit its value.
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ExtrudeFeature__get_taperAngle(self)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations":
        r"""Gets and sets the type of operation performed by the extrusion."""
        return _fusion.ExtrudeFeature__get_operation(self)

    def _set_operation(self, value: "FeatureOperations") -> "bool":
        r"""Gets and sets the type of operation performed by the extrusion."""
        return _fusion.ExtrudeFeature__set_operation(self, value)

    def _get_extentDefinition(self) -> "adsk::core::Ptr< adsk::fusion::ExtentDefinition >":
        r"""
        Gets the ExtentDefinition object that defines the extent of the extrude. Modifying the
        properties of the returned extent definition object will cause the extrude to recompute. 
        Various types of objects can be returned depending on the type of extent currently defined for 
        the extrusion. This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ExtrudeFeature__get_extentDefinition(self)

    def setDistanceExtent(self, isSymmetric: "bool", distance: "ValueInput") -> "bool":
        r"""
        Sets the extrusion extents option to 'Distance'. 
        isSymmetric : Set to 'true' for an extrusion symmetrical about the profile plane 
        distance : ValueInput object that defines the extrude distance.
        If the isSymmetric argument is 'false', a positive or negative distance can be used to control the direction. 
        Returns true if successful
        """
        return _fusion.ExtrudeFeature_setDistanceExtent(self, isSymmetric, distance)

    def setTwoSidesDistanceExtent(self, distanceOne: "ValueInput", distanceTwo: "ValueInput") -> "bool":
        r"""
        Sets the extrusion extents option to 'Two Side'.
        This method will fail in the case of a non-parametric extrusion. 
        distanceOne : ValueInput object that defines the extrude distance for the first side. 
        distanceTwo : ValueInput object that defines the extrude distance for the second side. 
        Returns true if successful
        """
        return _fusion.ExtrudeFeature_setTwoSidesDistanceExtent(self, distanceOne, distanceTwo)

    def setAllExtent(self, direction: "ExtentDirections") -> "bool":
        r"""
        Sets the extrusion extents option to 'All' (i.e. the extrusion is through-all, in both directions.)
        This method will fail in the case of a non-parametric extrusion. 
        direction : The direction can be either positive, negative, or symmetric. 
        Returns true if successful
        """
        return _fusion.ExtrudeFeature_setAllExtent(self, direction)

    def setOneSideToExtent(self, *args) -> "bool":
        r"""
        Sets the extrusion Direction option to 'One Side' and the Extents option to 'To' (a specified face) 
        toEntity : The entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For an extrude it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        matchShape : If the matchShape argument is 'true', the toEntity is extended to fully intersect the extrusion. 
        directionHint : Specifies the direction of the extrusion. This is only used in the case where there are two possible solutions and the extrusion can
        hit the toEntity in either direction. An example is if the profile of the extrusion is within a hole.
        The extrusion will intersect the cylinder of the hole in either direction.
        Typically there is only a single solution and the direction is determined automatically. 
        Returns true if successful.
        """
        return _fusion.ExtrudeFeature_setOneSideToExtent(self, *args)

    def setTwoSidesToExtent(self, toEntityOne: "Base", toEntityTwo: "Base", matchShape: "bool") -> "bool":
        r"""
        Set the extrusion Direction option to 'Two Side'
        This method will fail in the case of a non-parametric extrusion. 
        toEntityOne : The first entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For an extrude it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        toEntityTwo : The second entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For an extrude it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        matchShape : If the matchShape argument is 'true', the toEntity is extended to fully intersect the extrusion. 
        Returns true if successful.
        """
        return _fusion.ExtrudeFeature_setTwoSidesToExtent(self, toEntityOne, toEntityTwo, matchShape)

    def _get_startFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Property that returns the set of faces that cap the end of the extrusion and are coincident 
        with the sketch plane. In the case of a symmetric extrusion, these faces are the ones on the 
        positive normal side of the sketch plane. In the case where there are no start faces,
        this property will return null.
        """
        return _fusion.ExtrudeFeature__get_startFaces(self)

    def _get_endFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Property that returns the set of faces that cap the end of the extrusion, opposite the
        start faces. In the case where there are no end faces, this property will return null.
        """
        return _fusion.ExtrudeFeature__get_endFaces(self)

    def _get_sideFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Property that returns all of the side faces (i.e. those running perpendicular to the extrude direction) 
        of the feature.
        """
        return _fusion.ExtrudeFeature__get_sideFaces(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ExtrudeFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ExtrudeFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::ExtrudeFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ExtrudeFeature_createForAssemblyContext(self, occurrence)

    def _get_isSolid(self) -> "bool":
        r"""Indicates if this feature was initially created as a solid or a surface."""
        return _fusion.ExtrudeFeature__get_isSolid(self)

    def _get_startExtent(self) -> "adsk::core::Ptr< adsk::fusion::ExtentDefinition >":
        r"""
        Gets and sets the extent used to define the start of the extrusion. You can set this property
        with either a ProfilePlaneStartDefinition, ProfilePlaneWithOffsetStartDefinition or a 
        EntityStartDefinition object. You can get any of those objects by using the static create method on the class.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ExtrudeFeature__get_startExtent(self)

    def _set_startExtent(self, value: "ExtentDefinition") -> "bool":
        r"""
        Gets and sets the extent used to define the start of the extrusion. You can set this property
        with either a ProfilePlaneStartDefinition, ProfilePlaneWithOffsetStartDefinition or a 
        EntityStartDefinition object. You can get any of those objects by using the static create method on the class.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ExtrudeFeature__set_startExtent(self, value)

    def setOneSideExtent(self, *args) -> "bool":
        r"""
        Redefines the extrusion to go in one direction from the profile. The extent of the extrusion is 
        defined by the extent argument.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        extent : An ExtentDefinition object that defines how the extent of the extrusion is defined. This can be
        a specified distance (DistanceExtentDefinition), to an entity (ToEntityExtent), or through-all (AllExtentDefinition).
        These objects can be obtained by using the static create method on the appropriate class. 
        direction : Specifies the direction of the extrusion. PositiveExtentDirection and NegativeExtentDirection
        are valid values. PositiveExtentDirection is in the same direction as the normal of the profile's
        parent sketch plane. 
        taperAngle : Optional argument that specifies the taper angle. If omitted a taper angle of 0 is used. 
        Returns true is setting the input to a one sided extent was successful.
        """
        return _fusion.ExtrudeFeature_setOneSideExtent(self, *args)

    def setTwoSidesExtent(self, *args) -> "bool":
        r"""
        Redefines the extrusion to go in both directions from the profile. The extent is defined independently
        for each direction using the input arguments.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        sideOneExtent : An ExtentDefinition object that defines how the extent of the extrusion towards side one is defined. This can be
        a specified distance (DistanceExtentDefinition), to an entity (ToEntityExtent), or through-all (AllExtentDefinition).
        These objects can be obtained by using the static create method on the appropriate class. 
        sideTwoExtent : An ExtentDefinition object that defines how the extent of the extrusion towards side two is defined. This can be
        a specified distance (DistanceExtentDefinition), to an entity (ToEntityExtent), or through-all (AllExtentDefinition).
        These objects can be obtained by using the static create method on the appropriate class. 
        sideOneTaperAngle : Optional argument that specifies the taper angle for side one. If omitted a taper angle of 0 is used. 
        sideTwoTaperAngle : Optional argument that specifies the taper angle for side two. If omitted a taper angle of 0 is used. 
        Returns true, if the call was successful.
        """
        return _fusion.ExtrudeFeature_setTwoSidesExtent(self, *args)

    def setSymmetricExtent(self, *args) -> "bool":
        r"""
        Redefines the extrusion to go symmetrically in both directions from the profile.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        distance : The distance of the extrusions. This is either the full length of half of the length of the final extrusion
        depending on the value of the isFullLength property. 
        isFullLength : Defines if the value defines the full length of the extrusion or half of the length. A value of true indicates
        it defines the full length. 
        taperAngle : Optional argument that specifies the taper angle. The same taper angle is used for both sides for a symmetric 
        extrusion. If omitted a taper angle of 0 is used. 
        Returns true, if the call was successful.
        """
        return _fusion.ExtrudeFeature_setSymmetricExtent(self, *args)

    def _get_extentOne(self) -> "adsk::core::Ptr< adsk::fusion::ExtentDefinition >":
        r"""
        Gets and sets the extent used for a single sided extrude or side one of a two-sided extrusion. Valid 
        inputs are DistanceExtentDefinition, ToEntityExtentDefinition, and ThroughAllExtentDefinition object, 
        which can be created statically using the create method on the classes.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ExtrudeFeature__get_extentOne(self)

    def _set_extentOne(self, value: "ExtentDefinition") -> "bool":
        r"""
        Gets and sets the extent used for a single sided extrude or side one of a two-sided extrusion. Valid 
        inputs are DistanceExtentDefinition, ToEntityExtentDefinition, and ThroughAllExtentDefinition object, 
        which can be created statically using the create method on the classes.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ExtrudeFeature__set_extentOne(self, value)

    def _get_extentTwo(self) -> "adsk::core::Ptr< adsk::fusion::ExtentDefinition >":
        r"""
        Gets and sets the extent used for side two of the extrusion. If the extrude is a single sided extrude this
        property will return null and will fail if set. The hasTwoExtents property can be used to determine if
        there are two sides or not. When setting this property, valid inputs are DistanceExtentDefinition,
        ToEntityExtentDefinition, and ThroughAllExtentDefinition object, which can be created 
        statically using the create method on the classes.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ExtrudeFeature__get_extentTwo(self)

    def _set_extentTwo(self, value: "ExtentDefinition") -> "bool":
        r"""
        Gets and sets the extent used for side two of the extrusion. If the extrude is a single sided extrude this
        property will return null and will fail if set. The hasTwoExtents property can be used to determine if
        there are two sides or not. When setting this property, valid inputs are DistanceExtentDefinition,
        ToEntityExtentDefinition, and ThroughAllExtentDefinition object, which can be created 
        statically using the create method on the classes.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ExtrudeFeature__set_extentTwo(self, value)

    def _get_taperAngleOne(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the parameter controlling the taper angle for a single sided extrusion or side one of a two-sided
        extrusion. To edit the angle, use properties on the parameter to change the value of the parameter.
        """
        return _fusion.ExtrudeFeature__get_taperAngleOne(self)

    def _get_taperAngleTwo(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the parameter controlling the taper angle for side two of a two-sided extrusion. if the extrusion is 
        single-sided, this property will return null. The hasTwoExtents property can be used to determine if there
        are two sides or not. To edit the angle, use properties on the parameter to change the value of the parameter.
        """
        return _fusion.ExtrudeFeature__get_taperAngleTwo(self)

    def _get_hasTwoExtents(self) -> "bool":
        r"""
        Property that indicates if the extrusion is a single or two-sided extrusion. If false, the extentTwo
        and taperAngleTwo properties should not be used.
        """
        return _fusion.ExtrudeFeature__get_hasTwoExtents(self)

    def _get_participantBodies(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepBody > > >":
        r"""
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ExtrudeFeature__get_participantBodies(self)

    def _set_participantBodies(self, value: "BRepBodyVector") -> "bool":
        r"""
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ExtrudeFeature__set_participantBodies(self, value)

    def _get_extentType(self) -> "adsk::fusion::FeatureExtentTypes":
        r"""Returns a value indicating how the extent is defined for this extrude."""
        return _fusion.ExtrudeFeature__get_extentType(self)

    def _get_symmetricExtent(self) -> "adsk::core::Ptr< adsk::fusion::SymmetricExtentDefinition >":
        r"""
        If the current extent of the feature is defined as a symmetric extent, this property
        returns the SymmericExtentDefinition object that provides access to the information
        defining the symmetric extent. If the current extent is not symmetric, this property
        returns null. You can determine the type of extent by using the extentType property.
        To change the extent of a feature to symmetric extent you can use the setSymmetricExtent
        method.
        """
        return _fusion.ExtrudeFeature__get_symmetricExtent(self)

    def _get_isThinExtrude(self) -> "bool":
        r"""
        Sets or returns whether the extrude is a thin extrude.
        Setting it as false will make it a regular extrude.
        """
        return _fusion.ExtrudeFeature__get_isThinExtrude(self)

    def _set_isThinExtrude(self, value: "bool") -> "bool":
        r"""
        Sets or returns whether the extrude is a thin extrude.
        Setting it as false will make it a regular extrude.
        """
        return _fusion.ExtrudeFeature__set_isThinExtrude(self, value)

    def setThinExtrude(self, *args) -> "bool":
        r"""
        Changes the extrude feature to be a thin extrude. This is only valid if the isThinExtrude property
        is False. If the extrusion is already a thin extrude, you can use the properties on the ExtrudeFeature
        to modify the thin extrude specific values. 
        thinExtrudeWallLocationOne : Specifies the position of the thin wall extrude with respect to the profile being extruded. This defines
        the direction for a single sided thin extrude or side one of a two-sided extrusion. 
        thinExtrudeWallThicknessOne : A ValueInput object that defines the thickness for a single sided thin extrude or side one of a two-sided
        extrusion . 
        thinExtrudeWallLocationTwo : Optional argument that specifys the position of side two of a two-sided extrusion. This argument is ignored
        for a single sided thin extrude. 
        thinExtrudeWallThicknessTwo : Optional argument that is a ValueInput object that defines the thickness for side two of a
        two-sided extrusion extrusion. This argument is ignored for a single sided thin extrude. 
        Returns true if successful.
        """
        return _fusion.ExtrudeFeature_setThinExtrude(self, *args)

    def _get_thinExtrudeWallLocationOne(self) -> "adsk::fusion::ThinExtrudeWallLocation":
        r"""Gets and sets the wall location for a one sided thin extrude or side one of a two sided thin extrude"""
        return _fusion.ExtrudeFeature__get_thinExtrudeWallLocationOne(self)

    def _set_thinExtrudeWallLocationOne(self, value: "ThinExtrudeWallLocation") -> "bool":
        r"""Gets and sets the wall location for a one sided thin extrude or side one of a two sided thin extrude"""
        return _fusion.ExtrudeFeature__set_thinExtrudeWallLocationOne(self, value)

    def _get_thinExtrudeWallLocationTwo(self) -> "adsk::fusion::ThinExtrudeWallLocation":
        r"""Gets and sets the wall location for side two of a two sided thin extrude"""
        return _fusion.ExtrudeFeature__get_thinExtrudeWallLocationTwo(self)

    def _set_thinExtrudeWallLocationTwo(self, value: "ThinExtrudeWallLocation") -> "bool":
        r"""Gets and sets the wall location for side two of a two sided thin extrude"""
        return _fusion.ExtrudeFeature__set_thinExtrudeWallLocationTwo(self, value)

    def _get_thinExtrudeWallThicknessOne(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""Gets and sets the wall thickness for a one sided thin extrude or side one of a two sided thin extrude"""
        return _fusion.ExtrudeFeature__get_thinExtrudeWallThicknessOne(self)

    def _get_thinExtrudeWallThicknessTwo(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""Gets and sets the wall thickness for side two of a two sided thin extrude"""
        return _fusion.ExtrudeFeature__get_thinExtrudeWallThicknessTwo(self)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ExtrudeFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ExtrudeFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ExtrudeFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.ExtrudeFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ExtrudeFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ExtrudeFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.ExtrudeFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.ExtrudeFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.ExtrudeFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.ExtrudeFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ExtrudeFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.ExtrudeFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.ExtrudeFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.ExtrudeFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ExtrudeFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.ExtrudeFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ExtrudeFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.ExtrudeFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ExtrudeFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ExtrudeFeature__get_isValid(self)

# Register ExtrudeFeature in _fusion:
_fusion.ExtrudeFeature_swigregister(ExtrudeFeature)

def ExtrudeFeature_classType() -> "char const *":
    return _fusion.ExtrudeFeature_classType()


ExtrudeFeature.profile = property(ExtrudeFeature._get_profile, ExtrudeFeature._set_profile, doc="Gets and sets the profiles or planar faces used to define the shape of the extrude.\nThis property can return or be set with a single Profile, a single planar face, or\nan ObjectCollection consisting of multiple profiles and planar faces. When an\nObjectCollection is used all of the profiles and faces must be co-planar.\nWhen setting this property of a surface (non-solid) extrusion, you can use the\ncreateOpenProfile and createBRepEdgeProfile methods of the Component object to create\nan open profile.\nThis property returns null in the case where the feature is non-parametric.")


ExtrudeFeature.taperAngle = property(ExtrudeFeature._get_taperAngle, doc="Returns the parameter controlling the taper angle of the extrusion. To\nedit the taper angle use properties on the parameter to edit its value.\nThis property returns nothing in the case where the feature is non-parametric.")


ExtrudeFeature.operation = property(ExtrudeFeature._get_operation, ExtrudeFeature._set_operation, doc="Gets and sets the type of operation performed by the extrusion.")


ExtrudeFeature.extentDefinition = property(ExtrudeFeature._get_extentDefinition, doc="Gets the ExtentDefinition object that defines the extent of the extrude. Modifying the\nproperties of the returned extent definition object will cause the extrude to recompute.\nVarious types of objects can be returned depending on the type of extent currently defined for\nthe extrusion. This property returns nothing in the case where the feature is non-parametric.")


ExtrudeFeature.startFaces = property(ExtrudeFeature._get_startFaces, doc="Property that returns the set of faces that cap the end of the extrusion and are coincident\nwith the sketch plane. In the case of a symmetric extrusion, these faces are the ones on the\npositive normal side of the sketch plane. In the case where there are no start faces,\nthis property will return null.")


ExtrudeFeature.endFaces = property(ExtrudeFeature._get_endFaces, doc="Property that returns the set of faces that cap the end of the extrusion, opposite the\nstart faces. In the case where there are no end faces, this property will return null.")


ExtrudeFeature.sideFaces = property(ExtrudeFeature._get_sideFaces, doc="Property that returns all of the side faces (i.e. those running perpendicular to the extrude direction)\nof the feature.")


ExtrudeFeature.nativeObject = property(ExtrudeFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


ExtrudeFeature.isSolid = property(ExtrudeFeature._get_isSolid, doc="Indicates if this feature was initially created as a solid or a surface.")


ExtrudeFeature.startExtent = property(ExtrudeFeature._get_startExtent, ExtrudeFeature._set_startExtent, doc="Gets and sets the extent used to define the start of the extrusion. You can set this property\nwith either a ProfilePlaneStartDefinition, ProfilePlaneWithOffsetStartDefinition or a\nEntityStartDefinition object. You can get any of those objects by using the static create method on the class.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ExtrudeFeature.extentOne = property(ExtrudeFeature._get_extentOne, ExtrudeFeature._set_extentOne, doc="Gets and sets the extent used for a single sided extrude or side one of a two-sided extrusion. Valid\ninputs are DistanceExtentDefinition, ToEntityExtentDefinition, and ThroughAllExtentDefinition object,\nwhich can be created statically using the create method on the classes.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ExtrudeFeature.extentTwo = property(ExtrudeFeature._get_extentTwo, ExtrudeFeature._set_extentTwo, doc="Gets and sets the extent used for side two of the extrusion. If the extrude is a single sided extrude this\nproperty will return null and will fail if set. The hasTwoExtents property can be used to determine if\nthere are two sides or not. When setting this property, valid inputs are DistanceExtentDefinition,\nToEntityExtentDefinition, and ThroughAllExtentDefinition object, which can be created\nstatically using the create method on the classes.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ExtrudeFeature.taperAngleOne = property(ExtrudeFeature._get_taperAngleOne, doc="Gets the parameter controlling the taper angle for a single sided extrusion or side one of a two-sided\nextrusion. To edit the angle, use properties on the parameter to change the value of the parameter.")


ExtrudeFeature.taperAngleTwo = property(ExtrudeFeature._get_taperAngleTwo, doc="Gets the parameter controlling the taper angle for side two of a two-sided extrusion. if the extrusion is\nsingle-sided, this property will return null. The hasTwoExtents property can be used to determine if there\nare two sides or not. To edit the angle, use properties on the parameter to change the value of the parameter.")


ExtrudeFeature.hasTwoExtents = property(ExtrudeFeature._get_hasTwoExtents, doc="Property that indicates if the extrusion is a single or two-sided extrusion. If false, the extentTwo\nand taperAngleTwo properties should not be used.")


ExtrudeFeature.participantBodies = property(ExtrudeFeature._get_participantBodies, ExtrudeFeature._set_participantBodies, doc="Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ExtrudeFeature.extentType = property(ExtrudeFeature._get_extentType, doc="Returns a value indicating how the extent is defined for this extrude.")


ExtrudeFeature.symmetricExtent = property(ExtrudeFeature._get_symmetricExtent, doc="If the current extent of the feature is defined as a symmetric extent, this property\nreturns the SymmericExtentDefinition object that provides access to the information\ndefining the symmetric extent. If the current extent is not symmetric, this property\nreturns null. You can determine the type of extent by using the extentType property.\nTo change the extent of a feature to symmetric extent you can use the setSymmetricExtent\nmethod.")


ExtrudeFeature.isThinExtrude = property(ExtrudeFeature._get_isThinExtrude, ExtrudeFeature._set_isThinExtrude, doc="Sets or returns whether the extrude is a thin extrude.\nSetting it as false will make it a regular extrude.")


ExtrudeFeature.thinExtrudeWallLocationOne = property(ExtrudeFeature._get_thinExtrudeWallLocationOne, ExtrudeFeature._set_thinExtrudeWallLocationOne, doc="Gets and sets the wall location for a one sided thin extrude or side one of a two sided thin extrude")


ExtrudeFeature.thinExtrudeWallLocationTwo = property(ExtrudeFeature._get_thinExtrudeWallLocationTwo, ExtrudeFeature._set_thinExtrudeWallLocationTwo, doc="Gets and sets the wall location for side two of a two sided thin extrude")


ExtrudeFeature.thinExtrudeWallThicknessOne = property(ExtrudeFeature._get_thinExtrudeWallThicknessOne, doc="Gets and sets the wall thickness for a one sided thin extrude or side one of a two sided thin extrude")


ExtrudeFeature.thinExtrudeWallThicknessTwo = property(ExtrudeFeature._get_thinExtrudeWallThicknessTwo, doc="Gets and sets the wall thickness for side two of a two sided thin extrude")


ExtrudeFeature.cast = lambda arg: arg if isinstance(arg, ExtrudeFeature) else None

class FilletFeature(Feature):
    r"""Object that represents an existing fillet feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::FilletFeature *":
        return _fusion.FilletFeature___deref__(self)

    def __eq__(self, rhs: "FilletFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.FilletFeature___eq__(self, rhs)


    def __ne__(self, rhs: "FilletFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.FilletFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.FilletFeature_classType()
    __swig_destroy__ = _fusion.delete_FilletFeature

    def _get_edgeSets(self) -> "adsk::core::Ptr< adsk::fusion::FilletEdgeSets >":
        r"""Returns the edge sets collection associated with this fillet."""
        return _fusion.FilletFeature__get_edgeSets(self)

    def _get_isG2(self) -> "bool":
        r"""Gets and sets if the fillet uses the G2 (curvature-continuity) surface quality option."""
        return _fusion.FilletFeature__get_isG2(self)

    def _set_isG2(self, value: "bool") -> "bool":
        r"""Gets and sets if the fillet uses the G2 (curvature-continuity) surface quality option."""
        return _fusion.FilletFeature__set_isG2(self, value)

    def _get_isRollingBallCorner(self) -> "bool":
        r"""
        Gets and sets if a rolling ball solution is to be used in any corners.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.FilletFeature__get_isRollingBallCorner(self)

    def _set_isRollingBallCorner(self, value: "bool") -> "bool":
        r"""
        Gets and sets if a rolling ball solution is to be used in any corners.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.FilletFeature__set_isRollingBallCorner(self, value)

    def _get_isTangentChain(self) -> "bool":
        r"""
        Gets and sets whether or not edges that are tangentially connected to 
        the input edges (if any) will also be filleted.
        """
        return _fusion.FilletFeature__get_isTangentChain(self)

    def _set_isTangentChain(self, value: "bool") -> "bool":
        r"""
        Gets and sets whether or not edges that are tangentially connected to 
        the input edges (if any) will also be filleted.
        """
        return _fusion.FilletFeature__set_isTangentChain(self, value)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::FilletFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of its parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.FilletFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::FilletFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.FilletFeature_createForAssemblyContext(self, occurrence)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.FilletFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.FilletFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.FilletFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.FilletFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.FilletFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.FilletFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.FilletFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.FilletFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.FilletFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.FilletFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.FilletFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.FilletFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.FilletFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.FilletFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.FilletFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.FilletFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.FilletFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.FilletFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.FilletFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.FilletFeature__get_isValid(self)

# Register FilletFeature in _fusion:
_fusion.FilletFeature_swigregister(FilletFeature)

def FilletFeature_classType() -> "char const *":
    return _fusion.FilletFeature_classType()


FilletFeature.edgeSets = property(FilletFeature._get_edgeSets, doc="Returns the edge sets collection associated with this fillet.")


FilletFeature.isG2 = property(FilletFeature._get_isG2, FilletFeature._set_isG2, doc="Gets and sets if the fillet uses the G2 (curvature-continuity) surface quality option.")


FilletFeature.isRollingBallCorner = property(FilletFeature._get_isRollingBallCorner, FilletFeature._set_isRollingBallCorner, doc="Gets and sets if a rolling ball solution is to be used in any corners.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


FilletFeature.isTangentChain = property(FilletFeature._get_isTangentChain, FilletFeature._set_isTangentChain, doc="Gets and sets whether or not edges that are tangentially connected to\nthe input edges (if any) will also be filleted.")


FilletFeature.nativeObject = property(FilletFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of its parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


FilletFeature.cast = lambda arg: arg if isinstance(arg, FilletFeature) else None

class FitOnPathTextDefintion(SketchTextDefinition):
    r"""Defines the information for text that fits along a path."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::FitOnPathTextDefintion *":
        return _fusion.FitOnPathTextDefintion___deref__(self)

    def __eq__(self, rhs: "FitOnPathTextDefintion") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.FitOnPathTextDefintion___eq__(self, rhs)


    def __ne__(self, rhs: "FitOnPathTextDefintion") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.FitOnPathTextDefintion___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.FitOnPathTextDefintion_classType()
    __swig_destroy__ = _fusion.delete_FitOnPathTextDefintion

    def _get_path(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Get and sets the entity that defines the path for the text. This can be a SketchCurve or BRepEdge object."""
        return _fusion.FitOnPathTextDefintion__get_path(self)

    def _set_path(self, value: "Base") -> "bool":
        r"""Get and sets the entity that defines the path for the text. This can be a SketchCurve or BRepEdge object."""
        return _fusion.FitOnPathTextDefintion__set_path(self, value)

    def _get_isAbovePath(self) -> "bool":
        r"""Gets and sets if the text should be positioned above or below the path entity."""
        return _fusion.FitOnPathTextDefintion__get_isAbovePath(self)

    def _set_isAbovePath(self, value: "bool") -> "bool":
        r"""Gets and sets if the text should be positioned above or below the path entity."""
        return _fusion.FitOnPathTextDefintion__set_isAbovePath(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.FitOnPathTextDefintion__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.FitOnPathTextDefintion__get_isValid(self)

# Register FitOnPathTextDefintion in _fusion:
_fusion.FitOnPathTextDefintion_swigregister(FitOnPathTextDefintion)

def FitOnPathTextDefintion_classType() -> "char const *":
    return _fusion.FitOnPathTextDefintion_classType()


FitOnPathTextDefintion.path = property(FitOnPathTextDefintion._get_path, FitOnPathTextDefintion._set_path, doc="Get and sets the entity that defines the path for the text. This can be a SketchCurve or BRepEdge object.")


FitOnPathTextDefintion.isAbovePath = property(FitOnPathTextDefintion._get_isAbovePath, FitOnPathTextDefintion._set_isAbovePath, doc="Gets and sets if the text should be positioned above or below the path entity.")


FitOnPathTextDefintion.cast = lambda arg: arg if isinstance(arg, FitOnPathTextDefintion) else None

class FlangeFeature(Feature):
    r"""Object that represents an existing flange feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::FlangeFeature *":
        return _fusion.FlangeFeature___deref__(self)

    def __eq__(self, rhs: "FlangeFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.FlangeFeature___eq__(self, rhs)


    def __ne__(self, rhs: "FlangeFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.FlangeFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.FlangeFeature_classType()
    __swig_destroy__ = _fusion.delete_FlangeFeature

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.FlangeFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.FlangeFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.FlangeFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.FlangeFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.FlangeFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.FlangeFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.FlangeFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.FlangeFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.FlangeFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.FlangeFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.FlangeFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.FlangeFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.FlangeFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.FlangeFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.FlangeFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.FlangeFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.FlangeFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.FlangeFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.FlangeFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.FlangeFeature__get_isValid(self)

# Register FlangeFeature in _fusion:
_fusion.FlangeFeature_swigregister(FlangeFeature)

def FlangeFeature_classType() -> "char const *":
    return _fusion.FlangeFeature_classType()


FlangeFeature.cast = lambda arg: arg if isinstance(arg, FlangeFeature) else None

class FormFeature(Feature):
    r"""Object that represents an existing Form feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::FormFeature *":
        return _fusion.FormFeature___deref__(self)

    def __eq__(self, rhs: "FormFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.FormFeature___eq__(self, rhs)


    def __ne__(self, rhs: "FormFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.FormFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.FormFeature_classType()
    __swig_destroy__ = _fusion.delete_FormFeature

    def _get_tSplineBodies(self) -> "adsk::core::Ptr< adsk::fusion::TSplineBodies >":
        r"""
        Returns a TSplineBodies collection where you can access any existing 
        T-Spline bodies and through it create new T-Spline bodies.
        """
        return _fusion.FormFeature__get_tSplineBodies(self)

    def startEdit(self) -> "bool":
        r"""
        Set the user-interface so that the form body is in edit mode. 
        Returns true if successful.
        """
        return _fusion.FormFeature_startEdit(self)

    def finishEdit(self) -> "bool":
        r"""
        Exits from edit mode in the user-interface. If this form feature in not
        in edit mode, then nothing happens. 
        Returns true if successful.
        """
        return _fusion.FormFeature_finishEdit(self)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.FormFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.FormFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.FormFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.FormFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.FormFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.FormFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.FormFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.FormFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.FormFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.FormFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.FormFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.FormFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.FormFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.FormFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.FormFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.FormFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.FormFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.FormFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.FormFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.FormFeature__get_isValid(self)

# Register FormFeature in _fusion:
_fusion.FormFeature_swigregister(FormFeature)

def FormFeature_classType() -> "char const *":
    return _fusion.FormFeature_classType()


FormFeature.tSplineBodies = property(FormFeature._get_tSplineBodies, doc="Returns a TSplineBodies collection where you can access any existing\nT-Spline bodies and through it create new T-Spline bodies.")


FormFeature.cast = lambda arg: arg if isinstance(arg, FormFeature) else None

class FromEntityStartDefinition(ExtentDefinition):
    r"""
    A definition object that is used to define a feature whose start is defined by a specified construction
    plane or face. If a face is specified it must be large enough to completely contain the projected profile.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::FromEntityStartDefinition *":
        return _fusion.FromEntityStartDefinition___deref__(self)

    def __eq__(self, rhs: "FromEntityStartDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.FromEntityStartDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "FromEntityStartDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.FromEntityStartDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.FromEntityStartDefinition_classType()

    @staticmethod
    def create(entity: "Base", offset: "ValueInput") -> "adsk::core::Ptr< adsk::core::ValueInput > const &":
        return _fusion.FromEntityStartDefinition_create(entity, offset)
    __swig_destroy__ = _fusion.delete_FromEntityStartDefinition

    def _get_offset(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets the currently defined offset value. If the FromEntityStartDefinition object was
        created statically and is not associated with a feature, this will return a ValueInput object.
        if the FromEntityStartDefinition is associated with an existing feature, this will return
        the parameter that was created when the feature was created. To edit the offset, use properties
        on the parameter to change the value of the parameter.
        """
        return _fusion.FromEntityStartDefinition__get_offset(self)

    def _get_entity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Gets and sets the entity defining the start of the feature."""
        return _fusion.FromEntityStartDefinition__get_entity(self)

    def _set_entity(self, value: "Base") -> "bool":
        r"""Gets and sets the entity defining the start of the feature."""
        return _fusion.FromEntityStartDefinition__set_entity(self, value)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >":
        r"""
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.FromEntityStartDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.FromEntityStartDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.FromEntityStartDefinition__get_isValid(self)

# Register FromEntityStartDefinition in _fusion:
_fusion.FromEntityStartDefinition_swigregister(FromEntityStartDefinition)

def FromEntityStartDefinition_classType() -> "char const *":
    return _fusion.FromEntityStartDefinition_classType()

def FromEntityStartDefinition_create(entity: "Base", offset: "ValueInput") -> "adsk::core::Ptr< adsk::core::ValueInput > const &":
    return _fusion.FromEntityStartDefinition_create(entity, offset)


FromEntityStartDefinition.offset = property(FromEntityStartDefinition._get_offset, doc="Gets the currently defined offset value. If the FromEntityStartDefinition object was\ncreated statically and is not associated with a feature, this will return a ValueInput object.\nif the FromEntityStartDefinition is associated with an existing feature, this will return\nthe parameter that was created when the feature was created. To edit the offset, use properties\non the parameter to change the value of the parameter.")


FromEntityStartDefinition.entity = property(FromEntityStartDefinition._get_entity, FromEntityStartDefinition._set_entity, doc="Gets and sets the entity defining the start of the feature.")


FromEntityStartDefinition.cast = lambda arg: arg if isinstance(arg, FromEntityStartDefinition) else None

class FusionArchiveExportOptions(ExportOptions):
    r"""Defines that a Fusion 360 Archive export is to be done and specifies the various options."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::FusionArchiveExportOptions *":
        return _fusion.FusionArchiveExportOptions___deref__(self)

    def __eq__(self, rhs: "FusionArchiveExportOptions") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.FusionArchiveExportOptions___eq__(self, rhs)


    def __ne__(self, rhs: "FusionArchiveExportOptions") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.FusionArchiveExportOptions___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.FusionArchiveExportOptions_classType()
    __swig_destroy__ = _fusion.delete_FusionArchiveExportOptions

    def _get_filename(self) -> "std::string":
        r"""
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.FusionArchiveExportOptions__get_filename(self)

    def _set_filename(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.FusionArchiveExportOptions__set_filename(self, value)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Specifies the geometry to export. This can be an Occurrence, or the root Component. 
        For STL export, it can also be a BRepBody. For DXF export, it can be a sketch of flat pattern.
        """
        return _fusion.FusionArchiveExportOptions__get_geometry(self)

    def _set_geometry(self, value: "Base") -> "bool":
        r"""
        Specifies the geometry to export. This can be an Occurrence, or the root Component. 
        For STL export, it can also be a BRepBody. For DXF export, it can be a sketch of flat pattern.
        """
        return _fusion.FusionArchiveExportOptions__set_geometry(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.FusionArchiveExportOptions__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.FusionArchiveExportOptions__get_isValid(self)

# Register FusionArchiveExportOptions in _fusion:
_fusion.FusionArchiveExportOptions_swigregister(FusionArchiveExportOptions)

def FusionArchiveExportOptions_classType() -> "char const *":
    return _fusion.FusionArchiveExportOptions_classType()


FusionArchiveExportOptions.cast = lambda arg: arg if isinstance(arg, FusionArchiveExportOptions) else None

class HoleFeature(Feature):
    r"""Object that represents an existing hole feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::HoleFeature *":
        return _fusion.HoleFeature___deref__(self)

    def __eq__(self, rhs: "HoleFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.HoleFeature___eq__(self, rhs)


    def __ne__(self, rhs: "HoleFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.HoleFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.HoleFeature_classType()
    __swig_destroy__ = _fusion.delete_HoleFeature

    def _get_position(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Returns the position of the hole."""
        return _fusion.HoleFeature__get_position(self)

    def _get_direction(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Returns the direction of the hole."""
        return _fusion.HoleFeature__get_direction(self)

    def _get_holeType(self) -> "adsk::fusion::HoleTypes":
        r"""Returns the current type of hole this feature represents."""
        return _fusion.HoleFeature__get_holeType(self)

    def _get_holeDiameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the model parameter controlling the hole diameter. The diameter of
        the hole can be edited through the returned parameter object.
        """
        return _fusion.HoleFeature__get_holeDiameter(self)

    def _get_tipAngle(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the model parameter controlling the angle of the tip of the hole. The tip angle of
        the hole can be edited through the returned parameter object.
        """
        return _fusion.HoleFeature__get_tipAngle(self)

    def _get_counterboreDiameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the model parameter controlling the counterbore diameter.
        This will return null in the case the hole type is not a counterbore.
        The diameter of the counterbore can be edited through the returned parameter.
        """
        return _fusion.HoleFeature__get_counterboreDiameter(self)

    def _get_counterboreDepth(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the model parameter controlling the counterbore depth.
        This will return null in the case the hole type is not a counterbore.
        The depth of the counterbore can be edited through the returned parameter.
        """
        return _fusion.HoleFeature__get_counterboreDepth(self)

    def _get_countersinkDiameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the model parameter controlling the countersink diameter.
        This will return null in the case the hole type is not a countersink.
        The diameter of the countersink can be edited through the returned parameter.
        """
        return _fusion.HoleFeature__get_countersinkDiameter(self)

    def _get_countersinkAngle(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the model parameter controlling the countersink angle.
        This will return null in the case the hole type is not a countersink.
        The angle of the countersink can be edited through the returned parameter.
        """
        return _fusion.HoleFeature__get_countersinkAngle(self)

    def _get_isDefaultDirection(self) -> "bool":
        r"""Gets and sets if the hole is in the default direction or not."""
        return _fusion.HoleFeature__get_isDefaultDirection(self)

    def _set_isDefaultDirection(self, value: "bool") -> "bool":
        r"""Gets and sets if the hole is in the default direction or not."""
        return _fusion.HoleFeature__set_isDefaultDirection(self, value)

    def setToSimple(self) -> "bool":
        r"""
        Calling this method will change the hole to a simple hole. 
        Returns true if changing the hole was successful.
        """
        return _fusion.HoleFeature_setToSimple(self)

    def setToCounterbore(self, counterboreDiameter: "ValueInput", counterboreDepth: "ValueInput") -> "bool":
        r"""
        Calling this method will change the hole to a counterbore hole.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        counterboreDiameter : A ValueInput object that defines the counterbore diameter. If the ValueInput uses
        a real then it is interpreted as centimeters. If it is a string then the units
        can be defined as part of the string (i.e. '3 in'). If no units are specified
        it is interpreted using the current default units for length. 
        counterboreDepth : A ValueInput object that defines the counterbore depth. If the ValueInput uses
        a real then it is interpreted as centimeters. If it is a string then the units
        can be defined as part of the string (i.e. '3 in'). If no units are specified
        it is interpreted using the current default units for length. 
        Returns true if changing the hole was successful.
        """
        return _fusion.HoleFeature_setToCounterbore(self, counterboreDiameter, counterboreDepth)

    def setToCountersink(self, countersinkDiameter: "ValueInput", countersinkAngle: "ValueInput") -> "bool":
        r"""
        Calling this method will change the hole to a countersink hole.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        countersinkDiameter : A ValueInput object that defines the countersink diameter. If the ValueInput uses
        a real then it is interpreted as centimeters. If it is a string then the units
        can be defined as part of the string (i.e. '3 in'). If no units are specified
        it is interpreted using the current default units for length. 
        countersinkAngle : A ValueInput object that defines the countersink angle. If the ValueInput uses
        a real then it is interpreted as radians. If it is a string then the units
        can be defined as part of the string (i.e. '120 deg'). If no units are specified
        it is interpreted using the current default units for length. 
        Returns true if changing the hole was successful.
        """
        return _fusion.HoleFeature_setToCountersink(self, countersinkDiameter, countersinkAngle)

    def _get_extentDefinition(self) -> "adsk::core::Ptr< adsk::fusion::ExtentDefinition >":
        r"""
        Gets the definition object that is defining the extent of the hole. Modifying the
        definition object will cause the hole to recompute. The extent type of a hole
        is currently limited to a distance extent.
        """
        return _fusion.HoleFeature__get_extentDefinition(self)

    def setDistanceExtent(self, distance: "ValueInput") -> "bool":
        r"""
        Defines the depth of the hole using a specific distance.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        distance : The depth of the hole. If a real is specified the value is in centimeters. If a string is 
        specified the units are derived from the string. If no units are specified, the default 
        units of the document are used. 
        Returns true if setting the extent was successful.
        """
        return _fusion.HoleFeature_setDistanceExtent(self, distance)

    def setAllExtent(self, direction: "ExtentDirections") -> "bool":
        r"""
        Defines the extent of the hole to be through-all. The direction can be
        either positive, negative.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        direction : The direction of the hole relative to the normal of the sketch plane. 
        Returns true if successful.
        """
        return _fusion.HoleFeature_setAllExtent(self, direction)

    def setOneSideToExtent(self, *args) -> "bool":
        r"""
        Sets the extent of the hole to be from the sketch plane to the specified 'to' face.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        toEntity : The entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For a hole it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        matchShape : Indicates if the hole is not contained on the face that the hole should match
        the shape of the entity as if it extended beyond it's current boundaries. 
        directionHint : Specifies the direction of the hole. This is only used in the case where there are two possible solutions and the hole can
        hit the toEntity in either direction.
        Typically there is only a single solution and the direction is determined automatically. 
        Returns true if successful.
        """
        return _fusion.HoleFeature_setOneSideToExtent(self, *args)

    def _get_endFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Property that returns the faces at the bottom of the hole. This will typically be a single face
        but could return more than one face in the case where the bottom of the hole is uneven.
        """
        return _fusion.HoleFeature__get_endFaces(self)

    def _get_sideFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""Property that returns all of the side faces of the hole."""
        return _fusion.HoleFeature__get_sideFaces(self)

    def setPositionByPoint(self, planarEntity: "Base", point: "Base") -> "bool":
        r"""
        Redefines the position of a the hole using a point. The point can be a vertex on the face
        or it can be a Point3D object to define any location on the face. If a Point3D object is 
        provided it will be projected onto the plane along the planes normal. The orientation of the
        hole is defined by the planar face or construction plane. If a vertex is used, the position of 
        the hole is associative to that vertex. If a Point3D object is used the position of the hole 
        is not associative.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        planarEntity : The planar BRepFace or ConstructionPlane object that defines the orientation of the hole.
        The natural direction of the hole will be opposite the normal of the face or construction plane. 
        point : A Point3D object or vertex that defines the position of the hole. The point will be projected 
        onto the plane along the normal of the plane. 
        Returns true if successful.
        """
        return _fusion.HoleFeature_setPositionByPoint(self, planarEntity, point)

    def setPositionAtCenter(self, planarEntity: "Base", centerEdge: "BRepEdge") -> "bool":
        r"""
        Redefines the position of the hole at the center of a circular or elliptical edge of the face.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        planarEntity : The planar BRepFace or ConstructionPlane object that defines the orientation of the hole.
        The natural direction of the hole will be opposite the normal of the face or construction plane. 
        centerEdge : A circular or elliptical edge whose center point will be the position of the hole. 
        Returns true if successful.
        """
        return _fusion.HoleFeature_setPositionAtCenter(self, planarEntity, centerEdge)

    def setPositionBySketchPoint(self, sketchPoint: "SketchPoint") -> "bool":
        r"""
        Redefines the position and orienation of the hole using a sketch point.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        sketchPoint : The sketch point that defines the position of the hole. The orientation is
        inferred from the normal of the point's parent sketch. The natural direction will be 
        opposite the normal of the sketch. 
        Returns true if successful.
        """
        return _fusion.HoleFeature_setPositionBySketchPoint(self, sketchPoint)

    def setPositionBySketchPoints(self, sketchPoints: "ObjectCollection") -> "bool":
        r"""
        Redefines the position and orientation of the hole using a set of points.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        sketchPoints : A collection of sketch points that defines the positions of the holes. The orientation is
        inferred from the normal of the point's parent sketch. The natural direction will be 
        opposite the normal of the sketch. All of the points must be in the same sketch. 
        Returns true if successful.
        """
        return _fusion.HoleFeature_setPositionBySketchPoints(self, sketchPoints)

    def setPositionByPlaneAndOffsets(self, *args) -> "bool":
        r"""
        Redefines the orientation of the hole using a planar face or construction plane. 
        The position of the hole is defined by the distance from one or two edges.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        planarEntity : The planar BRepFace or ConstructionPlane object that defines the orientation of the hole.
        The natural direction of the hole will be opposite the normal of the face or construction plane. 
        point : A Point3D object that defines the approximate initial position of the hole. The point will be 
        projected onto the plane. This point should be close to the final position of the hole and 
        is used to determine which solution out of several possible solutions should be chosen 
        for the hole location. 
        edgeOne : A linear BRepEdge object that the position of the hole will be measured from. The position 
        of the hole will be measured along a perpendicular from this edge. 
        offsetOne : A ValueInput object that defines the offset distance from edgeOne. If the ValueInput uses
        a real then it is interpreted as centimeters. If it is a string then the units
        can be defined as part of the string (i.e. '3 in'). If no units are specified
        it is interpreted using the current default units for length. 
        edgeTwo : You can optionally define a second edge and offset to specify the position of the hole. If you use a
        second edge it has the same requirements as the edgeOne argument. If you provide a second edge you 
        must also provide the offsetTwo argument. 
        offsetTwo : If edgeTwo is defined, you must provide this argument which is a ValueInput object that 
        defines the offset from the edgeTwo. If the ValueInput uses a real then it is interpreted 
        as centimeters. If it is a string then the units can be defined as part of the string 
        (i.e. '3 in'). If no units are specified it is interpreted using the current default units 
        for length. 
        Returns true if successful.
        """
        return _fusion.HoleFeature_setPositionByPlaneAndOffsets(self, *args)

    def setPositionOnEdge(self, planarEntity: "Base", edge: "BRepEdge", position: "HoleEdgePositions") -> "bool":
        r"""
        Redefines the position and orientation of the hole to be on the start, end or center of an edge.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        planarEntity : The planar BRepFace or ConstructionPlane object that defines the orientation of the hole
        and start of the hole. The natural direction of the hole will be opposite the normal of 
        the face or construction plane. 
        edge : The edge to position the hole on. 
        position : The position along the edge to place the hole. 
        Returns true if successful.
        """
        return _fusion.HoleFeature_setPositionOnEdge(self, planarEntity, edge, position)

    def _get_holePositionDefinition(self) -> "adsk::core::Ptr< adsk::fusion::HolePositionDefinition >":
        r"""
        Returns a HolePositionDefinition object that provides access to the information used 
        to define the position of the hole. This returns null in the case where IsParametric 
        is false.
        """
        return _fusion.HoleFeature__get_holePositionDefinition(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::HoleFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.HoleFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::HoleFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.HoleFeature_createForAssemblyContext(self, occurrence)

    def _get_participantBodies(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepBody > > >":
        r"""
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.HoleFeature__get_participantBodies(self)

    def _set_participantBodies(self, value: "BRepBodyVector") -> "bool":
        r"""
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.HoleFeature__set_participantBodies(self, value)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.HoleFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.HoleFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.HoleFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.HoleFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.HoleFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.HoleFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.HoleFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.HoleFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.HoleFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.HoleFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.HoleFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.HoleFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.HoleFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.HoleFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.HoleFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.HoleFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.HoleFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.HoleFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.HoleFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.HoleFeature__get_isValid(self)

# Register HoleFeature in _fusion:
_fusion.HoleFeature_swigregister(HoleFeature)

def HoleFeature_classType() -> "char const *":
    return _fusion.HoleFeature_classType()


HoleFeature.position = property(HoleFeature._get_position, doc="Returns the position of the hole.")


HoleFeature.direction = property(HoleFeature._get_direction, doc="Returns the direction of the hole.")


HoleFeature.holeType = property(HoleFeature._get_holeType, doc="Returns the current type of hole this feature represents.")


HoleFeature.holeDiameter = property(HoleFeature._get_holeDiameter, doc="Returns the model parameter controlling the hole diameter. The diameter of\nthe hole can be edited through the returned parameter object.")


HoleFeature.tipAngle = property(HoleFeature._get_tipAngle, doc="Returns the model parameter controlling the angle of the tip of the hole. The tip angle of\nthe hole can be edited through the returned parameter object.")


HoleFeature.counterboreDiameter = property(HoleFeature._get_counterboreDiameter, doc="Returns the model parameter controlling the counterbore diameter.\nThis will return null in the case the hole type is not a counterbore.\nThe diameter of the counterbore can be edited through the returned parameter.")


HoleFeature.counterboreDepth = property(HoleFeature._get_counterboreDepth, doc="Returns the model parameter controlling the counterbore depth.\nThis will return null in the case the hole type is not a counterbore.\nThe depth of the counterbore can be edited through the returned parameter.")


HoleFeature.countersinkDiameter = property(HoleFeature._get_countersinkDiameter, doc="Returns the model parameter controlling the countersink diameter.\nThis will return null in the case the hole type is not a countersink.\nThe diameter of the countersink can be edited through the returned parameter.")


HoleFeature.countersinkAngle = property(HoleFeature._get_countersinkAngle, doc="Returns the model parameter controlling the countersink angle.\nThis will return null in the case the hole type is not a countersink.\nThe angle of the countersink can be edited through the returned parameter.")


HoleFeature.isDefaultDirection = property(HoleFeature._get_isDefaultDirection, HoleFeature._set_isDefaultDirection, doc="Gets and sets if the hole is in the default direction or not.")


HoleFeature.extentDefinition = property(HoleFeature._get_extentDefinition, doc="Gets the definition object that is defining the extent of the hole. Modifying the\ndefinition object will cause the hole to recompute. The extent type of a hole\nis currently limited to a distance extent.")


HoleFeature.endFaces = property(HoleFeature._get_endFaces, doc="Property that returns the faces at the bottom of the hole. This will typically be a single face\nbut could return more than one face in the case where the bottom of the hole is uneven.")


HoleFeature.sideFaces = property(HoleFeature._get_sideFaces, doc="Property that returns all of the side faces of the hole.")


HoleFeature.holePositionDefinition = property(HoleFeature._get_holePositionDefinition, doc="Returns a HolePositionDefinition object that provides access to the information used\nto define the position of the hole. This returns null in the case where IsParametric\nis false.")


HoleFeature.nativeObject = property(HoleFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


HoleFeature.participantBodies = property(HoleFeature._get_participantBodies, HoleFeature._set_participantBodies, doc="Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


HoleFeature.cast = lambda arg: arg if isinstance(arg, HoleFeature) else None

class HorizontalConstraint(GeometricConstraint):
    r"""A horizontal constraint in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::HorizontalConstraint *":
        return _fusion.HorizontalConstraint___deref__(self)

    def __eq__(self, rhs: "HorizontalConstraint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.HorizontalConstraint___eq__(self, rhs)


    def __ne__(self, rhs: "HorizontalConstraint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.HorizontalConstraint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.HorizontalConstraint_classType()
    __swig_destroy__ = _fusion.delete_HorizontalConstraint

    def _get_line(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""Returns the line being constrained."""
        return _fusion.HorizontalConstraint__get_line(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::HorizontalConstraint >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.HorizontalConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::HorizontalConstraint >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.HorizontalConstraint_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.HorizontalConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this constraint is deletable."""
        return _fusion.HorizontalConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.HorizontalConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.HorizontalConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.HorizontalConstraint__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the GeometricConstraint object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same geometric constraint.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.HorizontalConstraint__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.HorizontalConstraint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.HorizontalConstraint__get_isValid(self)

# Register HorizontalConstraint in _fusion:
_fusion.HorizontalConstraint_swigregister(HorizontalConstraint)

def HorizontalConstraint_classType() -> "char const *":
    return _fusion.HorizontalConstraint_classType()


HorizontalConstraint.line = property(HorizontalConstraint._get_line, doc="Returns the line being constrained.")


HorizontalConstraint.nativeObject = property(HorizontalConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


HorizontalConstraint.cast = lambda arg: arg if isinstance(arg, HorizontalConstraint) else None

class HorizontalPointsConstraint(GeometricConstraint):
    r"""A horizontal constraint between two points in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::HorizontalPointsConstraint *":
        return _fusion.HorizontalPointsConstraint___deref__(self)

    def __eq__(self, rhs: "HorizontalPointsConstraint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.HorizontalPointsConstraint___eq__(self, rhs)


    def __ne__(self, rhs: "HorizontalPointsConstraint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.HorizontalPointsConstraint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.HorizontalPointsConstraint_classType()
    __swig_destroy__ = _fusion.delete_HorizontalPointsConstraint

    def _get_pointOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""Returns the first point."""
        return _fusion.HorizontalPointsConstraint__get_pointOne(self)

    def _get_pointTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""Returns the second point."""
        return _fusion.HorizontalPointsConstraint__get_pointTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::HorizontalPointsConstraint >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.HorizontalPointsConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::HorizontalPointsConstraint >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.HorizontalPointsConstraint_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.HorizontalPointsConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this constraint is deletable."""
        return _fusion.HorizontalPointsConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.HorizontalPointsConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.HorizontalPointsConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.HorizontalPointsConstraint__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the GeometricConstraint object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same geometric constraint.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.HorizontalPointsConstraint__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.HorizontalPointsConstraint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.HorizontalPointsConstraint__get_isValid(self)

# Register HorizontalPointsConstraint in _fusion:
_fusion.HorizontalPointsConstraint_swigregister(HorizontalPointsConstraint)

def HorizontalPointsConstraint_classType() -> "char const *":
    return _fusion.HorizontalPointsConstraint_classType()


HorizontalPointsConstraint.pointOne = property(HorizontalPointsConstraint._get_pointOne, doc="Returns the first point.")


HorizontalPointsConstraint.pointTwo = property(HorizontalPointsConstraint._get_pointTwo, doc="Returns the second point.")


HorizontalPointsConstraint.nativeObject = property(HorizontalPointsConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


HorizontalPointsConstraint.cast = lambda arg: arg if isinstance(arg, HorizontalPointsConstraint) else None

class IGESExportOptions(ExportOptions):
    r"""Defines that an IGES export is to be done and specifies the various options."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::IGESExportOptions *":
        return _fusion.IGESExportOptions___deref__(self)

    def __eq__(self, rhs: "IGESExportOptions") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.IGESExportOptions___eq__(self, rhs)


    def __ne__(self, rhs: "IGESExportOptions") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.IGESExportOptions___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.IGESExportOptions_classType()
    __swig_destroy__ = _fusion.delete_IGESExportOptions

    def _get_filename(self) -> "std::string":
        r"""
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.IGESExportOptions__get_filename(self)

    def _set_filename(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.IGESExportOptions__set_filename(self, value)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Specifies the geometry to export. This can be an Occurrence, or the root Component. 
        For STL export, it can also be a BRepBody. For DXF export, it can be a sketch of flat pattern.
        """
        return _fusion.IGESExportOptions__get_geometry(self)

    def _set_geometry(self, value: "Base") -> "bool":
        r"""
        Specifies the geometry to export. This can be an Occurrence, or the root Component. 
        For STL export, it can also be a BRepBody. For DXF export, it can be a sketch of flat pattern.
        """
        return _fusion.IGESExportOptions__set_geometry(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.IGESExportOptions__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.IGESExportOptions__get_isValid(self)

# Register IGESExportOptions in _fusion:
_fusion.IGESExportOptions_swigregister(IGESExportOptions)

def IGESExportOptions_classType() -> "char const *":
    return _fusion.IGESExportOptions_classType()


IGESExportOptions.cast = lambda arg: arg if isinstance(arg, IGESExportOptions) else None

class LoftDirectionEndCondition(LoftEndCondition):
    r"""Represents a 'Direction' loft end condition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::LoftDirectionEndCondition *":
        return _fusion.LoftDirectionEndCondition___deref__(self)

    def __eq__(self, rhs: "LoftDirectionEndCondition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.LoftDirectionEndCondition___eq__(self, rhs)


    def __ne__(self, rhs: "LoftDirectionEndCondition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.LoftDirectionEndCondition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.LoftDirectionEndCondition_classType()
    __swig_destroy__ = _fusion.delete_LoftDirectionEndCondition

    def _get_angle(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets the valueInput or Parameter that defines the angle of the direction of the loft.
        If this object was obtained from a LoftFeatureInput object then this will return a 
        valueInput object with the initial value provided. If this object was obtained from 
        an exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the angle, 
        edit the value of the associated parameter.
        """
        return _fusion.LoftDirectionEndCondition__get_angle(self)

    def _get_weight(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets the valueInput or Parameter that defines the weight of the loft.
        If this object was obtained from a LoftFeatureInput object then this will return a 
        valueInput object with the initial value provided. If this object was obtained from 
        an exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the weight, 
        edit the value of the associated parameter.
        """
        return _fusion.LoftDirectionEndCondition__get_weight(self)

    def _get_parentLoftSection(self) -> "adsk::core::Ptr< adsk::fusion::LoftSection >":
        r"""Returns the parent loft section."""
        return _fusion.LoftDirectionEndCondition__get_parentLoftSection(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.LoftDirectionEndCondition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.LoftDirectionEndCondition__get_isValid(self)

# Register LoftDirectionEndCondition in _fusion:
_fusion.LoftDirectionEndCondition_swigregister(LoftDirectionEndCondition)

def LoftDirectionEndCondition_classType() -> "char const *":
    return _fusion.LoftDirectionEndCondition_classType()


LoftDirectionEndCondition.angle = property(LoftDirectionEndCondition._get_angle, doc="Gets the valueInput or Parameter that defines the angle of the direction of the loft.\nIf this object was obtained from a LoftFeatureInput object then this will return a\nvalueInput object with the initial value provided. If this object was obtained from\nan exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the angle,\nedit the value of the associated parameter.")


LoftDirectionEndCondition.weight = property(LoftDirectionEndCondition._get_weight, doc="Gets the valueInput or Parameter that defines the weight of the loft.\nIf this object was obtained from a LoftFeatureInput object then this will return a\nvalueInput object with the initial value provided. If this object was obtained from\nan exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the weight,\nedit the value of the associated parameter.")


LoftDirectionEndCondition.cast = lambda arg: arg if isinstance(arg, LoftDirectionEndCondition) else None

class LoftFeature(Feature):
    r"""Object that represents an existing loft feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::LoftFeature *":
        return _fusion.LoftFeature___deref__(self)

    def __eq__(self, rhs: "LoftFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.LoftFeature___eq__(self, rhs)


    def __ne__(self, rhs: "LoftFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.LoftFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.LoftFeature_classType()
    __swig_destroy__ = _fusion.delete_LoftFeature

    def _get_loftSections(self) -> "adsk::core::Ptr< adsk::fusion::LoftSections >":
        r"""
        Returns the set of sections that the loft passes through.
        This property returns null in the case where the feature is non-parametric.
        """
        return _fusion.LoftFeature__get_loftSections(self)

    def _get_centerLineOrRails(self) -> "adsk::core::Ptr< adsk::fusion::LoftCenterLineOrRails >":
        r"""
        Returns the single centerline or the set of rails that define the shape of the loft.
        This property returns null in the case where the feature is non-parametric.
        """
        return _fusion.LoftFeature__get_centerLineOrRails(self)

    def _get_startFace(self) -> "adsk::core::Ptr< adsk::fusion::BRepFace >":
        r"""
        Property that returns the face that caps the start of the loft and is coincident 
        with the first section. In the case where the loft isn't capped and there isn't
        a start face, this property will return null.
        """
        return _fusion.LoftFeature__get_startFace(self)

    def _get_endFace(self) -> "adsk::core::Ptr< adsk::fusion::BRepFace >":
        r"""
        Property that returns the face that caps the end of the loft and is coincident
        with the last section. In the case where the loft isn't capped and there isn't an end face,
        this property will return null.
        """
        return _fusion.LoftFeature__get_endFace(self)

    def _get_sideFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Property that returns all of the side faces (i.e. those running through the sections) 
        of the feature.
        """
        return _fusion.LoftFeature__get_sideFaces(self)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations":
        r"""
        Gets and sets the type of operation performed by the extrusion.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.LoftFeature__get_operation(self)

    def _set_operation(self, value: "FeatureOperations") -> "bool":
        r"""
        Gets and sets the type of operation performed by the extrusion.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.LoftFeature__set_operation(self, value)

    def _get_isSolid(self) -> "bool":
        r"""Indicates if this feature was initially created as a solid or a surface."""
        return _fusion.LoftFeature__get_isSolid(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::LoftFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.LoftFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::LoftFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.LoftFeature_createForAssemblyContext(self, occurrence)

    def _get_participantBodies(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepBody > > >":
        r"""
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.LoftFeature__get_participantBodies(self)

    def _set_participantBodies(self, value: "BRepBodyVector") -> "bool":
        r"""
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.LoftFeature__set_participantBodies(self, value)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.LoftFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.LoftFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.LoftFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.LoftFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.LoftFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.LoftFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.LoftFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.LoftFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.LoftFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.LoftFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.LoftFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.LoftFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.LoftFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.LoftFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.LoftFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.LoftFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.LoftFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.LoftFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.LoftFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.LoftFeature__get_isValid(self)

# Register LoftFeature in _fusion:
_fusion.LoftFeature_swigregister(LoftFeature)

def LoftFeature_classType() -> "char const *":
    return _fusion.LoftFeature_classType()


LoftFeature.loftSections = property(LoftFeature._get_loftSections, doc="Returns the set of sections that the loft passes through.\nThis property returns null in the case where the feature is non-parametric.")


LoftFeature.centerLineOrRails = property(LoftFeature._get_centerLineOrRails, doc="Returns the single centerline or the set of rails that define the shape of the loft.\nThis property returns null in the case where the feature is non-parametric.")


LoftFeature.startFace = property(LoftFeature._get_startFace, doc="Property that returns the face that caps the start of the loft and is coincident\nwith the first section. In the case where the loft isn't capped and there isn't\na start face, this property will return null.")


LoftFeature.endFace = property(LoftFeature._get_endFace, doc="Property that returns the face that caps the end of the loft and is coincident\nwith the last section. In the case where the loft isn't capped and there isn't an end face,\nthis property will return null.")


LoftFeature.sideFaces = property(LoftFeature._get_sideFaces, doc="Property that returns all of the side faces (i.e. those running through the sections)\nof the feature.")


LoftFeature.operation = property(LoftFeature._get_operation, LoftFeature._set_operation, doc="Gets and sets the type of operation performed by the extrusion.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


LoftFeature.isSolid = property(LoftFeature._get_isSolid, doc="Indicates if this feature was initially created as a solid or a surface.")


LoftFeature.nativeObject = property(LoftFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


LoftFeature.participantBodies = property(LoftFeature._get_participantBodies, LoftFeature._set_participantBodies, doc="Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


LoftFeature.cast = lambda arg: arg if isinstance(arg, LoftFeature) else None

class LoftFreeEndCondition(LoftEndCondition):
    r"""Represents a 'Free' loft end condition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::LoftFreeEndCondition *":
        return _fusion.LoftFreeEndCondition___deref__(self)

    def __eq__(self, rhs: "LoftFreeEndCondition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.LoftFreeEndCondition___eq__(self, rhs)


    def __ne__(self, rhs: "LoftFreeEndCondition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.LoftFreeEndCondition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.LoftFreeEndCondition_classType()
    __swig_destroy__ = _fusion.delete_LoftFreeEndCondition

    def _get_parentLoftSection(self) -> "adsk::core::Ptr< adsk::fusion::LoftSection >":
        r"""Returns the parent loft section."""
        return _fusion.LoftFreeEndCondition__get_parentLoftSection(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.LoftFreeEndCondition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.LoftFreeEndCondition__get_isValid(self)

# Register LoftFreeEndCondition in _fusion:
_fusion.LoftFreeEndCondition_swigregister(LoftFreeEndCondition)

def LoftFreeEndCondition_classType() -> "char const *":
    return _fusion.LoftFreeEndCondition_classType()


LoftFreeEndCondition.cast = lambda arg: arg if isinstance(arg, LoftFreeEndCondition) else None

class LoftPointSharpEndCondition(LoftEndCondition):
    r"""Represents a 'Point Sharp' loft end condition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::LoftPointSharpEndCondition *":
        return _fusion.LoftPointSharpEndCondition___deref__(self)

    def __eq__(self, rhs: "LoftPointSharpEndCondition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.LoftPointSharpEndCondition___eq__(self, rhs)


    def __ne__(self, rhs: "LoftPointSharpEndCondition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.LoftPointSharpEndCondition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.LoftPointSharpEndCondition_classType()
    __swig_destroy__ = _fusion.delete_LoftPointSharpEndCondition

    def _get_parentLoftSection(self) -> "adsk::core::Ptr< adsk::fusion::LoftSection >":
        r"""Returns the parent loft section."""
        return _fusion.LoftPointSharpEndCondition__get_parentLoftSection(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.LoftPointSharpEndCondition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.LoftPointSharpEndCondition__get_isValid(self)

# Register LoftPointSharpEndCondition in _fusion:
_fusion.LoftPointSharpEndCondition_swigregister(LoftPointSharpEndCondition)

def LoftPointSharpEndCondition_classType() -> "char const *":
    return _fusion.LoftPointSharpEndCondition_classType()


LoftPointSharpEndCondition.cast = lambda arg: arg if isinstance(arg, LoftPointSharpEndCondition) else None

class LoftPointTangentEndCondition(LoftEndCondition):
    r"""Represents a 'Point Tangent' loft end condition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::LoftPointTangentEndCondition *":
        return _fusion.LoftPointTangentEndCondition___deref__(self)

    def __eq__(self, rhs: "LoftPointTangentEndCondition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.LoftPointTangentEndCondition___eq__(self, rhs)


    def __ne__(self, rhs: "LoftPointTangentEndCondition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.LoftPointTangentEndCondition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.LoftPointTangentEndCondition_classType()
    __swig_destroy__ = _fusion.delete_LoftPointTangentEndCondition

    def _get_weight(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets the valueInput or Parameter that defines the weight of the loft.
        If this object was obtained from a LoftFeatureInput object then this will return a 
        valueInput object with the initial value provided. If this object was obtained from 
        an exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the weight, 
        edit the value of the associated parameter.
        """
        return _fusion.LoftPointTangentEndCondition__get_weight(self)

    def _get_parentLoftSection(self) -> "adsk::core::Ptr< adsk::fusion::LoftSection >":
        r"""Returns the parent loft section."""
        return _fusion.LoftPointTangentEndCondition__get_parentLoftSection(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.LoftPointTangentEndCondition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.LoftPointTangentEndCondition__get_isValid(self)

# Register LoftPointTangentEndCondition in _fusion:
_fusion.LoftPointTangentEndCondition_swigregister(LoftPointTangentEndCondition)

def LoftPointTangentEndCondition_classType() -> "char const *":
    return _fusion.LoftPointTangentEndCondition_classType()


LoftPointTangentEndCondition.weight = property(LoftPointTangentEndCondition._get_weight, doc="Gets the valueInput or Parameter that defines the weight of the loft.\nIf this object was obtained from a LoftFeatureInput object then this will return a\nvalueInput object with the initial value provided. If this object was obtained from\nan exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the weight,\nedit the value of the associated parameter.")


LoftPointTangentEndCondition.cast = lambda arg: arg if isinstance(arg, LoftPointTangentEndCondition) else None

class LoftSmoothEndCondition(LoftEndCondition):
    r"""Represents a 'Smooth' loft end condition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::LoftSmoothEndCondition *":
        return _fusion.LoftSmoothEndCondition___deref__(self)

    def __eq__(self, rhs: "LoftSmoothEndCondition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.LoftSmoothEndCondition___eq__(self, rhs)


    def __ne__(self, rhs: "LoftSmoothEndCondition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.LoftSmoothEndCondition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.LoftSmoothEndCondition_classType()
    __swig_destroy__ = _fusion.delete_LoftSmoothEndCondition

    def _get_weight(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets the valueInput or Parameter that defines the weight of the loft.
        If this object was obtained from a LoftFeatureInput object then this will return a 
        valueInput object with the initial value provided. If this object was obtained from 
        an exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the weight, 
        edit the value of the associated parameter.
        """
        return _fusion.LoftSmoothEndCondition__get_weight(self)

    def _get_parentLoftSection(self) -> "adsk::core::Ptr< adsk::fusion::LoftSection >":
        r"""Returns the parent loft section."""
        return _fusion.LoftSmoothEndCondition__get_parentLoftSection(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.LoftSmoothEndCondition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.LoftSmoothEndCondition__get_isValid(self)

# Register LoftSmoothEndCondition in _fusion:
_fusion.LoftSmoothEndCondition_swigregister(LoftSmoothEndCondition)

def LoftSmoothEndCondition_classType() -> "char const *":
    return _fusion.LoftSmoothEndCondition_classType()


LoftSmoothEndCondition.weight = property(LoftSmoothEndCondition._get_weight, doc="Gets the valueInput or Parameter that defines the weight of the loft.\nIf this object was obtained from a LoftFeatureInput object then this will return a\nvalueInput object with the initial value provided. If this object was obtained from\nan exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the weight,\nedit the value of the associated parameter.")


LoftSmoothEndCondition.cast = lambda arg: arg if isinstance(arg, LoftSmoothEndCondition) else None

class LoftTangentEndCondition(LoftEndCondition):
    r"""Represents a 'Tangent' loft end condition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::LoftTangentEndCondition *":
        return _fusion.LoftTangentEndCondition___deref__(self)

    def __eq__(self, rhs: "LoftTangentEndCondition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.LoftTangentEndCondition___eq__(self, rhs)


    def __ne__(self, rhs: "LoftTangentEndCondition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.LoftTangentEndCondition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.LoftTangentEndCondition_classType()
    __swig_destroy__ = _fusion.delete_LoftTangentEndCondition

    def _get_weight(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets the valueInput or Parameter that defines the weight of the loft.
        If this object was obtained from a LoftFeatureInput object then this will return a 
        valueInput object with the initial value provided. If this object was obtained from 
        an exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the weight, 
        edit the value of the associated parameter.
        """
        return _fusion.LoftTangentEndCondition__get_weight(self)

    def _get_parentLoftSection(self) -> "adsk::core::Ptr< adsk::fusion::LoftSection >":
        r"""Returns the parent loft section."""
        return _fusion.LoftTangentEndCondition__get_parentLoftSection(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.LoftTangentEndCondition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.LoftTangentEndCondition__get_isValid(self)

# Register LoftTangentEndCondition in _fusion:
_fusion.LoftTangentEndCondition_swigregister(LoftTangentEndCondition)

def LoftTangentEndCondition_classType() -> "char const *":
    return _fusion.LoftTangentEndCondition_classType()


LoftTangentEndCondition.weight = property(LoftTangentEndCondition._get_weight, doc="Gets the valueInput or Parameter that defines the weight of the loft.\nIf this object was obtained from a LoftFeatureInput object then this will return a\nvalueInput object with the initial value provided. If this object was obtained from\nan exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the weight,\nedit the value of the associated parameter.")


LoftTangentEndCondition.cast = lambda arg: arg if isinstance(arg, LoftTangentEndCondition) else None

class MidPointConstraint(GeometricConstraint):
    r"""A midpoint constraint in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::MidPointConstraint *":
        return _fusion.MidPointConstraint___deref__(self)

    def __eq__(self, rhs: "MidPointConstraint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.MidPointConstraint___eq__(self, rhs)


    def __ne__(self, rhs: "MidPointConstraint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.MidPointConstraint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.MidPointConstraint_classType()
    __swig_destroy__ = _fusion.delete_MidPointConstraint

    def _get_point(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""Returns the sketch point being constrained."""
        return _fusion.MidPointConstraint__get_point(self)

    def _get_midPointCurve(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >":
        r"""Returns the curve defining the midpoint."""
        return _fusion.MidPointConstraint__get_midPointCurve(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::MidPointConstraint >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.MidPointConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::MidPointConstraint >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.MidPointConstraint_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.MidPointConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this constraint is deletable."""
        return _fusion.MidPointConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.MidPointConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.MidPointConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.MidPointConstraint__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the GeometricConstraint object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same geometric constraint.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.MidPointConstraint__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.MidPointConstraint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.MidPointConstraint__get_isValid(self)

# Register MidPointConstraint in _fusion:
_fusion.MidPointConstraint_swigregister(MidPointConstraint)

def MidPointConstraint_classType() -> "char const *":
    return _fusion.MidPointConstraint_classType()


MidPointConstraint.point = property(MidPointConstraint._get_point, doc="Returns the sketch point being constrained.")


MidPointConstraint.midPointCurve = property(MidPointConstraint._get_midPointCurve, doc="Returns the curve defining the midpoint.")


MidPointConstraint.nativeObject = property(MidPointConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


MidPointConstraint.cast = lambda arg: arg if isinstance(arg, MidPointConstraint) else None

class MirrorFeature(Feature):
    r"""Object that represents an existing mirror feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::MirrorFeature *":
        return _fusion.MirrorFeature___deref__(self)

    def __eq__(self, rhs: "MirrorFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.MirrorFeature___eq__(self, rhs)


    def __ne__(self, rhs: "MirrorFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.MirrorFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.MirrorFeature_classType()
    __swig_destroy__ = _fusion.delete_MirrorFeature

    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the entities that are mirrored. It can contain faces, features, bodies, or components. 
        The input must all be of a single type. For example, you can't provide a body and a component but 
        the collection must be either all bodies or all components.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.MirrorFeature__get_inputEntities(self)

    def _set_inputEntities(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the entities that are mirrored. It can contain faces, features, bodies, or components. 
        The input must all be of a single type. For example, you can't provide a body and a component but 
        the collection must be either all bodies or all components.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.MirrorFeature__set_inputEntities(self, value)

    def _get_mirrorPlane(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the mirror plane. This can be either a planar face or construction plane. 
        This works only for parametric features.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.MirrorFeature__get_mirrorPlane(self)

    def _set_mirrorPlane(self, value: "Base") -> "bool":
        r"""
        Gets and sets the mirror plane. This can be either a planar face or construction plane. 
        This works only for parametric features.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.MirrorFeature__set_mirrorPlane(self, value)

    def _get_patternElements(self) -> "adsk::core::Ptr< adsk::fusion::PatternElements >":
        r"""Gets the PatternElements collection that contains the elements created by this pattern."""
        return _fusion.MirrorFeature__get_patternElements(self)

    def _get_resultFeatures(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Get the features that were created for this mirror.
        Returns null in the case where the feature is not parametric.
        """
        return _fusion.MirrorFeature__get_resultFeatures(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::MirrorFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.MirrorFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::MirrorFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.MirrorFeature_createForAssemblyContext(self, occurrence)

    def _get_patternComputeOption(self) -> "adsk::fusion::PatternComputeOptions":
        r"""
        Gets and sets the compute option for this mirror feature.
        This property only applies when mirroring features and is ignored in the direct modeling environment.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.MirrorFeature__get_patternComputeOption(self)

    def _set_patternComputeOption(self, value: "PatternComputeOptions") -> "bool":
        r"""
        Gets and sets the compute option for this mirror feature.
        This property only applies when mirroring features and is ignored in the direct modeling environment.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.MirrorFeature__set_patternComputeOption(self, value)

    def _get_isCombine(self) -> "bool":
        r"""
        Gets and sets whether combine is set when doing the Mirror.
        When true, the mirrored geometry will be Boolean unioned with the original solid or surface body(s)
        when they connect within the stitch tolerance defined with the stitchTolerance property. If the bodies
        cannot be unioned or stitched the result will be separate bodies.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.MirrorFeature__get_isCombine(self)

    def _set_isCombine(self, value: "bool") -> "bool":
        r"""
        Gets and sets whether combine is set when doing the Mirror.
        When true, the mirrored geometry will be Boolean unioned with the original solid or surface body(s)
        when they connect within the stitch tolerance defined with the stitchTolerance property. If the bodies
        cannot be unioned or stitched the result will be separate bodies.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.MirrorFeature__set_isCombine(self, value)

    def _get_stitchTolerance(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the parameter controlling the Stitch tolerance to use when stitching mirrored
        surface bodies with the original bodies. You can edit the tolerance by
        editing the value of the parameter object.
        """
        return _fusion.MirrorFeature__get_stitchTolerance(self)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.MirrorFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.MirrorFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.MirrorFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.MirrorFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.MirrorFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.MirrorFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.MirrorFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.MirrorFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.MirrorFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.MirrorFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.MirrorFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.MirrorFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.MirrorFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.MirrorFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.MirrorFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.MirrorFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.MirrorFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.MirrorFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.MirrorFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.MirrorFeature__get_isValid(self)

# Register MirrorFeature in _fusion:
_fusion.MirrorFeature_swigregister(MirrorFeature)

def MirrorFeature_classType() -> "char const *":
    return _fusion.MirrorFeature_classType()


MirrorFeature.inputEntities = property(MirrorFeature._get_inputEntities, MirrorFeature._set_inputEntities, doc="Gets and sets the entities that are mirrored. It can contain faces, features, bodies, or components.\nThe input must all be of a single type. For example, you can't provide a body and a component but\nthe collection must be either all bodies or all components.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


MirrorFeature.mirrorPlane = property(MirrorFeature._get_mirrorPlane, MirrorFeature._set_mirrorPlane, doc="Gets and sets the mirror plane. This can be either a planar face or construction plane.\nThis works only for parametric features.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


MirrorFeature.patternElements = property(MirrorFeature._get_patternElements, doc="Gets the PatternElements collection that contains the elements created by this pattern.")


MirrorFeature.resultFeatures = property(MirrorFeature._get_resultFeatures, doc="Get the features that were created for this mirror.\nReturns null in the case where the feature is not parametric.")


MirrorFeature.nativeObject = property(MirrorFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


MirrorFeature.patternComputeOption = property(MirrorFeature._get_patternComputeOption, MirrorFeature._set_patternComputeOption, doc="Gets and sets the compute option for this mirror feature.\nThis property only applies when mirroring features and is ignored in the direct modeling environment.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


MirrorFeature.isCombine = property(MirrorFeature._get_isCombine, MirrorFeature._set_isCombine, doc="Gets and sets whether combine is set when doing the Mirror.\nWhen true, the mirrored geometry will be Boolean unioned with the original solid or surface body(s)\nwhen they connect within the stitch tolerance defined with the stitchTolerance property. If the bodies\ncannot be unioned or stitched the result will be separate bodies.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


MirrorFeature.stitchTolerance = property(MirrorFeature._get_stitchTolerance, doc="Returns the parameter controlling the Stitch tolerance to use when stitching mirrored\nsurface bodies with the original bodies. You can edit the tolerance by\nediting the value of the parameter object.")


MirrorFeature.cast = lambda arg: arg if isinstance(arg, MirrorFeature) else None

class ModelParameter(Parameter):
    r"""Represents a Model Parameter."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ModelParameter *":
        return _fusion.ModelParameter___deref__(self)

    def __eq__(self, rhs: "ModelParameter") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ModelParameter___eq__(self, rhs)


    def __ne__(self, rhs: "ModelParameter") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ModelParameter___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ModelParameter_classType()
    __swig_destroy__ = _fusion.delete_ModelParameter

    def _get_modelParameters(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameters >":
        r"""Returns the Collection containing the ModelParameter."""
        return _fusion.ModelParameter__get_modelParameters(self)

    def _get_component(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the Component containing the ModelParameter."""
        return _fusion.ModelParameter__get_component(self)

    def _get_role(self) -> "std::string":
        r"""
        This property identifies what the parameter is used for. For an extrude, it 
        could be 'Depth', for a Workplane it could be 'Offset'.
        """
        return _fusion.ModelParameter__get_role(self)

    def _get_createdBy(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the object that created this parameter. For example,
        a feature, a sketch dimension, or a construction plane.
        """
        return _fusion.ModelParameter__get_createdBy(self)

    def _get_value(self) -> "double":
        r"""
        Gets and sets the real value (a double) of the parameter in database units. 
        Setting this property will set/reset the expression value for this parameter
        """
        return _fusion.ModelParameter__get_value(self)

    def _set_value(self, value: "double") -> "bool":
        r"""
        Gets and sets the real value (a double) of the parameter in database units. 
        Setting this property will set/reset the expression value for this parameter
        """
        return _fusion.ModelParameter__set_value(self, value)

    def _get_expression(self) -> "std::string":
        r"""Gets and sets the expression (ie. '22.064 mm') used to calculate the value of the parameter"""
        return _fusion.ModelParameter__get_expression(self)

    def _set_expression(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the expression (ie. '22.064 mm') used to calculate the value of the parameter"""
        return _fusion.ModelParameter__set_expression(self, value)

    def _get_name(self) -> "std::string":
        r"""
        Gets and sets the name of the parameter. Setting the name can fail if the name 
        is not unique with respect to all other parameters in the design.
        """
        return _fusion.ModelParameter__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the name of the parameter. Setting the name can fail if the name 
        is not unique with respect to all other parameters in the design.
        """
        return _fusion.ModelParameter__set_name(self, value)

    def _get_unit(self) -> "std::string":
        r"""
        The unit type associated with this parameter. An empty string is returned for parameters
        that don't have a unit type.
        """
        return _fusion.ModelParameter__get_unit(self)

    def _get_comment(self) -> "std::string":
        r"""The comment associated with this parameter"""
        return _fusion.ModelParameter__get_comment(self)

    def _set_comment(self, value: "std::string const &") -> "bool":
        r"""The comment associated with this parameter"""
        return _fusion.ModelParameter__set_comment(self, value)

    def _get_isFavorite(self) -> "bool":
        r"""
        Gets and sets whether this parameter is included in the Favorites list in the
        parameters dialog
        """
        return _fusion.ModelParameter__get_isFavorite(self)

    def _set_isFavorite(self, value: "bool") -> "bool":
        r"""
        Gets and sets whether this parameter is included in the Favorites list in the
        parameters dialog
        """
        return _fusion.ModelParameter__set_isFavorite(self, value)

    def _get_dependentParameters(self) -> "adsk::core::Ptr< adsk::fusion::ParameterList >":
        r"""
        Returns a list of parameters that are dependent on this parameter as a result
        of this parameter being referenced in their equation.
        """
        return _fusion.ModelParameter__get_dependentParameters(self)

    def _get_isDeletable(self) -> "bool":
        r"""
        Gets if this parameter can be deleted. Parameters that cannot be deleted are: Model Parameters and 
        User Parameters that have dependents.
        """
        return _fusion.ModelParameter__get_isDeletable(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.ModelParameter__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Parameter object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same parameter.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.ModelParameter__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ModelParameter__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ModelParameter__get_isValid(self)

# Register ModelParameter in _fusion:
_fusion.ModelParameter_swigregister(ModelParameter)

def ModelParameter_classType() -> "char const *":
    return _fusion.ModelParameter_classType()


ModelParameter.modelParameters = property(ModelParameter._get_modelParameters, doc="Returns the Collection containing the ModelParameter.")


ModelParameter.component = property(ModelParameter._get_component, doc="Returns the Component containing the ModelParameter.")


ModelParameter.role = property(ModelParameter._get_role, doc="This property identifies what the parameter is used for. For an extrude, it\ncould be 'Depth', for a Workplane it could be 'Offset'.")


ModelParameter.createdBy = property(ModelParameter._get_createdBy, doc="Returns the object that created this parameter. For example,\na feature, a sketch dimension, or a construction plane.")


ModelParameter.cast = lambda arg: arg if isinstance(arg, ModelParameter) else None

class MoveFeature(Feature):
    r"""Object that represents an existing move feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::MoveFeature *":
        return _fusion.MoveFeature___deref__(self)

    def __eq__(self, rhs: "MoveFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.MoveFeature___eq__(self, rhs)


    def __ne__(self, rhs: "MoveFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.MoveFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.MoveFeature_classType()
    __swig_destroy__ = _fusion.delete_MoveFeature

    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the entities to move. This is done by using an ObjectCollection
        containing the objects to move. For a parametric model, the collection can contain 
        BRepBody or BRepFace objects but not a combination of both.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.MoveFeature__get_inputEntities(self)

    def _set_inputEntities(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the entities to move. This is done by using an ObjectCollection
        containing the objects to move. For a parametric model, the collection can contain 
        BRepBody or BRepFace objects but not a combination of both.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.MoveFeature__set_inputEntities(self, value)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >":
        r"""
        Gets and sets the move transform of the input bodies.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.MoveFeature__get_transform(self)

    def _set_transform(self, value: "Matrix3D") -> "bool":
        r"""
        Gets and sets the move transform of the input bodies.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.MoveFeature__set_transform(self, value)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::MoveFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.MoveFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::MoveFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.MoveFeature_createForAssemblyContext(self, occurrence)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.MoveFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.MoveFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.MoveFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.MoveFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.MoveFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.MoveFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.MoveFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.MoveFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.MoveFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.MoveFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.MoveFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.MoveFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.MoveFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.MoveFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.MoveFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.MoveFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.MoveFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.MoveFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.MoveFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.MoveFeature__get_isValid(self)

# Register MoveFeature in _fusion:
_fusion.MoveFeature_swigregister(MoveFeature)

def MoveFeature_classType() -> "char const *":
    return _fusion.MoveFeature_classType()


MoveFeature.inputEntities = property(MoveFeature._get_inputEntities, MoveFeature._set_inputEntities, doc="Gets and sets the entities to move. This is done by using an ObjectCollection\ncontaining the objects to move. For a parametric model, the collection can contain\nBRepBody or BRepFace objects but not a combination of both.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


MoveFeature.transform = property(MoveFeature._get_transform, MoveFeature._set_transform, doc="Gets and sets the move transform of the input bodies.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


MoveFeature.nativeObject = property(MoveFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


MoveFeature.cast = lambda arg: arg if isinstance(arg, MoveFeature) else None

class MultiLineTextDefinition(SketchTextDefinition):
    r"""Defines the information for multi-line text."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::MultiLineTextDefinition *":
        return _fusion.MultiLineTextDefinition___deref__(self)

    def __eq__(self, rhs: "MultiLineTextDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.MultiLineTextDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "MultiLineTextDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.MultiLineTextDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.MultiLineTextDefinition_classType()
    __swig_destroy__ = _fusion.delete_MultiLineTextDefinition

    def _get_rectangleLines(self) -> "adsk::core::Ptr< adsk::fusion::SketchLineList >":
        r"""
        Returns the four sketch lines that define the boundary of the sketch text. By adding constraints to these lines
        you can associatively control the size, position and angle of the sketch text. If the MultiLineTextDefinition
        object is obtained from a SketchTextInput object, this property will return null because the text and it's
        associated lines have not been created yet.
        """
        return _fusion.MultiLineTextDefinition__get_rectangleLines(self)

    def _get_horizontalAlignment(self) -> "adsk::core::HorizontalAlignments":
        r"""Gets and sets the horizontal alignment of the text with respect to the text rectangle."""
        return _fusion.MultiLineTextDefinition__get_horizontalAlignment(self)

    def _set_horizontalAlignment(self, value: "HorizontalAlignments") -> "bool":
        r"""Gets and sets the horizontal alignment of the text with respect to the text rectangle."""
        return _fusion.MultiLineTextDefinition__set_horizontalAlignment(self, value)

    def _get_verticalAlignment(self) -> "adsk::core::VerticalAlignments":
        r"""Gets and sets the vertical alignment of the text with respect to the text rectangle."""
        return _fusion.MultiLineTextDefinition__get_verticalAlignment(self)

    def _set_verticalAlignment(self, value: "VerticalAlignments") -> "bool":
        r"""Gets and sets the vertical alignment of the text with respect to the text rectangle."""
        return _fusion.MultiLineTextDefinition__set_verticalAlignment(self, value)

    def rotate(self, *args) -> "bool":
        r"""
        Rotates the text box. 
        angle : The angle to rotate the text, specified in radians. 
        keyPoint : The key point the rotation is defined around. This is optional and defaults the center of the text box.
        """
        return _fusion.MultiLineTextDefinition_rotate(self, *args)

    def _get_characterSpacing(self) -> "double":
        r"""
        Gets and sets the spacing between the characters. This is an additional spacing to apply 
        that is defined as a percentage of the default spacing. A spacing of 0 indicates no
        additional spacing. A spacing of 50 indicates to use the default plus 50% of the default.
        """
        return _fusion.MultiLineTextDefinition__get_characterSpacing(self)

    def _set_characterSpacing(self, value: "double") -> "bool":
        r"""
        Gets and sets the spacing between the characters. This is an additional spacing to apply 
        that is defined as a percentage of the default spacing. A spacing of 0 indicates no
        additional spacing. A spacing of 50 indicates to use the default plus 50% of the default.
        """
        return _fusion.MultiLineTextDefinition__set_characterSpacing(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.MultiLineTextDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.MultiLineTextDefinition__get_isValid(self)

# Register MultiLineTextDefinition in _fusion:
_fusion.MultiLineTextDefinition_swigregister(MultiLineTextDefinition)

def MultiLineTextDefinition_classType() -> "char const *":
    return _fusion.MultiLineTextDefinition_classType()


MultiLineTextDefinition.rectangleLines = property(MultiLineTextDefinition._get_rectangleLines, doc="Returns the four sketch lines that define the boundary of the sketch text. By adding constraints to these lines\nyou can associatively control the size, position and angle of the sketch text. If the MultiLineTextDefinition\nobject is obtained from a SketchTextInput object, this property will return null because the text and it's\nassociated lines have not been created yet.")


MultiLineTextDefinition.horizontalAlignment = property(MultiLineTextDefinition._get_horizontalAlignment, MultiLineTextDefinition._set_horizontalAlignment, doc="Gets and sets the horizontal alignment of the text with respect to the text rectangle.")


MultiLineTextDefinition.verticalAlignment = property(MultiLineTextDefinition._get_verticalAlignment, MultiLineTextDefinition._set_verticalAlignment, doc="Gets and sets the vertical alignment of the text with respect to the text rectangle.")


MultiLineTextDefinition.characterSpacing = property(MultiLineTextDefinition._get_characterSpacing, MultiLineTextDefinition._set_characterSpacing, doc="Gets and sets the spacing between the characters. This is an additional spacing to apply\nthat is defined as a percentage of the default spacing. A spacing of 0 indicates no\nadditional spacing. A spacing of 50 indicates to use the default plus 50% of the default.")


MultiLineTextDefinition.cast = lambda arg: arg if isinstance(arg, MultiLineTextDefinition) else None

class OffsetConstraint(GeometricConstraint):
    r"""An offset constraint in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::OffsetConstraint *":
        return _fusion.OffsetConstraint___deref__(self)

    def __eq__(self, rhs: "OffsetConstraint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.OffsetConstraint___eq__(self, rhs)


    def __ne__(self, rhs: "OffsetConstraint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.OffsetConstraint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.OffsetConstraint_classType()
    __swig_destroy__ = _fusion.delete_OffsetConstraint

    def _get_parentCurves(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve >,std::allocator< adsk::core::Ptr< adsk::fusion::SketchCurve > > >":
        r"""
        Returns an array of sketch curves that are the set of parent curves.
        Nothing should be assumed about the order in how the curves are returned.
        """
        return _fusion.OffsetConstraint__get_parentCurves(self)

    def _get_childCurves(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve >,std::allocator< adsk::core::Ptr< adsk::fusion::SketchCurve > > >":
        r"""
        Returns an array of sketch curves that are the set of child curves resulting from the offset.
        Nothing should be assumed about the order in how the curves are returned.
        """
        return _fusion.OffsetConstraint__get_childCurves(self)

    def _get_distance(self) -> "double":
        r"""
        The current distance of the offset in centimeters. To change the offset you need to
        modify the value of the parameter associated with the dimension, which you can get
        using the dimension property.
        """
        return _fusion.OffsetConstraint__get_distance(self)

    def _get_dimension(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimension >":
        r"""
        Returns the dimension controlling the offset distance. This can return null in the 
        case where the dimension has been deleted. To change the offset distance you can use
        the parameter property of the returned dimension to get the parameter that controls the value and
        use properties on the parameter to change the value. This can return either a SketchOffsetCurvesDimension
        or an SketchOffsetDimension. A SketchOffsetCurvesDimension is created automatically when curves are
        offset but if it is deleted the offset can also be controlled by a SketchOffsetDimension.
        """
        return _fusion.OffsetConstraint__get_dimension(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::OffsetConstraint >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.OffsetConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::OffsetConstraint >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.OffsetConstraint_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.OffsetConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this constraint is deletable."""
        return _fusion.OffsetConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.OffsetConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.OffsetConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.OffsetConstraint__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the GeometricConstraint object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same geometric constraint.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.OffsetConstraint__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.OffsetConstraint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.OffsetConstraint__get_isValid(self)

# Register OffsetConstraint in _fusion:
_fusion.OffsetConstraint_swigregister(OffsetConstraint)

def OffsetConstraint_classType() -> "char const *":
    return _fusion.OffsetConstraint_classType()


OffsetConstraint.parentCurves = property(OffsetConstraint._get_parentCurves, doc="Returns an array of sketch curves that are the set of parent curves.\nNothing should be assumed about the order in how the curves are returned.")


OffsetConstraint.childCurves = property(OffsetConstraint._get_childCurves, doc="Returns an array of sketch curves that are the set of child curves resulting from the offset.\nNothing should be assumed about the order in how the curves are returned.")


OffsetConstraint.distance = property(OffsetConstraint._get_distance, doc="The current distance of the offset in centimeters. To change the offset you need to\nmodify the value of the parameter associated with the dimension, which you can get\nusing the dimension property.")


OffsetConstraint.dimension = property(OffsetConstraint._get_dimension, doc="Returns the dimension controlling the offset distance. This can return null in the\ncase where the dimension has been deleted. To change the offset distance you can use\nthe parameter property of the returned dimension to get the parameter that controls the value and\nuse properties on the parameter to change the value. This can return either a SketchOffsetCurvesDimension\nor an SketchOffsetDimension. A SketchOffsetCurvesDimension is created automatically when curves are\noffset but if it is deleted the offset can also be controlled by a SketchOffsetDimension.")


OffsetConstraint.nativeObject = property(OffsetConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


OffsetConstraint.cast = lambda arg: arg if isinstance(arg, OffsetConstraint) else None

class OffsetFacesFeature(Feature):
    r"""
    Object that represents an existing Offset Face feature in a design.
    Offset Face features are created in the UI using the 'Press Pull' command.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::OffsetFacesFeature *":
        return _fusion.OffsetFacesFeature___deref__(self)

    def __eq__(self, rhs: "OffsetFacesFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.OffsetFacesFeature___eq__(self, rhs)


    def __ne__(self, rhs: "OffsetFacesFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.OffsetFacesFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.OffsetFacesFeature_classType()
    __swig_destroy__ = _fusion.delete_OffsetFacesFeature

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.OffsetFacesFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.OffsetFacesFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.OffsetFacesFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.OffsetFacesFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.OffsetFacesFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.OffsetFacesFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.OffsetFacesFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.OffsetFacesFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.OffsetFacesFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.OffsetFacesFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.OffsetFacesFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.OffsetFacesFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.OffsetFacesFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.OffsetFacesFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.OffsetFacesFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.OffsetFacesFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.OffsetFacesFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.OffsetFacesFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.OffsetFacesFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.OffsetFacesFeature__get_isValid(self)

# Register OffsetFacesFeature in _fusion:
_fusion.OffsetFacesFeature_swigregister(OffsetFacesFeature)

def OffsetFacesFeature_classType() -> "char const *":
    return _fusion.OffsetFacesFeature_classType()


OffsetFacesFeature.cast = lambda arg: arg if isinstance(arg, OffsetFacesFeature) else None

class OffsetFeature(Feature):
    r"""Object that represents an existing offset feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::OffsetFeature *":
        return _fusion.OffsetFeature___deref__(self)

    def __eq__(self, rhs: "OffsetFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.OffsetFeature___eq__(self, rhs)


    def __ne__(self, rhs: "OffsetFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.OffsetFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.OffsetFeature_classType()
    __swig_destroy__ = _fusion.delete_OffsetFeature

    def setInputEntities(self, entities: "ObjectCollection", isChainSelection: "bool"=True) -> "bool":
        r"""
        Sets the faces and sheet bodies to offset.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        entities : An ObjectCollection containing the BRepFace objects to offset. Additional faces may be
        automatically used depending on the value of the isChainSelection argument.
        Input faces need not be from the same body. 
        isChainSelection : A boolean value for setting whether or not faces that are tangentially connected to 
        the input faces (if any) will also be offset. The default value is true. 
        Returns true if successful
        """
        return _fusion.OffsetFeature_setInputEntities(self, entities, isChainSelection)

    def _get_entities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the faces to be offset.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.OffsetFeature__get_entities(self)

    def _set_entities(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the faces to be offset.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.OffsetFeature__set_entities(self, value)

    def _get_isChainSelection(self) -> "bool":
        r"""Get if the faces that are tangentially connected to the input faces (if any) are also offset."""
        return _fusion.OffsetFeature__get_isChainSelection(self)

    def _get_distance(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the parameter controlling the offset distance. You can edit the distance
        by editing the value of the parameter object. A positive value specifies that the offset
        is in the same direction as the normal direction of the face.
        """
        return _fusion.OffsetFeature__get_distance(self)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations":
        r"""
        Gets the feature operation that was performed when the feature was created, 
        (either 'NewBodyFeatureOperation' or 'NewComponentFeatureOperation'.
        """
        return _fusion.OffsetFeature__get_operation(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::OffsetFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.OffsetFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::OffsetFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.OffsetFeature_createForAssemblyContext(self, occurrence)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.OffsetFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.OffsetFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.OffsetFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.OffsetFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.OffsetFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.OffsetFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.OffsetFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.OffsetFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.OffsetFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.OffsetFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.OffsetFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.OffsetFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.OffsetFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.OffsetFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.OffsetFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.OffsetFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.OffsetFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.OffsetFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.OffsetFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.OffsetFeature__get_isValid(self)

# Register OffsetFeature in _fusion:
_fusion.OffsetFeature_swigregister(OffsetFeature)

def OffsetFeature_classType() -> "char const *":
    return _fusion.OffsetFeature_classType()


OffsetFeature.entities = property(OffsetFeature._get_entities, OffsetFeature._set_entities, doc="Gets and sets the faces to be offset.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


OffsetFeature.isChainSelection = property(OffsetFeature._get_isChainSelection, doc="Get if the faces that are tangentially connected to the input faces (if any) are also offset.")


OffsetFeature.distance = property(OffsetFeature._get_distance, doc="Returns the parameter controlling the offset distance. You can edit the distance\nby editing the value of the parameter object. A positive value specifies that the offset\nis in the same direction as the normal direction of the face.")


OffsetFeature.operation = property(OffsetFeature._get_operation, doc="Gets the feature operation that was performed when the feature was created,\n(either 'NewBodyFeatureOperation' or 'NewComponentFeatureOperation'.")


OffsetFeature.nativeObject = property(OffsetFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


OffsetFeature.cast = lambda arg: arg if isinstance(arg, OffsetFeature) else None

class OffsetStartDefinition(ExtentDefinition):
    r"""
    A definition object that is used to define a feature whose start plane is defined as plane that is
    offset from the sketch plane of the profile.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::OffsetStartDefinition *":
        return _fusion.OffsetStartDefinition___deref__(self)

    def __eq__(self, rhs: "OffsetStartDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.OffsetStartDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "OffsetStartDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.OffsetStartDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.OffsetStartDefinition_classType()

    @staticmethod
    def create(offset: "ValueInput") -> "adsk::core::Ptr< adsk::core::ValueInput > const &":
        return _fusion.OffsetStartDefinition_create(offset)
    __swig_destroy__ = _fusion.delete_OffsetStartDefinition

    def _get_offset(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets the currently defined offset value. If the ProfilePlaneWithOffsetDefinition object was
        created statically and is not associated with a feature, this will return a ValueInput object.
        if the ProfilePlaneWithOffsetDefinition is associated with an existing feature, this will return
        the parameter that was created when the feature was created. To edit the offset, use properties
        on the parameter to change the value of the parameter.
        """
        return _fusion.OffsetStartDefinition__get_offset(self)

    def _get_profilePlane(self) -> "adsk::core::Ptr< adsk::core::Plane >":
        r"""Returns the geometric definition of the profile plane."""
        return _fusion.OffsetStartDefinition__get_profilePlane(self)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >":
        r"""
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.OffsetStartDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.OffsetStartDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.OffsetStartDefinition__get_isValid(self)

# Register OffsetStartDefinition in _fusion:
_fusion.OffsetStartDefinition_swigregister(OffsetStartDefinition)

def OffsetStartDefinition_classType() -> "char const *":
    return _fusion.OffsetStartDefinition_classType()

def OffsetStartDefinition_create(offset: "ValueInput") -> "adsk::core::Ptr< adsk::core::ValueInput > const &":
    return _fusion.OffsetStartDefinition_create(offset)


OffsetStartDefinition.offset = property(OffsetStartDefinition._get_offset, doc="Gets the currently defined offset value. If the ProfilePlaneWithOffsetDefinition object was\ncreated statically and is not associated with a feature, this will return a ValueInput object.\nif the ProfilePlaneWithOffsetDefinition is associated with an existing feature, this will return\nthe parameter that was created when the feature was created. To edit the offset, use properties\non the parameter to change the value of the parameter.")


OffsetStartDefinition.profilePlane = property(OffsetStartDefinition._get_profilePlane, doc="Returns the geometric definition of the profile plane.")


OffsetStartDefinition.cast = lambda arg: arg if isinstance(arg, OffsetStartDefinition) else None

class OnEdgeHolePositionDefinition(HolePositionDefinition):
    r"""
    Provides positioning information for a hole that is positioned
    on the start, end or center of an edge.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::OnEdgeHolePositionDefinition *":
        return _fusion.OnEdgeHolePositionDefinition___deref__(self)

    def __eq__(self, rhs: "OnEdgeHolePositionDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.OnEdgeHolePositionDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "OnEdgeHolePositionDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.OnEdgeHolePositionDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.OnEdgeHolePositionDefinition_classType()
    __swig_destroy__ = _fusion.delete_OnEdgeHolePositionDefinition

    def _get_planarEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the plane that defines the orientation and start of the hole."""
        return _fusion.OnEdgeHolePositionDefinition__get_planarEntity(self)

    def _get_edge(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdge >":
        r"""Returns the edge the hole is positioned on."""
        return _fusion.OnEdgeHolePositionDefinition__get_edge(self)

    def _get_position(self) -> "adsk::fusion::HoleEdgePositions":
        r"""
        Returns the position of the hole on the edge.
        The hole can be at the start, midpoint, or end of the edge.
        """
        return _fusion.OnEdgeHolePositionDefinition__get_position(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.OnEdgeHolePositionDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.OnEdgeHolePositionDefinition__get_isValid(self)

# Register OnEdgeHolePositionDefinition in _fusion:
_fusion.OnEdgeHolePositionDefinition_swigregister(OnEdgeHolePositionDefinition)

def OnEdgeHolePositionDefinition_classType() -> "char const *":
    return _fusion.OnEdgeHolePositionDefinition_classType()


OnEdgeHolePositionDefinition.planarEntity = property(OnEdgeHolePositionDefinition._get_planarEntity, doc="Returns the plane that defines the orientation and start of the hole.")


OnEdgeHolePositionDefinition.edge = property(OnEdgeHolePositionDefinition._get_edge, doc="Returns the edge the hole is positioned on.")


OnEdgeHolePositionDefinition.position = property(OnEdgeHolePositionDefinition._get_position, doc="Returns the position of the hole on the edge.\nThe hole can be at the start, midpoint, or end of the edge.")


OnEdgeHolePositionDefinition.cast = lambda arg: arg if isinstance(arg, OnEdgeHolePositionDefinition) else None

class OneSideToExtentDefinition(ExtentDefinition):
    r"""
    Defines the inputs for a OneSideToExtentDefinition object.
    This defines a feature extent that goes up to a face or construction plane in one direction.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::OneSideToExtentDefinition *":
        return _fusion.OneSideToExtentDefinition___deref__(self)

    def __eq__(self, rhs: "OneSideToExtentDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.OneSideToExtentDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "OneSideToExtentDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.OneSideToExtentDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.OneSideToExtentDefinition_classType()
    __swig_destroy__ = _fusion.delete_OneSideToExtentDefinition

    def _get_toEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the entity that defines the extent. The valid types of entities can vary depending on
        the type of feature this is being used with.
        """
        return _fusion.OneSideToExtentDefinition__get_toEntity(self)

    def _set_toEntity(self, value: "Base") -> "bool":
        r"""
        Gets and sets the entity that defines the extent. The valid types of entities can vary depending on
        the type of feature this is being used with.
        """
        return _fusion.OneSideToExtentDefinition__set_toEntity(self, value)

    def _get_matchShape(self) -> "bool":
        r"""
        Specifies if the face should be extended or use adjacent faces if necessary to define the termination 
        of the extrusion.
        When used for a revolve feature this is ignored and is always treated as true.
        """
        return _fusion.OneSideToExtentDefinition__get_matchShape(self)

    def _set_matchShape(self, value: "bool") -> "bool":
        r"""
        Specifies if the face should be extended or use adjacent faces if necessary to define the termination 
        of the extrusion.
        When used for a revolve feature this is ignored and is always treated as true.
        """
        return _fusion.OneSideToExtentDefinition__set_matchShape(self, value)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >":
        r"""
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.OneSideToExtentDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.OneSideToExtentDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.OneSideToExtentDefinition__get_isValid(self)

# Register OneSideToExtentDefinition in _fusion:
_fusion.OneSideToExtentDefinition_swigregister(OneSideToExtentDefinition)

def OneSideToExtentDefinition_classType() -> "char const *":
    return _fusion.OneSideToExtentDefinition_classType()


OneSideToExtentDefinition.toEntity = property(OneSideToExtentDefinition._get_toEntity, OneSideToExtentDefinition._set_toEntity, doc="Gets and sets the entity that defines the extent. The valid types of entities can vary depending on\nthe type of feature this is being used with.")


OneSideToExtentDefinition.matchShape = property(OneSideToExtentDefinition._get_matchShape, OneSideToExtentDefinition._set_matchShape, doc="Specifies if the face should be extended or use adjacent faces if necessary to define the termination\nof the extrusion.\nWhen used for a revolve feature this is ignored and is always treated as true.")


OneSideToExtentDefinition.cast = lambda arg: arg if isinstance(arg, OneSideToExtentDefinition) else None

class ParallelConstraint(GeometricConstraint):
    r"""A parallel constraint in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ParallelConstraint *":
        return _fusion.ParallelConstraint___deref__(self)

    def __eq__(self, rhs: "ParallelConstraint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ParallelConstraint___eq__(self, rhs)


    def __ne__(self, rhs: "ParallelConstraint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ParallelConstraint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ParallelConstraint_classType()
    __swig_destroy__ = _fusion.delete_ParallelConstraint

    def _get_lineOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""Returns the first line."""
        return _fusion.ParallelConstraint__get_lineOne(self)

    def _get_lineTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""Returns the second line."""
        return _fusion.ParallelConstraint__get_lineTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ParallelConstraint >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ParallelConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::ParallelConstraint >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ParallelConstraint_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.ParallelConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this constraint is deletable."""
        return _fusion.ParallelConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.ParallelConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ParallelConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.ParallelConstraint__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the GeometricConstraint object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same geometric constraint.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.ParallelConstraint__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ParallelConstraint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ParallelConstraint__get_isValid(self)

# Register ParallelConstraint in _fusion:
_fusion.ParallelConstraint_swigregister(ParallelConstraint)

def ParallelConstraint_classType() -> "char const *":
    return _fusion.ParallelConstraint_classType()


ParallelConstraint.lineOne = property(ParallelConstraint._get_lineOne, doc="Returns the first line.")


ParallelConstraint.lineTwo = property(ParallelConstraint._get_lineTwo, doc="Returns the second line.")


ParallelConstraint.nativeObject = property(ParallelConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


ParallelConstraint.cast = lambda arg: arg if isinstance(arg, ParallelConstraint) else None

class PatchFeature(Feature):
    r"""Object that represents an existing patch feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::PatchFeature *":
        return _fusion.PatchFeature___deref__(self)

    def __eq__(self, rhs: "PatchFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.PatchFeature___eq__(self, rhs)


    def __ne__(self, rhs: "PatchFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.PatchFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.PatchFeature_classType()
    __swig_destroy__ = _fusion.delete_PatchFeature

    def _get_boundaryCurve(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns an ObjectCollection that contains all of the sketch curves or B-Rep edges
        that define the closed outer boundary of the patch feature.
        When setting this property, the input can be a sketch profile, a single sketch curve, a single B-Rep edge, 
        or an ObjectCollection of sketch curves or B-Rep edges. 
        If a single sketch curve or B-Rep edge is input, that is not closed, Fusion 360 will automatically find connected sketch curves 
        or B-Rep edges in order to define a closed loop. All sketch curves are valid as input. BRepEdges are valid if they are 
        an 'open' edge, which means they are only used by one face.
        If an ObjectCollection of sketch curves or B-Rep edges is input they must define a closed shape and the B-Rep 
        edges must be valid 'open' edges.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.PatchFeature__get_boundaryCurve(self)

    def _set_boundaryCurve(self, value: "Base") -> "bool":
        r"""
        Returns an ObjectCollection that contains all of the sketch curves or B-Rep edges
        that define the closed outer boundary of the patch feature.
        When setting this property, the input can be a sketch profile, a single sketch curve, a single B-Rep edge, 
        or an ObjectCollection of sketch curves or B-Rep edges. 
        If a single sketch curve or B-Rep edge is input, that is not closed, Fusion 360 will automatically find connected sketch curves 
        or B-Rep edges in order to define a closed loop. All sketch curves are valid as input. BRepEdges are valid if they are 
        an 'open' edge, which means they are only used by one face.
        If an ObjectCollection of sketch curves or B-Rep edges is input they must define a closed shape and the B-Rep 
        edges must be valid 'open' edges.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.PatchFeature__set_boundaryCurve(self, value)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations":
        r"""Gets the type of operation performed by the patch feature."""
        return _fusion.PatchFeature__get_operation(self)

    def _get_continuity(self) -> "adsk::fusion::SurfaceContinuityTypes":
        r"""
        Gets and sets the type of surface continuity used when creating the patch face. This is only used when BRepEdges are input and 
        defines the continuity of how the patch face connects to the face adjacent to each of the input edges. 
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.PatchFeature__get_continuity(self)

    def _set_continuity(self, value: "SurfaceContinuityTypes") -> "bool":
        r"""
        Gets and sets the type of surface continuity used when creating the patch face. This is only used when BRepEdges are input and 
        defines the continuity of how the patch face connects to the face adjacent to each of the input edges. 
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.PatchFeature__set_continuity(self, value)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::PatchFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.PatchFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::PatchFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.PatchFeature_createForAssemblyContext(self, occurrence)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.PatchFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.PatchFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.PatchFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.PatchFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.PatchFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.PatchFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.PatchFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.PatchFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.PatchFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.PatchFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.PatchFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.PatchFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.PatchFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.PatchFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.PatchFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.PatchFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.PatchFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.PatchFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.PatchFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.PatchFeature__get_isValid(self)

# Register PatchFeature in _fusion:
_fusion.PatchFeature_swigregister(PatchFeature)

def PatchFeature_classType() -> "char const *":
    return _fusion.PatchFeature_classType()


PatchFeature.boundaryCurve = property(PatchFeature._get_boundaryCurve, PatchFeature._set_boundaryCurve, doc="Returns an ObjectCollection that contains all of the sketch curves or B-Rep edges\nthat define the closed outer boundary of the patch feature.\nWhen setting this property, the input can be a sketch profile, a single sketch curve, a single B-Rep edge,\nor an ObjectCollection of sketch curves or B-Rep edges.\nIf a single sketch curve or B-Rep edge is input, that is not closed, Fusion 360 will automatically find connected sketch curves\nor B-Rep edges in order to define a closed loop. All sketch curves are valid as input. BRepEdges are valid if they are\nan 'open' edge, which means they are only used by one face.\nIf an ObjectCollection of sketch curves or B-Rep edges is input they must define a closed shape and the B-Rep\nedges must be valid 'open' edges.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


PatchFeature.operation = property(PatchFeature._get_operation, doc="Gets the type of operation performed by the patch feature.")


PatchFeature.continuity = property(PatchFeature._get_continuity, PatchFeature._set_continuity, doc="Gets and sets the type of surface continuity used when creating the patch face. This is only used when BRepEdges are input and\ndefines the continuity of how the patch face connects to the face adjacent to each of the input edges.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


PatchFeature.nativeObject = property(PatchFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


PatchFeature.cast = lambda arg: arg if isinstance(arg, PatchFeature) else None

class PathPatternFeature(Feature):
    r"""Object that represents an existing path pattern feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::PathPatternFeature *":
        return _fusion.PathPatternFeature___deref__(self)

    def __eq__(self, rhs: "PathPatternFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.PathPatternFeature___eq__(self, rhs)


    def __ne__(self, rhs: "PathPatternFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.PathPatternFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.PathPatternFeature_classType()
    __swig_destroy__ = _fusion.delete_PathPatternFeature

    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.PathPatternFeature__get_inputEntities(self)

    def _set_inputEntities(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.PathPatternFeature__set_inputEntities(self, value)

    def _get_path(self) -> "adsk::core::Ptr< adsk::fusion::Path >":
        r"""
        Gets and sets the path to create the pattern on path.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.PathPatternFeature__get_path(self)

    def _set_path(self, value: "Path") -> "bool":
        r"""
        Gets and sets the path to create the pattern on path.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.PathPatternFeature__set_path(self, value)

    def _get_quantity(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the quantity of the elements.
        Edit the value through ModelParameter.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.PathPatternFeature__get_quantity(self)

    def _get_distance(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the distance.
        Edit the value through ModelParameter.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.PathPatternFeature__get_distance(self)

    def _get_startPoint(self) -> "double":
        r"""
        Gets and sets the start point on the path to count the distance.
        It's between 0 and 1. 0 means start point of the path, 1 means end point of the path.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.PathPatternFeature__get_startPoint(self)

    def _set_startPoint(self, value: "double") -> "bool":
        r"""
        Gets and sets the start point on the path to count the distance.
        It's between 0 and 1. 0 means start point of the path, 1 means end point of the path.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.PathPatternFeature__set_startPoint(self, value)

    def _get_isFlipDirection(self) -> "bool":
        r"""
        Gets and sets if flip the direction from start point.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.PathPatternFeature__get_isFlipDirection(self)

    def _set_isFlipDirection(self, value: "bool") -> "bool":
        r"""
        Gets and sets if flip the direction from start point.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.PathPatternFeature__set_isFlipDirection(self, value)

    def _get_patternDistanceType(self) -> "adsk::fusion::PatternDistanceType":
        r"""
        Gets and sets how the distance between elements is computed.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.PathPatternFeature__get_patternDistanceType(self)

    def _set_patternDistanceType(self, value: "PatternDistanceType") -> "bool":
        r"""
        Gets and sets how the distance between elements is computed.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.PathPatternFeature__set_patternDistanceType(self, value)

    def _get_isSymmetric(self) -> "bool":
        r"""
        Gets and sets if the pattern is in one direction or symmetric.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.PathPatternFeature__get_isSymmetric(self)

    def _set_isSymmetric(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the pattern is in one direction or symmetric.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.PathPatternFeature__set_isSymmetric(self, value)

    def _get_isOrientationAlongPath(self) -> "bool":
        r"""
        Gets and sets if the orientation is along path.
        If false, the orientation is identical.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.PathPatternFeature__get_isOrientationAlongPath(self)

    def _set_isOrientationAlongPath(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the orientation is along path.
        If false, the orientation is identical.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.PathPatternFeature__set_isOrientationAlongPath(self, value)

    def _get_suppressedElementsIds(self) -> "std::vector< size_t,std::allocator< size_t > >":
        r"""
        Gets and sets the id's of the elements to suppress.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.PathPatternFeature__get_suppressedElementsIds(self)

    def _set_suppressedElementsIds(self, value: "UintVector") -> "bool":
        r"""
        Gets and sets the id's of the elements to suppress.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.PathPatternFeature__set_suppressedElementsIds(self, value)

    def _get_patternElements(self) -> "adsk::core::Ptr< adsk::fusion::PatternElements >":
        r"""Gets the PatternElements collection that contains the elements created by this pattern."""
        return _fusion.PathPatternFeature__get_patternElements(self)

    def _get_resultFeatures(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Get the features that were created for this mirror.
        Returns null in the case where the feature is parametric.
        """
        return _fusion.PathPatternFeature__get_resultFeatures(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::PathPatternFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.PathPatternFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::PathPatternFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.PathPatternFeature_createForAssemblyContext(self, occurrence)

    def _get_patternEntityType(self) -> "adsk::fusion::PatternEntityTypes":
        r"""
        Returns the type of entities the pattern consists of. This can be used to help
        determine the type of results that will be found in the pattern elements.
        """
        return _fusion.PathPatternFeature__get_patternEntityType(self)

    def _get_patternComputeOption(self) -> "adsk::fusion::PatternComputeOptions":
        r"""
        Gets and sets the compute option for this pattern feature.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.PathPatternFeature__get_patternComputeOption(self)

    def _set_patternComputeOption(self, value: "PatternComputeOptions") -> "bool":
        r"""
        Gets and sets the compute option for this pattern feature.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.PathPatternFeature__set_patternComputeOption(self, value)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.PathPatternFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.PathPatternFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.PathPatternFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.PathPatternFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.PathPatternFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.PathPatternFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.PathPatternFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.PathPatternFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.PathPatternFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.PathPatternFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.PathPatternFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.PathPatternFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.PathPatternFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.PathPatternFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.PathPatternFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.PathPatternFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.PathPatternFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.PathPatternFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.PathPatternFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.PathPatternFeature__get_isValid(self)

# Register PathPatternFeature in _fusion:
_fusion.PathPatternFeature_swigregister(PathPatternFeature)

def PathPatternFeature_classType() -> "char const *":
    return _fusion.PathPatternFeature_classType()


PathPatternFeature.inputEntities = property(PathPatternFeature._get_inputEntities, PathPatternFeature._set_inputEntities, doc="Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.\nAll of the entities must be of a single type. For example, it can't contain features and occurrences\nbut only features or occurrences.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


PathPatternFeature.path = property(PathPatternFeature._get_path, PathPatternFeature._set_path, doc="Gets and sets the path to create the pattern on path.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


PathPatternFeature.quantity = property(PathPatternFeature._get_quantity, doc="Gets the quantity of the elements.\nEdit the value through ModelParameter.\nReturns nothing in the case where the feature is non-parametric.")


PathPatternFeature.distance = property(PathPatternFeature._get_distance, doc="Gets the distance.\nEdit the value through ModelParameter.\nReturns nothing in the case where the feature is non-parametric.")


PathPatternFeature.startPoint = property(PathPatternFeature._get_startPoint, PathPatternFeature._set_startPoint, doc="Gets and sets the start point on the path to count the distance.\nIt's between 0 and 1. 0 means start point of the path, 1 means end point of the path.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


PathPatternFeature.isFlipDirection = property(PathPatternFeature._get_isFlipDirection, PathPatternFeature._set_isFlipDirection, doc="Gets and sets if flip the direction from start point.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


PathPatternFeature.patternDistanceType = property(PathPatternFeature._get_patternDistanceType, PathPatternFeature._set_patternDistanceType, doc="Gets and sets how the distance between elements is computed.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


PathPatternFeature.isSymmetric = property(PathPatternFeature._get_isSymmetric, PathPatternFeature._set_isSymmetric, doc="Gets and sets if the pattern is in one direction or symmetric.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


PathPatternFeature.isOrientationAlongPath = property(PathPatternFeature._get_isOrientationAlongPath, PathPatternFeature._set_isOrientationAlongPath, doc="Gets and sets if the orientation is along path.\nIf false, the orientation is identical.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


PathPatternFeature.suppressedElementsIds = property(PathPatternFeature._get_suppressedElementsIds, PathPatternFeature._set_suppressedElementsIds, doc="Gets and sets the id's of the elements to suppress.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


PathPatternFeature.patternElements = property(PathPatternFeature._get_patternElements, doc="Gets the PatternElements collection that contains the elements created by this pattern.")


PathPatternFeature.resultFeatures = property(PathPatternFeature._get_resultFeatures, doc="Get the features that were created for this mirror.\nReturns null in the case where the feature is parametric.")


PathPatternFeature.nativeObject = property(PathPatternFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


PathPatternFeature.patternEntityType = property(PathPatternFeature._get_patternEntityType, doc="Returns the type of entities the pattern consists of. This can be used to help\ndetermine the type of results that will be found in the pattern elements.")


PathPatternFeature.patternComputeOption = property(PathPatternFeature._get_patternComputeOption, PathPatternFeature._set_patternComputeOption, doc="Gets and sets the compute option for this pattern feature.\nThis property only applies when patterning features and is ignored in the direct modeling environment.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


PathPatternFeature.cast = lambda arg: arg if isinstance(arg, PathPatternFeature) else None

class PerpendicularConstraint(GeometricConstraint):
    r"""A perpendicular constraint in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::PerpendicularConstraint *":
        return _fusion.PerpendicularConstraint___deref__(self)

    def __eq__(self, rhs: "PerpendicularConstraint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.PerpendicularConstraint___eq__(self, rhs)


    def __ne__(self, rhs: "PerpendicularConstraint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.PerpendicularConstraint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.PerpendicularConstraint_classType()
    __swig_destroy__ = _fusion.delete_PerpendicularConstraint

    def _get_lineOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""Returns the first line."""
        return _fusion.PerpendicularConstraint__get_lineOne(self)

    def _get_lineTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""Returns the second line."""
        return _fusion.PerpendicularConstraint__get_lineTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::PerpendicularConstraint >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.PerpendicularConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::PerpendicularConstraint >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.PerpendicularConstraint_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.PerpendicularConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this constraint is deletable."""
        return _fusion.PerpendicularConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.PerpendicularConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.PerpendicularConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.PerpendicularConstraint__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the GeometricConstraint object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same geometric constraint.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.PerpendicularConstraint__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.PerpendicularConstraint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.PerpendicularConstraint__get_isValid(self)

# Register PerpendicularConstraint in _fusion:
_fusion.PerpendicularConstraint_swigregister(PerpendicularConstraint)

def PerpendicularConstraint_classType() -> "char const *":
    return _fusion.PerpendicularConstraint_classType()


PerpendicularConstraint.lineOne = property(PerpendicularConstraint._get_lineOne, doc="Returns the first line.")


PerpendicularConstraint.lineTwo = property(PerpendicularConstraint._get_lineTwo, doc="Returns the second line.")


PerpendicularConstraint.nativeObject = property(PerpendicularConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


PerpendicularConstraint.cast = lambda arg: arg if isinstance(arg, PerpendicularConstraint) else None

class PinSlotJointMotion(JointMotion):
    r"""Represents the set of information specific to a pin slot joint."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::PinSlotJointMotion *":
        return _fusion.PinSlotJointMotion___deref__(self)

    def __eq__(self, rhs: "PinSlotJointMotion") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.PinSlotJointMotion___eq__(self, rhs)


    def __ne__(self, rhs: "PinSlotJointMotion") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.PinSlotJointMotion___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.PinSlotJointMotion_classType()
    __swig_destroy__ = _fusion.delete_PinSlotJointMotion

    def _get_rotationAxis(self) -> "adsk::fusion::JointDirections":
        r"""
        Gets and sets the direction of the axis of rotation. This can be set to
        XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
        return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customRotationAxisEntity will return an entity
        that defines the axis. If there is a custom rotation axis defined and this
        property is set to one of the three standard axes, the custom rotation will
        be removed and customRotationAxisEntity will return null.
        """
        return _fusion.PinSlotJointMotion__get_rotationAxis(self)

    def _set_rotationAxis(self, value: "JointDirections") -> "bool":
        r"""
        Gets and sets the direction of the axis of rotation. This can be set to
        XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
        return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customRotationAxisEntity will return an entity
        that defines the axis. If there is a custom rotation axis defined and this
        property is set to one of the three standard axes, the custom rotation will
        be removed and customRotationAxisEntity will return null.
        """
        return _fusion.PinSlotJointMotion__set_rotationAxis(self, value)

    def _get_rotationAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Returns the direction of the rotation axis. This property will return null in the case
        where the PinSlotJointMotion object was obtained from a JointInput object.
        """
        return _fusion.PinSlotJointMotion__get_rotationAxisVector(self)

    def _get_customRotationAxisEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        This property can be set using various types of entities that can infer an
        axis. For example, a linear edge, sketch line, planar face, and cylindrical face.
        This property is only valid in the case where the rotationAxis property returns
        CustomJointDirection. Setting this property will automatically set
        the rotationAxis property to CustomJointDirection.
        """
        return _fusion.PinSlotJointMotion__get_customRotationAxisEntity(self)

    def _set_customRotationAxisEntity(self, value: "Base") -> "bool":
        r"""
        This property can be set using various types of entities that can infer an
        axis. For example, a linear edge, sketch line, planar face, and cylindrical face.
        This property is only valid in the case where the rotationAxis property returns
        CustomJointDirection. Setting this property will automatically set
        the rotationAxis property to CustomJointDirection.
        """
        return _fusion.PinSlotJointMotion__set_customRotationAxisEntity(self, value)

    def _get_rotationValue(self) -> "double":
        r"""
        Gets and sets the rotation value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.PinSlotJointMotion__get_rotationValue(self)

    def _set_rotationValue(self, value: "double") -> "bool":
        r"""
        Gets and sets the rotation value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.PinSlotJointMotion__set_rotationValue(self, value)

    def _get_rotationLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >":
        r"""
        Returns a JointLimits object that defines the rotation limits for this joint.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.PinSlotJointMotion__get_rotationLimits(self)

    def _get_slideDirection(self) -> "adsk::fusion::JointDirections":
        r"""
        Gets and sets the direction of the slide motion in the slot. This can be set to
        XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
        return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customSlideDirectionEntity will return an entity
        that defines the direction. If there is a custom direction defined and this
        property is set to one of the three standard axes, the custom direction will
        be removed and customSlideDirectionEntity will return null.
        """
        return _fusion.PinSlotJointMotion__get_slideDirection(self)

    def _set_slideDirection(self, value: "JointDirections") -> "bool":
        r"""
        Gets and sets the direction of the slide motion in the slot. This can be set to
        XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
        return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customSlideDirectionEntity will return an entity
        that defines the direction. If there is a custom direction defined and this
        property is set to one of the three standard axes, the custom direction will
        be removed and customSlideDirectionEntity will return null.
        """
        return _fusion.PinSlotJointMotion__set_slideDirection(self, value)

    def _get_slideDirectionVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Returns the direction of the primary slide direction. This property will return null in the case
        where the PinSlotJointMotion object was obtained from a JointInput object.
        """
        return _fusion.PinSlotJointMotion__get_slideDirectionVector(self)

    def _get_customSlideDirectionEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        This property can be set using various types of entities that can infer a
        direction. For example, a linear edge, sketch line, planar face, and cylindrical face.
        This property is only valid in the case where the slideDirection property returns
        CustomJointDirection. Setting this property will automatically set
        the slideDirection property to CustomJointDirection.
        """
        return _fusion.PinSlotJointMotion__get_customSlideDirectionEntity(self)

    def _set_customSlideDirectionEntity(self, value: "Base") -> "bool":
        r"""
        This property can be set using various types of entities that can infer a
        direction. For example, a linear edge, sketch line, planar face, and cylindrical face.
        This property is only valid in the case where the slideDirection property returns
        CustomJointDirection. Setting this property will automatically set
        the slideDirection property to CustomJointDirection.
        """
        return _fusion.PinSlotJointMotion__set_customSlideDirectionEntity(self, value)

    def _get_slideValue(self) -> "double":
        r"""
        Gets and sets the slide value. This is in centimeters. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.PinSlotJointMotion__get_slideValue(self)

    def _set_slideValue(self, value: "double") -> "bool":
        r"""
        Gets and sets the slide value. This is in centimeters. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.PinSlotJointMotion__set_slideValue(self, value)

    def _get_slideLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >":
        r"""
        Returns a JointLimits object that defines the slide limits for this joint.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.PinSlotJointMotion__get_slideLimits(self)

    def _get_jointType(self) -> "adsk::fusion::JointTypes":
        r"""Returns an enum value indicating the type of joint this joint represents."""
        return _fusion.PinSlotJointMotion__get_jointType(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.PinSlotJointMotion__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.PinSlotJointMotion__get_isValid(self)

# Register PinSlotJointMotion in _fusion:
_fusion.PinSlotJointMotion_swigregister(PinSlotJointMotion)

def PinSlotJointMotion_classType() -> "char const *":
    return _fusion.PinSlotJointMotion_classType()


PinSlotJointMotion.rotationAxis = property(PinSlotJointMotion._get_rotationAxis, PinSlotJointMotion._set_rotationAxis, doc="Gets and sets the direction of the axis of rotation. This can be set to\nXAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can\nreturn those three directions and CustomJointDirection. If this returns\nCustomJointDirection then the customRotationAxisEntity will return an entity\nthat defines the axis. If there is a custom rotation axis defined and this\nproperty is set to one of the three standard axes, the custom rotation will\nbe removed and customRotationAxisEntity will return null.")


PinSlotJointMotion.rotationAxisVector = property(PinSlotJointMotion._get_rotationAxisVector, doc="Returns the direction of the rotation axis. This property will return null in the case\nwhere the PinSlotJointMotion object was obtained from a JointInput object.")


PinSlotJointMotion.customRotationAxisEntity = property(PinSlotJointMotion._get_customRotationAxisEntity, PinSlotJointMotion._set_customRotationAxisEntity, doc="This property can be set using various types of entities that can infer an\naxis. For example, a linear edge, sketch line, planar face, and cylindrical face.\nThis property is only valid in the case where the rotationAxis property returns\nCustomJointDirection. Setting this property will automatically set\nthe rotationAxis property to CustomJointDirection.")


PinSlotJointMotion.rotationValue = property(PinSlotJointMotion._get_rotationValue, PinSlotJointMotion._set_rotationValue, doc="Gets and sets the rotation value. This is in radians. Setting this value is\nthe equivalent of using the Drive Joints command.")


PinSlotJointMotion.rotationLimits = property(PinSlotJointMotion._get_rotationLimits, doc="Returns a JointLimits object that defines the rotation limits for this joint.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")


PinSlotJointMotion.slideDirection = property(PinSlotJointMotion._get_slideDirection, PinSlotJointMotion._set_slideDirection, doc="Gets and sets the direction of the slide motion in the slot. This can be set to\nXAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can\nreturn those three directions and CustomJointDirection. If this returns\nCustomJointDirection then the customSlideDirectionEntity will return an entity\nthat defines the direction. If there is a custom direction defined and this\nproperty is set to one of the three standard axes, the custom direction will\nbe removed and customSlideDirectionEntity will return null.")


PinSlotJointMotion.slideDirectionVector = property(PinSlotJointMotion._get_slideDirectionVector, doc="Returns the direction of the primary slide direction. This property will return null in the case\nwhere the PinSlotJointMotion object was obtained from a JointInput object.")


PinSlotJointMotion.customSlideDirectionEntity = property(PinSlotJointMotion._get_customSlideDirectionEntity, PinSlotJointMotion._set_customSlideDirectionEntity, doc="This property can be set using various types of entities that can infer a\ndirection. For example, a linear edge, sketch line, planar face, and cylindrical face.\nThis property is only valid in the case where the slideDirection property returns\nCustomJointDirection. Setting this property will automatically set\nthe slideDirection property to CustomJointDirection.")


PinSlotJointMotion.slideValue = property(PinSlotJointMotion._get_slideValue, PinSlotJointMotion._set_slideValue, doc="Gets and sets the slide value. This is in centimeters. Setting this value is\nthe equivalent of using the Drive Joints command.")


PinSlotJointMotion.slideLimits = property(PinSlotJointMotion._get_slideLimits, doc="Returns a JointLimits object that defines the slide limits for this joint.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")


PinSlotJointMotion.cast = lambda arg: arg if isinstance(arg, PinSlotJointMotion) else None

class PipeFeature(Feature):
    r"""Object that represents an existing pipe feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::PipeFeature *":
        return _fusion.PipeFeature___deref__(self)

    def __eq__(self, rhs: "PipeFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.PipeFeature___eq__(self, rhs)


    def __ne__(self, rhs: "PipeFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.PipeFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.PipeFeature_classType()
    __swig_destroy__ = _fusion.delete_PipeFeature

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.PipeFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.PipeFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.PipeFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.PipeFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.PipeFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.PipeFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.PipeFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.PipeFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.PipeFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.PipeFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.PipeFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.PipeFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.PipeFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.PipeFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.PipeFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.PipeFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.PipeFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.PipeFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.PipeFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.PipeFeature__get_isValid(self)

# Register PipeFeature in _fusion:
_fusion.PipeFeature_swigregister(PipeFeature)

def PipeFeature_classType() -> "char const *":
    return _fusion.PipeFeature_classType()


PipeFeature.cast = lambda arg: arg if isinstance(arg, PipeFeature) else None

class PlanarJointMotion(JointMotion):
    r"""Represents the set of information specific to a planar joint."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::PlanarJointMotion *":
        return _fusion.PlanarJointMotion___deref__(self)

    def __eq__(self, rhs: "PlanarJointMotion") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.PlanarJointMotion___eq__(self, rhs)


    def __ne__(self, rhs: "PlanarJointMotion") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.PlanarJointMotion___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.PlanarJointMotion_classType()
    __swig_destroy__ = _fusion.delete_PlanarJointMotion

    def _get_normalDirection(self) -> "adsk::fusion::JointDirections":
        r"""
        Gets and sets the direction of the normal of the single degree of rotation.
        This can be set to XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. 
        It can return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customNormalDirectionEntity will return an entity
        that defines the direction. If there is a custom direction defined and this
        property is set to one of the three standard axes, the custom direction will
        be removed and customNormalDirectionEntity will return null.
        """
        return _fusion.PlanarJointMotion__get_normalDirection(self)

    def _set_normalDirection(self, value: "JointDirections") -> "bool":
        r"""
        Gets and sets the direction of the normal of the single degree of rotation.
        This can be set to XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. 
        It can return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customNormalDirectionEntity will return an entity
        that defines the direction. If there is a custom direction defined and this
        property is set to one of the three standard axes, the custom direction will
        be removed and customNormalDirectionEntity will return null.
        """
        return _fusion.PlanarJointMotion__set_normalDirection(self, value)

    def _get_normalDirectionVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Returns the direction of the normal direction. This property will return null in the case
        where the PlanarJointMotion object was obtained from a JointInput object.
        """
        return _fusion.PlanarJointMotion__get_normalDirectionVector(self)

    def _get_customNormalDirectionEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        This property defines a custom normal direction and can be set using various types 
        of entities that can infer a direction. For example, a linear edge, sketch line, 
        planar face, and cylindrical face.This property is only valid in the case where the 
        normalDirection property returns CustomJointDirection. Setting this property will 
        automatically set the normalDirection property to CustomJointDirection.
        """
        return _fusion.PlanarJointMotion__get_customNormalDirectionEntity(self)

    def _set_customNormalDirectionEntity(self, value: "Base") -> "bool":
        r"""
        This property defines a custom normal direction and can be set using various types 
        of entities that can infer a direction. For example, a linear edge, sketch line, 
        planar face, and cylindrical face.This property is only valid in the case where the 
        normalDirection property returns CustomJointDirection. Setting this property will 
        automatically set the normalDirection property to CustomJointDirection.
        """
        return _fusion.PlanarJointMotion__set_customNormalDirectionEntity(self, value)

    def _get_primarySlideDirection(self) -> "adsk::fusion::JointDirections":
        r"""
        Gets the direction used as the primary direction for the two translational degrees of 
        freedom. The value of this property is automatically set when setting the normalDirection.
        When reading this value it can return XAxisJointDirection, YAxisJointDirection, ZAxisJointDirection,
        or CustomJointDirection. If it's CustomJointDirection then the direction the direction can be
        determined using the primarySlideDirectionVector and the entity controlling the direction can
        be get and set using the customPrimarySlideDirectionEntity.
        """
        return _fusion.PlanarJointMotion__get_primarySlideDirection(self)

    def _get_primarySlideDirectionVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Returns the direction of the primary slide direction. This property will return null in the case
        where the PlanarJointMotion object was obtained from a JointInput object.
        """
        return _fusion.PlanarJointMotion__get_primarySlideDirectionVector(self)

    def _get_customPrimarySlideDirectionEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        This property can be set using various types of entities that can infer a
        direction. For example, a linear edge, sketch line, planar face, and cylindrical face.
        When reading this property, it is only valid in the case where the primarySlideDirection property returns
        CustomJointDirection. Setting this property will automatically set the primarySlideDirection property to 
        CustomJointDirection. The entity defining the custom direction by be perpendicular to the normal direction.
        """
        return _fusion.PlanarJointMotion__get_customPrimarySlideDirectionEntity(self)

    def _set_customPrimarySlideDirectionEntity(self, value: "Base") -> "bool":
        r"""
        This property can be set using various types of entities that can infer a
        direction. For example, a linear edge, sketch line, planar face, and cylindrical face.
        When reading this property, it is only valid in the case where the primarySlideDirection property returns
        CustomJointDirection. Setting this property will automatically set the primarySlideDirection property to 
        CustomJointDirection. The entity defining the custom direction by be perpendicular to the normal direction.
        """
        return _fusion.PlanarJointMotion__set_customPrimarySlideDirectionEntity(self, value)

    def _get_secondarySlideDirectionVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Returns the direction of the secondary slide direction. This property will return null in the case
        where the PlanarJointMotion object was obtained from a JointInput object.
        """
        return _fusion.PlanarJointMotion__get_secondarySlideDirectionVector(self)

    def _get_rotationValue(self) -> "double":
        r"""
        Gets and sets the rotation value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.PlanarJointMotion__get_rotationValue(self)

    def _set_rotationValue(self, value: "double") -> "bool":
        r"""
        Gets and sets the rotation value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.PlanarJointMotion__set_rotationValue(self, value)

    def _get_rotationLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >":
        r"""
        Returns a JointLimits object that defines the limits of rotation for this joint.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.PlanarJointMotion__get_rotationLimits(self)

    def _get_primarySlideValue(self) -> "double":
        r"""
        Gets and sets the offset value in the primary direction. This is in centimeters. 
        Setting this value is the equivalent of using the Drive Joints command.
        """
        return _fusion.PlanarJointMotion__get_primarySlideValue(self)

    def _set_primarySlideValue(self, value: "double") -> "bool":
        r"""
        Gets and sets the offset value in the primary direction. This is in centimeters. 
        Setting this value is the equivalent of using the Drive Joints command.
        """
        return _fusion.PlanarJointMotion__set_primarySlideValue(self, value)

    def _get_primarySlideLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >":
        r"""
        Returns a JointLimits object that defines the limits in the primary direction for this joint.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.PlanarJointMotion__get_primarySlideLimits(self)

    def _get_secondarySlideValue(self) -> "double":
        r"""
        Gets and sets the offset value in the secondary direction. This is in centimeters. 
        Setting this value is the equivalent of using the Drive Joints command.
        """
        return _fusion.PlanarJointMotion__get_secondarySlideValue(self)

    def _set_secondarySlideValue(self, value: "double") -> "bool":
        r"""
        Gets and sets the offset value in the secondary direction. This is in centimeters. 
        Setting this value is the equivalent of using the Drive Joints command.
        """
        return _fusion.PlanarJointMotion__set_secondarySlideValue(self, value)

    def _get_secondarySlideLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >":
        r"""
        Returns a JointLimits object that defines the limits in the secondary direction for this joint.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.PlanarJointMotion__get_secondarySlideLimits(self)

    def _get_jointType(self) -> "adsk::fusion::JointTypes":
        r"""Returns an enum value indicating the type of joint this joint represents."""
        return _fusion.PlanarJointMotion__get_jointType(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.PlanarJointMotion__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.PlanarJointMotion__get_isValid(self)

# Register PlanarJointMotion in _fusion:
_fusion.PlanarJointMotion_swigregister(PlanarJointMotion)

def PlanarJointMotion_classType() -> "char const *":
    return _fusion.PlanarJointMotion_classType()


PlanarJointMotion.normalDirection = property(PlanarJointMotion._get_normalDirection, PlanarJointMotion._set_normalDirection, doc="Gets and sets the direction of the normal of the single degree of rotation.\nThis can be set to XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection.\nIt can return those three directions and CustomJointDirection. If this returns\nCustomJointDirection then the customNormalDirectionEntity will return an entity\nthat defines the direction. If there is a custom direction defined and this\nproperty is set to one of the three standard axes, the custom direction will\nbe removed and customNormalDirectionEntity will return null.")


PlanarJointMotion.normalDirectionVector = property(PlanarJointMotion._get_normalDirectionVector, doc="Returns the direction of the normal direction. This property will return null in the case\nwhere the PlanarJointMotion object was obtained from a JointInput object.")


PlanarJointMotion.customNormalDirectionEntity = property(PlanarJointMotion._get_customNormalDirectionEntity, PlanarJointMotion._set_customNormalDirectionEntity, doc="This property defines a custom normal direction and can be set using various types\nof entities that can infer a direction. For example, a linear edge, sketch line,\nplanar face, and cylindrical face.This property is only valid in the case where the\nnormalDirection property returns CustomJointDirection. Setting this property will\nautomatically set the normalDirection property to CustomJointDirection.")


PlanarJointMotion.primarySlideDirection = property(PlanarJointMotion._get_primarySlideDirection, doc="Gets the direction used as the primary direction for the two translational degrees of\nfreedom. The value of this property is automatically set when setting the normalDirection.\nWhen reading this value it can return XAxisJointDirection, YAxisJointDirection, ZAxisJointDirection,\nor CustomJointDirection. If it's CustomJointDirection then the direction the direction can be\ndetermined using the primarySlideDirectionVector and the entity controlling the direction can\nbe get and set using the customPrimarySlideDirectionEntity.")


PlanarJointMotion.primarySlideDirectionVector = property(PlanarJointMotion._get_primarySlideDirectionVector, doc="Returns the direction of the primary slide direction. This property will return null in the case\nwhere the PlanarJointMotion object was obtained from a JointInput object.")


PlanarJointMotion.customPrimarySlideDirectionEntity = property(PlanarJointMotion._get_customPrimarySlideDirectionEntity, PlanarJointMotion._set_customPrimarySlideDirectionEntity, doc="This property can be set using various types of entities that can infer a\ndirection. For example, a linear edge, sketch line, planar face, and cylindrical face.\nWhen reading this property, it is only valid in the case where the primarySlideDirection property returns\nCustomJointDirection. Setting this property will automatically set the primarySlideDirection property to\nCustomJointDirection. The entity defining the custom direction by be perpendicular to the normal direction.")


PlanarJointMotion.secondarySlideDirectionVector = property(PlanarJointMotion._get_secondarySlideDirectionVector, doc="Returns the direction of the secondary slide direction. This property will return null in the case\nwhere the PlanarJointMotion object was obtained from a JointInput object.")


PlanarJointMotion.rotationValue = property(PlanarJointMotion._get_rotationValue, PlanarJointMotion._set_rotationValue, doc="Gets and sets the rotation value. This is in radians. Setting this value is\nthe equivalent of using the Drive Joints command.")


PlanarJointMotion.rotationLimits = property(PlanarJointMotion._get_rotationLimits, doc="Returns a JointLimits object that defines the limits of rotation for this joint.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")


PlanarJointMotion.primarySlideValue = property(PlanarJointMotion._get_primarySlideValue, PlanarJointMotion._set_primarySlideValue, doc="Gets and sets the offset value in the primary direction. This is in centimeters.\nSetting this value is the equivalent of using the Drive Joints command.")


PlanarJointMotion.primarySlideLimits = property(PlanarJointMotion._get_primarySlideLimits, doc="Returns a JointLimits object that defines the limits in the primary direction for this joint.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")


PlanarJointMotion.secondarySlideValue = property(PlanarJointMotion._get_secondarySlideValue, PlanarJointMotion._set_secondarySlideValue, doc="Gets and sets the offset value in the secondary direction. This is in centimeters.\nSetting this value is the equivalent of using the Drive Joints command.")


PlanarJointMotion.secondarySlideLimits = property(PlanarJointMotion._get_secondarySlideLimits, doc="Returns a JointLimits object that defines the limits in the secondary direction for this joint.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")


PlanarJointMotion.cast = lambda arg: arg if isinstance(arg, PlanarJointMotion) else None

class PlaneAndOffsetsHolePositionDefinition(HolePositionDefinition):
    r"""
    Provides positioning information for a hole that is positioned on a plane 
    and at a distance from one or two edges.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::PlaneAndOffsetsHolePositionDefinition *":
        return _fusion.PlaneAndOffsetsHolePositionDefinition___deref__(self)

    def __eq__(self, rhs: "PlaneAndOffsetsHolePositionDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.PlaneAndOffsetsHolePositionDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "PlaneAndOffsetsHolePositionDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.PlaneAndOffsetsHolePositionDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.PlaneAndOffsetsHolePositionDefinition_classType()
    __swig_destroy__ = _fusion.delete_PlaneAndOffsetsHolePositionDefinition

    def _get_planarEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the plane that defines the orientation and start of the hole."""
        return _fusion.PlaneAndOffsetsHolePositionDefinition__get_planarEntity(self)

    def _get_edgeOne(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdge >":
        r"""
        The first of 2 edges the hole position is measured from. OffsetOne provides access to 
        the model parameter controlling the offset distance.
        """
        return _fusion.PlaneAndOffsetsHolePositionDefinition__get_edgeOne(self)

    def _get_offsetOne(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the model parameter controlling the distance from the center of the hole 
        to EdgeOne.
        """
        return _fusion.PlaneAndOffsetsHolePositionDefinition__get_offsetOne(self)

    def _get_edgeTwo(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdge >":
        r"""
        The second of two edges the hole position is measured from. OffsetTwo provides access 
        to the model parameter controlling the offset distance. This property can return null 
        in the case where only one edge is used.
        """
        return _fusion.PlaneAndOffsetsHolePositionDefinition__get_edgeTwo(self)

    def _get_offsetTwo(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the model parameter controlling the distance from the center of the hole 
        to EdgeTwo. This property returns null in the case where only one edge is used.
        """
        return _fusion.PlaneAndOffsetsHolePositionDefinition__get_offsetTwo(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.PlaneAndOffsetsHolePositionDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.PlaneAndOffsetsHolePositionDefinition__get_isValid(self)

# Register PlaneAndOffsetsHolePositionDefinition in _fusion:
_fusion.PlaneAndOffsetsHolePositionDefinition_swigregister(PlaneAndOffsetsHolePositionDefinition)

def PlaneAndOffsetsHolePositionDefinition_classType() -> "char const *":
    return _fusion.PlaneAndOffsetsHolePositionDefinition_classType()


PlaneAndOffsetsHolePositionDefinition.planarEntity = property(PlaneAndOffsetsHolePositionDefinition._get_planarEntity, doc="Returns the plane that defines the orientation and start of the hole.")


PlaneAndOffsetsHolePositionDefinition.edgeOne = property(PlaneAndOffsetsHolePositionDefinition._get_edgeOne, doc="The first of 2 edges the hole position is measured from. OffsetOne provides access to\nthe model parameter controlling the offset distance.")


PlaneAndOffsetsHolePositionDefinition.offsetOne = property(PlaneAndOffsetsHolePositionDefinition._get_offsetOne, doc="Returns the model parameter controlling the distance from the center of the hole\nto EdgeOne.")


PlaneAndOffsetsHolePositionDefinition.edgeTwo = property(PlaneAndOffsetsHolePositionDefinition._get_edgeTwo, doc="The second of two edges the hole position is measured from. OffsetTwo provides access\nto the model parameter controlling the offset distance. This property can return null\nin the case where only one edge is used.")


PlaneAndOffsetsHolePositionDefinition.offsetTwo = property(PlaneAndOffsetsHolePositionDefinition._get_offsetTwo, doc="Returns the model parameter controlling the distance from the center of the hole\nto EdgeTwo. This property returns null in the case where only one edge is used.")


PlaneAndOffsetsHolePositionDefinition.cast = lambda arg: arg if isinstance(arg, PlaneAndOffsetsHolePositionDefinition) else None

class PointHolePositionDefinition(HolePositionDefinition):
    r"""
    Provides positioning information for a hole that is positioned relative to a 3D coordinate 
    point.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::PointHolePositionDefinition *":
        return _fusion.PointHolePositionDefinition___deref__(self)

    def __eq__(self, rhs: "PointHolePositionDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.PointHolePositionDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "PointHolePositionDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.PointHolePositionDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.PointHolePositionDefinition_classType()
    __swig_destroy__ = _fusion.delete_PointHolePositionDefinition

    def _get_planarEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the plane that defines the orientation and start of the hole."""
        return _fusion.PointHolePositionDefinition__get_planarEntity(self)

    def _get_point(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""Returns the coordinates defining the position of the hole."""
        return _fusion.PointHolePositionDefinition__get_point(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.PointHolePositionDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.PointHolePositionDefinition__get_isValid(self)

# Register PointHolePositionDefinition in _fusion:
_fusion.PointHolePositionDefinition_swigregister(PointHolePositionDefinition)

def PointHolePositionDefinition_classType() -> "char const *":
    return _fusion.PointHolePositionDefinition_classType()


PointHolePositionDefinition.planarEntity = property(PointHolePositionDefinition._get_planarEntity, doc="Returns the plane that defines the orientation and start of the hole.")


PointHolePositionDefinition.point = property(PointHolePositionDefinition._get_point, doc="Returns the coordinates defining the position of the hole.")


PointHolePositionDefinition.cast = lambda arg: arg if isinstance(arg, PointHolePositionDefinition) else None

class PolygonConstraint(GeometricConstraint):
    r"""A polygon constraint in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::PolygonConstraint *":
        return _fusion.PolygonConstraint___deref__(self)

    def __eq__(self, rhs: "PolygonConstraint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.PolygonConstraint___eq__(self, rhs)


    def __ne__(self, rhs: "PolygonConstraint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.PolygonConstraint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.PolygonConstraint_classType()
    __swig_destroy__ = _fusion.delete_PolygonConstraint

    def _get_lines(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine >,std::allocator< adsk::core::Ptr< adsk::fusion::SketchLine > > >":
        r"""Returns the sketch lines that represent the polygon."""
        return _fusion.PolygonConstraint__get_lines(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.PolygonConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this constraint is deletable."""
        return _fusion.PolygonConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.PolygonConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.PolygonConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.PolygonConstraint__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the GeometricConstraint object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same geometric constraint.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.PolygonConstraint__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.PolygonConstraint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.PolygonConstraint__get_isValid(self)

# Register PolygonConstraint in _fusion:
_fusion.PolygonConstraint_swigregister(PolygonConstraint)

def PolygonConstraint_classType() -> "char const *":
    return _fusion.PolygonConstraint_classType()


PolygonConstraint.lines = property(PolygonConstraint._get_lines, doc="Returns the sketch lines that represent the polygon.")


PolygonConstraint.cast = lambda arg: arg if isinstance(arg, PolygonConstraint) else None

class ProfilePlaneStartDefinition(ExtentDefinition):
    r"""A definition object that is used to define a feature whose start plane is the sketch plane of the profile."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ProfilePlaneStartDefinition *":
        return _fusion.ProfilePlaneStartDefinition___deref__(self)

    def __eq__(self, rhs: "ProfilePlaneStartDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ProfilePlaneStartDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ProfilePlaneStartDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ProfilePlaneStartDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ProfilePlaneStartDefinition_classType()

    @staticmethod
    def create() -> "adsk::core::Ptr< adsk::fusion::ProfilePlaneStartDefinition >":
        return _fusion.ProfilePlaneStartDefinition_create()
    __swig_destroy__ = _fusion.delete_ProfilePlaneStartDefinition

    def _get_profilePlane(self) -> "adsk::core::Ptr< adsk::core::Plane >":
        r"""Returns the geometric definition of the profile plane."""
        return _fusion.ProfilePlaneStartDefinition__get_profilePlane(self)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >":
        r"""
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.ProfilePlaneStartDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ProfilePlaneStartDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ProfilePlaneStartDefinition__get_isValid(self)

# Register ProfilePlaneStartDefinition in _fusion:
_fusion.ProfilePlaneStartDefinition_swigregister(ProfilePlaneStartDefinition)

def ProfilePlaneStartDefinition_classType() -> "char const *":
    return _fusion.ProfilePlaneStartDefinition_classType()

def ProfilePlaneStartDefinition_create() -> "adsk::core::Ptr< adsk::fusion::ProfilePlaneStartDefinition >":
    return _fusion.ProfilePlaneStartDefinition_create()


ProfilePlaneStartDefinition.profilePlane = property(ProfilePlaneStartDefinition._get_profilePlane, doc="Returns the geometric definition of the profile plane.")


ProfilePlaneStartDefinition.cast = lambda arg: arg if isinstance(arg, ProfilePlaneStartDefinition) else None

class RectangularPatternConstraint(GeometricConstraint):
    r"""A rectangular pattern constraint in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RectangularPatternConstraint *":
        return _fusion.RectangularPatternConstraint___deref__(self)

    def __eq__(self, rhs: "RectangularPatternConstraint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RectangularPatternConstraint___eq__(self, rhs)


    def __ne__(self, rhs: "RectangularPatternConstraint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RectangularPatternConstraint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RectangularPatternConstraint_classType()
    __swig_destroy__ = _fusion.delete_RectangularPatternConstraint

    def deleteMe(self) -> "bool":
        r"""
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.RectangularPatternConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this constraint is deletable."""
        return _fusion.RectangularPatternConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.RectangularPatternConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.RectangularPatternConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.RectangularPatternConstraint__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the GeometricConstraint object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same geometric constraint.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.RectangularPatternConstraint__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.RectangularPatternConstraint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RectangularPatternConstraint__get_isValid(self)

# Register RectangularPatternConstraint in _fusion:
_fusion.RectangularPatternConstraint_swigregister(RectangularPatternConstraint)

def RectangularPatternConstraint_classType() -> "char const *":
    return _fusion.RectangularPatternConstraint_classType()


RectangularPatternConstraint.cast = lambda arg: arg if isinstance(arg, RectangularPatternConstraint) else None

class RectangularPatternFeature(Feature):
    r"""Object that represents an existing rectangular pattern feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RectangularPatternFeature *":
        return _fusion.RectangularPatternFeature___deref__(self)

    def __eq__(self, rhs: "RectangularPatternFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RectangularPatternFeature___eq__(self, rhs)


    def __ne__(self, rhs: "RectangularPatternFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RectangularPatternFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RectangularPatternFeature_classType()
    __swig_destroy__ = _fusion.delete_RectangularPatternFeature

    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RectangularPatternFeature__get_inputEntities(self)

    def _set_inputEntities(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RectangularPatternFeature__set_inputEntities(self, value)

    def _get_directionOneEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the first direction entity.
        This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
        If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RectangularPatternFeature__get_directionOneEntity(self)

    def _set_directionOneEntity(self, value: "Base") -> "bool":
        r"""
        Gets and sets the first direction entity.
        This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
        If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RectangularPatternFeature__set_directionOneEntity(self, value)

    def _get_directionTwoEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the second direction entity.
        This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
        If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
        This can be null when not entity has been specified to control the second direction. In this case Fusion 360 will compute a default direction which is
        90 degrees to the direction one.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RectangularPatternFeature__get_directionTwoEntity(self)

    def _set_directionTwoEntity(self, value: "Base") -> "bool":
        r"""
        Gets and sets the second direction entity.
        This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
        If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
        This can be null when not entity has been specified to control the second direction. In this case Fusion 360 will compute a default direction which is
        90 degrees to the direction one.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RectangularPatternFeature__set_directionTwoEntity(self, value)

    def _get_directionOne(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Returns a Vector3D indicating the positive direction of direction one."""
        return _fusion.RectangularPatternFeature__get_directionOne(self)

    def _get_directionTwo(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""Returns a Vector3D indicating the positive direction of direction two."""
        return _fusion.RectangularPatternFeature__get_directionTwo(self)

    def _get_quantityOne(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the number of instances in the first direction.
        Edit the value through ModelParameter.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.RectangularPatternFeature__get_quantityOne(self)

    def _get_quantityTwo(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the number of instances in the second direction.
        Edit the value through ModelParameter.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.RectangularPatternFeature__get_quantityTwo(self)

    def _get_distanceOne(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the distance in the first direction.
        Edit the value through ModelParameter.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.RectangularPatternFeature__get_distanceOne(self)

    def _get_distanceTwo(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the distance in the second direction.
        Edit the value through ModelParameter.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.RectangularPatternFeature__get_distanceTwo(self)

    def _get_isSymmetricInDirectionOne(self) -> "bool":
        r"""
        Gets and sets if the pattern in direction one is in one direction or symmetric.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RectangularPatternFeature__get_isSymmetricInDirectionOne(self)

    def _set_isSymmetricInDirectionOne(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the pattern in direction one is in one direction or symmetric.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RectangularPatternFeature__set_isSymmetricInDirectionOne(self, value)

    def _get_isSymmetricInDirectionTwo(self) -> "bool":
        r"""
        Gets and sets if the pattern in direction two is in one direction or symmetric.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RectangularPatternFeature__get_isSymmetricInDirectionTwo(self)

    def _set_isSymmetricInDirectionTwo(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the pattern in direction two is in one direction or symmetric.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RectangularPatternFeature__set_isSymmetricInDirectionTwo(self, value)

    def _get_patternDistanceType(self) -> "adsk::fusion::PatternDistanceType":
        r"""
        Gets and sets how the distance between elements is computed. Is initialized to ExtentPatternDistanceType when a new
        RectangularPatternFeatureInput has been created.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RectangularPatternFeature__get_patternDistanceType(self)

    def _set_patternDistanceType(self, value: "PatternDistanceType") -> "bool":
        r"""
        Gets and sets how the distance between elements is computed. Is initialized to ExtentPatternDistanceType when a new
        RectangularPatternFeatureInput has been created.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RectangularPatternFeature__set_patternDistanceType(self, value)

    def _get_suppressedElementsIds(self) -> "std::vector< size_t,std::allocator< size_t > >":
        r"""
        Gets and sets the ids of the patterns to suppress.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RectangularPatternFeature__get_suppressedElementsIds(self)

    def _set_suppressedElementsIds(self, value: "UintVector") -> "bool":
        r"""
        Gets and sets the ids of the patterns to suppress.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RectangularPatternFeature__set_suppressedElementsIds(self, value)

    def _get_patternElements(self) -> "adsk::core::Ptr< adsk::fusion::PatternElements >":
        r"""Gets the PatternElements collection that contains the elements created by this pattern."""
        return _fusion.RectangularPatternFeature__get_patternElements(self)

    def _get_resultFeatures(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Get the features that were created for this pattern.
        Returns null in the case where the feature is parametric.
        """
        return _fusion.RectangularPatternFeature__get_resultFeatures(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::RectangularPatternFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.RectangularPatternFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::RectangularPatternFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.RectangularPatternFeature_createForAssemblyContext(self, occurrence)

    def _get_patternEntityType(self) -> "adsk::fusion::PatternEntityTypes":
        r"""
        Returns the type of entities the pattern consists of. This can be used to help
        determine the type of results that will be found in the pattern elements.
        """
        return _fusion.RectangularPatternFeature__get_patternEntityType(self)

    def _get_patternComputeOption(self) -> "adsk::fusion::PatternComputeOptions":
        r"""
        Gets and sets the compute option for this pattern feature.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RectangularPatternFeature__get_patternComputeOption(self)

    def _set_patternComputeOption(self, value: "PatternComputeOptions") -> "bool":
        r"""
        Gets and sets the compute option for this pattern feature.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RectangularPatternFeature__set_patternComputeOption(self, value)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RectangularPatternFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RectangularPatternFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.RectangularPatternFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.RectangularPatternFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RectangularPatternFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RectangularPatternFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.RectangularPatternFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.RectangularPatternFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.RectangularPatternFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.RectangularPatternFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.RectangularPatternFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.RectangularPatternFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.RectangularPatternFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.RectangularPatternFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.RectangularPatternFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.RectangularPatternFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.RectangularPatternFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.RectangularPatternFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.RectangularPatternFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RectangularPatternFeature__get_isValid(self)

# Register RectangularPatternFeature in _fusion:
_fusion.RectangularPatternFeature_swigregister(RectangularPatternFeature)

def RectangularPatternFeature_classType() -> "char const *":
    return _fusion.RectangularPatternFeature_classType()


RectangularPatternFeature.inputEntities = property(RectangularPatternFeature._get_inputEntities, RectangularPatternFeature._set_inputEntities, doc="Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.\nAll of the entities must be of a single type. For example, it can't contain features and occurrences\nbut only features or occurrences.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


RectangularPatternFeature.directionOneEntity = property(RectangularPatternFeature._get_directionOneEntity, RectangularPatternFeature._set_directionOneEntity, doc="Gets and sets the first direction entity.\nThis can be a linear edge, construction axis, sketch line or rectangular pattern feature.\nIf a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


RectangularPatternFeature.directionTwoEntity = property(RectangularPatternFeature._get_directionTwoEntity, RectangularPatternFeature._set_directionTwoEntity, doc="Gets and sets the second direction entity.\nThis can be a linear edge, construction axis, sketch line or rectangular pattern feature.\nIf a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.\nThis can be null when not entity has been specified to control the second direction. In this case Fusion 360 will compute a default direction which is\n90 degrees to the direction one.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


RectangularPatternFeature.directionOne = property(RectangularPatternFeature._get_directionOne, doc="Returns a Vector3D indicating the positive direction of direction one.")


RectangularPatternFeature.directionTwo = property(RectangularPatternFeature._get_directionTwo, doc="Returns a Vector3D indicating the positive direction of direction two.")


RectangularPatternFeature.quantityOne = property(RectangularPatternFeature._get_quantityOne, doc="Gets the number of instances in the first direction.\nEdit the value through ModelParameter.\nReturns nothing in the case where the feature is non-parametric.")


RectangularPatternFeature.quantityTwo = property(RectangularPatternFeature._get_quantityTwo, doc="Gets the number of instances in the second direction.\nEdit the value through ModelParameter.\nReturns nothing in the case where the feature is non-parametric.")


RectangularPatternFeature.distanceOne = property(RectangularPatternFeature._get_distanceOne, doc="Gets the distance in the first direction.\nEdit the value through ModelParameter.\nReturns nothing in the case where the feature is non-parametric.")


RectangularPatternFeature.distanceTwo = property(RectangularPatternFeature._get_distanceTwo, doc="Gets the distance in the second direction.\nEdit the value through ModelParameter.\nReturns nothing in the case where the feature is non-parametric.")


RectangularPatternFeature.isSymmetricInDirectionOne = property(RectangularPatternFeature._get_isSymmetricInDirectionOne, RectangularPatternFeature._set_isSymmetricInDirectionOne, doc="Gets and sets if the pattern in direction one is in one direction or symmetric.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


RectangularPatternFeature.isSymmetricInDirectionTwo = property(RectangularPatternFeature._get_isSymmetricInDirectionTwo, RectangularPatternFeature._set_isSymmetricInDirectionTwo, doc="Gets and sets if the pattern in direction two is in one direction or symmetric.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


RectangularPatternFeature.patternDistanceType = property(RectangularPatternFeature._get_patternDistanceType, RectangularPatternFeature._set_patternDistanceType, doc="Gets and sets how the distance between elements is computed. Is initialized to ExtentPatternDistanceType when a new\nRectangularPatternFeatureInput has been created.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


RectangularPatternFeature.suppressedElementsIds = property(RectangularPatternFeature._get_suppressedElementsIds, RectangularPatternFeature._set_suppressedElementsIds, doc="Gets and sets the ids of the patterns to suppress.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


RectangularPatternFeature.patternElements = property(RectangularPatternFeature._get_patternElements, doc="Gets the PatternElements collection that contains the elements created by this pattern.")


RectangularPatternFeature.resultFeatures = property(RectangularPatternFeature._get_resultFeatures, doc="Get the features that were created for this pattern.\nReturns null in the case where the feature is parametric.")


RectangularPatternFeature.nativeObject = property(RectangularPatternFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


RectangularPatternFeature.patternEntityType = property(RectangularPatternFeature._get_patternEntityType, doc="Returns the type of entities the pattern consists of. This can be used to help\ndetermine the type of results that will be found in the pattern elements.")


RectangularPatternFeature.patternComputeOption = property(RectangularPatternFeature._get_patternComputeOption, RectangularPatternFeature._set_patternComputeOption, doc="Gets and sets the compute option for this pattern feature.\nThis property only applies when patterning features and is ignored in the direct modeling environment.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


RectangularPatternFeature.cast = lambda arg: arg if isinstance(arg, RectangularPatternFeature) else None

class RefoldFeature(Feature):
    r"""Object that represents an existing refold feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RefoldFeature *":
        return _fusion.RefoldFeature___deref__(self)

    def __eq__(self, rhs: "RefoldFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RefoldFeature___eq__(self, rhs)


    def __ne__(self, rhs: "RefoldFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RefoldFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RefoldFeature_classType()
    __swig_destroy__ = _fusion.delete_RefoldFeature

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RefoldFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RefoldFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.RefoldFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.RefoldFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RefoldFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RefoldFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.RefoldFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.RefoldFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.RefoldFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.RefoldFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.RefoldFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.RefoldFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.RefoldFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.RefoldFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.RefoldFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.RefoldFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.RefoldFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.RefoldFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.RefoldFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RefoldFeature__get_isValid(self)

# Register RefoldFeature in _fusion:
_fusion.RefoldFeature_swigregister(RefoldFeature)

def RefoldFeature_classType() -> "char const *":
    return _fusion.RefoldFeature_classType()


RefoldFeature.cast = lambda arg: arg if isinstance(arg, RefoldFeature) else None

class RemoveFeature(Feature):
    r"""Object that represents an existing Remove feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RemoveFeature *":
        return _fusion.RemoveFeature___deref__(self)

    def __eq__(self, rhs: "RemoveFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RemoveFeature___eq__(self, rhs)


    def __ne__(self, rhs: "RemoveFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RemoveFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RemoveFeature_classType()
    __swig_destroy__ = _fusion.delete_RemoveFeature

    def _get_itemToRemove(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the body or component occurrence to remove.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RemoveFeature__get_itemToRemove(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::RemoveFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.RemoveFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::RemoveFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.RemoveFeature_createForAssemblyContext(self, occurrence)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RemoveFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RemoveFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.RemoveFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.RemoveFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RemoveFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RemoveFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.RemoveFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.RemoveFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.RemoveFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.RemoveFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.RemoveFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.RemoveFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.RemoveFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.RemoveFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.RemoveFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.RemoveFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.RemoveFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.RemoveFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.RemoveFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RemoveFeature__get_isValid(self)

# Register RemoveFeature in _fusion:
_fusion.RemoveFeature_swigregister(RemoveFeature)

def RemoveFeature_classType() -> "char const *":
    return _fusion.RemoveFeature_classType()


RemoveFeature.itemToRemove = property(RemoveFeature._get_itemToRemove, doc="Gets and sets the body or component occurrence to remove.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


RemoveFeature.nativeObject = property(RemoveFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


RemoveFeature.cast = lambda arg: arg if isinstance(arg, RemoveFeature) else None

class ReplaceFaceFeature(Feature):
    r"""Object that represents an existing replace face feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ReplaceFaceFeature *":
        return _fusion.ReplaceFaceFeature___deref__(self)

    def __eq__(self, rhs: "ReplaceFaceFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ReplaceFaceFeature___eq__(self, rhs)


    def __ne__(self, rhs: "ReplaceFaceFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ReplaceFaceFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ReplaceFaceFeature_classType()
    __swig_destroy__ = _fusion.delete_ReplaceFaceFeature

    def setInputEntities(self, sourceFaces: "ObjectCollection", isTangentChain: "bool") -> "bool":
        r"""
        Method that sets faces to replace.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        sourceFaces : The collection can contain the faces from a solid and/or from features. All the faces must be on the same body. 
        isTangentChain : A boolean value for setting whether or not faces that are tangentially connected to 
        the input faces (if any) will also be included. A value of true indicates that tangent
        faces will be included. 
        Returns true if successful.
        """
        return _fusion.ReplaceFaceFeature_setInputEntities(self, sourceFaces, isTangentChain)

    def _get_targetFaces(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the entities that define the target faces. The new faces must completely intersect the part.
        The collection can contain the surface faces, surface bodies and construction planes.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ReplaceFaceFeature__get_targetFaces(self)

    def _set_targetFaces(self, value: "Base") -> "bool":
        r"""
        Gets and sets the entities that define the target faces. The new faces must completely intersect the part.
        The collection can contain the surface faces, surface bodies and construction planes.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ReplaceFaceFeature__set_targetFaces(self, value)

    def _get_isTangentChain(self) -> "bool":
        r"""
        Gets if any faces that are tangentially connected to any of 
        the input faces will also be included in setting InputEntities.
        """
        return _fusion.ReplaceFaceFeature__get_isTangentChain(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ReplaceFaceFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ReplaceFaceFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::ReplaceFaceFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ReplaceFaceFeature_createForAssemblyContext(self, occurrence)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ReplaceFaceFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ReplaceFaceFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ReplaceFaceFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.ReplaceFaceFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ReplaceFaceFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ReplaceFaceFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.ReplaceFaceFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.ReplaceFaceFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.ReplaceFaceFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.ReplaceFaceFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ReplaceFaceFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.ReplaceFaceFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.ReplaceFaceFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.ReplaceFaceFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ReplaceFaceFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.ReplaceFaceFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ReplaceFaceFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.ReplaceFaceFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ReplaceFaceFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ReplaceFaceFeature__get_isValid(self)

# Register ReplaceFaceFeature in _fusion:
_fusion.ReplaceFaceFeature_swigregister(ReplaceFaceFeature)

def ReplaceFaceFeature_classType() -> "char const *":
    return _fusion.ReplaceFaceFeature_classType()


ReplaceFaceFeature.targetFaces = property(ReplaceFaceFeature._get_targetFaces, ReplaceFaceFeature._set_targetFaces, doc="Gets and sets the entities that define the target faces. The new faces must completely intersect the part.\nThe collection can contain the surface faces, surface bodies and construction planes.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ReplaceFaceFeature.isTangentChain = property(ReplaceFaceFeature._get_isTangentChain, doc="Gets if any faces that are tangentially connected to any of\nthe input faces will also be included in setting InputEntities.")


ReplaceFaceFeature.nativeObject = property(ReplaceFaceFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


ReplaceFaceFeature.cast = lambda arg: arg if isinstance(arg, ReplaceFaceFeature) else None

class ReverseNormalFeature(Feature):
    r"""Object that represents an existing Reverse Normal feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ReverseNormalFeature *":
        return _fusion.ReverseNormalFeature___deref__(self)

    def __eq__(self, rhs: "ReverseNormalFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ReverseNormalFeature___eq__(self, rhs)


    def __ne__(self, rhs: "ReverseNormalFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ReverseNormalFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ReverseNormalFeature_classType()
    __swig_destroy__ = _fusion.delete_ReverseNormalFeature

    def _get_surfaces(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the surface bodies (open BRepBodies) whose faces normals are to be reversed. 
        All faces of the input surface bodies get reversed.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ReverseNormalFeature__get_surfaces(self)

    def _set_surfaces(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the surface bodies (open BRepBodies) whose faces normals are to be reversed. 
        All faces of the input surface bodies get reversed.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ReverseNormalFeature__set_surfaces(self, value)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ReverseNormalFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ReverseNormalFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::ReverseNormalFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.ReverseNormalFeature_createForAssemblyContext(self, occurrence)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ReverseNormalFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ReverseNormalFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ReverseNormalFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.ReverseNormalFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ReverseNormalFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ReverseNormalFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.ReverseNormalFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.ReverseNormalFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.ReverseNormalFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.ReverseNormalFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ReverseNormalFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.ReverseNormalFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.ReverseNormalFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.ReverseNormalFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ReverseNormalFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.ReverseNormalFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ReverseNormalFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.ReverseNormalFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ReverseNormalFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ReverseNormalFeature__get_isValid(self)

# Register ReverseNormalFeature in _fusion:
_fusion.ReverseNormalFeature_swigregister(ReverseNormalFeature)

def ReverseNormalFeature_classType() -> "char const *":
    return _fusion.ReverseNormalFeature_classType()


ReverseNormalFeature.surfaces = property(ReverseNormalFeature._get_surfaces, ReverseNormalFeature._set_surfaces, doc="Gets and sets the surface bodies (open BRepBodies) whose faces normals are to be reversed.\nAll faces of the input surface bodies get reversed.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ReverseNormalFeature.nativeObject = property(ReverseNormalFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


ReverseNormalFeature.cast = lambda arg: arg if isinstance(arg, ReverseNormalFeature) else None

class RevoluteJointMotion(JointMotion):
    r"""Represents the set of information specific to a revolute joint."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RevoluteJointMotion *":
        return _fusion.RevoluteJointMotion___deref__(self)

    def __eq__(self, rhs: "RevoluteJointMotion") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RevoluteJointMotion___eq__(self, rhs)


    def __ne__(self, rhs: "RevoluteJointMotion") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RevoluteJointMotion___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RevoluteJointMotion_classType()
    __swig_destroy__ = _fusion.delete_RevoluteJointMotion

    def _get_rotationAxis(self) -> "adsk::fusion::JointDirections":
        r"""
        Gets and sets the direction of the axis of rotation. This can be set to
        XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
        return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customRotationAxisEntity will return an entity
        that defines the axis. If there is a custom rotation axis defined and this
        property is set to one of the three standard axes, the custom rotation will
        be removed and customRotationAxisEntity will return null.
        """
        return _fusion.RevoluteJointMotion__get_rotationAxis(self)

    def _set_rotationAxis(self, value: "JointDirections") -> "bool":
        r"""
        Gets and sets the direction of the axis of rotation. This can be set to
        XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
        return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customRotationAxisEntity will return an entity
        that defines the axis. If there is a custom rotation axis defined and this
        property is set to one of the three standard axes, the custom rotation will
        be removed and customRotationAxisEntity will return null.
        """
        return _fusion.RevoluteJointMotion__set_rotationAxis(self, value)

    def _get_rotationAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Returns the direction of the rotation axis. This property will return null in the case
        where the RevolutionJointMotion object was obtained from a JointInput object.
        """
        return _fusion.RevoluteJointMotion__get_rotationAxisVector(self)

    def _get_customRotationAxisEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        This property can be set using various types of entities that can infer an
        axis. For example, a linear edge, sketch line, planar face, and cylindrical face.
        This property is only valid in the case where the rotationAxis property returns
        CustomJointDirection. Setting this property will automatically set
        the rotationAxis property to CustomJointDirection.
        """
        return _fusion.RevoluteJointMotion__get_customRotationAxisEntity(self)

    def _set_customRotationAxisEntity(self, value: "Base") -> "bool":
        r"""
        This property can be set using various types of entities that can infer an
        axis. For example, a linear edge, sketch line, planar face, and cylindrical face.
        This property is only valid in the case where the rotationAxis property returns
        CustomJointDirection. Setting this property will automatically set
        the rotationAxis property to CustomJointDirection.
        """
        return _fusion.RevoluteJointMotion__set_customRotationAxisEntity(self, value)

    def _get_rotationValue(self) -> "double":
        r"""
        Gets and sets the rotation value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.RevoluteJointMotion__get_rotationValue(self)

    def _set_rotationValue(self, value: "double") -> "bool":
        r"""
        Gets and sets the rotation value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.RevoluteJointMotion__set_rotationValue(self, value)

    def _get_rotationLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >":
        r"""
        Returns a JointLimits object that defines the rotation limits for this joint.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.RevoluteJointMotion__get_rotationLimits(self)

    def _get_jointType(self) -> "adsk::fusion::JointTypes":
        r"""Returns an enum value indicating the type of joint this joint represents."""
        return _fusion.RevoluteJointMotion__get_jointType(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.RevoluteJointMotion__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RevoluteJointMotion__get_isValid(self)

# Register RevoluteJointMotion in _fusion:
_fusion.RevoluteJointMotion_swigregister(RevoluteJointMotion)

def RevoluteJointMotion_classType() -> "char const *":
    return _fusion.RevoluteJointMotion_classType()


RevoluteJointMotion.rotationAxis = property(RevoluteJointMotion._get_rotationAxis, RevoluteJointMotion._set_rotationAxis, doc="Gets and sets the direction of the axis of rotation. This can be set to\nXAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can\nreturn those three directions and CustomJointDirection. If this returns\nCustomJointDirection then the customRotationAxisEntity will return an entity\nthat defines the axis. If there is a custom rotation axis defined and this\nproperty is set to one of the three standard axes, the custom rotation will\nbe removed and customRotationAxisEntity will return null.")


RevoluteJointMotion.rotationAxisVector = property(RevoluteJointMotion._get_rotationAxisVector, doc="Returns the direction of the rotation axis. This property will return null in the case\nwhere the RevolutionJointMotion object was obtained from a JointInput object.")


RevoluteJointMotion.customRotationAxisEntity = property(RevoluteJointMotion._get_customRotationAxisEntity, RevoluteJointMotion._set_customRotationAxisEntity, doc="This property can be set using various types of entities that can infer an\naxis. For example, a linear edge, sketch line, planar face, and cylindrical face.\nThis property is only valid in the case where the rotationAxis property returns\nCustomJointDirection. Setting this property will automatically set\nthe rotationAxis property to CustomJointDirection.")


RevoluteJointMotion.rotationValue = property(RevoluteJointMotion._get_rotationValue, RevoluteJointMotion._set_rotationValue, doc="Gets and sets the rotation value. This is in radians. Setting this value is\nthe equivalent of using the Drive Joints command.")


RevoluteJointMotion.rotationLimits = property(RevoluteJointMotion._get_rotationLimits, doc="Returns a JointLimits object that defines the rotation limits for this joint.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")


RevoluteJointMotion.cast = lambda arg: arg if isinstance(arg, RevoluteJointMotion) else None

class RevolveFeature(Feature):
    r"""Object that represents an existing revolve feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RevolveFeature *":
        return _fusion.RevolveFeature___deref__(self)

    def __eq__(self, rhs: "RevolveFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RevolveFeature___eq__(self, rhs)


    def __ne__(self, rhs: "RevolveFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RevolveFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RevolveFeature_classType()
    __swig_destroy__ = _fusion.delete_RevolveFeature

    def _get_profile(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the profiles or planar faces used to define the shape of the revolve.
        This property can return or be set with a single Profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        When setting this property of a surface (non-solid) extrusion, you can use the 
        createOpenProfile and createBRepEdgeProfile methods of the Component object to create
        an open profile.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        This property returns null in the case where the feature is non-parametric.
        """
        return _fusion.RevolveFeature__get_profile(self)

    def _set_profile(self, value: "Base") -> "bool":
        r"""
        Gets and sets the profiles or planar faces used to define the shape of the revolve.
        This property can return or be set with a single Profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        When setting this property of a surface (non-solid) extrusion, you can use the 
        createOpenProfile and createBRepEdgeProfile methods of the Component object to create
        an open profile.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        This property returns null in the case where the feature is non-parametric.
        """
        return _fusion.RevolveFeature__set_profile(self, value)

    def _get_axis(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the entity used to define the axis of revolution.
        The axis can be a sketch line, construction axis, or linear edge. If it is not in
        the same plane as the profile, it is projected onto the profile plane.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RevolveFeature__get_axis(self)

    def _set_axis(self, value: "Base") -> "bool":
        r"""
        Gets and sets the entity used to define the axis of revolution.
        The axis can be a sketch line, construction axis, or linear edge. If it is not in
        the same plane as the profile, it is projected onto the profile plane.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RevolveFeature__set_axis(self, value)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations":
        r"""
        Gets and sets the type of operation performed by the revolve.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RevolveFeature__get_operation(self)

    def _set_operation(self, value: "FeatureOperations") -> "bool":
        r"""
        Gets and sets the type of operation performed by the revolve.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RevolveFeature__set_operation(self, value)

    def _get_extentDefinition(self) -> "adsk::core::Ptr< adsk::fusion::ExtentDefinition >":
        r"""
        Gets the definition object that is defining the extent of the revolve. Modifying the
        definition object will cause the revolve to recompute. Various types of objects can
        be returned depending on the type of extent currently defined for the revolve.
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.RevolveFeature__get_extentDefinition(self)

    def setAngleExtent(self, isSymmetric: "bool", angle: "ValueInput") -> "bool":
        r"""
        Defines the extent of the revolution to be at a defined angle.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        isSymmetric : Boolean that specifies if the extent is symmetric or not. 
        angle : ValueInput object that defines the angle. This can be a string or a value. If
        it's a string it is interpreted using the current document units and can include
        equations. For example all of the following are valid as long as they result in
        angle units; '45', '45 deg', 'a1 / 2'. If a value is input it is interpreted
        as radians.
        If isSymmetric is false a positive or negative angle can be
        used to control the direction. If isSymmetric is true, the angle is the extent in one
        direction so the entire angle of the revolution will be twice the specified angle. 
        Use an angle of 360 deg or 2 pi radians to create a full revolve. 
        Returns true if successful
        """
        return _fusion.RevolveFeature_setAngleExtent(self, isSymmetric, angle)

    def setTwoSideAngleExtent(self, angleOne: "ValueInput", angleTwo: "ValueInput") -> "bool":
        r"""
        Changes the extent of the revolve to be defined as a two sided angle extent.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        angleOne : ValueInput object that defines the first angle. This can be a string or a value. If
        it's a string it is interpreted using the current document units and can include
        equations. For example all of the following are valid as long as they result in
        angle units; '45', '45 deg', 'a1 / 2'. If a value is input it is interpreted
        as radians. 
        angleTwo : ValueInput object that defines the second angle. This can be a string or a value. If
        it's a string it is interpreted using the current document units and can include
        equations. For example all of the following are valid as long as they result in
        angle units; '45', '45 deg', 'a1 / 2'. If a value is input it is interpreted
        as radians. 
        Returns true if successful
        """
        return _fusion.RevolveFeature_setTwoSideAngleExtent(self, angleOne, angleTwo)

    def setOneSideToExtent(self, *args) -> "bool":
        r"""
        Changes the extent of the revolve to be from the sketch plane to the specified 'to' face.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        toEntity : The entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For a revolve it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        directionHint : Specifies the direction of the revolve. 
        Returns true if successful.
        """
        return _fusion.RevolveFeature_setOneSideToExtent(self, *args)

    def setTwoSidesToExtent(self, toEntityOne: "Base", toEntityTwo: "Base") -> "bool":
        r"""
        Changes the extent of the revolve to be defined as a two sided to extent.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        toEntityOne : The first entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For a revolve it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        toEntityTwo : The second entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For a revolve it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        Returns true if successful
        """
        return _fusion.RevolveFeature_setTwoSidesToExtent(self, toEntityOne, toEntityTwo)

    def _get_startFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Property that returns the set of faces that cap one end of the revolve and are coincident 
        with the sketch plane. In the case of a symmetric revolve these faces are the ones on the 
        positive normal side of the sketch plane. In the case where there aren't any start faces,
        this property will return null.
        """
        return _fusion.RevolveFeature__get_startFaces(self)

    def _get_endFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Property that returns the set of faces that cap the end of the revolve opposite the
        start faces. In the case where there aren't any start faces, this property will return null.
        """
        return _fusion.RevolveFeature__get_endFaces(self)

    def _get_sideFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""Property that returns all of the faces created around the perimeter of the feature."""
        return _fusion.RevolveFeature__get_sideFaces(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::RevolveFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.RevolveFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::RevolveFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.RevolveFeature_createForAssemblyContext(self, occurrence)

    def _get_isSolid(self) -> "bool":
        r"""Indicates if this feature was initially created as a solid or a surface."""
        return _fusion.RevolveFeature__get_isSolid(self)

    def _get_participantBodies(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepBody > > >":
        r"""
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RevolveFeature__get_participantBodies(self)

    def _set_participantBodies(self, value: "BRepBodyVector") -> "bool":
        r"""
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.RevolveFeature__set_participantBodies(self, value)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RevolveFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RevolveFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.RevolveFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.RevolveFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RevolveFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RevolveFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.RevolveFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.RevolveFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.RevolveFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.RevolveFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.RevolveFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.RevolveFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.RevolveFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.RevolveFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.RevolveFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.RevolveFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.RevolveFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.RevolveFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.RevolveFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RevolveFeature__get_isValid(self)

# Register RevolveFeature in _fusion:
_fusion.RevolveFeature_swigregister(RevolveFeature)

def RevolveFeature_classType() -> "char const *":
    return _fusion.RevolveFeature_classType()


RevolveFeature.profile = property(RevolveFeature._get_profile, RevolveFeature._set_profile, doc="Gets and sets the profiles or planar faces used to define the shape of the revolve.\nThis property can return or be set with a single Profile, a single planar face, or\nan ObjectCollection consisting of multiple profiles and planar faces. When an\nObjectCollection is used all of the profiles and faces must be co-planar.\nWhen setting this property of a surface (non-solid) extrusion, you can use the\ncreateOpenProfile and createBRepEdgeProfile methods of the Component object to create\nan open profile.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)\nThis property returns null in the case where the feature is non-parametric.")


RevolveFeature.axis = property(RevolveFeature._get_axis, RevolveFeature._set_axis, doc="Gets and sets the entity used to define the axis of revolution.\nThe axis can be a sketch line, construction axis, or linear edge. If it is not in\nthe same plane as the profile, it is projected onto the profile plane.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


RevolveFeature.operation = property(RevolveFeature._get_operation, RevolveFeature._set_operation, doc="Gets and sets the type of operation performed by the revolve.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


RevolveFeature.extentDefinition = property(RevolveFeature._get_extentDefinition, doc="Gets the definition object that is defining the extent of the revolve. Modifying the\ndefinition object will cause the revolve to recompute. Various types of objects can\nbe returned depending on the type of extent currently defined for the revolve.\nThis property returns nothing in the case where the feature is non-parametric.")


RevolveFeature.startFaces = property(RevolveFeature._get_startFaces, doc="Property that returns the set of faces that cap one end of the revolve and are coincident\nwith the sketch plane. In the case of a symmetric revolve these faces are the ones on the\npositive normal side of the sketch plane. In the case where there aren't any start faces,\nthis property will return null.")


RevolveFeature.endFaces = property(RevolveFeature._get_endFaces, doc="Property that returns the set of faces that cap the end of the revolve opposite the\nstart faces. In the case where there aren't any start faces, this property will return null.")


RevolveFeature.sideFaces = property(RevolveFeature._get_sideFaces, doc="Property that returns all of the faces created around the perimeter of the feature.")


RevolveFeature.nativeObject = property(RevolveFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


RevolveFeature.isSolid = property(RevolveFeature._get_isSolid, doc="Indicates if this feature was initially created as a solid or a surface.")


RevolveFeature.participantBodies = property(RevolveFeature._get_participantBodies, RevolveFeature._set_participantBodies, doc="Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


RevolveFeature.cast = lambda arg: arg if isinstance(arg, RevolveFeature) else None

class RibFeature(Feature):
    r"""Object that represents an existing Rib feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RibFeature *":
        return _fusion.RibFeature___deref__(self)

    def __eq__(self, rhs: "RibFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RibFeature___eq__(self, rhs)


    def __ne__(self, rhs: "RibFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RibFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RibFeature_classType()
    __swig_destroy__ = _fusion.delete_RibFeature

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RibFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RibFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.RibFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.RibFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RibFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RibFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.RibFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.RibFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.RibFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.RibFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.RibFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.RibFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.RibFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.RibFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.RibFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.RibFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.RibFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.RibFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.RibFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RibFeature__get_isValid(self)

# Register RibFeature in _fusion:
_fusion.RibFeature_swigregister(RibFeature)

def RibFeature_classType() -> "char const *":
    return _fusion.RibFeature_classType()


RibFeature.cast = lambda arg: arg if isinstance(arg, RibFeature) else None

class RigidJointMotion(JointMotion):
    r"""
    Represents the set of information specific to a rigid joint. A 
    rigid joint doesn't support any additional information beyond
    getting the joint type which it derives from JointMotion.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RigidJointMotion *":
        return _fusion.RigidJointMotion___deref__(self)

    def __eq__(self, rhs: "RigidJointMotion") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RigidJointMotion___eq__(self, rhs)


    def __ne__(self, rhs: "RigidJointMotion") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RigidJointMotion___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RigidJointMotion_classType()
    __swig_destroy__ = _fusion.delete_RigidJointMotion

    def _get_jointType(self) -> "adsk::fusion::JointTypes":
        r"""Returns an enum value indicating the type of joint this joint represents."""
        return _fusion.RigidJointMotion__get_jointType(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.RigidJointMotion__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RigidJointMotion__get_isValid(self)

# Register RigidJointMotion in _fusion:
_fusion.RigidJointMotion_swigregister(RigidJointMotion)

def RigidJointMotion_classType() -> "char const *":
    return _fusion.RigidJointMotion_classType()


RigidJointMotion.cast = lambda arg: arg if isinstance(arg, RigidJointMotion) else None

class RuledSurfaceFeature(Feature):
    r"""Object that represents an existing RuledSurface feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RuledSurfaceFeature *":
        return _fusion.RuledSurfaceFeature___deref__(self)

    def __eq__(self, rhs: "RuledSurfaceFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RuledSurfaceFeature___eq__(self, rhs)


    def __ne__(self, rhs: "RuledSurfaceFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RuledSurfaceFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RuledSurfaceFeature_classType()
    __swig_destroy__ = _fusion.delete_RuledSurfaceFeature

    def _get_profile(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the Profile object that defines the sketch geometry or edges that define the shape of 
        the ruled surface. The Component.createBRepEdgeProfile method is useful to create a profile defined from edges.
        In many cases the RuledSurface operation results in the profile being consumed so it is no longer available 
        after the feature is created. In this case, you need to reposition the timeline marker to just before this feature,
        when the profile still exists.
        """
        return _fusion.RuledSurfaceFeature__get_profile(self)

    def _set_profile(self, value: "Base") -> "bool":
        r"""
        Gets and sets the Profile object that defines the sketch geometry or edges that define the shape of 
        the ruled surface. The Component.createBRepEdgeProfile method is useful to create a profile defined from edges.
        In many cases the RuledSurface operation results in the profile being consumed so it is no longer available 
        after the feature is created. In this case, you need to reposition the timeline marker to just before this feature,
        when the profile still exists.
        """
        return _fusion.RuledSurfaceFeature__set_profile(self, value)

    def _get_distance(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the parameter controlling the Ruled Surface distance. You can edit the distance
        by editing the value of the parameter object.
        """
        return _fusion.RuledSurfaceFeature__get_distance(self)

    def _get_angle(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the parameter controlling the Ruled Surface angle. You can edit the angle
        by editing the value of the parameter object.
        """
        return _fusion.RuledSurfaceFeature__get_angle(self)

    def _get_ruledSurfaceType(self) -> "adsk::fusion::RuledSurfaceTypes":
        r"""
        Gets and sets the type of ruled surface. To set this to DirectionRuledSurfaceType,
        use the direction property to set the direction entity, which will automatically set
        this to DirectionRuledSurfaceType.
        """
        return _fusion.RuledSurfaceFeature__get_ruledSurfaceType(self)

    def _set_ruledSurfaceType(self, value: "RuledSurfaceTypes") -> "bool":
        r"""
        Gets and sets the type of ruled surface. To set this to DirectionRuledSurfaceType,
        use the direction property to set the direction entity, which will automatically set
        this to DirectionRuledSurfaceType.
        """
        return _fusion.RuledSurfaceFeature__set_ruledSurfaceType(self, value)

    def _get_direction(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the entity that defines the direction when the ruled surface type is DirectionRuledSurfaceType.
        The direction is specified by providing a linear or planar entity. For example, a linear edge, construction axis, 
        planar face, or construction plane can be used as input.
        If this property is set when the ruledSurfaceType is not DirectionRuledSurfaceType, the type will automatically be
        changed to DirectionRuledSurfaceType. If you get this property when the direction is not DirectionRuledSurfaceType,
        it will return null.
        """
        return _fusion.RuledSurfaceFeature__get_direction(self)

    def _set_direction(self, value: "Base") -> "bool":
        r"""
        Gets and sets the entity that defines the direction when the ruled surface type is DirectionRuledSurfaceType.
        The direction is specified by providing a linear or planar entity. For example, a linear edge, construction axis, 
        planar face, or construction plane can be used as input.
        If this property is set when the ruledSurfaceType is not DirectionRuledSurfaceType, the type will automatically be
        changed to DirectionRuledSurfaceType. If you get this property when the direction is not DirectionRuledSurfaceType,
        it will return null.
        """
        return _fusion.RuledSurfaceFeature__set_direction(self, value)

    def _get_alternateFace(self) -> "bool":
        r"""
        Gets and sets if the other face is used for creation of the Ruled Surface.
        When creating a ruled surface using the edges of a solid or the interior edges
        of a surface the angle of the ruled surface is measured with respect to the
        face the selected edge is bounding. For a solid, or an interior edge on a surface,
        the edge connects to two faces. This setting toggles which of the two faces will
        be used for measuring the angle.
        """
        return _fusion.RuledSurfaceFeature__get_alternateFace(self)

    def _set_alternateFace(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the other face is used for creation of the Ruled Surface.
        When creating a ruled surface using the edges of a solid or the interior edges
        of a surface the angle of the ruled surface is measured with respect to the
        face the selected edge is bounding. For a solid, or an interior edge on a surface,
        the edge connects to two faces. This setting toggles which of the two faces will
        be used for measuring the angle.
        """
        return _fusion.RuledSurfaceFeature__set_alternateFace(self, value)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::RuledSurfaceFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.RuledSurfaceFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::RuledSurfaceFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.RuledSurfaceFeature_createForAssemblyContext(self, occurrence)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RuledSurfaceFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RuledSurfaceFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.RuledSurfaceFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.RuledSurfaceFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RuledSurfaceFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RuledSurfaceFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.RuledSurfaceFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.RuledSurfaceFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.RuledSurfaceFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.RuledSurfaceFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.RuledSurfaceFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.RuledSurfaceFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.RuledSurfaceFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.RuledSurfaceFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.RuledSurfaceFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.RuledSurfaceFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.RuledSurfaceFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.RuledSurfaceFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.RuledSurfaceFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RuledSurfaceFeature__get_isValid(self)

# Register RuledSurfaceFeature in _fusion:
_fusion.RuledSurfaceFeature_swigregister(RuledSurfaceFeature)

def RuledSurfaceFeature_classType() -> "char const *":
    return _fusion.RuledSurfaceFeature_classType()


RuledSurfaceFeature.profile = property(RuledSurfaceFeature._get_profile, RuledSurfaceFeature._set_profile, doc="Gets and sets the Profile object that defines the sketch geometry or edges that define the shape of\nthe ruled surface. The Component.createBRepEdgeProfile method is useful to create a profile defined from edges.\nIn many cases the RuledSurface operation results in the profile being consumed so it is no longer available\nafter the feature is created. In this case, you need to reposition the timeline marker to just before this feature,\nwhen the profile still exists.")


RuledSurfaceFeature.distance = property(RuledSurfaceFeature._get_distance, doc="Returns the parameter controlling the Ruled Surface distance. You can edit the distance\nby editing the value of the parameter object.")


RuledSurfaceFeature.angle = property(RuledSurfaceFeature._get_angle, doc="Returns the parameter controlling the Ruled Surface angle. You can edit the angle\nby editing the value of the parameter object.")


RuledSurfaceFeature.ruledSurfaceType = property(RuledSurfaceFeature._get_ruledSurfaceType, RuledSurfaceFeature._set_ruledSurfaceType, doc="Gets and sets the type of ruled surface. To set this to DirectionRuledSurfaceType,\nuse the direction property to set the direction entity, which will automatically set\nthis to DirectionRuledSurfaceType.")


RuledSurfaceFeature.direction = property(RuledSurfaceFeature._get_direction, RuledSurfaceFeature._set_direction, doc="Gets and sets the entity that defines the direction when the ruled surface type is DirectionRuledSurfaceType.\nThe direction is specified by providing a linear or planar entity. For example, a linear edge, construction axis,\nplanar face, or construction plane can be used as input.\nIf this property is set when the ruledSurfaceType is not DirectionRuledSurfaceType, the type will automatically be\nchanged to DirectionRuledSurfaceType. If you get this property when the direction is not DirectionRuledSurfaceType,\nit will return null.")


RuledSurfaceFeature.alternateFace = property(RuledSurfaceFeature._get_alternateFace, RuledSurfaceFeature._set_alternateFace, doc="Gets and sets if the other face is used for creation of the Ruled Surface.\nWhen creating a ruled surface using the edges of a solid or the interior edges\nof a surface the angle of the ruled surface is measured with respect to the\nface the selected edge is bounding. For a solid, or an interior edge on a surface,\nthe edge connects to two faces. This setting toggles which of the two faces will\nbe used for measuring the angle.")


RuledSurfaceFeature.nativeObject = property(RuledSurfaceFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


RuledSurfaceFeature.cast = lambda arg: arg if isinstance(arg, RuledSurfaceFeature) else None

class RuleFilletFeature(Feature):
    r"""Object that represents an existing rule fillet feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::RuleFilletFeature *":
        return _fusion.RuleFilletFeature___deref__(self)

    def __eq__(self, rhs: "RuleFilletFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.RuleFilletFeature___eq__(self, rhs)


    def __ne__(self, rhs: "RuleFilletFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.RuleFilletFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.RuleFilletFeature_classType()
    __swig_destroy__ = _fusion.delete_RuleFilletFeature

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RuleFilletFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RuleFilletFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.RuleFilletFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.RuleFilletFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RuleFilletFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RuleFilletFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.RuleFilletFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.RuleFilletFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.RuleFilletFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.RuleFilletFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.RuleFilletFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.RuleFilletFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.RuleFilletFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.RuleFilletFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.RuleFilletFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.RuleFilletFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.RuleFilletFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.RuleFilletFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.RuleFilletFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.RuleFilletFeature__get_isValid(self)

# Register RuleFilletFeature in _fusion:
_fusion.RuleFilletFeature_swigregister(RuleFilletFeature)

def RuleFilletFeature_classType() -> "char const *":
    return _fusion.RuleFilletFeature_classType()


RuleFilletFeature.cast = lambda arg: arg if isinstance(arg, RuleFilletFeature) else None

class SATExportOptions(ExportOptions):
    r"""Defines that a SAT export is to be done and specifies the various options."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SATExportOptions *":
        return _fusion.SATExportOptions___deref__(self)

    def __eq__(self, rhs: "SATExportOptions") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SATExportOptions___eq__(self, rhs)


    def __ne__(self, rhs: "SATExportOptions") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SATExportOptions___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SATExportOptions_classType()
    __swig_destroy__ = _fusion.delete_SATExportOptions

    def _get_filename(self) -> "std::string":
        r"""
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.SATExportOptions__get_filename(self)

    def _set_filename(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.SATExportOptions__set_filename(self, value)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Specifies the geometry to export. This can be an Occurrence, or the root Component. 
        For STL export, it can also be a BRepBody. For DXF export, it can be a sketch of flat pattern.
        """
        return _fusion.SATExportOptions__get_geometry(self)

    def _set_geometry(self, value: "Base") -> "bool":
        r"""
        Specifies the geometry to export. This can be an Occurrence, or the root Component. 
        For STL export, it can also be a BRepBody. For DXF export, it can be a sketch of flat pattern.
        """
        return _fusion.SATExportOptions__set_geometry(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.SATExportOptions__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SATExportOptions__get_isValid(self)

# Register SATExportOptions in _fusion:
_fusion.SATExportOptions_swigregister(SATExportOptions)

def SATExportOptions_classType() -> "char const *":
    return _fusion.SATExportOptions_classType()


SATExportOptions.cast = lambda arg: arg if isinstance(arg, SATExportOptions) else None

class ScaleFeature(Feature):
    r"""Object that represents an existing scale feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ScaleFeature *":
        return _fusion.ScaleFeature___deref__(self)

    def __eq__(self, rhs: "ScaleFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ScaleFeature___eq__(self, rhs)


    def __ne__(self, rhs: "ScaleFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ScaleFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ScaleFeature_classType()
    __swig_destroy__ = _fusion.delete_ScaleFeature

    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the input entities.
        This collection can contain sketches, BRep bodies and T-Spline bodies in parametric modeling.
        It can contain sketches, BRep bodies, T-Spline bodies, mesh bodies, root component and occurrences in non-parametric modeling.
        If the scaling is non-uniform (the isUniform property is false), this collection cannot contain sketches or components.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ScaleFeature__get_inputEntities(self)

    def _set_inputEntities(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the input entities.
        This collection can contain sketches, BRep bodies and T-Spline bodies in parametric modeling.
        It can contain sketches, BRep bodies, T-Spline bodies, mesh bodies, root component and occurrences in non-parametric modeling.
        If the scaling is non-uniform (the isUniform property is false), this collection cannot contain sketches or components.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ScaleFeature__set_inputEntities(self, value)

    def _get_point(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the point as reference to scale. This can be a BRepVertex, a SketchPoint or a ConstructionPoint.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ScaleFeature__get_point(self)

    def _set_point(self, value: "Base") -> "bool":
        r"""
        Gets and sets the point as reference to scale. This can be a BRepVertex, a SketchPoint or a ConstructionPoint.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ScaleFeature__set_point(self, value)

    def setToUniform(self, scaleFactor: "ValueInput") -> "bool":
        r"""
        Calling this method will change to a uniform scale.
        The isUniform is set to true if successful.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        scaleFactor : A ValueInput object that defines the scale factor. 
        Returns true if successful.
        """
        return _fusion.ScaleFeature_setToUniform(self, scaleFactor)

    def setToNonUniform(self, xScale: "ValueInput", yScale: "ValueInput", zScale: "ValueInput") -> "bool":
        r"""
        Calling this method will change to a non-uniform scale.
        Fails of the inputEntities collection contains sketches or components.
        The isUniform is set to false if successful.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        xScale : A ValueInput object that defines the scale in the X direction. 
        yScale : A ValueInput object that defines the scale in the Y direction. 
        zScale : A ValueInput object that defines the scale in the Z direction. 
        Returns true if successful.
        """
        return _fusion.ScaleFeature_setToNonUniform(self, xScale, yScale, zScale)

    def _get_isUniform(self) -> "bool":
        r"""Gets if it's uniform scale."""
        return _fusion.ScaleFeature__get_isUniform(self)

    def _get_scaleFactor(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the parameter that controls the uniform scale factor. This will return null in the case
        where isUniform is false or the feature is non-parametric. You can use the properties and 
        methods on the ModelParameter object to get and set the value.
        """
        return _fusion.ScaleFeature__get_scaleFactor(self)

    def _get_xScale(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the parameter that controls the X scale factor. This will return null in the case
        where isUniform is false or the feature is non-parametric. You can use the properties and 
        methods on the ModelParameter object to get and set the value.
        """
        return _fusion.ScaleFeature__get_xScale(self)

    def _get_yScale(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the parameter that controls the Y scale factor. This will return null in the case
        where isUniform is false or the feature is non-parametric. You can use the properties and 
        methods on the ModelParameter object to get and set the value.
        """
        return _fusion.ScaleFeature__get_yScale(self)

    def _get_zScale(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the parameter that controls the Z scale factor. This will return null in the case
        where isUniform is false or the feature is non-parametric. You can use the properties and 
        methods on the ModelParameter object to get and set the value.
        """
        return _fusion.ScaleFeature__get_zScale(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ScaleFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ScaleFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::ScaleFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ScaleFeature_createForAssemblyContext(self, occurrence)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ScaleFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ScaleFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ScaleFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.ScaleFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ScaleFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ScaleFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.ScaleFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.ScaleFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.ScaleFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.ScaleFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ScaleFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.ScaleFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.ScaleFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.ScaleFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ScaleFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.ScaleFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ScaleFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.ScaleFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ScaleFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ScaleFeature__get_isValid(self)

# Register ScaleFeature in _fusion:
_fusion.ScaleFeature_swigregister(ScaleFeature)

def ScaleFeature_classType() -> "char const *":
    return _fusion.ScaleFeature_classType()


ScaleFeature.inputEntities = property(ScaleFeature._get_inputEntities, ScaleFeature._set_inputEntities, doc="Gets and sets the input entities.\nThis collection can contain sketches, BRep bodies and T-Spline bodies in parametric modeling.\nIt can contain sketches, BRep bodies, T-Spline bodies, mesh bodies, root component and occurrences in non-parametric modeling.\nIf the scaling is non-uniform (the isUniform property is false), this collection cannot contain sketches or components.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ScaleFeature.point = property(ScaleFeature._get_point, ScaleFeature._set_point, doc="Gets and sets the point as reference to scale. This can be a BRepVertex, a SketchPoint or a ConstructionPoint.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ScaleFeature.isUniform = property(ScaleFeature._get_isUniform, doc="Gets if it's uniform scale.")


ScaleFeature.scaleFactor = property(ScaleFeature._get_scaleFactor, doc="Returns the parameter that controls the uniform scale factor. This will return null in the case\nwhere isUniform is false or the feature is non-parametric. You can use the properties and\nmethods on the ModelParameter object to get and set the value.")


ScaleFeature.xScale = property(ScaleFeature._get_xScale, doc="Returns the parameter that controls the X scale factor. This will return null in the case\nwhere isUniform is false or the feature is non-parametric. You can use the properties and\nmethods on the ModelParameter object to get and set the value.")


ScaleFeature.yScale = property(ScaleFeature._get_yScale, doc="Returns the parameter that controls the Y scale factor. This will return null in the case\nwhere isUniform is false or the feature is non-parametric. You can use the properties and\nmethods on the ModelParameter object to get and set the value.")


ScaleFeature.zScale = property(ScaleFeature._get_zScale, doc="Returns the parameter that controls the Z scale factor. This will return null in the case\nwhere isUniform is false or the feature is non-parametric. You can use the properties and\nmethods on the ModelParameter object to get and set the value.")


ScaleFeature.nativeObject = property(ScaleFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


ScaleFeature.cast = lambda arg: arg if isinstance(arg, ScaleFeature) else None

class ShellFeature(Feature):
    r"""Object that represents an existing shell feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ShellFeature *":
        return _fusion.ShellFeature___deref__(self)

    def __eq__(self, rhs: "ShellFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ShellFeature___eq__(self, rhs)


    def __ne__(self, rhs: "ShellFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ShellFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ShellFeature_classType()
    __swig_destroy__ = _fusion.delete_ShellFeature

    def setInputEntities(self, inputEntities: "ObjectCollection", isTangentChain: "bool"=True) -> "bool":
        r"""
        Method that sets faces to remove and bodies to preform shell. Return false if any faces are input, and the owning bodies of the faces are also input.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        inputEntities : The collection contains the faces to remove and the bodies to perform shell.
        Fails if any faces are input, and the owning bodies of the faces are also input. 
        isTangentChain : A boolean value for setting whether or not faces that are tangentially connected to 
        the input faces (if any) will also be included. It defaults to true. 
        Returns true if successful
        """
        return _fusion.ShellFeature_setInputEntities(self, inputEntities, isTangentChain)

    def setThicknesses(self, insideThickness: "ValueInput", outsideThickness: "ValueInput") -> "bool":
        r"""
        Method that sets the inside and outside thicknesses of the shell.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        insideThickness : ValueInput object that defines the inside thickness. If set to null, the inside thickness is removed. 
        outsideThickness : ValueInput object that defines the outside thickness. If set to null, the outside thickness is removed. 
        Returns true if successful
        """
        return _fusion.ShellFeature_setThicknesses(self, insideThickness, outsideThickness)

    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""Gets the input faces/bodies."""
        return _fusion.ShellFeature__get_inputEntities(self)

    def _get_isTangentChain(self) -> "bool":
        r"""
        Gets if any faces that are tangentially connected to any of 
        the input faces will also be included in setting InputEntities.
        """
        return _fusion.ShellFeature__get_isTangentChain(self)

    def _get_insideThickness(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the inside thickness.
        Edit the thickness through ModelParameter.
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ShellFeature__get_insideThickness(self)

    def _get_outsideThickness(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the outside thickness.
        Edit the thickness through ModelParameter.
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ShellFeature__get_outsideThickness(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ShellFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ShellFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::ShellFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ShellFeature_createForAssemblyContext(self, occurrence)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ShellFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ShellFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ShellFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.ShellFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ShellFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ShellFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.ShellFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.ShellFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.ShellFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.ShellFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ShellFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.ShellFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.ShellFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.ShellFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ShellFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.ShellFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ShellFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.ShellFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ShellFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ShellFeature__get_isValid(self)

# Register ShellFeature in _fusion:
_fusion.ShellFeature_swigregister(ShellFeature)

def ShellFeature_classType() -> "char const *":
    return _fusion.ShellFeature_classType()


ShellFeature.inputEntities = property(ShellFeature._get_inputEntities, doc="Gets the input faces/bodies.")


ShellFeature.isTangentChain = property(ShellFeature._get_isTangentChain, doc="Gets if any faces that are tangentially connected to any of\nthe input faces will also be included in setting InputEntities.")


ShellFeature.insideThickness = property(ShellFeature._get_insideThickness, doc="Gets the inside thickness.\nEdit the thickness through ModelParameter.\nThis property returns nothing in the case where the feature is non-parametric.")


ShellFeature.outsideThickness = property(ShellFeature._get_outsideThickness, doc="Gets the outside thickness.\nEdit the thickness through ModelParameter.\nThis property returns nothing in the case where the feature is non-parametric.")


ShellFeature.nativeObject = property(ShellFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


ShellFeature.cast = lambda arg: arg if isinstance(arg, ShellFeature) else None

class SilhouetteSplitFeature(Feature):
    r"""Object that represents an existing silhouette split feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SilhouetteSplitFeature *":
        return _fusion.SilhouetteSplitFeature___deref__(self)

    def __eq__(self, rhs: "SilhouetteSplitFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SilhouetteSplitFeature___eq__(self, rhs)


    def __ne__(self, rhs: "SilhouetteSplitFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SilhouetteSplitFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SilhouetteSplitFeature_classType()
    __swig_destroy__ = _fusion.delete_SilhouetteSplitFeature

    def _get_viewDirection(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the entity that defines the silhouette view direction, which can be a 
        construction axis, linear BRepEdge, planar BRepFace or a construction plane.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SilhouetteSplitFeature__get_viewDirection(self)

    def _set_viewDirection(self, value: "Base") -> "bool":
        r"""
        Gets and sets the entity that defines the silhouette view direction, which can be a 
        construction axis, linear BRepEdge, planar BRepFace or a construction plane.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SilhouetteSplitFeature__set_viewDirection(self, value)

    def _get_targetBody(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >":
        r"""
        Gets and sets the solid body to split.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SilhouetteSplitFeature__get_targetBody(self)

    def _set_targetBody(self, value: "BRepBody") -> "bool":
        r"""
        Gets and sets the solid body to split.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SilhouetteSplitFeature__set_targetBody(self, value)

    def _get_operation(self) -> "adsk::fusion::SilhouetteSplitOperations":
        r"""Gets the type of silhouette split operation."""
        return _fusion.SilhouetteSplitFeature__get_operation(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SilhouetteSplitFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SilhouetteSplitFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SilhouetteSplitFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.SilhouetteSplitFeature_createForAssemblyContext(self, occurrence)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SilhouetteSplitFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SilhouetteSplitFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.SilhouetteSplitFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.SilhouetteSplitFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SilhouetteSplitFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SilhouetteSplitFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.SilhouetteSplitFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.SilhouetteSplitFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.SilhouetteSplitFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.SilhouetteSplitFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SilhouetteSplitFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.SilhouetteSplitFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.SilhouetteSplitFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.SilhouetteSplitFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.SilhouetteSplitFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.SilhouetteSplitFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.SilhouetteSplitFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SilhouetteSplitFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SilhouetteSplitFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SilhouetteSplitFeature__get_isValid(self)

# Register SilhouetteSplitFeature in _fusion:
_fusion.SilhouetteSplitFeature_swigregister(SilhouetteSplitFeature)

def SilhouetteSplitFeature_classType() -> "char const *":
    return _fusion.SilhouetteSplitFeature_classType()


SilhouetteSplitFeature.viewDirection = property(SilhouetteSplitFeature._get_viewDirection, SilhouetteSplitFeature._set_viewDirection, doc="Gets and sets the entity that defines the silhouette view direction, which can be a\nconstruction axis, linear BRepEdge, planar BRepFace or a construction plane.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


SilhouetteSplitFeature.targetBody = property(SilhouetteSplitFeature._get_targetBody, SilhouetteSplitFeature._set_targetBody, doc="Gets and sets the solid body to split.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


SilhouetteSplitFeature.operation = property(SilhouetteSplitFeature._get_operation, doc="Gets the type of silhouette split operation.")


SilhouetteSplitFeature.nativeObject = property(SilhouetteSplitFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SilhouetteSplitFeature.cast = lambda arg: arg if isinstance(arg, SilhouetteSplitFeature) else None

class SketchAngularDimension(SketchDimension):
    r"""An angular dimension in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchAngularDimension *":
        return _fusion.SketchAngularDimension___deref__(self)

    def __eq__(self, rhs: "SketchAngularDimension") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchAngularDimension___eq__(self, rhs)


    def __ne__(self, rhs: "SketchAngularDimension") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchAngularDimension___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchAngularDimension_classType()
    __swig_destroy__ = _fusion.delete_SketchAngularDimension

    def _get_lineOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""The first line being constrained."""
        return _fusion.SketchAngularDimension__get_lineOne(self)

    def _get_lineTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""The second line being constrained."""
        return _fusion.SketchAngularDimension__get_lineTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchAngularDimension >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchAngularDimension__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SketchAngularDimension >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchAngularDimension_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this dimension. The IsDeletable property indicates if this dimension can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SketchAngularDimension_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this dimension is deletable."""
        return _fusion.SketchAngularDimension__get_isDeletable(self)

    def _get_textPosition(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets position of the dimension text."""
        return _fusion.SketchAngularDimension__get_textPosition(self)

    def _set_textPosition(self, value: "Point3D") -> "bool":
        r"""Gets and sets position of the dimension text."""
        return _fusion.SketchAngularDimension__set_textPosition(self, value)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.SketchAngularDimension__get_parentSketch(self)

    def _get_parameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""Returns the associated parameter or null if there is no associated parameter."""
        return _fusion.SketchAngularDimension__get_parameter(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchAngularDimension__get_assemblyContext(self)

    def _get_isDriving(self) -> "bool":
        r"""
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchAngularDimension__get_isDriving(self)

    def _set_isDriving(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchAngularDimension__set_isDriving(self, value)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this sketch dimension."""
        return _fusion.SketchAngularDimension__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the SketchDimension object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same sketch dimension.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SketchAngularDimension__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchAngularDimension__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchAngularDimension__get_isValid(self)

# Register SketchAngularDimension in _fusion:
_fusion.SketchAngularDimension_swigregister(SketchAngularDimension)

def SketchAngularDimension_classType() -> "char const *":
    return _fusion.SketchAngularDimension_classType()


SketchAngularDimension.lineOne = property(SketchAngularDimension._get_lineOne, doc="The first line being constrained.")


SketchAngularDimension.lineTwo = property(SketchAngularDimension._get_lineTwo, doc="The second line being constrained.")


SketchAngularDimension.nativeObject = property(SketchAngularDimension._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SketchAngularDimension.cast = lambda arg: arg if isinstance(arg, SketchAngularDimension) else None

class SketchConcentricCircleDimension(SketchDimension):
    r"""A concentric circle dimension in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchConcentricCircleDimension *":
        return _fusion.SketchConcentricCircleDimension___deref__(self)

    def __eq__(self, rhs: "SketchConcentricCircleDimension") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchConcentricCircleDimension___eq__(self, rhs)


    def __ne__(self, rhs: "SketchConcentricCircleDimension") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchConcentricCircleDimension___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchConcentricCircleDimension_classType()
    __swig_destroy__ = _fusion.delete_SketchConcentricCircleDimension

    def _get_circleOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >":
        r"""Returns the first concentric circle or arc."""
        return _fusion.SketchConcentricCircleDimension__get_circleOne(self)

    def _get_circleTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >":
        r"""Returns the second concentric circle or arc."""
        return _fusion.SketchConcentricCircleDimension__get_circleTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchConcentricCircleDimension >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchConcentricCircleDimension__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SketchConcentricCircleDimension >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchConcentricCircleDimension_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this dimension. The IsDeletable property indicates if this dimension can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SketchConcentricCircleDimension_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this dimension is deletable."""
        return _fusion.SketchConcentricCircleDimension__get_isDeletable(self)

    def _get_textPosition(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets position of the dimension text."""
        return _fusion.SketchConcentricCircleDimension__get_textPosition(self)

    def _set_textPosition(self, value: "Point3D") -> "bool":
        r"""Gets and sets position of the dimension text."""
        return _fusion.SketchConcentricCircleDimension__set_textPosition(self, value)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.SketchConcentricCircleDimension__get_parentSketch(self)

    def _get_parameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""Returns the associated parameter or null if there is no associated parameter."""
        return _fusion.SketchConcentricCircleDimension__get_parameter(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchConcentricCircleDimension__get_assemblyContext(self)

    def _get_isDriving(self) -> "bool":
        r"""
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchConcentricCircleDimension__get_isDriving(self)

    def _set_isDriving(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchConcentricCircleDimension__set_isDriving(self, value)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this sketch dimension."""
        return _fusion.SketchConcentricCircleDimension__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the SketchDimension object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same sketch dimension.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SketchConcentricCircleDimension__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchConcentricCircleDimension__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchConcentricCircleDimension__get_isValid(self)

# Register SketchConcentricCircleDimension in _fusion:
_fusion.SketchConcentricCircleDimension_swigregister(SketchConcentricCircleDimension)

def SketchConcentricCircleDimension_classType() -> "char const *":
    return _fusion.SketchConcentricCircleDimension_classType()


SketchConcentricCircleDimension.circleOne = property(SketchConcentricCircleDimension._get_circleOne, doc="Returns the first concentric circle or arc.")


SketchConcentricCircleDimension.circleTwo = property(SketchConcentricCircleDimension._get_circleTwo, doc="Returns the second concentric circle or arc.")


SketchConcentricCircleDimension.nativeObject = property(SketchConcentricCircleDimension._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SketchConcentricCircleDimension.cast = lambda arg: arg if isinstance(arg, SketchConcentricCircleDimension) else None

class SketchCurve(SketchEntity):
    r"""A single sketch curve. This is the base class for the specific curve types."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchCurve *":
        return _fusion.SketchCurve___deref__(self)

    def __eq__(self, rhs: "SketchCurve") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchCurve___eq__(self, rhs)


    def __ne__(self, rhs: "SketchCurve") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchCurve___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchCurve_classType()
    __swig_destroy__ = _fusion.delete_SketchCurve

    def _get_length(self) -> "double":
        r"""Returns the length of the curve in centimeters."""
        return _fusion.SketchCurve__get_length(self)

    def _get_isConstruction(self) -> "bool":
        r"""Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchCurve__get_isConstruction(self)

    def _set_isConstruction(self, value: "bool") -> "bool":
        r"""Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchCurve__set_isConstruction(self, value)

    def split(self, splitPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Split a curve at a position specified along the curve 
        splitPoint : A position (transient Point3D) on the curve that defines the point at which to split the curve 
        createConstraints : Constraints are created by default. Specify false to create no constraints. 
        Returns the resulting 2 curves; the original curve + the newly created curve
        When split spline the original is deleted and two new curves returned.
        Empty collection returned if curve is closed.
        """
        return _fusion.SketchCurve_split(self, splitPoint, createConstraints)

    def trim(self, segmentPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Trim a curve by specifying a point that determines the segment of the curve to trim away 
        segmentPoint : A point (transient Point3D) on or closest to the segment of the curve to remove. (start, end or middle)
        The segment of the curve closest to the segmentPoint gets removed 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        When trimming the start or end side of a line, unclosed circular or elliptical arc, the original entity is modified and returned
        When trimming the middle of a line, unclosed circular or elliptical arc the original entity is deleted and two new entities are returned
        When trimming the start or end of any type of closed curve, the original is deleted and a new curve is returned
        Any trimming of a spline (open or closed) deletes the original and new spline/s are returned
        Trimming a curve having no intersections deletes the original and returns an empty collection
        """
        return _fusion.SketchCurve_trim(self, segmentPoint, createConstraints)

    def breakCurve(self, segmentPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Breaks a curve into two or three pieces by finding intersections of this curve with all other curves in the
        sketch and splitting this curve at the nearest intersections to a specified point on the curve. 
        segmentPoint : A point that specifies the segment of the curve that is to be split from the rest of the curve. The nearest
        intersection(s) to this point define the break location(s). 
        createConstraints : Optional argument that specifies if constraints should be created between the new curve segments. A value of
        true indicates constraints will be created. 
        All of the curves resulting from the break are returned in an ObjectCollection. In the case where no intersections
        are found and as a result the curve is not broken, an empty ObjectCollection is returned.
        """
        return _fusion.SketchCurve_breakCurve(self, segmentPoint, createConstraints)

    def extend(self, endPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Extend a curve by specifying a point that determines the end of the curve to extend 
        endPoint : A point (transient Point3D) on or closest to the end of the curve to extend. (start or end)
        The end of the curve closest to the endPoint gets extended 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        Returns the modified original curve if the start or end of the curve is extended
        If the extend joins a curve to another, the two original curves are deleted and a new curve is returned
        If an arc is extended so as to become a circle, the original arc is deleted and a new circle is returned
        """
        return _fusion.SketchCurve_extend(self, endPoint, createConstraints)

    def intersections(self, sketchCurves: "ObjectCollection") -> "bool":
        r"""
        Get the curves that intersect this curve along with the intersection points (Point3D) 
        sketchCurves : A collection of curves to attempt to find intersections with. 
        Set the value of this parameter to null to use all curves in the sketch for the calculation. 
        intersectingCurves : A collection of the actual intersecting curves 
        intersectionPoints : A collection of intersection points (Point3D)
        Item numbers in this collection correspond to the item numbers in the intersectingCurves collection. 
        Returns true if the method was successful. It can be successful regardless of whether intersections were found or not.
        """
        return _fusion.SketchCurve_intersections(self, sketchCurves)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch."""
        return _fusion.SketchCurve__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >":
        r"""Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchCurve__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >":
        r"""Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchCurve__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool":
        r"""Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchCurve__get_is2D(self)

    def _get_isReference(self) -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchCurve__get_isReference(self)

    def _set_isReference(self, value: "bool") -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchCurve__set_isReference(self, value)

    def _get_isFixed(self) -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchCurve__get_isFixed(self)

    def _set_isFixed(self, value: "bool") -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchCurve__set_isFixed(self, value)

    def _get_isVisible(self) -> "bool":
        r"""
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchCurve__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchCurve__get_boundingBox(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchCurve_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchCurve__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchCurve__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool":
        r"""
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchCurve__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool":
        r"""Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchCurve__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.SketchCurve__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the SketchEntity object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same sketch entity.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SketchCurve__get_entityToken(self)

    def _get_isLinked(self) -> "bool":
        r"""
        Indicates if this sketch entity was created by a projection, inclusion, or driven by an API script.
        If this returns true, then the entity is presented to the user as not editable and with a 'break link'
        command available.
        """
        return _fusion.SketchCurve__get_isLinked(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchCurve__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchCurve__get_isValid(self)

# Register SketchCurve in _fusion:
_fusion.SketchCurve_swigregister(SketchCurve)

def SketchCurve_classType() -> "char const *":
    return _fusion.SketchCurve_classType()


SketchCurve.length = property(SketchCurve._get_length, doc="Returns the length of the curve in centimeters.")


SketchCurve.isConstruction = property(SketchCurve._get_isConstruction, SketchCurve._set_isConstruction, doc="Gets and sets whether this curve is construction geometry.")


SketchCurve.cast = lambda arg: arg if isinstance(arg, SketchCurve) else None

class SketchDiameterDimension(SketchDimension):
    r"""An diameter dimension in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchDiameterDimension *":
        return _fusion.SketchDiameterDimension___deref__(self)

    def __eq__(self, rhs: "SketchDiameterDimension") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchDiameterDimension___eq__(self, rhs)


    def __ne__(self, rhs: "SketchDiameterDimension") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchDiameterDimension___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchDiameterDimension_classType()
    __swig_destroy__ = _fusion.delete_SketchDiameterDimension

    def _get_entity(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >":
        r"""Returns the arc or circle being constrained."""
        return _fusion.SketchDiameterDimension__get_entity(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchDiameterDimension >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchDiameterDimension__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SketchDiameterDimension >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchDiameterDimension_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this dimension. The IsDeletable property indicates if this dimension can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SketchDiameterDimension_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this dimension is deletable."""
        return _fusion.SketchDiameterDimension__get_isDeletable(self)

    def _get_textPosition(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets position of the dimension text."""
        return _fusion.SketchDiameterDimension__get_textPosition(self)

    def _set_textPosition(self, value: "Point3D") -> "bool":
        r"""Gets and sets position of the dimension text."""
        return _fusion.SketchDiameterDimension__set_textPosition(self, value)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.SketchDiameterDimension__get_parentSketch(self)

    def _get_parameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""Returns the associated parameter or null if there is no associated parameter."""
        return _fusion.SketchDiameterDimension__get_parameter(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchDiameterDimension__get_assemblyContext(self)

    def _get_isDriving(self) -> "bool":
        r"""
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchDiameterDimension__get_isDriving(self)

    def _set_isDriving(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchDiameterDimension__set_isDriving(self, value)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this sketch dimension."""
        return _fusion.SketchDiameterDimension__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the SketchDimension object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same sketch dimension.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SketchDiameterDimension__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchDiameterDimension__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchDiameterDimension__get_isValid(self)

# Register SketchDiameterDimension in _fusion:
_fusion.SketchDiameterDimension_swigregister(SketchDiameterDimension)

def SketchDiameterDimension_classType() -> "char const *":
    return _fusion.SketchDiameterDimension_classType()


SketchDiameterDimension.entity = property(SketchDiameterDimension._get_entity, doc="Returns the arc or circle being constrained.")


SketchDiameterDimension.nativeObject = property(SketchDiameterDimension._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SketchDiameterDimension.cast = lambda arg: arg if isinstance(arg, SketchDiameterDimension) else None

class SketchEllipseMajorRadiusDimension(SketchDimension):
    r"""An ellipse major radius dimension in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchEllipseMajorRadiusDimension *":
        return _fusion.SketchEllipseMajorRadiusDimension___deref__(self)

    def __eq__(self, rhs: "SketchEllipseMajorRadiusDimension") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchEllipseMajorRadiusDimension___eq__(self, rhs)


    def __ne__(self, rhs: "SketchEllipseMajorRadiusDimension") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchEllipseMajorRadiusDimension___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchEllipseMajorRadiusDimension_classType()
    __swig_destroy__ = _fusion.delete_SketchEllipseMajorRadiusDimension

    def _get_ellipse(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >":
        r"""Returns the ellipse or elliptical arc being constrained."""
        return _fusion.SketchEllipseMajorRadiusDimension__get_ellipse(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchEllipseMajorRadiusDimension >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchEllipseMajorRadiusDimension__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SketchEllipseMajorRadiusDimension >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchEllipseMajorRadiusDimension_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this dimension. The IsDeletable property indicates if this dimension can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SketchEllipseMajorRadiusDimension_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this dimension is deletable."""
        return _fusion.SketchEllipseMajorRadiusDimension__get_isDeletable(self)

    def _get_textPosition(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets position of the dimension text."""
        return _fusion.SketchEllipseMajorRadiusDimension__get_textPosition(self)

    def _set_textPosition(self, value: "Point3D") -> "bool":
        r"""Gets and sets position of the dimension text."""
        return _fusion.SketchEllipseMajorRadiusDimension__set_textPosition(self, value)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.SketchEllipseMajorRadiusDimension__get_parentSketch(self)

    def _get_parameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""Returns the associated parameter or null if there is no associated parameter."""
        return _fusion.SketchEllipseMajorRadiusDimension__get_parameter(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchEllipseMajorRadiusDimension__get_assemblyContext(self)

    def _get_isDriving(self) -> "bool":
        r"""
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchEllipseMajorRadiusDimension__get_isDriving(self)

    def _set_isDriving(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchEllipseMajorRadiusDimension__set_isDriving(self, value)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this sketch dimension."""
        return _fusion.SketchEllipseMajorRadiusDimension__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the SketchDimension object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same sketch dimension.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SketchEllipseMajorRadiusDimension__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchEllipseMajorRadiusDimension__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchEllipseMajorRadiusDimension__get_isValid(self)

# Register SketchEllipseMajorRadiusDimension in _fusion:
_fusion.SketchEllipseMajorRadiusDimension_swigregister(SketchEllipseMajorRadiusDimension)

def SketchEllipseMajorRadiusDimension_classType() -> "char const *":
    return _fusion.SketchEllipseMajorRadiusDimension_classType()


SketchEllipseMajorRadiusDimension.ellipse = property(SketchEllipseMajorRadiusDimension._get_ellipse, doc="Returns the ellipse or elliptical arc being constrained.")


SketchEllipseMajorRadiusDimension.nativeObject = property(SketchEllipseMajorRadiusDimension._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SketchEllipseMajorRadiusDimension.cast = lambda arg: arg if isinstance(arg, SketchEllipseMajorRadiusDimension) else None

class SketchEllipseMinorRadiusDimension(SketchDimension):
    r"""An ellipse minor radius dimension in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchEllipseMinorRadiusDimension *":
        return _fusion.SketchEllipseMinorRadiusDimension___deref__(self)

    def __eq__(self, rhs: "SketchEllipseMinorRadiusDimension") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchEllipseMinorRadiusDimension___eq__(self, rhs)


    def __ne__(self, rhs: "SketchEllipseMinorRadiusDimension") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchEllipseMinorRadiusDimension___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchEllipseMinorRadiusDimension_classType()
    __swig_destroy__ = _fusion.delete_SketchEllipseMinorRadiusDimension

    def _get_ellipse(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >":
        r"""Returns the ellipse or elliptical arc being constrained."""
        return _fusion.SketchEllipseMinorRadiusDimension__get_ellipse(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchEllipseMinorRadiusDimension >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchEllipseMinorRadiusDimension__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SketchEllipseMinorRadiusDimension >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchEllipseMinorRadiusDimension_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this dimension. The IsDeletable property indicates if this dimension can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SketchEllipseMinorRadiusDimension_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this dimension is deletable."""
        return _fusion.SketchEllipseMinorRadiusDimension__get_isDeletable(self)

    def _get_textPosition(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets position of the dimension text."""
        return _fusion.SketchEllipseMinorRadiusDimension__get_textPosition(self)

    def _set_textPosition(self, value: "Point3D") -> "bool":
        r"""Gets and sets position of the dimension text."""
        return _fusion.SketchEllipseMinorRadiusDimension__set_textPosition(self, value)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.SketchEllipseMinorRadiusDimension__get_parentSketch(self)

    def _get_parameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""Returns the associated parameter or null if there is no associated parameter."""
        return _fusion.SketchEllipseMinorRadiusDimension__get_parameter(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchEllipseMinorRadiusDimension__get_assemblyContext(self)

    def _get_isDriving(self) -> "bool":
        r"""
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchEllipseMinorRadiusDimension__get_isDriving(self)

    def _set_isDriving(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchEllipseMinorRadiusDimension__set_isDriving(self, value)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this sketch dimension."""
        return _fusion.SketchEllipseMinorRadiusDimension__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the SketchDimension object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same sketch dimension.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SketchEllipseMinorRadiusDimension__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchEllipseMinorRadiusDimension__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchEllipseMinorRadiusDimension__get_isValid(self)

# Register SketchEllipseMinorRadiusDimension in _fusion:
_fusion.SketchEllipseMinorRadiusDimension_swigregister(SketchEllipseMinorRadiusDimension)

def SketchEllipseMinorRadiusDimension_classType() -> "char const *":
    return _fusion.SketchEllipseMinorRadiusDimension_classType()


SketchEllipseMinorRadiusDimension.ellipse = property(SketchEllipseMinorRadiusDimension._get_ellipse, doc="Returns the ellipse or elliptical arc being constrained.")


SketchEllipseMinorRadiusDimension.nativeObject = property(SketchEllipseMinorRadiusDimension._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SketchEllipseMinorRadiusDimension.cast = lambda arg: arg if isinstance(arg, SketchEllipseMinorRadiusDimension) else None

class SketchLinearDimension(SketchDimension):
    r"""A linear dimension in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchLinearDimension *":
        return _fusion.SketchLinearDimension___deref__(self)

    def __eq__(self, rhs: "SketchLinearDimension") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchLinearDimension___eq__(self, rhs)


    def __ne__(self, rhs: "SketchLinearDimension") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchLinearDimension___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchLinearDimension_classType()
    __swig_destroy__ = _fusion.delete_SketchLinearDimension

    def _get_entityOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchEntity >":
        r"""The first entity being constrained."""
        return _fusion.SketchLinearDimension__get_entityOne(self)

    def _get_entityTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchEntity >":
        r"""The second entity being constrained."""
        return _fusion.SketchLinearDimension__get_entityTwo(self)

    def _get_orientation(self) -> "adsk::fusion::DimensionOrientations":
        r"""The orientation of this dimension."""
        return _fusion.SketchLinearDimension__get_orientation(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchLinearDimension >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchLinearDimension__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SketchLinearDimension >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchLinearDimension_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this dimension. The IsDeletable property indicates if this dimension can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SketchLinearDimension_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this dimension is deletable."""
        return _fusion.SketchLinearDimension__get_isDeletable(self)

    def _get_textPosition(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets position of the dimension text."""
        return _fusion.SketchLinearDimension__get_textPosition(self)

    def _set_textPosition(self, value: "Point3D") -> "bool":
        r"""Gets and sets position of the dimension text."""
        return _fusion.SketchLinearDimension__set_textPosition(self, value)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.SketchLinearDimension__get_parentSketch(self)

    def _get_parameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""Returns the associated parameter or null if there is no associated parameter."""
        return _fusion.SketchLinearDimension__get_parameter(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchLinearDimension__get_assemblyContext(self)

    def _get_isDriving(self) -> "bool":
        r"""
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchLinearDimension__get_isDriving(self)

    def _set_isDriving(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchLinearDimension__set_isDriving(self, value)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this sketch dimension."""
        return _fusion.SketchLinearDimension__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the SketchDimension object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same sketch dimension.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SketchLinearDimension__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchLinearDimension__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchLinearDimension__get_isValid(self)

# Register SketchLinearDimension in _fusion:
_fusion.SketchLinearDimension_swigregister(SketchLinearDimension)

def SketchLinearDimension_classType() -> "char const *":
    return _fusion.SketchLinearDimension_classType()


SketchLinearDimension.entityOne = property(SketchLinearDimension._get_entityOne, doc="The first entity being constrained.")


SketchLinearDimension.entityTwo = property(SketchLinearDimension._get_entityTwo, doc="The second entity being constrained.")


SketchLinearDimension.orientation = property(SketchLinearDimension._get_orientation, doc="The orientation of this dimension.")


SketchLinearDimension.nativeObject = property(SketchLinearDimension._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SketchLinearDimension.cast = lambda arg: arg if isinstance(arg, SketchLinearDimension) else None

class SketchOffsetCurvesDimension(SketchDimension):
    r"""A SketchOffsetCurvesDimension object is created automatically whenever curves are offset."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchOffsetCurvesDimension *":
        return _fusion.SketchOffsetCurvesDimension___deref__(self)

    def __eq__(self, rhs: "SketchOffsetCurvesDimension") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchOffsetCurvesDimension___eq__(self, rhs)


    def __ne__(self, rhs: "SketchOffsetCurvesDimension") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchOffsetCurvesDimension___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchOffsetCurvesDimension_classType()
    __swig_destroy__ = _fusion.delete_SketchOffsetCurvesDimension

    def _get_offsetConstraint(self) -> "adsk::core::Ptr< adsk::fusion::OffsetConstraint >":
        r"""
        Returns the OffsetConstraint object that defines the curve offset. From the constraint
        you can get the original curves, the offset curves, and the dimension controlling the offset distance.
        """
        return _fusion.SketchOffsetCurvesDimension__get_offsetConstraint(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchOffsetCurvesDimension >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchOffsetCurvesDimension__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SketchOffsetCurvesDimension >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchOffsetCurvesDimension_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this dimension. The IsDeletable property indicates if this dimension can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SketchOffsetCurvesDimension_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this dimension is deletable."""
        return _fusion.SketchOffsetCurvesDimension__get_isDeletable(self)

    def _get_textPosition(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets position of the dimension text."""
        return _fusion.SketchOffsetCurvesDimension__get_textPosition(self)

    def _set_textPosition(self, value: "Point3D") -> "bool":
        r"""Gets and sets position of the dimension text."""
        return _fusion.SketchOffsetCurvesDimension__set_textPosition(self, value)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.SketchOffsetCurvesDimension__get_parentSketch(self)

    def _get_parameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""Returns the associated parameter or null if there is no associated parameter."""
        return _fusion.SketchOffsetCurvesDimension__get_parameter(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchOffsetCurvesDimension__get_assemblyContext(self)

    def _get_isDriving(self) -> "bool":
        r"""
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchOffsetCurvesDimension__get_isDriving(self)

    def _set_isDriving(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchOffsetCurvesDimension__set_isDriving(self, value)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this sketch dimension."""
        return _fusion.SketchOffsetCurvesDimension__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the SketchDimension object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same sketch dimension.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SketchOffsetCurvesDimension__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchOffsetCurvesDimension__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchOffsetCurvesDimension__get_isValid(self)

# Register SketchOffsetCurvesDimension in _fusion:
_fusion.SketchOffsetCurvesDimension_swigregister(SketchOffsetCurvesDimension)

def SketchOffsetCurvesDimension_classType() -> "char const *":
    return _fusion.SketchOffsetCurvesDimension_classType()


SketchOffsetCurvesDimension.offsetConstraint = property(SketchOffsetCurvesDimension._get_offsetConstraint, doc="Returns the OffsetConstraint object that defines the curve offset. From the constraint\nyou can get the original curves, the offset curves, and the dimension controlling the offset distance.")


SketchOffsetCurvesDimension.nativeObject = property(SketchOffsetCurvesDimension._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SketchOffsetCurvesDimension.cast = lambda arg: arg if isinstance(arg, SketchOffsetCurvesDimension) else None

class SketchOffsetDimension(SketchDimension):
    r"""An offset dimension in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchOffsetDimension *":
        return _fusion.SketchOffsetDimension___deref__(self)

    def __eq__(self, rhs: "SketchOffsetDimension") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchOffsetDimension___eq__(self, rhs)


    def __ne__(self, rhs: "SketchOffsetDimension") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchOffsetDimension___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchOffsetDimension_classType()
    __swig_destroy__ = _fusion.delete_SketchOffsetDimension

    def _get_line(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""The first line being constrained."""
        return _fusion.SketchOffsetDimension__get_line(self)

    def _get_entityTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchEntity >":
        r"""The second entity being constrained. (a parallel SketchLine or a SketchPoint)"""
        return _fusion.SketchOffsetDimension__get_entityTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchOffsetDimension >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchOffsetDimension__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SketchOffsetDimension >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchOffsetDimension_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this dimension. The IsDeletable property indicates if this dimension can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SketchOffsetDimension_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this dimension is deletable."""
        return _fusion.SketchOffsetDimension__get_isDeletable(self)

    def _get_textPosition(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets position of the dimension text."""
        return _fusion.SketchOffsetDimension__get_textPosition(self)

    def _set_textPosition(self, value: "Point3D") -> "bool":
        r"""Gets and sets position of the dimension text."""
        return _fusion.SketchOffsetDimension__set_textPosition(self, value)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.SketchOffsetDimension__get_parentSketch(self)

    def _get_parameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""Returns the associated parameter or null if there is no associated parameter."""
        return _fusion.SketchOffsetDimension__get_parameter(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchOffsetDimension__get_assemblyContext(self)

    def _get_isDriving(self) -> "bool":
        r"""
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchOffsetDimension__get_isDriving(self)

    def _set_isDriving(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchOffsetDimension__set_isDriving(self, value)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this sketch dimension."""
        return _fusion.SketchOffsetDimension__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the SketchDimension object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same sketch dimension.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SketchOffsetDimension__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchOffsetDimension__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchOffsetDimension__get_isValid(self)

# Register SketchOffsetDimension in _fusion:
_fusion.SketchOffsetDimension_swigregister(SketchOffsetDimension)

def SketchOffsetDimension_classType() -> "char const *":
    return _fusion.SketchOffsetDimension_classType()


SketchOffsetDimension.line = property(SketchOffsetDimension._get_line, doc="The first line being constrained.")


SketchOffsetDimension.entityTwo = property(SketchOffsetDimension._get_entityTwo, doc="The second entity being constrained. (a parallel SketchLine or a SketchPoint)")


SketchOffsetDimension.nativeObject = property(SketchOffsetDimension._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SketchOffsetDimension.cast = lambda arg: arg if isinstance(arg, SketchOffsetDimension) else None

class SketchPoint(SketchEntity):
    r"""A point within a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchPoint *":
        return _fusion.SketchPoint___deref__(self)

    def __eq__(self, rhs: "SketchPoint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchPoint___eq__(self, rhs)


    def __ne__(self, rhs: "SketchPoint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchPoint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchPoint_classType()
    __swig_destroy__ = _fusion.delete_SketchPoint

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""
        Returns a Point3D object which provides the position of the sketch point.
        The returned geometry is always in sketch space.
        """
        return _fusion.SketchPoint__get_geometry(self)

    def _get_worldGeometry(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""
        Returns a Point3D object which provides the position of the sketch point in world space.
        The returned coordinate takes into account the assembly context and the position of the
        sketch in it's parent component, which means the coordinate will be returned in the root
        component space.
        """
        return _fusion.SketchPoint__get_worldGeometry(self)

    def move(self, translation: "Vector3D") -> "bool":
        r"""
        Moves the sketch geometry using the specified transform.
        Move respects any constraints that would normally prohibit the move.
        This will fail in the case where the IsReference property is true. 
        translation : The vector that defines the distance and direction to move. 
        Returns true if moving the sketch point was successful.
        """
        return _fusion.SketchPoint_move(self, translation)

    def merge(self, point: "SketchPoint") -> "bool":
        r"""
        Merges the input sketch point into this sketch point. This effectively
        deletes the other sketch point and changes all entities that referenced
        that sketch point to reference this sketch point.
        This is the equivalent of dragging a sketch point on top of another
        sketch point in the user interface. 
        point : The point to merge with this point. 
        Returns true if the merge was successful.
        """
        return _fusion.SketchPoint_merge(self, point)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchPoint__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchPoint_createForAssemblyContext(self, occurrence)

    def _get_connectedEntities(self) -> "adsk::core::Ptr< adsk::fusion::SketchEntityList >":
        r"""
        Returns the set of sketch entities that are directly connected to this point. For
        example any entities that use this point as their start point or end point will be returned
        and any circle, arc or ellipse who have this point as a center point will be returned. This
        does not include entities that are related to the point through a constraint.
        """
        return _fusion.SketchPoint__get_connectedEntities(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch."""
        return _fusion.SketchPoint__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >":
        r"""Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchPoint__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >":
        r"""Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchPoint__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool":
        r"""Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchPoint__get_is2D(self)

    def _get_isReference(self) -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchPoint__get_isReference(self)

    def _set_isReference(self, value: "bool") -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchPoint__set_isReference(self, value)

    def _get_isFixed(self) -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchPoint__get_isFixed(self)

    def _set_isFixed(self, value: "bool") -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchPoint__set_isFixed(self, value)

    def _get_isVisible(self) -> "bool":
        r"""
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchPoint__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchPoint__get_boundingBox(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchPoint_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchPoint__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchPoint__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool":
        r"""
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchPoint__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool":
        r"""Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchPoint__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.SketchPoint__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the SketchEntity object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same sketch entity.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SketchPoint__get_entityToken(self)

    def _get_isLinked(self) -> "bool":
        r"""
        Indicates if this sketch entity was created by a projection, inclusion, or driven by an API script.
        If this returns true, then the entity is presented to the user as not editable and with a 'break link'
        command available.
        """
        return _fusion.SketchPoint__get_isLinked(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchPoint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchPoint__get_isValid(self)

# Register SketchPoint in _fusion:
_fusion.SketchPoint_swigregister(SketchPoint)

def SketchPoint_classType() -> "char const *":
    return _fusion.SketchPoint_classType()


SketchPoint.geometry = property(SketchPoint._get_geometry, doc="Returns a Point3D object which provides the position of the sketch point.\nThe returned geometry is always in sketch space.")


SketchPoint.worldGeometry = property(SketchPoint._get_worldGeometry, doc="Returns a Point3D object which provides the position of the sketch point in world space.\nThe returned coordinate takes into account the assembly context and the position of the\nsketch in it's parent component, which means the coordinate will be returned in the root\ncomponent space.")


SketchPoint.nativeObject = property(SketchPoint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SketchPoint.connectedEntities = property(SketchPoint._get_connectedEntities, doc="Returns the set of sketch entities that are directly connected to this point. For\nexample any entities that use this point as their start point or end point will be returned\nand any circle, arc or ellipse who have this point as a center point will be returned. This\ndoes not include entities that are related to the point through a constraint.")


SketchPoint.cast = lambda arg: arg if isinstance(arg, SketchPoint) else None

class SketchPointHolePositionDefinition(HolePositionDefinition):
    r"""Provides positioning information for a hole that is positioned by a sketch point."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchPointHolePositionDefinition *":
        return _fusion.SketchPointHolePositionDefinition___deref__(self)

    def __eq__(self, rhs: "SketchPointHolePositionDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchPointHolePositionDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "SketchPointHolePositionDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchPointHolePositionDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchPointHolePositionDefinition_classType()
    __swig_destroy__ = _fusion.delete_SketchPointHolePositionDefinition

    def _get_sketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""Returns the sketch point that defines the center of the hole."""
        return _fusion.SketchPointHolePositionDefinition__get_sketchPoint(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchPointHolePositionDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchPointHolePositionDefinition__get_isValid(self)

# Register SketchPointHolePositionDefinition in _fusion:
_fusion.SketchPointHolePositionDefinition_swigregister(SketchPointHolePositionDefinition)

def SketchPointHolePositionDefinition_classType() -> "char const *":
    return _fusion.SketchPointHolePositionDefinition_classType()


SketchPointHolePositionDefinition.sketchPoint = property(SketchPointHolePositionDefinition._get_sketchPoint, doc="Returns the sketch point that defines the center of the hole.")


SketchPointHolePositionDefinition.cast = lambda arg: arg if isinstance(arg, SketchPointHolePositionDefinition) else None

class SketchPointsHolePositionDefinition(HolePositionDefinition):
    r"""Provides positioning information for a hole that is positioned by a sketch point."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchPointsHolePositionDefinition *":
        return _fusion.SketchPointsHolePositionDefinition___deref__(self)

    def __eq__(self, rhs: "SketchPointsHolePositionDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchPointsHolePositionDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "SketchPointsHolePositionDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchPointsHolePositionDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchPointsHolePositionDefinition_classType()
    __swig_destroy__ = _fusion.delete_SketchPointsHolePositionDefinition

    def _get_sketchPoints(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""Returns the sketch point that defines the center of the hole."""
        return _fusion.SketchPointsHolePositionDefinition__get_sketchPoints(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchPointsHolePositionDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchPointsHolePositionDefinition__get_isValid(self)

# Register SketchPointsHolePositionDefinition in _fusion:
_fusion.SketchPointsHolePositionDefinition_swigregister(SketchPointsHolePositionDefinition)

def SketchPointsHolePositionDefinition_classType() -> "char const *":
    return _fusion.SketchPointsHolePositionDefinition_classType()


SketchPointsHolePositionDefinition.sketchPoints = property(SketchPointsHolePositionDefinition._get_sketchPoints, doc="Returns the sketch point that defines the center of the hole.")


SketchPointsHolePositionDefinition.cast = lambda arg: arg if isinstance(arg, SketchPointsHolePositionDefinition) else None

class SketchRadialDimension(SketchDimension):
    r"""An radial dimension in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchRadialDimension *":
        return _fusion.SketchRadialDimension___deref__(self)

    def __eq__(self, rhs: "SketchRadialDimension") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchRadialDimension___eq__(self, rhs)


    def __ne__(self, rhs: "SketchRadialDimension") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchRadialDimension___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchRadialDimension_classType()
    __swig_destroy__ = _fusion.delete_SketchRadialDimension

    def _get_entity(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >":
        r"""The arc or circle being constrained."""
        return _fusion.SketchRadialDimension__get_entity(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchRadialDimension >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchRadialDimension__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SketchRadialDimension >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchRadialDimension_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this dimension. The IsDeletable property indicates if this dimension can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SketchRadialDimension_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this dimension is deletable."""
        return _fusion.SketchRadialDimension__get_isDeletable(self)

    def _get_textPosition(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""Gets and sets position of the dimension text."""
        return _fusion.SketchRadialDimension__get_textPosition(self)

    def _set_textPosition(self, value: "Point3D") -> "bool":
        r"""Gets and sets position of the dimension text."""
        return _fusion.SketchRadialDimension__set_textPosition(self, value)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.SketchRadialDimension__get_parentSketch(self)

    def _get_parameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""Returns the associated parameter or null if there is no associated parameter."""
        return _fusion.SketchRadialDimension__get_parameter(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchRadialDimension__get_assemblyContext(self)

    def _get_isDriving(self) -> "bool":
        r"""
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchRadialDimension__get_isDriving(self)

    def _set_isDriving(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchRadialDimension__set_isDriving(self, value)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this sketch dimension."""
        return _fusion.SketchRadialDimension__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the SketchDimension object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same sketch dimension.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SketchRadialDimension__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchRadialDimension__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchRadialDimension__get_isValid(self)

# Register SketchRadialDimension in _fusion:
_fusion.SketchRadialDimension_swigregister(SketchRadialDimension)

def SketchRadialDimension_classType() -> "char const *":
    return _fusion.SketchRadialDimension_classType()


SketchRadialDimension.entity = property(SketchRadialDimension._get_entity, doc="The arc or circle being constrained.")


SketchRadialDimension.nativeObject = property(SketchRadialDimension._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SketchRadialDimension.cast = lambda arg: arg if isinstance(arg, SketchRadialDimension) else None

class SketchText(SketchEntity):
    r"""Text in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchText *":
        return _fusion.SketchText___deref__(self)

    def __eq__(self, rhs: "SketchText") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchText___eq__(self, rhs)


    def __ne__(self, rhs: "SketchText") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchText___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchText_classType()
    __swig_destroy__ = _fusion.delete_SketchText

    def _get_height(self) -> "double":
        r"""Gets and sets the height of the text in centimeters."""
        return _fusion.SketchText__get_height(self)

    def _set_height(self, value: "double") -> "bool":
        r"""Gets and sets the height of the text in centimeters."""
        return _fusion.SketchText__set_height(self, value)

    def _get_text(self) -> "std::string":
        r"""Gets and sets the text. This is a simple string and ignores any formatting defined within the text."""
        return _fusion.SketchText__get_text(self)

    def _set_text(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the text. This is a simple string and ignores any formatting defined within the text."""
        return _fusion.SketchText__set_text(self, value)

    def _get_position(self) -> "adsk::core::Ptr< adsk::core::Point3D >":
        r"""
        Gets and sets the position of the text on the x-y plane of the sketch. The text must lie on the x-y plane so the Z component
        of the point is ignored and always treated as zero.
        """
        return _fusion.SketchText__get_position(self)

    def _set_position(self, value: "Point3D") -> "bool":
        r"""
        Gets and sets the position of the text on the x-y plane of the sketch. The text must lie on the x-y plane so the Z component
        of the point is ignored and always treated as zero.
        """
        return _fusion.SketchText__set_position(self, value)

    def _get_fontName(self) -> "std::string":
        r"""Gets and sets the name of the font to use."""
        return _fusion.SketchText__get_fontName(self)

    def _set_fontName(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the name of the font to use."""
        return _fusion.SketchText__set_fontName(self, value)

    def _get_angle(self) -> "double":
        r"""Gets and sets the angle of the text relative to the x-axis of the x-y plane of the sketch."""
        return _fusion.SketchText__get_angle(self)

    def _set_angle(self, value: "double") -> "bool":
        r"""Gets and sets the angle of the text relative to the x-axis of the x-y plane of the sketch."""
        return _fusion.SketchText__set_angle(self, value)

    def _get_textStyle(self) -> "adsk::fusion::TextStyles":
        r"""
        Gets and sets the text style to apply to the entire text. This is a bitwise enum so styles
        can be combined to apply multiple styles. For example you can apply bold and underline.
        """
        return _fusion.SketchText__get_textStyle(self)

    def _set_textStyle(self, value: "TextStyles") -> "bool":
        r"""
        Gets and sets the text style to apply to the entire text. This is a bitwise enum so styles
        can be combined to apply multiple styles. For example you can apply bold and underline.
        """
        return _fusion.SketchText__set_textStyle(self, value)

    def _get_boundaryLines(self) -> "adsk::core::Ptr< adsk::fusion::SketchLineList >":
        r"""
        Returns the four sketch lines that define the boundary of the sketch text. By adding constraints to these lines
        you can associatively control the size, position and angle of the sketch text.
        """
        return _fusion.SketchText__get_boundaryLines(self)

    def explode(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve >,std::allocator< adsk::core::Ptr< adsk::fusion::SketchCurve > > >":
        r"""
        Explodes the SketchText into a set of curves. The original SketchText is deleted as a result of calling this. 
        Returns an array of the sketch curves that were created that represent the text.
        """
        return _fusion.SketchText_explode(self)

    def asCurves(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D >,std::allocator< adsk::core::Ptr< adsk::core::Curve3D > > >":
        r"""
        Returns the underlying curves that define the outline of the text. Calling this does not affect the
        SketchText and does not create any new sketch geometry but returns the geometrical definition of the
        sketch outline. 
        Returns an array of transient curves that represent the outline of the text.
        """
        return _fusion.SketchText_asCurves(self)

    def _get_isHorizontalFlip(self) -> "bool":
        r"""Gets and sets if the text is flipped horizontally."""
        return _fusion.SketchText__get_isHorizontalFlip(self)

    def _set_isHorizontalFlip(self, value: "bool") -> "bool":
        r"""Gets and sets if the text is flipped horizontally."""
        return _fusion.SketchText__set_isHorizontalFlip(self, value)

    def _get_isVerticalFlip(self) -> "bool":
        r"""Gets and sets if the text is flipped vertically."""
        return _fusion.SketchText__get_isVerticalFlip(self)

    def _set_isVerticalFlip(self, value: "bool") -> "bool":
        r"""Gets and sets if the text is flipped vertically."""
        return _fusion.SketchText__set_isVerticalFlip(self, value)

    def redefineAsFitOnPath(self, path: "Base", isAbovePath: "bool") -> "bool":
        r"""
        Sets this SketchTextInput to define text that fits along a specified path. Fitting on a path will
        space the characters so the text fits along the entire length of the path entity. 
        path : The entity that defines the path for the text. This can be a SketchCurve or BRepEdge object. 
        isAbovePath : Indicates if the text should be positioned above or below the path entity. 
        Returns true if the setting the definition was successful.
        """
        return _fusion.SketchText_redefineAsFitOnPath(self, path, isAbovePath)

    def redefineAsAlongPath(self, path: "Base", isAbovePath: "bool", horizontalAlignment: "HorizontalAlignments", characterSpacing: "double") -> "bool":
        r"""
        Sets this SketchTextInput to define text that follows along a specified path. 
        path : The entity that defines the path for the text. This can be a SketchCurve or BRepEdge object. 
        isAbovePath : Indicates if the text should be positioned above or below the path entity. 
        horizontalAlignment : Specifies the horizontal alignment of the text with respect to the path curve. 
        characterSpacing : The spacing between the characters. This is an additional spacing to apply that is defined
        as a percentage of the default spacing. A spacing of 0 indicates no additional spacing.
        A spacing of 50 indicates to use the default plus 50% of the default. 
        Returns true if the setting the definition was successful.
        """
        return _fusion.SketchText_redefineAsAlongPath(self, path, isAbovePath, horizontalAlignment, characterSpacing)

    def _get_definition(self) -> "adsk::core::Ptr< adsk::fusion::SketchTextDefinition >":
        r"""Gets the definition that is currently used to specify how the sketch text is defined."""
        return _fusion.SketchText__get_definition(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch."""
        return _fusion.SketchText__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >":
        r"""Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchText__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >":
        r"""Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchText__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool":
        r"""Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchText__get_is2D(self)

    def _get_isReference(self) -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchText__get_isReference(self)

    def _set_isReference(self, value: "bool") -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchText__set_isReference(self, value)

    def _get_isFixed(self) -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchText__get_isFixed(self)

    def _set_isFixed(self, value: "bool") -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchText__set_isFixed(self, value)

    def _get_isVisible(self) -> "bool":
        r"""
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchText__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchText__get_boundingBox(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchText_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchText__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchText__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool":
        r"""
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchText__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool":
        r"""Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchText__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.SketchText__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the SketchEntity object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same sketch entity.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SketchText__get_entityToken(self)

    def _get_isLinked(self) -> "bool":
        r"""
        Indicates if this sketch entity was created by a projection, inclusion, or driven by an API script.
        If this returns true, then the entity is presented to the user as not editable and with a 'break link'
        command available.
        """
        return _fusion.SketchText__get_isLinked(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchText__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchText__get_isValid(self)

# Register SketchText in _fusion:
_fusion.SketchText_swigregister(SketchText)

def SketchText_classType() -> "char const *":
    return _fusion.SketchText_classType()


SketchText.height = property(SketchText._get_height, SketchText._set_height, doc="Gets and sets the height of the text in centimeters.")


SketchText.text = property(SketchText._get_text, SketchText._set_text, doc="Gets and sets the text. This is a simple string and ignores any formatting defined within the text.")


SketchText.position = property(SketchText._get_position, SketchText._set_position, doc="Gets and sets the position of the text on the x-y plane of the sketch. The text must lie on the x-y plane so the Z component\nof the point is ignored and always treated as zero.")


SketchText.fontName = property(SketchText._get_fontName, SketchText._set_fontName, doc="Gets and sets the name of the font to use.")


SketchText.angle = property(SketchText._get_angle, SketchText._set_angle, doc="Gets and sets the angle of the text relative to the x-axis of the x-y plane of the sketch.")


SketchText.textStyle = property(SketchText._get_textStyle, SketchText._set_textStyle, doc="Gets and sets the text style to apply to the entire text. This is a bitwise enum so styles\ncan be combined to apply multiple styles. For example you can apply bold and underline.")


SketchText.boundaryLines = property(SketchText._get_boundaryLines, doc="Returns the four sketch lines that define the boundary of the sketch text. By adding constraints to these lines\nyou can associatively control the size, position and angle of the sketch text.")


SketchText.isHorizontalFlip = property(SketchText._get_isHorizontalFlip, SketchText._set_isHorizontalFlip, doc="Gets and sets if the text is flipped horizontally.")


SketchText.isVerticalFlip = property(SketchText._get_isVerticalFlip, SketchText._set_isVerticalFlip, doc="Gets and sets if the text is flipped vertically.")


SketchText.definition = property(SketchText._get_definition, doc="Gets the definition that is currently used to specify how the sketch text is defined.")


SketchText.cast = lambda arg: arg if isinstance(arg, SketchText) else None

class SliderJointMotion(JointMotion):
    r"""Represents the set of information specific to a slider joint."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SliderJointMotion *":
        return _fusion.SliderJointMotion___deref__(self)

    def __eq__(self, rhs: "SliderJointMotion") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SliderJointMotion___eq__(self, rhs)


    def __ne__(self, rhs: "SliderJointMotion") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SliderJointMotion___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SliderJointMotion_classType()
    __swig_destroy__ = _fusion.delete_SliderJointMotion

    def _get_slideDirection(self) -> "adsk::fusion::JointDirections":
        r"""
        Gets and sets the direction of the slide. This can be set to
        XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
        return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customSlideDirectionEntity will return an entity
        that defines the direction. If there is a custom direction defined and this
        property is set to one of the three standard axes, the custom direction will
        be removed and customSlideDirectionEntity will return null.
        """
        return _fusion.SliderJointMotion__get_slideDirection(self)

    def _set_slideDirection(self, value: "JointDirections") -> "bool":
        r"""
        Gets and sets the direction of the slide. This can be set to
        XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
        return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customSlideDirectionEntity will return an entity
        that defines the direction. If there is a custom direction defined and this
        property is set to one of the three standard axes, the custom direction will
        be removed and customSlideDirectionEntity will return null.
        """
        return _fusion.SliderJointMotion__set_slideDirection(self, value)

    def _get_slideDirectionVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Returns the direction of the slide. This property will return null in the case
        where the SliderJointMotion object was obtained from a JointInput object.
        """
        return _fusion.SliderJointMotion__get_slideDirectionVector(self)

    def _get_customSlideDirectionEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        This property can be set using various types of entities that can infer a
        direction. For example, a linear edge, sketch line, planar face, and cylindrical face.
        This property is only valid in the case where the slideDirection property returns
        CustomJointDirection. Setting this property will automatically set
        the slideDirection property to CustomJointDirection.
        """
        return _fusion.SliderJointMotion__get_customSlideDirectionEntity(self)

    def _set_customSlideDirectionEntity(self, value: "Base") -> "bool":
        r"""
        This property can be set using various types of entities that can infer a
        direction. For example, a linear edge, sketch line, planar face, and cylindrical face.
        This property is only valid in the case where the slideDirection property returns
        CustomJointDirection. Setting this property will automatically set
        the slideDirection property to CustomJointDirection.
        """
        return _fusion.SliderJointMotion__set_customSlideDirectionEntity(self, value)

    def _get_slideValue(self) -> "double":
        r"""
        Gets and sets the slide value. This is in centimeters. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.SliderJointMotion__get_slideValue(self)

    def _set_slideValue(self, value: "double") -> "bool":
        r"""
        Gets and sets the slide value. This is in centimeters. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.SliderJointMotion__set_slideValue(self, value)

    def _get_slideLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >":
        r"""
        Returns a JointLimits object that defines the slide limits for this joint.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.SliderJointMotion__get_slideLimits(self)

    def _get_jointType(self) -> "adsk::fusion::JointTypes":
        r"""Returns an enum value indicating the type of joint this joint represents."""
        return _fusion.SliderJointMotion__get_jointType(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SliderJointMotion__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SliderJointMotion__get_isValid(self)

# Register SliderJointMotion in _fusion:
_fusion.SliderJointMotion_swigregister(SliderJointMotion)

def SliderJointMotion_classType() -> "char const *":
    return _fusion.SliderJointMotion_classType()


SliderJointMotion.slideDirection = property(SliderJointMotion._get_slideDirection, SliderJointMotion._set_slideDirection, doc="Gets and sets the direction of the slide. This can be set to\nXAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can\nreturn those three directions and CustomJointDirection. If this returns\nCustomJointDirection then the customSlideDirectionEntity will return an entity\nthat defines the direction. If there is a custom direction defined and this\nproperty is set to one of the three standard axes, the custom direction will\nbe removed and customSlideDirectionEntity will return null.")


SliderJointMotion.slideDirectionVector = property(SliderJointMotion._get_slideDirectionVector, doc="Returns the direction of the slide. This property will return null in the case\nwhere the SliderJointMotion object was obtained from a JointInput object.")


SliderJointMotion.customSlideDirectionEntity = property(SliderJointMotion._get_customSlideDirectionEntity, SliderJointMotion._set_customSlideDirectionEntity, doc="This property can be set using various types of entities that can infer a\ndirection. For example, a linear edge, sketch line, planar face, and cylindrical face.\nThis property is only valid in the case where the slideDirection property returns\nCustomJointDirection. Setting this property will automatically set\nthe slideDirection property to CustomJointDirection.")


SliderJointMotion.slideValue = property(SliderJointMotion._get_slideValue, SliderJointMotion._set_slideValue, doc="Gets and sets the slide value. This is in centimeters. Setting this value is\nthe equivalent of using the Drive Joints command.")


SliderJointMotion.slideLimits = property(SliderJointMotion._get_slideLimits, doc="Returns a JointLimits object that defines the slide limits for this joint.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")


SliderJointMotion.cast = lambda arg: arg if isinstance(arg, SliderJointMotion) else None

class SmoothConstraint(GeometricConstraint):
    r"""A smooth constraint in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SmoothConstraint *":
        return _fusion.SmoothConstraint___deref__(self)

    def __eq__(self, rhs: "SmoothConstraint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SmoothConstraint___eq__(self, rhs)


    def __ne__(self, rhs: "SmoothConstraint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SmoothConstraint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SmoothConstraint_classType()
    __swig_destroy__ = _fusion.delete_SmoothConstraint

    def _get_curveOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >":
        r"""Returns the first curve."""
        return _fusion.SmoothConstraint__get_curveOne(self)

    def _get_curveTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >":
        r"""Returns the second curve."""
        return _fusion.SmoothConstraint__get_curveTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SmoothConstraint >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SmoothConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SmoothConstraint >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SmoothConstraint_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SmoothConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this constraint is deletable."""
        return _fusion.SmoothConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.SmoothConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SmoothConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.SmoothConstraint__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the GeometricConstraint object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same geometric constraint.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SmoothConstraint__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SmoothConstraint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SmoothConstraint__get_isValid(self)

# Register SmoothConstraint in _fusion:
_fusion.SmoothConstraint_swigregister(SmoothConstraint)

def SmoothConstraint_classType() -> "char const *":
    return _fusion.SmoothConstraint_classType()


SmoothConstraint.curveOne = property(SmoothConstraint._get_curveOne, doc="Returns the first curve.")


SmoothConstraint.curveTwo = property(SmoothConstraint._get_curveTwo, doc="Returns the second curve.")


SmoothConstraint.nativeObject = property(SmoothConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SmoothConstraint.cast = lambda arg: arg if isinstance(arg, SmoothConstraint) else None

class SMTExportOptions(ExportOptions):
    r"""Defines that an SMT export is to be done and specifies the various options."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SMTExportOptions *":
        return _fusion.SMTExportOptions___deref__(self)

    def __eq__(self, rhs: "SMTExportOptions") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SMTExportOptions___eq__(self, rhs)


    def __ne__(self, rhs: "SMTExportOptions") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SMTExportOptions___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SMTExportOptions_classType()
    __swig_destroy__ = _fusion.delete_SMTExportOptions

    def _get_version(self) -> "int":
        r"""
        Gets and set the version of the SMT format to write to. The default
        is to use the current version of the Autodesk Shape Manager kernel
        that Fusion 360 is using. Specifying an invalid version will result
        in an assert.
        Valid versions are 218 up to the current version, which is what this
        property returns by default when a new SMTExportOptions object is
        created.
        """
        return _fusion.SMTExportOptions__get_version(self)

    def _set_version(self, value: "int") -> "bool":
        r"""
        Gets and set the version of the SMT format to write to. The default
        is to use the current version of the Autodesk Shape Manager kernel
        that Fusion 360 is using. Specifying an invalid version will result
        in an assert.
        Valid versions are 218 up to the current version, which is what this
        property returns by default when a new SMTExportOptions object is
        created.
        """
        return _fusion.SMTExportOptions__set_version(self, value)

    def _get_filename(self) -> "std::string":
        r"""
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.SMTExportOptions__get_filename(self)

    def _set_filename(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.SMTExportOptions__set_filename(self, value)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Specifies the geometry to export. This can be an Occurrence, or the root Component. 
        For STL export, it can also be a BRepBody. For DXF export, it can be a sketch of flat pattern.
        """
        return _fusion.SMTExportOptions__get_geometry(self)

    def _set_geometry(self, value: "Base") -> "bool":
        r"""
        Specifies the geometry to export. This can be an Occurrence, or the root Component. 
        For STL export, it can also be a BRepBody. For DXF export, it can be a sketch of flat pattern.
        """
        return _fusion.SMTExportOptions__set_geometry(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.SMTExportOptions__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SMTExportOptions__get_isValid(self)

# Register SMTExportOptions in _fusion:
_fusion.SMTExportOptions_swigregister(SMTExportOptions)

def SMTExportOptions_classType() -> "char const *":
    return _fusion.SMTExportOptions_classType()


SMTExportOptions.version = property(SMTExportOptions._get_version, SMTExportOptions._set_version, doc="Gets and set the version of the SMT format to write to. The default\nis to use the current version of the Autodesk Shape Manager kernel\nthat Fusion 360 is using. Specifying an invalid version will result\nin an assert.\nValid versions are 218 up to the current version, which is what this\nproperty returns by default when a new SMTExportOptions object is\ncreated.")


SMTExportOptions.cast = lambda arg: arg if isinstance(arg, SMTExportOptions) else None

class SphereFeature(Feature):
    r"""Object that represents an existing sphere feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SphereFeature *":
        return _fusion.SphereFeature___deref__(self)

    def __eq__(self, rhs: "SphereFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SphereFeature___eq__(self, rhs)


    def __ne__(self, rhs: "SphereFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SphereFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SphereFeature_classType()
    __swig_destroy__ = _fusion.delete_SphereFeature

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SphereFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SphereFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.SphereFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.SphereFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SphereFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SphereFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.SphereFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.SphereFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.SphereFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.SphereFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SphereFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.SphereFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.SphereFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.SphereFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.SphereFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.SphereFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.SphereFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SphereFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SphereFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SphereFeature__get_isValid(self)

# Register SphereFeature in _fusion:
_fusion.SphereFeature_swigregister(SphereFeature)

def SphereFeature_classType() -> "char const *":
    return _fusion.SphereFeature_classType()


SphereFeature.cast = lambda arg: arg if isinstance(arg, SphereFeature) else None

class SplitBodyFeature(Feature):
    r"""Object that represents an existing split body feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SplitBodyFeature *":
        return _fusion.SplitBodyFeature___deref__(self)

    def __eq__(self, rhs: "SplitBodyFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SplitBodyFeature___eq__(self, rhs)


    def __ne__(self, rhs: "SplitBodyFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SplitBodyFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SplitBodyFeature_classType()
    __swig_destroy__ = _fusion.delete_SplitBodyFeature

    def _get_splitBodies(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the input solid or open bodies that are split.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SplitBodyFeature__get_splitBodies(self)

    def _set_splitBodies(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the input solid or open bodies that are split.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SplitBodyFeature__set_splitBodies(self, value)

    def setSplittingTool(self, splittingTool: "Base", isSplittingToolExtended: "bool") -> "bool":
        r"""
        Sets the splitting tool used for the feature.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        splittingTool : Input entity that defines the splitting tool. The splitting tool is a single entity that can be either a solid body,
        open body, construction plane, face, or sketch curve that partially or fully intersects the body to split. 
        isSplittingToolExtended : A boolean value for setting whether or not the splittingTool is to be automatically extended (if possible) so as to
        completely intersect the facesToSplit. 
        Returns true if successful.
        """
        return _fusion.SplitBodyFeature_setSplittingTool(self, splittingTool, isSplittingToolExtended)

    def _get_splittingTool(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets the entity that defines the splitting tool. The splitting tool is a single entity that can be either a 
        solid body, open body, plane, sketch curve or face that partially or fully intersects the bodyToSplit.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SplitBodyFeature__get_splittingTool(self)

    def _get_isSplittingToolExtended(self) -> "bool":
        r"""
        Gets whether or not the splitting tool is to be automatically extended (if possible) so as to
        completely intersect the bodyToSplit.
        """
        return _fusion.SplitBodyFeature__get_isSplittingToolExtended(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SplitBodyFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SplitBodyFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SplitBodyFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.SplitBodyFeature_createForAssemblyContext(self, occurrence)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SplitBodyFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SplitBodyFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.SplitBodyFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.SplitBodyFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SplitBodyFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SplitBodyFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.SplitBodyFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.SplitBodyFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.SplitBodyFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.SplitBodyFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SplitBodyFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.SplitBodyFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.SplitBodyFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.SplitBodyFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.SplitBodyFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.SplitBodyFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.SplitBodyFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SplitBodyFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SplitBodyFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SplitBodyFeature__get_isValid(self)

# Register SplitBodyFeature in _fusion:
_fusion.SplitBodyFeature_swigregister(SplitBodyFeature)

def SplitBodyFeature_classType() -> "char const *":
    return _fusion.SplitBodyFeature_classType()


SplitBodyFeature.splitBodies = property(SplitBodyFeature._get_splitBodies, SplitBodyFeature._set_splitBodies, doc="Gets and sets the input solid or open bodies that are split.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


SplitBodyFeature.splittingTool = property(SplitBodyFeature._get_splittingTool, doc="Gets the entity that defines the splitting tool. The splitting tool is a single entity that can be either a\nsolid body, open body, plane, sketch curve or face that partially or fully intersects the bodyToSplit.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


SplitBodyFeature.isSplittingToolExtended = property(SplitBodyFeature._get_isSplittingToolExtended, doc="Gets whether or not the splitting tool is to be automatically extended (if possible) so as to\ncompletely intersect the bodyToSplit.")


SplitBodyFeature.nativeObject = property(SplitBodyFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SplitBodyFeature.cast = lambda arg: arg if isinstance(arg, SplitBodyFeature) else None

class SplitFaceFeature(Feature):
    r"""Object that represents an existing split face feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SplitFaceFeature *":
        return _fusion.SplitFaceFeature___deref__(self)

    def __eq__(self, rhs: "SplitFaceFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SplitFaceFeature___eq__(self, rhs)


    def __ne__(self, rhs: "SplitFaceFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SplitFaceFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SplitFaceFeature_classType()
    __swig_destroy__ = _fusion.delete_SplitFaceFeature

    def _get_facesToSplit(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the faces to be split.
        The collection can contain one or more faces selected from solid and/or open bodies.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SplitFaceFeature__get_facesToSplit(self)

    def _set_facesToSplit(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the faces to be split.
        The collection can contain one or more faces selected from solid and/or open bodies.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SplitFaceFeature__set_facesToSplit(self, value)

    def setSplittingTool(self, splittingTool: "Base", isSplittingToolExtended: "bool") -> "bool":
        r"""
        Sets the splitting tool used for the feature.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        splittingTool : Input entity that defines the splitting tool. The splitting tool is a single entity that can be either a solid body,
        open body, construction plane, face, or sketch curve that partially or fully intersects the facesToSplit.
        The input for this argument can be one of the valid types or an ObjectCollection in the case where multiple splitting
        tools are being defined. 
        isSplittingToolExtended : A boolean value for setting whether or not the splittingTool is to be automatically extended (if possible) so as to
        completely intersect the facesToSplit. 
        Returns true if successful.
        """
        return _fusion.SplitFaceFeature_setSplittingTool(self, splittingTool, isSplittingToolExtended)

    def _get_splittingTool(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets the entity(s) that define the splitting tool(s). The splitting tool can consist of one or more of 
        the following: BRepBody, ConstructionPlane, BRepFace, sketch curve that extends or can
        be extended beyond the extents of the face. To set the splitting tool, use one of the set methods to
        also define the split type.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SplitFaceFeature__get_splittingTool(self)

    def _get_isSplittingToolExtended(self) -> "bool":
        r"""
        Gets whether or not the setting to automatically extend the splittingTool was set when the feature was created.
        This property is valid only when the splitType property returns surfaceIntersectionSplitType.
        """
        return _fusion.SplitFaceFeature__get_isSplittingToolExtended(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SplitFaceFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SplitFaceFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SplitFaceFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.SplitFaceFeature_createForAssemblyContext(self, occurrence)

    def setAsSurfaceIntersectionSplitType(self, splittingTool: "Base", isSplittingToolExtended: "bool") -> "bool":
        r"""
        Set the split type to be a surface to surface intersection. If the split tool is a curve
        it will be extruded into a surface to use in the split. If it's a surface, the surface will
        be used and optionally extended to fully intersect the faces to be split.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        splittingTool : Input entity(s) that defines the splitting tool. The splitting tool can be a single entity or an ObjectCollection
        containing solid and/or open bodies, construction planes, faces, or sketch curves that partially or fully intersect
        the faces that are being split. 
        isSplittingToolExtended : Specifies if the splitting tool should be extended so that is fully intersects the faces to be split. 
        Returns true is setting the split type was successful.
        """
        return _fusion.SplitFaceFeature_setAsSurfaceIntersectionSplitType(self, splittingTool, isSplittingToolExtended)

    def setAsAlongVectorSplitType(self, splittingTool: "Base", directionEntity: "Base") -> "bool":
        r"""
        Sets the split type to project the splitting tool along the direction defined by the
        specified entity.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        splittingTool : Input entity(s) that defines the splitting tool. The splitting tool can be a single entity or an ObjectCollection
        containing faces or sketch curves. If faces are input, the edges of the face are used as the splitting tool. 
        directionEntity : An entity that defines the direction of projection of the splitting tool. This can be
        a linear BRepEdge, SketchLine, ConstructionLine, or a planar face where the face
        normal is used. 
        Returns true is setting the split type was successful.
        """
        return _fusion.SplitFaceFeature_setAsAlongVectorSplitType(self, splittingTool, directionEntity)

    def setAsClosestPointSplitType(self, splittingTool: "Base") -> "bool":
        r"""
        Sets the split type to be a curve that defined by projecting the splitting curve to the
        closest point on the surface.
        To use this mehtod, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        splittingTool : Input entity(s) that defines the splitting tool. The splitting tool can be a single entity or an ObjectCollection
        containing faces or sketch curves. If faces are input, the edges of the face are used as the splitting tool. 
        Returns true if setting the closest point split type was successful.
        """
        return _fusion.SplitFaceFeature_setAsClosestPointSplitType(self, splittingTool)

    def _get_directionEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets the direction entity when the split type is along a vector. If the split type
        is not alongVectorSplitType this property will return null.
        To set the direction entity use the setAsAlongVectorSplitType method.
        """
        return _fusion.SplitFaceFeature__get_directionEntity(self)

    def _get_splitType(self) -> "adsk::fusion::SplitFaceSplitTypes":
        r"""
        Returns the type of split type currently defined. To change the split type, use
        one of the set methods.
        """
        return _fusion.SplitFaceFeature__get_splitType(self)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SplitFaceFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SplitFaceFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.SplitFaceFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.SplitFaceFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SplitFaceFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SplitFaceFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.SplitFaceFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.SplitFaceFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.SplitFaceFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.SplitFaceFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SplitFaceFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.SplitFaceFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.SplitFaceFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.SplitFaceFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.SplitFaceFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.SplitFaceFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.SplitFaceFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SplitFaceFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SplitFaceFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SplitFaceFeature__get_isValid(self)

# Register SplitFaceFeature in _fusion:
_fusion.SplitFaceFeature_swigregister(SplitFaceFeature)

def SplitFaceFeature_classType() -> "char const *":
    return _fusion.SplitFaceFeature_classType()


SplitFaceFeature.facesToSplit = property(SplitFaceFeature._get_facesToSplit, SplitFaceFeature._set_facesToSplit, doc="Gets and sets the faces to be split.\nThe collection can contain one or more faces selected from solid and/or open bodies.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


SplitFaceFeature.splittingTool = property(SplitFaceFeature._get_splittingTool, doc="Gets the entity(s) that define the splitting tool(s). The splitting tool can consist of one or more of\nthe following: BRepBody, ConstructionPlane, BRepFace, sketch curve that extends or can\nbe extended beyond the extents of the face. To set the splitting tool, use one of the set methods to\nalso define the split type.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


SplitFaceFeature.isSplittingToolExtended = property(SplitFaceFeature._get_isSplittingToolExtended, doc="Gets whether or not the setting to automatically extend the splittingTool was set when the feature was created.\nThis property is valid only when the splitType property returns surfaceIntersectionSplitType.")


SplitFaceFeature.nativeObject = property(SplitFaceFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SplitFaceFeature.directionEntity = property(SplitFaceFeature._get_directionEntity, doc="Gets the direction entity when the split type is along a vector. If the split type\nis not alongVectorSplitType this property will return null.\nTo set the direction entity use the setAsAlongVectorSplitType method.")


SplitFaceFeature.splitType = property(SplitFaceFeature._get_splitType, doc="Returns the type of split type currently defined. To change the split type, use\none of the set methods.")


SplitFaceFeature.cast = lambda arg: arg if isinstance(arg, SplitFaceFeature) else None

class STEPExportOptions(ExportOptions):
    r"""Defines that a STEP export is to be done and specifies the various options."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::STEPExportOptions *":
        return _fusion.STEPExportOptions___deref__(self)

    def __eq__(self, rhs: "STEPExportOptions") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.STEPExportOptions___eq__(self, rhs)


    def __ne__(self, rhs: "STEPExportOptions") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.STEPExportOptions___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.STEPExportOptions_classType()
    __swig_destroy__ = _fusion.delete_STEPExportOptions

    def _get_filename(self) -> "std::string":
        r"""
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.STEPExportOptions__get_filename(self)

    def _set_filename(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.STEPExportOptions__set_filename(self, value)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Specifies the geometry to export. This can be an Occurrence, or the root Component. 
        For STL export, it can also be a BRepBody. For DXF export, it can be a sketch of flat pattern.
        """
        return _fusion.STEPExportOptions__get_geometry(self)

    def _set_geometry(self, value: "Base") -> "bool":
        r"""
        Specifies the geometry to export. This can be an Occurrence, or the root Component. 
        For STL export, it can also be a BRepBody. For DXF export, it can be a sketch of flat pattern.
        """
        return _fusion.STEPExportOptions__set_geometry(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.STEPExportOptions__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.STEPExportOptions__get_isValid(self)

# Register STEPExportOptions in _fusion:
_fusion.STEPExportOptions_swigregister(STEPExportOptions)

def STEPExportOptions_classType() -> "char const *":
    return _fusion.STEPExportOptions_classType()


STEPExportOptions.cast = lambda arg: arg if isinstance(arg, STEPExportOptions) else None

class StitchFeature(Feature):
    r"""Object that represents an existing stitch feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::StitchFeature *":
        return _fusion.StitchFeature___deref__(self)

    def __eq__(self, rhs: "StitchFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.StitchFeature___eq__(self, rhs)


    def __ne__(self, rhs: "StitchFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.StitchFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.StitchFeature_classType()
    __swig_destroy__ = _fusion.delete_StitchFeature

    def _get_stitchSurfaces(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the surfaces to stitch together. In some cases the stitch operation results in 
        faces being merged so the original faces are no longer available after the feature is created.
        in this case you need to reposition the timeline marker to just before this feature
        when the faces do exist.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.StitchFeature__get_stitchSurfaces(self)

    def _set_stitchSurfaces(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the surfaces to stitch together. In some cases the stitch operation results in 
        faces being merged so the original faces are no longer available after the feature is created.
        in this case you need to reposition the timeline marker to just before this feature
        when the faces do exist.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.StitchFeature__set_stitchSurfaces(self, value)

    def _get_tolerance(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the parameter controlling the tolerance. You can edit the tolerance
        by editing the value of the parameter object.
        """
        return _fusion.StitchFeature__get_tolerance(self)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations":
        r"""
        Gets and sets the feature operation to perform. This property value is ignored if the stitched result does not 
        form a solid body.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.StitchFeature__get_operation(self)

    def _set_operation(self, value: "FeatureOperations") -> "bool":
        r"""
        Gets and sets the feature operation to perform. This property value is ignored if the stitched result does not 
        form a solid body.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.StitchFeature__set_operation(self, value)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::StitchFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.StitchFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::StitchFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.StitchFeature_createForAssemblyContext(self, occurrence)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.StitchFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.StitchFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.StitchFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.StitchFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.StitchFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.StitchFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.StitchFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.StitchFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.StitchFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.StitchFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.StitchFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.StitchFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.StitchFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.StitchFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.StitchFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.StitchFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.StitchFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.StitchFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.StitchFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.StitchFeature__get_isValid(self)

# Register StitchFeature in _fusion:
_fusion.StitchFeature_swigregister(StitchFeature)

def StitchFeature_classType() -> "char const *":
    return _fusion.StitchFeature_classType()


StitchFeature.stitchSurfaces = property(StitchFeature._get_stitchSurfaces, StitchFeature._set_stitchSurfaces, doc="Gets and sets the surfaces to stitch together. In some cases the stitch operation results in\nfaces being merged so the original faces are no longer available after the feature is created.\nin this case you need to reposition the timeline marker to just before this feature\nwhen the faces do exist.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


StitchFeature.tolerance = property(StitchFeature._get_tolerance, doc="Returns the parameter controlling the tolerance. You can edit the tolerance\nby editing the value of the parameter object.")


StitchFeature.operation = property(StitchFeature._get_operation, StitchFeature._set_operation, doc="Gets and sets the feature operation to perform. This property value is ignored if the stitched result does not\nform a solid body.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


StitchFeature.nativeObject = property(StitchFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


StitchFeature.cast = lambda arg: arg if isinstance(arg, StitchFeature) else None

class STLExportOptions(ExportOptions):
    r"""Defines that a STL export is to be done and specifies the various options."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::STLExportOptions *":
        return _fusion.STLExportOptions___deref__(self)

    def __eq__(self, rhs: "STLExportOptions") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.STLExportOptions___eq__(self, rhs)


    def __ne__(self, rhs: "STLExportOptions") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.STLExportOptions___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.STLExportOptions_classType()
    __swig_destroy__ = _fusion.delete_STLExportOptions

    def _get_isBinaryFormat(self) -> "bool":
        r"""Indicates if the STL file is to be an ASCII or binary STL format. The default is true."""
        return _fusion.STLExportOptions__get_isBinaryFormat(self)

    def _set_isBinaryFormat(self, value: "bool") -> "bool":
        r"""Indicates if the STL file is to be an ASCII or binary STL format. The default is true."""
        return _fusion.STLExportOptions__set_isBinaryFormat(self, value)

    def _get_isOneFilePerBody(self) -> "bool":
        r"""
        If the input is an Occurrence or the root Component, this specifies if a single file should be created containing
        all of the bodies within that occurrence or component or if multiple files should be created; one for each body.
        If multiple files are created, the body name is appended to the filename. The default is false.
        """
        return _fusion.STLExportOptions__get_isOneFilePerBody(self)

    def _set_isOneFilePerBody(self, value: "bool") -> "bool":
        r"""
        If the input is an Occurrence or the root Component, this specifies if a single file should be created containing
        all of the bodies within that occurrence or component or if multiple files should be created; one for each body.
        If multiple files are created, the body name is appended to the filename. The default is false.
        """
        return _fusion.STLExportOptions__set_isOneFilePerBody(self, value)

    def _get_meshRefinement(self) -> "adsk::fusion::MeshRefinementSettings":
        r"""
        Gets and sets the current simple mesh refinement settings. Setting this property
        will reset the surfaceDeviation, normalDeviation, maximumEdgeLength, and aspectRatio
        to values that correspond to the specified mesh refinement. The default is MeshRefinementMedium
        """
        return _fusion.STLExportOptions__get_meshRefinement(self)

    def _set_meshRefinement(self, value: "MeshRefinementSettings") -> "bool":
        r"""
        Gets and sets the current simple mesh refinement settings. Setting this property
        will reset the surfaceDeviation, normalDeviation, maximumEdgeLength, and aspectRatio
        to values that correspond to the specified mesh refinement. The default is MeshRefinementMedium
        """
        return _fusion.STLExportOptions__set_meshRefinement(self, value)

    def _get_surfaceDeviation(self) -> "double":
        r"""
        Gets and sets the current surface deviation, or the distance the mesh can deviate
        from the actual surface. This is defined in centimetre. Setting this property
        will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
        associated with medium mesh refinement.
        """
        return _fusion.STLExportOptions__get_surfaceDeviation(self)

    def _set_surfaceDeviation(self, value: "double") -> "bool":
        r"""
        Gets and sets the current surface deviation, or the distance the mesh can deviate
        from the actual surface. This is defined in centimetre. Setting this property
        will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
        associated with medium mesh refinement.
        """
        return _fusion.STLExportOptions__set_surfaceDeviation(self, value)

    def _get_normalDeviation(self) -> "double":
        r"""
        Gets and sets the current normal deviation, or the angle the mesh normals at the vertices can deviate
        from the actual surface normals. This is defined in radians. Setting this property
        will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
        associated with medium mesh refinement.
        """
        return _fusion.STLExportOptions__get_normalDeviation(self)

    def _set_normalDeviation(self, value: "double") -> "bool":
        r"""
        Gets and sets the current normal deviation, or the angle the mesh normals at the vertices can deviate
        from the actual surface normals. This is defined in radians. Setting this property
        will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
        associated with medium mesh refinement.
        """
        return _fusion.STLExportOptions__set_normalDeviation(self, value)

    def _get_maximumEdgeLength(self) -> "double":
        r"""
        Gets and sets the maximum length of any mesh edge. This is defined in centimetre. Setting this property
        will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
        associated with medium mesh refinement.
        """
        return _fusion.STLExportOptions__get_maximumEdgeLength(self)

    def _set_maximumEdgeLength(self, value: "double") -> "bool":
        r"""
        Gets and sets the maximum length of any mesh edge. This is defined in centimetre. Setting this property
        will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
        associated with medium mesh refinement.
        """
        return _fusion.STLExportOptions__set_maximumEdgeLength(self, value)

    def _get_aspectRatio(self) -> "double":
        r"""
        Gets and sets the minimum aspect ratio for that triangles that are generated for the mesh. Setting this property
        will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
        associated with medium mesh refinement.
        """
        return _fusion.STLExportOptions__get_aspectRatio(self)

    def _set_aspectRatio(self, value: "double") -> "bool":
        r"""
        Gets and sets the minimum aspect ratio for that triangles that are generated for the mesh. Setting this property
        will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
        associated with medium mesh refinement.
        """
        return _fusion.STLExportOptions__set_aspectRatio(self, value)

    def _get_availablePrintUtilities(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Returns a list of the known available print utilities. These strings can be used to set the PrintUtility
        property to specify which print utility to open the STL file in.
        """
        return _fusion.STLExportOptions__get_availablePrintUtilities(self)

    def _get_printUtility(self) -> "std::string":
        r"""
        Specifies which print utility to use when opening the STL file if the sendToPrintUtility property is true.
        The value of this property can be one of the strings returned by the availalbePrintUtilities property, which
        will specify one of the know print utilities. You can also specify a custom print utility by specifying
        the full path to the print utility executable. The default value of this property is the last setting specified
        in the user-interface.
        """
        return _fusion.STLExportOptions__get_printUtility(self)

    def _set_printUtility(self, value: "std::string const &") -> "bool":
        r"""
        Specifies which print utility to use when opening the STL file if the sendToPrintUtility property is true.
        The value of this property can be one of the strings returned by the availalbePrintUtilities property, which
        will specify one of the know print utilities. You can also specify a custom print utility by specifying
        the full path to the print utility executable. The default value of this property is the last setting specified
        in the user-interface.
        """
        return _fusion.STLExportOptions__set_printUtility(self, value)

    def _get_sendToPrintUtility(self) -> "bool":
        r"""
        Gets and sets whether the created STL file will be sent to the print utility specified by the printUtility property. If this
        is false a filename must be defined.
        """
        return _fusion.STLExportOptions__get_sendToPrintUtility(self)

    def _set_sendToPrintUtility(self, value: "bool") -> "bool":
        r"""
        Gets and sets whether the created STL file will be sent to the print utility specified by the printUtility property. If this
        is false a filename must be defined.
        """
        return _fusion.STLExportOptions__set_sendToPrintUtility(self, value)

    def _get_filename(self) -> "std::string":
        r"""
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.STLExportOptions__get_filename(self)

    def _set_filename(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.STLExportOptions__set_filename(self, value)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Specifies the geometry to export. This can be an Occurrence, or the root Component. 
        For STL export, it can also be a BRepBody. For DXF export, it can be a sketch of flat pattern.
        """
        return _fusion.STLExportOptions__get_geometry(self)

    def _set_geometry(self, value: "Base") -> "bool":
        r"""
        Specifies the geometry to export. This can be an Occurrence, or the root Component. 
        For STL export, it can also be a BRepBody. For DXF export, it can be a sketch of flat pattern.
        """
        return _fusion.STLExportOptions__set_geometry(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.STLExportOptions__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.STLExportOptions__get_isValid(self)

# Register STLExportOptions in _fusion:
_fusion.STLExportOptions_swigregister(STLExportOptions)

def STLExportOptions_classType() -> "char const *":
    return _fusion.STLExportOptions_classType()


STLExportOptions.isBinaryFormat = property(STLExportOptions._get_isBinaryFormat, STLExportOptions._set_isBinaryFormat, doc="Indicates if the STL file is to be an ASCII or binary STL format. The default is true.")


STLExportOptions.isOneFilePerBody = property(STLExportOptions._get_isOneFilePerBody, STLExportOptions._set_isOneFilePerBody, doc="If the input is an Occurrence or the root Component, this specifies if a single file should be created containing\nall of the bodies within that occurrence or component or if multiple files should be created; one for each body.\nIf multiple files are created, the body name is appended to the filename. The default is false.")


STLExportOptions.meshRefinement = property(STLExportOptions._get_meshRefinement, STLExportOptions._set_meshRefinement, doc="Gets and sets the current simple mesh refinement settings. Setting this property\nwill reset the surfaceDeviation, normalDeviation, maximumEdgeLength, and aspectRatio\nto values that correspond to the specified mesh refinement. The default is MeshRefinementMedium")


STLExportOptions.surfaceDeviation = property(STLExportOptions._get_surfaceDeviation, STLExportOptions._set_surfaceDeviation, doc="Gets and sets the current surface deviation, or the distance the mesh can deviate\nfrom the actual surface. This is defined in centimetre. Setting this property\nwill automatically set the meshRefinement to MeshRefinementCustom. The default is the value\nassociated with medium mesh refinement.")


STLExportOptions.normalDeviation = property(STLExportOptions._get_normalDeviation, STLExportOptions._set_normalDeviation, doc="Gets and sets the current normal deviation, or the angle the mesh normals at the vertices can deviate\nfrom the actual surface normals. This is defined in radians. Setting this property\nwill automatically set the meshRefinement to MeshRefinementCustom. The default is the value\nassociated with medium mesh refinement.")


STLExportOptions.maximumEdgeLength = property(STLExportOptions._get_maximumEdgeLength, STLExportOptions._set_maximumEdgeLength, doc="Gets and sets the maximum length of any mesh edge. This is defined in centimetre. Setting this property\nwill automatically set the meshRefinement to MeshRefinementCustom. The default is the value\nassociated with medium mesh refinement.")


STLExportOptions.aspectRatio = property(STLExportOptions._get_aspectRatio, STLExportOptions._set_aspectRatio, doc="Gets and sets the minimum aspect ratio for that triangles that are generated for the mesh. Setting this property\nwill automatically set the meshRefinement to MeshRefinementCustom. The default is the value\nassociated with medium mesh refinement.")


STLExportOptions.availablePrintUtilities = property(STLExportOptions._get_availablePrintUtilities, doc="Returns a list of the known available print utilities. These strings can be used to set the PrintUtility\nproperty to specify which print utility to open the STL file in.")


STLExportOptions.printUtility = property(STLExportOptions._get_printUtility, STLExportOptions._set_printUtility, doc="Specifies which print utility to use when opening the STL file if the sendToPrintUtility property is true.\nThe value of this property can be one of the strings returned by the availalbePrintUtilities property, which\nwill specify one of the know print utilities. You can also specify a custom print utility by specifying\nthe full path to the print utility executable. The default value of this property is the last setting specified\nin the user-interface.")


STLExportOptions.sendToPrintUtility = property(STLExportOptions._get_sendToPrintUtility, STLExportOptions._set_sendToPrintUtility, doc="Gets and sets whether the created STL file will be sent to the print utility specified by the printUtility property. If this\nis false a filename must be defined.")


STLExportOptions.cast = lambda arg: arg if isinstance(arg, STLExportOptions) else None

class SurfaceDeleteFaceFeature(Feature):
    r"""
    Object that represents an existing Surface Delete Face feature in a design.
    The SurfaceDeleteFaceFeature and DeleteFaceFeature differ in that the SurfaceDeleteFaceFeature
    can delete any face without any restrictions. If the body is a solid, it will become a surface
    when the first face is deleted. The specified face is deleted without any other changes being
    made to the body. The DeleteFaceFeature deletes the specified face and also modifies the other faces
    in the body to heal or fill in the area of the deleted face. This means that a solid body will
    remain solid.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SurfaceDeleteFaceFeature *":
        return _fusion.SurfaceDeleteFaceFeature___deref__(self)

    def __eq__(self, rhs: "SurfaceDeleteFaceFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SurfaceDeleteFaceFeature___eq__(self, rhs)


    def __ne__(self, rhs: "SurfaceDeleteFaceFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SurfaceDeleteFaceFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SurfaceDeleteFaceFeature_classType()
    __swig_destroy__ = _fusion.delete_SurfaceDeleteFaceFeature

    def _get_deletedFaces(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepFace > > >":
        r"""
        Gets and sets the set of faces that are deleted by this feature.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SurfaceDeleteFaceFeature__get_deletedFaces(self)

    def _set_deletedFaces(self, value: "BRepFaceVector") -> "bool":
        r"""
        Gets and sets the set of faces that are deleted by this feature.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SurfaceDeleteFaceFeature__set_deletedFaces(self, value)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SurfaceDeleteFaceFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SurfaceDeleteFaceFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SurfaceDeleteFaceFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.SurfaceDeleteFaceFeature_createForAssemblyContext(self, occurrence)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SurfaceDeleteFaceFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SurfaceDeleteFaceFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.SurfaceDeleteFaceFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.SurfaceDeleteFaceFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SurfaceDeleteFaceFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SurfaceDeleteFaceFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.SurfaceDeleteFaceFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.SurfaceDeleteFaceFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.SurfaceDeleteFaceFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.SurfaceDeleteFaceFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SurfaceDeleteFaceFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.SurfaceDeleteFaceFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.SurfaceDeleteFaceFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.SurfaceDeleteFaceFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.SurfaceDeleteFaceFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.SurfaceDeleteFaceFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.SurfaceDeleteFaceFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SurfaceDeleteFaceFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SurfaceDeleteFaceFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SurfaceDeleteFaceFeature__get_isValid(self)

# Register SurfaceDeleteFaceFeature in _fusion:
_fusion.SurfaceDeleteFaceFeature_swigregister(SurfaceDeleteFaceFeature)

def SurfaceDeleteFaceFeature_classType() -> "char const *":
    return _fusion.SurfaceDeleteFaceFeature_classType()


SurfaceDeleteFaceFeature.deletedFaces = property(SurfaceDeleteFaceFeature._get_deletedFaces, SurfaceDeleteFaceFeature._set_deletedFaces, doc="Gets and sets the set of faces that are deleted by this feature.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


SurfaceDeleteFaceFeature.nativeObject = property(SurfaceDeleteFaceFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SurfaceDeleteFaceFeature.cast = lambda arg: arg if isinstance(arg, SurfaceDeleteFaceFeature) else None

class SweepFeature(Feature):
    r"""Object that represents an existing sweep feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SweepFeature *":
        return _fusion.SweepFeature___deref__(self)

    def __eq__(self, rhs: "SweepFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SweepFeature___eq__(self, rhs)


    def __ne__(self, rhs: "SweepFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SweepFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SweepFeature_classType()
    __swig_destroy__ = _fusion.delete_SweepFeature

    def _get_profile(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the profiles or planar faces used to define the shape of the sweep.
        This property can return or be set with a single Profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        This property returns nothing in the case where the feature is non-parametric.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SweepFeature__get_profile(self)

    def _set_profile(self, value: "Base") -> "bool":
        r"""
        Gets and sets the profiles or planar faces used to define the shape of the sweep.
        This property can return or be set with a single Profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        This property returns nothing in the case where the feature is non-parametric.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SweepFeature__set_profile(self, value)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations":
        r"""Gets and sets the type of operation performed by the sweep."""
        return _fusion.SweepFeature__get_operation(self)

    def _set_operation(self, value: "FeatureOperations") -> "bool":
        r"""Gets and sets the type of operation performed by the sweep."""
        return _fusion.SweepFeature__set_operation(self, value)

    def _get_path(self) -> "adsk::core::Ptr< adsk::fusion::Path >":
        r"""
        Gets and sets the path to create the sweep.
        This property returns nothing in the case where the feature is non-parametric.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SweepFeature__get_path(self)

    def _set_path(self, value: "Path") -> "bool":
        r"""
        Gets and sets the path to create the sweep.
        This property returns nothing in the case where the feature is non-parametric.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SweepFeature__set_path(self, value)

    def _get_distanceOne(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the distance for the first side.
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.SweepFeature__get_distanceOne(self)

    def _get_distanceTwo(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the distance for the second side.
        Returns nothing if the path is only on one side of the profile or if the sweep definition includes a guide rail.
        It's always the distance against the normal of the profile if available.
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.SweepFeature__get_distanceTwo(self)

    def _get_orientation(self) -> "adsk::fusion::SweepOrientationTypes":
        r"""
        Gets and sets the sweep orientation. It defaults to PerpendicularOrientationType.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SweepFeature__get_orientation(self)

    def _set_orientation(self, value: "SweepOrientationTypes") -> "bool":
        r"""
        Gets and sets the sweep orientation. It defaults to PerpendicularOrientationType.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SweepFeature__set_orientation(self, value)

    def _get_startFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Property that returns the set of that cap one end of the sweep that are coincident with the sketch plane. 
        In the cases where there aren't any start faces this property will return Nothing.
        """
        return _fusion.SweepFeature__get_startFaces(self)

    def _get_endFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Property that returns the set of that cap one end of the sweep that are coincident with the sketch plane. 
        The end faces are those not coincident to the sketch plane of the feature's profile. 
        In the case of a symmetric revolution these faces are the ones on the negative normal side of the sketch plane. 
        In the cases where there aren't any end faces this property will return Nothing.
        """
        return _fusion.SweepFeature__get_endFaces(self)

    def _get_sideFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""Property that returns a object that provides access to all of the faces created around the perimeter of the feature."""
        return _fusion.SweepFeature__get_sideFaces(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SweepFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SweepFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SweepFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SweepFeature_createForAssemblyContext(self, occurrence)

    def _get_isSolid(self) -> "bool":
        r"""Indicates if this feature was initially created as a solid or a surface."""
        return _fusion.SweepFeature__get_isSolid(self)

    def _get_guideRail(self) -> "adsk::core::Ptr< adsk::fusion::Path >":
        r"""
        Gets and sets the guide rail to create the sweep. This can be set to null
        to have a path only sweep.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SweepFeature__get_guideRail(self)

    def _set_guideRail(self, value: "Path") -> "bool":
        r"""
        Gets and sets the guide rail to create the sweep. This can be set to null
        to have a path only sweep.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SweepFeature__set_guideRail(self, value)

    def _get_isDirectionFlipped(self) -> "bool":
        r"""
        Gets and sets if the direction of the sweep is flipped. 
        This property only applies to sweep features that include a guide rail and whose path runs on both 
        sides of the profile.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SweepFeature__get_isDirectionFlipped(self)

    def _set_isDirectionFlipped(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the direction of the sweep is flipped. 
        This property only applies to sweep features that include a guide rail and whose path runs on both 
        sides of the profile.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SweepFeature__set_isDirectionFlipped(self, value)

    def _get_profileScaling(self) -> "adsk::fusion::SweepProfileScalingOptions":
        r"""
        Gets and sets the sweep profile scaling option. It defaults to SweepProfileScaleOption. This
        property is only used when a guide rail has been specified.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SweepFeature__get_profileScaling(self)

    def _set_profileScaling(self, value: "SweepProfileScalingOptions") -> "bool":
        r"""
        Gets and sets the sweep profile scaling option. It defaults to SweepProfileScaleOption. This
        property is only used when a guide rail has been specified.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SweepFeature__set_profileScaling(self, value)

    def _get_participantBodies(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepBody > > >":
        r"""
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SweepFeature__get_participantBodies(self)

    def _set_participantBodies(self, value: "BRepBodyVector") -> "bool":
        r"""
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SweepFeature__set_participantBodies(self, value)

    def _get_taperAngle(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the ModelParameter that defines the taper angle of the sweep feature.
        The value of the angle can be edited by using the properties on the ModelParameter object to edit the parameter.
        """
        return _fusion.SweepFeature__get_taperAngle(self)

    def _get_twistAngle(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the ModelParameter that defines the twist angle of the sweep feature.
        The value of the angle can be edited by using the properties on the ModelParameter object to edit the parameter.
        """
        return _fusion.SweepFeature__get_twistAngle(self)

    def _get_extent(self) -> "adsk::fusion::SweepExtentTypes":
        r"""
        Gets and sets the sweep extent type. It defaults to PerpendicularToPathExtentType.
        This property is ignored when a guide rail has not been specified.
        """
        return _fusion.SweepFeature__get_extent(self)

    def _set_extent(self, value: "SweepExtentTypes") -> "bool":
        r"""
        Gets and sets the sweep extent type. It defaults to PerpendicularToPathExtentType.
        This property is ignored when a guide rail has not been specified.
        """
        return _fusion.SweepFeature__set_extent(self, value)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SweepFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SweepFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.SweepFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.SweepFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SweepFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SweepFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.SweepFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.SweepFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.SweepFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.SweepFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SweepFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.SweepFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.SweepFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.SweepFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.SweepFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.SweepFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.SweepFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SweepFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SweepFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SweepFeature__get_isValid(self)

# Register SweepFeature in _fusion:
_fusion.SweepFeature_swigregister(SweepFeature)

def SweepFeature_classType() -> "char const *":
    return _fusion.SweepFeature_classType()


SweepFeature.profile = property(SweepFeature._get_profile, SweepFeature._set_profile, doc="Gets and sets the profiles or planar faces used to define the shape of the sweep.\nThis property can return or be set with a single Profile, a single planar face, or\nan ObjectCollection consisting of multiple profiles and planar faces. When an\nObjectCollection is used all of the profiles and faces must be co-planar.\nThis property returns nothing in the case where the feature is non-parametric.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


SweepFeature.operation = property(SweepFeature._get_operation, SweepFeature._set_operation, doc="Gets and sets the type of operation performed by the sweep.")


SweepFeature.path = property(SweepFeature._get_path, SweepFeature._set_path, doc="Gets and sets the path to create the sweep.\nThis property returns nothing in the case where the feature is non-parametric.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


SweepFeature.distanceOne = property(SweepFeature._get_distanceOne, doc="Gets the distance for the first side.\nThis property returns nothing in the case where the feature is non-parametric.")


SweepFeature.distanceTwo = property(SweepFeature._get_distanceTwo, doc="Gets the distance for the second side.\nReturns nothing if the path is only on one side of the profile or if the sweep definition includes a guide rail.\nIt's always the distance against the normal of the profile if available.\nThis property returns nothing in the case where the feature is non-parametric.")


SweepFeature.orientation = property(SweepFeature._get_orientation, SweepFeature._set_orientation, doc="Gets and sets the sweep orientation. It defaults to PerpendicularOrientationType.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


SweepFeature.startFaces = property(SweepFeature._get_startFaces, doc="Property that returns the set of that cap one end of the sweep that are coincident with the sketch plane.\nIn the cases where there aren't any start faces this property will return Nothing.")


SweepFeature.endFaces = property(SweepFeature._get_endFaces, doc="Property that returns the set of that cap one end of the sweep that are coincident with the sketch plane.\nThe end faces are those not coincident to the sketch plane of the feature's profile.\nIn the case of a symmetric revolution these faces are the ones on the negative normal side of the sketch plane.\nIn the cases where there aren't any end faces this property will return Nothing.")


SweepFeature.sideFaces = property(SweepFeature._get_sideFaces, doc="Property that returns a object that provides access to all of the faces created around the perimeter of the feature.")


SweepFeature.nativeObject = property(SweepFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SweepFeature.isSolid = property(SweepFeature._get_isSolid, doc="Indicates if this feature was initially created as a solid or a surface.")


SweepFeature.guideRail = property(SweepFeature._get_guideRail, SweepFeature._set_guideRail, doc="Gets and sets the guide rail to create the sweep. This can be set to null\nto have a path only sweep.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


SweepFeature.isDirectionFlipped = property(SweepFeature._get_isDirectionFlipped, SweepFeature._set_isDirectionFlipped, doc="Gets and sets if the direction of the sweep is flipped.\nThis property only applies to sweep features that include a guide rail and whose path runs on both\nsides of the profile.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


SweepFeature.profileScaling = property(SweepFeature._get_profileScaling, SweepFeature._set_profileScaling, doc="Gets and sets the sweep profile scaling option. It defaults to SweepProfileScaleOption. This\nproperty is only used when a guide rail has been specified.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


SweepFeature.participantBodies = property(SweepFeature._get_participantBodies, SweepFeature._set_participantBodies, doc="Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


SweepFeature.taperAngle = property(SweepFeature._get_taperAngle, doc="Gets the ModelParameter that defines the taper angle of the sweep feature.\nThe value of the angle can be edited by using the properties on the ModelParameter object to edit the parameter.")


SweepFeature.twistAngle = property(SweepFeature._get_twistAngle, doc="Gets the ModelParameter that defines the twist angle of the sweep feature.\nThe value of the angle can be edited by using the properties on the ModelParameter object to edit the parameter.")


SweepFeature.extent = property(SweepFeature._get_extent, SweepFeature._set_extent, doc="Gets and sets the sweep extent type. It defaults to PerpendicularToPathExtentType.\nThis property is ignored when a guide rail has not been specified.")


SweepFeature.cast = lambda arg: arg if isinstance(arg, SweepFeature) else None

class SymmetricExtentDefinition(ExtentDefinition):
    r"""A definition object that is used to define the extents of a feature to be symmetric."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SymmetricExtentDefinition *":
        return _fusion.SymmetricExtentDefinition___deref__(self)

    def __eq__(self, rhs: "SymmetricExtentDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SymmetricExtentDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "SymmetricExtentDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SymmetricExtentDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SymmetricExtentDefinition_classType()

    @staticmethod
    def create(distance: "ValueInput", isFullLength: "bool") -> "adsk::core::Ptr< adsk::core::ValueInput > const &":
        return _fusion.SymmetricExtentDefinition_create(distance, isFullLength)
    __swig_destroy__ = _fusion.delete_SymmetricExtentDefinition

    def _get_isFullLength(self) -> "bool":
        r"""
        Gets and sets if the distance defines the full extent length or half the length. A value of
        True indicates if defines the full length.
        """
        return _fusion.SymmetricExtentDefinition__get_isFullLength(self)

    def _set_isFullLength(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the distance defines the full extent length or half the length. A value of
        True indicates if defines the full length.
        """
        return _fusion.SymmetricExtentDefinition__set_isFullLength(self, value)

    def _get_distance(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the current extent distance. If the SymmetricExtentDefinition object has been created statically and isn't associated with
        a feature this will return a ValueInput object. If the SymmetricExtentDefinition object is obtained from a feature this
        will return a ModelParameter object. You can use properties of the parameter to edit it's value which will result in
        the feature updating.
        """
        return _fusion.SymmetricExtentDefinition__get_distance(self)

    def _get_taperAngle(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the current taper angle. If the SymmetricExtentDefinition object has been created statically and isn't associated with
        a feature this will return a ValueInput object. If the SymmetricExtentDefinition object is obtained from a feature this
        will return a ModelParameter object. You can use properties of the parameter to edit it's value which will result in
        the feature updating.
        """
        return _fusion.SymmetricExtentDefinition__get_taperAngle(self)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >":
        r"""
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.SymmetricExtentDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SymmetricExtentDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SymmetricExtentDefinition__get_isValid(self)

# Register SymmetricExtentDefinition in _fusion:
_fusion.SymmetricExtentDefinition_swigregister(SymmetricExtentDefinition)

def SymmetricExtentDefinition_classType() -> "char const *":
    return _fusion.SymmetricExtentDefinition_classType()

def SymmetricExtentDefinition_create(distance: "ValueInput", isFullLength: "bool") -> "adsk::core::Ptr< adsk::core::ValueInput > const &":
    return _fusion.SymmetricExtentDefinition_create(distance, isFullLength)


SymmetricExtentDefinition.isFullLength = property(SymmetricExtentDefinition._get_isFullLength, SymmetricExtentDefinition._set_isFullLength, doc="Gets and sets if the distance defines the full extent length or half the length. A value of\nTrue indicates if defines the full length.")


SymmetricExtentDefinition.distance = property(SymmetricExtentDefinition._get_distance, doc="Returns the current extent distance. If the SymmetricExtentDefinition object has been created statically and isn't associated with\na feature this will return a ValueInput object. If the SymmetricExtentDefinition object is obtained from a feature this\nwill return a ModelParameter object. You can use properties of the parameter to edit it's value which will result in\nthe feature updating.")


SymmetricExtentDefinition.taperAngle = property(SymmetricExtentDefinition._get_taperAngle, doc="Returns the current taper angle. If the SymmetricExtentDefinition object has been created statically and isn't associated with\na feature this will return a ValueInput object. If the SymmetricExtentDefinition object is obtained from a feature this\nwill return a ModelParameter object. You can use properties of the parameter to edit it's value which will result in\nthe feature updating.")


SymmetricExtentDefinition.cast = lambda arg: arg if isinstance(arg, SymmetricExtentDefinition) else None

class SymmetryConstraint(GeometricConstraint):
    r"""A symmetry constraint in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SymmetryConstraint *":
        return _fusion.SymmetryConstraint___deref__(self)

    def __eq__(self, rhs: "SymmetryConstraint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SymmetryConstraint___eq__(self, rhs)


    def __ne__(self, rhs: "SymmetryConstraint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SymmetryConstraint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SymmetryConstraint_classType()
    __swig_destroy__ = _fusion.delete_SymmetryConstraint

    def _get_entityOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchEntity >":
        r"""Returns the first curve."""
        return _fusion.SymmetryConstraint__get_entityOne(self)

    def _get_entityTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchEntity >":
        r"""Returns the second curve."""
        return _fusion.SymmetryConstraint__get_entityTwo(self)

    def _get_symmetryLine(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""Returns the axis (SketchLine) that defines the symmetry."""
        return _fusion.SymmetryConstraint__get_symmetryLine(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SymmetryConstraint >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SymmetryConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SymmetryConstraint >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SymmetryConstraint_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SymmetryConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this constraint is deletable."""
        return _fusion.SymmetryConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.SymmetryConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SymmetryConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.SymmetryConstraint__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the GeometricConstraint object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same geometric constraint.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SymmetryConstraint__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SymmetryConstraint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SymmetryConstraint__get_isValid(self)

# Register SymmetryConstraint in _fusion:
_fusion.SymmetryConstraint_swigregister(SymmetryConstraint)

def SymmetryConstraint_classType() -> "char const *":
    return _fusion.SymmetryConstraint_classType()


SymmetryConstraint.entityOne = property(SymmetryConstraint._get_entityOne, doc="Returns the first curve.")


SymmetryConstraint.entityTwo = property(SymmetryConstraint._get_entityTwo, doc="Returns the second curve.")


SymmetryConstraint.symmetryLine = property(SymmetryConstraint._get_symmetryLine, doc="Returns the axis (SketchLine) that defines the symmetry.")


SymmetryConstraint.nativeObject = property(SymmetryConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SymmetryConstraint.cast = lambda arg: arg if isinstance(arg, SymmetryConstraint) else None

class TangentConstraint(GeometricConstraint):
    r"""A tangent constraint in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::TangentConstraint *":
        return _fusion.TangentConstraint___deref__(self)

    def __eq__(self, rhs: "TangentConstraint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.TangentConstraint___eq__(self, rhs)


    def __ne__(self, rhs: "TangentConstraint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.TangentConstraint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.TangentConstraint_classType()
    __swig_destroy__ = _fusion.delete_TangentConstraint

    def _get_curveOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >":
        r"""Returns the first curve."""
        return _fusion.TangentConstraint__get_curveOne(self)

    def _get_curveTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >":
        r"""Returns the second curve."""
        return _fusion.TangentConstraint__get_curveTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::TangentConstraint >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.TangentConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::TangentConstraint >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.TangentConstraint_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.TangentConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this constraint is deletable."""
        return _fusion.TangentConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.TangentConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.TangentConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.TangentConstraint__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the GeometricConstraint object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same geometric constraint.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.TangentConstraint__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.TangentConstraint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.TangentConstraint__get_isValid(self)

# Register TangentConstraint in _fusion:
_fusion.TangentConstraint_swigregister(TangentConstraint)

def TangentConstraint_classType() -> "char const *":
    return _fusion.TangentConstraint_classType()


TangentConstraint.curveOne = property(TangentConstraint._get_curveOne, doc="Returns the first curve.")


TangentConstraint.curveTwo = property(TangentConstraint._get_curveTwo, doc="Returns the second curve.")


TangentConstraint.nativeObject = property(TangentConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


TangentConstraint.cast = lambda arg: arg if isinstance(arg, TangentConstraint) else None

class ThickenFeature(Feature):
    r"""Object that represents an existing Thicken feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ThickenFeature *":
        return _fusion.ThickenFeature___deref__(self)

    def __eq__(self, rhs: "ThickenFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ThickenFeature___eq__(self, rhs)


    def __ne__(self, rhs: "ThickenFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ThickenFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ThickenFeature_classType()
    __swig_destroy__ = _fusion.delete_ThickenFeature

    def setInputEntities(self, inputFaces: "ObjectCollection", isChainSelection: "bool"=True) -> "bool":
        r"""
        Sets the faces and patch bodies to thicken.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        inputFaces : The faces or patch bodies to thicken. Faces need not be from the same component or body, nor do they need to be 
        connected or touching one another. 
        isChainSelection : A boolean value for setting whether or not faces that are tangentially connected to 
        the input faces (if any) will be included in the offset. The default value is true. 
        Returns true if successful
        """
        return _fusion.ThickenFeature_setInputEntities(self, inputFaces, isChainSelection)

    def _get_inputFaces(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the ObjectCollection containing the face and/or patch bodies to thicken.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ThickenFeature__get_inputFaces(self)

    def _set_inputFaces(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the ObjectCollection containing the face and/or patch bodies to thicken.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ThickenFeature__set_inputFaces(self, value)

    def _get_thickness(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the parameter controlling the thickness. You can edit the thickness value
        by editing the value of the parameter object.
        """
        return _fusion.ThickenFeature__get_thickness(self)

    def _get_isSymmetric(self) -> "bool":
        r"""
        Gets and sets whether to add thickness symmetrically or only on one side of the face/s to thicken.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ThickenFeature__get_isSymmetric(self)

    def _set_isSymmetric(self, value: "bool") -> "bool":
        r"""
        Gets and sets whether to add thickness symmetrically or only on one side of the face/s to thicken.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ThickenFeature__set_isSymmetric(self, value)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations":
        r"""
        Gets and sets the feature operation to perform.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ThickenFeature__get_operation(self)

    def _set_operation(self, value: "FeatureOperations") -> "bool":
        r"""
        Gets and sets the feature operation to perform.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ThickenFeature__set_operation(self, value)

    def _get_isChainSelection(self) -> "bool":
        r"""Get and sets whether faces that are tangentially connected to the input faces will be included in the thicken feature."""
        return _fusion.ThickenFeature__get_isChainSelection(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ThickenFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ThickenFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::ThickenFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.ThickenFeature_createForAssemblyContext(self, occurrence)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ThickenFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ThickenFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ThickenFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.ThickenFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ThickenFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ThickenFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.ThickenFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.ThickenFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.ThickenFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.ThickenFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ThickenFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.ThickenFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.ThickenFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.ThickenFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ThickenFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.ThickenFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ThickenFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.ThickenFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ThickenFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ThickenFeature__get_isValid(self)

# Register ThickenFeature in _fusion:
_fusion.ThickenFeature_swigregister(ThickenFeature)

def ThickenFeature_classType() -> "char const *":
    return _fusion.ThickenFeature_classType()


ThickenFeature.inputFaces = property(ThickenFeature._get_inputFaces, ThickenFeature._set_inputFaces, doc="Gets and sets the ObjectCollection containing the face and/or patch bodies to thicken.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ThickenFeature.thickness = property(ThickenFeature._get_thickness, doc="Returns the parameter controlling the thickness. You can edit the thickness value\nby editing the value of the parameter object.")


ThickenFeature.isSymmetric = property(ThickenFeature._get_isSymmetric, ThickenFeature._set_isSymmetric, doc="Gets and sets whether to add thickness symmetrically or only on one side of the face/s to thicken.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ThickenFeature.operation = property(ThickenFeature._get_operation, ThickenFeature._set_operation, doc="Gets and sets the feature operation to perform.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ThickenFeature.isChainSelection = property(ThickenFeature._get_isChainSelection, doc="Get and sets whether faces that are tangentially connected to the input faces will be included in the thicken feature.")


ThickenFeature.nativeObject = property(ThickenFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


ThickenFeature.cast = lambda arg: arg if isinstance(arg, ThickenFeature) else None

class ThreadFeature(Feature):
    r"""Object that represents an existing thread feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ThreadFeature *":
        return _fusion.ThreadFeature___deref__(self)

    def __eq__(self, rhs: "ThreadFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ThreadFeature___eq__(self, rhs)


    def __ne__(self, rhs: "ThreadFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ThreadFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ThreadFeature_classType()
    __swig_destroy__ = _fusion.delete_ThreadFeature

    def _get_inputCylindricalFace(self) -> "adsk::core::Ptr< adsk::fusion::BRepFace >":
        r"""
        Gets and sets the threaded face. In the case where there are multiple faces, only the first one is returned.
        Setting this results in a thread being applied to only a single face.
        It is recommended that you use the inputCylindricalfaces property in order to have full access to the collection of faces
        to be threaded.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ThreadFeature__get_inputCylindricalFace(self)

    def _set_inputCylindricalFace(self, value: "BRepFace") -> "bool":
        r"""
        Gets and sets the threaded face. In the case where there are multiple faces, only the first one is returned.
        Setting this results in a thread being applied to only a single face.
        It is recommended that you use the inputCylindricalfaces property in order to have full access to the collection of faces
        to be threaded.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ThreadFeature__set_inputCylindricalFace(self, value)

    def _get_isModeled(self) -> "bool":
        r"""
        Gets and sets if the thread is physical or cosmetic thread. A value of true indicates a physical thread.
        It defaults to false.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ThreadFeature__get_isModeled(self)

    def _set_isModeled(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the thread is physical or cosmetic thread. A value of true indicates a physical thread.
        It defaults to false.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ThreadFeature__set_isModeled(self, value)

    def _get_isFullLength(self) -> "bool":
        r"""
        Gets and sets if this thread is the full length of the cylinder.
        It only can be set to true.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ThreadFeature__get_isFullLength(self)

    def _set_isFullLength(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this thread is the full length of the cylinder.
        It only can be set to true.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ThreadFeature__set_isFullLength(self, value)

    def setThreadOffsetLength(self, threadOffset: "ValueInput", threadLength: "ValueInput", threadLocation: "ThreadLocations") -> "bool":
        r"""
        Sets the thread offset, length and location.
        Calling this method will cause the isFullLength property to be set to false.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        threadOffset : A ValueInput object that defines the thread offset. 
        threadLength : A ValueInput object that defines the thread length. 
        threadLocation : Indicates where the thread length is measured from. 
        Returns true if successful.
        """
        return _fusion.ThreadFeature_setThreadOffsetLength(self, threadOffset, threadLength, threadLocation)

    def _get_threadLength(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the parameter that controls the depth of the thread. 
        Even though the parameter for the thread depth is always created and accessible through this property, 
        it is only used in the case where the isFullLength property is false.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ThreadFeature__get_threadLength(self)

    def _get_threadOffset(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the parameter that controls the offset value of the thread. 
        The offset is the distance along the axis of the cylinder from the edge to the start of the thread,
        it is only used in the case where the isFullLength property is false.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ThreadFeature__get_threadOffset(self)

    def _get_threadLocation(self) -> "adsk::fusion::ThreadLocations":
        r"""
        Gets and sets where the thread length is measured from.
        This property is only used in the case where the isFullLength property is false.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ThreadFeature__get_threadLocation(self)

    def _set_threadLocation(self, value: "ThreadLocations") -> "bool":
        r"""
        Gets and sets where the thread length is measured from.
        This property is only used in the case where the isFullLength property is false.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ThreadFeature__set_threadLocation(self, value)

    def _get_threadInfo(self) -> "adsk::core::Ptr< adsk::fusion::ThreadInfo >":
        r"""
        Gets and sets the thread data. 
        Also can edit the thread through the properties and methods on the ThreadInfo object.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ThreadFeature__get_threadInfo(self)

    def _set_threadInfo(self, value: "ThreadInfo") -> "bool":
        r"""
        Gets and sets the thread data. 
        Also can edit the thread through the properties and methods on the ThreadInfo object.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ThreadFeature__set_threadInfo(self, value)

    def _get_isRightHanded(self) -> "bool":
        r"""
        Gets and sets if the thread is right or left-handed thread. A value of true indicates a right-handed thread.
        It defaults to true.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ThreadFeature__get_isRightHanded(self)

    def _set_isRightHanded(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the thread is right or left-handed thread. A value of true indicates a right-handed thread.
        It defaults to true.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ThreadFeature__set_isRightHanded(self, value)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ThreadFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ThreadFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::ThreadFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ThreadFeature_createForAssemblyContext(self, occurrence)

    def _get_inputCylindricalFaces(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the cylindrical input faces.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ThreadFeature__get_inputCylindricalFaces(self)

    def _set_inputCylindricalFaces(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the cylindrical input faces.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.ThreadFeature__set_inputCylindricalFaces(self, value)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ThreadFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ThreadFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ThreadFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.ThreadFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ThreadFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ThreadFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.ThreadFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.ThreadFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.ThreadFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.ThreadFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ThreadFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.ThreadFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.ThreadFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.ThreadFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ThreadFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.ThreadFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ThreadFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.ThreadFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ThreadFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ThreadFeature__get_isValid(self)

# Register ThreadFeature in _fusion:
_fusion.ThreadFeature_swigregister(ThreadFeature)

def ThreadFeature_classType() -> "char const *":
    return _fusion.ThreadFeature_classType()


ThreadFeature.inputCylindricalFace = property(ThreadFeature._get_inputCylindricalFace, ThreadFeature._set_inputCylindricalFace, doc="Gets and sets the threaded face. In the case where there are multiple faces, only the first one is returned.\nSetting this results in a thread being applied to only a single face.\nIt is recommended that you use the inputCylindricalfaces property in order to have full access to the collection of faces\nto be threaded.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ThreadFeature.isModeled = property(ThreadFeature._get_isModeled, ThreadFeature._set_isModeled, doc="Gets and sets if the thread is physical or cosmetic thread. A value of true indicates a physical thread.\nIt defaults to false.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ThreadFeature.isFullLength = property(ThreadFeature._get_isFullLength, ThreadFeature._set_isFullLength, doc="Gets and sets if this thread is the full length of the cylinder.\nIt only can be set to true.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ThreadFeature.threadLength = property(ThreadFeature._get_threadLength, doc="Gets the parameter that controls the depth of the thread.\nEven though the parameter for the thread depth is always created and accessible through this property,\nit is only used in the case where the isFullLength property is false.\nReturns nothing in the case where the feature is non-parametric.")


ThreadFeature.threadOffset = property(ThreadFeature._get_threadOffset, doc="Gets the parameter that controls the offset value of the thread.\nThe offset is the distance along the axis of the cylinder from the edge to the start of the thread,\nit is only used in the case where the isFullLength property is false.\nReturns nothing in the case where the feature is non-parametric.")


ThreadFeature.threadLocation = property(ThreadFeature._get_threadLocation, ThreadFeature._set_threadLocation, doc="Gets and sets where the thread length is measured from.\nThis property is only used in the case where the isFullLength property is false.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ThreadFeature.threadInfo = property(ThreadFeature._get_threadInfo, ThreadFeature._set_threadInfo, doc="Gets and sets the thread data.\nAlso can edit the thread through the properties and methods on the ThreadInfo object.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ThreadFeature.isRightHanded = property(ThreadFeature._get_isRightHanded, ThreadFeature._set_isRightHanded, doc="Gets and sets if the thread is right or left-handed thread. A value of true indicates a right-handed thread.\nIt defaults to true.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ThreadFeature.nativeObject = property(ThreadFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


ThreadFeature.inputCylindricalFaces = property(ThreadFeature._get_inputCylindricalFaces, ThreadFeature._set_inputCylindricalFaces, doc="Gets and sets the cylindrical input faces.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


ThreadFeature.cast = lambda arg: arg if isinstance(arg, ThreadFeature) else None

class ThroughAllExtentDefinition(ExtentDefinition):
    r"""A definition object that is used to define the extents of a feature to be through all."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ThroughAllExtentDefinition *":
        return _fusion.ThroughAllExtentDefinition___deref__(self)

    def __eq__(self, rhs: "ThroughAllExtentDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ThroughAllExtentDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ThroughAllExtentDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ThroughAllExtentDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ThroughAllExtentDefinition_classType()

    @staticmethod
    def create() -> "adsk::core::Ptr< adsk::fusion::ThroughAllExtentDefinition >":
        return _fusion.ThroughAllExtentDefinition_create()
    __swig_destroy__ = _fusion.delete_ThroughAllExtentDefinition

    def _get_isPositiveDirection(self) -> "bool":
        r"""
        Gets and sets if the direction is positive or negative. A value of true indicates it is 
        in the same direction as the z direction of the profile's sketch plane. 
        This is only used when the extrusion is only defined in a single direction from the 
        profile plane. If it's a two sided extrusion, this value is ignored.
        """
        return _fusion.ThroughAllExtentDefinition__get_isPositiveDirection(self)

    def _set_isPositiveDirection(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the direction is positive or negative. A value of true indicates it is 
        in the same direction as the z direction of the profile's sketch plane. 
        This is only used when the extrusion is only defined in a single direction from the 
        profile plane. If it's a two sided extrusion, this value is ignored.
        """
        return _fusion.ThroughAllExtentDefinition__set_isPositiveDirection(self, value)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >":
        r"""
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.ThroughAllExtentDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ThroughAllExtentDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ThroughAllExtentDefinition__get_isValid(self)

# Register ThroughAllExtentDefinition in _fusion:
_fusion.ThroughAllExtentDefinition_swigregister(ThroughAllExtentDefinition)

def ThroughAllExtentDefinition_classType() -> "char const *":
    return _fusion.ThroughAllExtentDefinition_classType()

def ThroughAllExtentDefinition_create() -> "adsk::core::Ptr< adsk::fusion::ThroughAllExtentDefinition >":
    return _fusion.ThroughAllExtentDefinition_create()


ThroughAllExtentDefinition.isPositiveDirection = property(ThroughAllExtentDefinition._get_isPositiveDirection, ThroughAllExtentDefinition._set_isPositiveDirection, doc="Gets and sets if the direction is positive or negative. A value of true indicates it is\nin the same direction as the z direction of the profile's sketch plane.\nThis is only used when the extrusion is only defined in a single direction from the\nprofile plane. If it's a two sided extrusion, this value is ignored.")


ThroughAllExtentDefinition.cast = lambda arg: arg if isinstance(arg, ThroughAllExtentDefinition) else None

class TimelineGroup(TimelineObject):
    r"""Represents a group in the timeline."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::TimelineGroup *":
        return _fusion.TimelineGroup___deref__(self)

    def __eq__(self, rhs: "TimelineGroup") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.TimelineGroup___eq__(self, rhs)


    def __ne__(self, rhs: "TimelineGroup") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.TimelineGroup___ne__(self, rhs)


    def __len__(self) -> "size_t":
        return _fusion.TimelineGroup___len__(self)

    def __getitem__(self, i: "int") -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":

        if i < 0:
            i = len(self) + i
        if i < 0 or i >= len(self):
            raise IndexError("The index (%d) is out of range." % i)


        return _fusion.TimelineGroup___getitem__(self, i)


    def __iter__(self):
        i = 0
        while i < len(self):
            yield self.item(i)
            i = i + 1


    @staticmethod
    def classType() -> "char const *":
        return _fusion.TimelineGroup_classType()
    __swig_destroy__ = _fusion.delete_TimelineGroup

    def deleteMe(self, deleteGroupAndContents: "bool") -> "bool":
        r"""
        Deletes the group with the option of deleting or keeping the contents. 
        deleteGroupAndContents : Indicates if the group and its contents should be deleted or if only the group
        should be deleted and the contents kept and expanded. A value of true will delete
        the group and its contents. 
        Returns true if the delete was successful.
        """
        return _fusion.TimelineGroup_deleteMe(self, deleteGroupAndContents)

    def _get_isCollapsed(self) -> "bool":
        r"""Indicates if the group is collapsed or expanded."""
        return _fusion.TimelineGroup__get_isCollapsed(self)

    def _set_isCollapsed(self, value: "bool") -> "bool":
        r"""Indicates if the group is collapsed or expanded."""
        return _fusion.TimelineGroup__set_isCollapsed(self, value)

    def item(self, index: "size_t") -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""
        Function that returns the specified timeline object within the group using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.TimelineGroup_item(self, index)

    def _get_count(self) -> "size_t":
        r"""The number of items in the group."""
        return _fusion.TimelineGroup__get_count(self)

    def _get_isSuppressed(self) -> "bool":
        r"""Gets and sets if this object is suppressed."""
        return _fusion.TimelineGroup__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""Gets and sets if this object is suppressed."""
        return _fusion.TimelineGroup__set_isSuppressed(self, value)

    def _get_parentGroup(self) -> "adsk::core::Ptr< adsk::fusion::TimelineGroup >":
        r"""
        Returns the parent group, if this object is part of a group.
        Returns null if this object is not part of a group.
        """
        return _fusion.TimelineGroup__get_parentGroup(self)

    def _get_index(self) -> "int":
        r"""
        Returns the position of this item within the timeline where
        the first item has an index of 0.
        This property can return -1 in the two cases where this object
        is not currently represented in the timeline. The two cases are:
        1. When this is a TimelineGroup object and the group is expanded.
        2. When this object is part of a group and the group is collapsed.
        """
        return _fusion.TimelineGroup__get_index(self)

    def _get_isRolledBack(self) -> "bool":
        r"""
        Indicates if this item is currently not being computed
        because it has been rolled back.
        If this is a timelineGroup object and the group is expanded
        the value of this property should be ignored.
        """
        return _fusion.TimelineGroup__get_isRolledBack(self)

    def rollTo(self, rollBefore: "bool") -> "bool":
        r"""
        Rolls the timeline by repositioning the marker to either before or after this object.
        This method will fail if this is a timelineGroup object and the group is expanded. 
        rollBefore : Set rollBefore to true to reposition the marker before this object or to false to
        reposition the marker after this object 
        Returns true if the move was successful
        """
        return _fusion.TimelineGroup_rollTo(self, rollBefore)

    def _get_entity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the entity associated with this timeline object.
        Edit operations can be performed by getting the object
        representing the associated entity and using the methods
        and properties on that entity to make changes.
        Returns null if this is a TimelineGroup object
        """
        return _fusion.TimelineGroup__get_entity(self)

    def canReorder(self, beforeIndex: "int"=-1) -> "bool":
        r"""
        Checks to see if this object can be reordered to the specified position.
        The default value of -1 indicates the end of the timeline.
        This method will fail if this is a timelineGroup object and the group is expanded. 
        beforeIndex : The index number of the position in the timeline to check 
        Returns true if the object can be reordered to the specified position
        """
        return _fusion.TimelineGroup_canReorder(self, beforeIndex)

    def reorder(self, beforeIndex: "int"=-1) -> "bool":
        r"""
        Reorders this object to the position specified.
        The default value of -1 indicates the end of the timeline. 
        beforeIndex : The index number of the position in the timeline to place this object before 
        Returns true if the reorder operation was successful
        This method will fail and return false if this is a timelineGroup object and the 
        group is expanded.
        """
        return _fusion.TimelineGroup_reorder(self, beforeIndex)

    def _get_isGroup(self) -> "bool":
        r"""
        Indicates if this TimelineObject represents a group. If True you can
        operate on this object as a TimelineGroup object.
        """
        return _fusion.TimelineGroup__get_isGroup(self)

    def _get_name(self) -> "std::string":
        r"""
        Gets and sets the name of this timeline object. This name is shared by the object
        the timeline object represents. For example, if the TimelineObject represents a Sketch
        and you change the name using the TimelineObject, the name of the sketch in the browser
        is also changed. The reverse is also true. Setting the name of an object; sketch, feature
        construction geometry, etc, will also change the name of the associated node in the timeline.
        """
        return _fusion.TimelineGroup__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the name of this timeline object. This name is shared by the object
        the timeline object represents. For example, if the TimelineObject represents a Sketch
        and you change the name using the TimelineObject, the name of the sketch in the browser
        is also changed. The reverse is also true. Setting the name of an object; sketch, feature
        construction geometry, etc, will also change the name of the associated node in the timeline.
        """
        return _fusion.TimelineGroup__set_name(self, value)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the object associated with this TimelineObject."""
        return _fusion.TimelineGroup__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.TimelineGroup__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.TimelineGroup__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.TimelineGroup__get_isValid(self)

# Register TimelineGroup in _fusion:
_fusion.TimelineGroup_swigregister(TimelineGroup)

def TimelineGroup_classType() -> "char const *":
    return _fusion.TimelineGroup_classType()


TimelineGroup.isCollapsed = property(TimelineGroup._get_isCollapsed, TimelineGroup._set_isCollapsed, doc="Indicates if the group is collapsed or expanded.")


TimelineGroup.count = property(TimelineGroup._get_count, doc="The number of items in the group.")


TimelineGroup.cast = lambda arg: arg if isinstance(arg, TimelineGroup) else None

class ToEntityExtentDefinition(ExtentDefinition):
    r"""
    A definition object that is used to define the extents of a feature to be up to a specified
    construction plane or face.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::ToEntityExtentDefinition *":
        return _fusion.ToEntityExtentDefinition___deref__(self)

    def __eq__(self, rhs: "ToEntityExtentDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.ToEntityExtentDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "ToEntityExtentDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.ToEntityExtentDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.ToEntityExtentDefinition_classType()

    @staticmethod
    def create(*args) -> "adsk::core::Ptr< adsk::fusion::ToEntityExtentDefinition >":
        return _fusion.ToEntityExtentDefinition_create(*args)
    __swig_destroy__ = _fusion.delete_ToEntityExtentDefinition

    def _get_entity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the entity that the feature extent is defined up to. This can be a ConstructionPlane, Profile, BrepFace,
        BrepBody, or BRepVertex.
        """
        return _fusion.ToEntityExtentDefinition__get_entity(self)

    def _set_entity(self, value: "Base") -> "bool":
        r"""
        Gets and sets the entity that the feature extent is defined up to. This can be a ConstructionPlane, Profile, BrepFace,
        BrepBody, or BRepVertex.
        """
        return _fusion.ToEntityExtentDefinition__set_entity(self, value)

    def _get_offset(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the current offset. If the EntityExtentDefinition object has been created statically and isn't associated with
        a feature this will return a ValueInput object. If the EntityExtentDefinition object is obtained from a feature this
        will return a ModelParameter object. You can use properties of the parameter to edit it's value which will result in
        the feature updating.
        """
        return _fusion.ToEntityExtentDefinition__get_offset(self)

    def _get_isChained(self) -> "bool":
        r"""
        Gets and sets whether connected faces to the input entity should also be used when calculating the extent or if the 
        input entity should be extended. A value of true indicates that connected entities should be used.
        """
        return _fusion.ToEntityExtentDefinition__get_isChained(self)

    def _set_isChained(self, value: "bool") -> "bool":
        r"""
        Gets and sets whether connected faces to the input entity should also be used when calculating the extent or if the 
        input entity should be extended. A value of true indicates that connected entities should be used.
        """
        return _fusion.ToEntityExtentDefinition__set_isChained(self, value)

    def _get_directionHint(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Gets and sets a direction that is used when the result is ambiguous. For example, if you have a profile in
        the center of a torus and are extruding to the torus, the extrusion can go in either direction. When needed,
        this provides the information to tell Fusion 360 which direction to go. In most cases this is not needed and
        the property will be null.
        """
        return _fusion.ToEntityExtentDefinition__get_directionHint(self)

    def _set_directionHint(self, value: "Vector3D") -> "bool":
        r"""
        Gets and sets a direction that is used when the result is ambiguous. For example, if you have a profile in
        the center of a torus and are extruding to the torus, the extrusion can go in either direction. When needed,
        this provides the information to tell Fusion 360 which direction to go. In most cases this is not needed and
        the property will be null.
        """
        return _fusion.ToEntityExtentDefinition__set_directionHint(self, value)

    def _get_isMinimumSolution(self) -> "bool":
        r"""
        Gets and sets if the minimum or maximum solution is calculated. This is only used when the input entity is
        a body and defines if the extrusion to go to the near side (minimum solution) of the body or the far side.
        When a new ToEntityExtentDefinition object is created, this property defaults to True.
        """
        return _fusion.ToEntityExtentDefinition__get_isMinimumSolution(self)

    def _set_isMinimumSolution(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the minimum or maximum solution is calculated. This is only used when the input entity is
        a body and defines if the extrusion to go to the near side (minimum solution) of the body or the far side.
        When a new ToEntityExtentDefinition object is created, this property defaults to True.
        """
        return _fusion.ToEntityExtentDefinition__set_isMinimumSolution(self, value)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >":
        r"""
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.ToEntityExtentDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.ToEntityExtentDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.ToEntityExtentDefinition__get_isValid(self)

# Register ToEntityExtentDefinition in _fusion:
_fusion.ToEntityExtentDefinition_swigregister(ToEntityExtentDefinition)

def ToEntityExtentDefinition_classType() -> "char const *":
    return _fusion.ToEntityExtentDefinition_classType()

def ToEntityExtentDefinition_create(*args) -> "adsk::core::Ptr< adsk::fusion::ToEntityExtentDefinition >":
    return _fusion.ToEntityExtentDefinition_create(*args)


ToEntityExtentDefinition.entity = property(ToEntityExtentDefinition._get_entity, ToEntityExtentDefinition._set_entity, doc="Gets and sets the entity that the feature extent is defined up to. This can be a ConstructionPlane, Profile, BrepFace,\nBrepBody, or BRepVertex.")


ToEntityExtentDefinition.offset = property(ToEntityExtentDefinition._get_offset, doc="Returns the current offset. If the EntityExtentDefinition object has been created statically and isn't associated with\na feature this will return a ValueInput object. If the EntityExtentDefinition object is obtained from a feature this\nwill return a ModelParameter object. You can use properties of the parameter to edit it's value which will result in\nthe feature updating.")


ToEntityExtentDefinition.isChained = property(ToEntityExtentDefinition._get_isChained, ToEntityExtentDefinition._set_isChained, doc="Gets and sets whether connected faces to the input entity should also be used when calculating the extent or if the\ninput entity should be extended. A value of true indicates that connected entities should be used.")


ToEntityExtentDefinition.directionHint = property(ToEntityExtentDefinition._get_directionHint, ToEntityExtentDefinition._set_directionHint, doc="Gets and sets a direction that is used when the result is ambiguous. For example, if you have a profile in\nthe center of a torus and are extruding to the torus, the extrusion can go in either direction. When needed,\nthis provides the information to tell Fusion 360 which direction to go. In most cases this is not needed and\nthe property will be null.")


ToEntityExtentDefinition.isMinimumSolution = property(ToEntityExtentDefinition._get_isMinimumSolution, ToEntityExtentDefinition._set_isMinimumSolution, doc="Gets and sets if the minimum or maximum solution is calculated. This is only used when the input entity is\na body and defines if the extrusion to go to the near side (minimum solution) of the body or the far side.\nWhen a new ToEntityExtentDefinition object is created, this property defaults to True.")


ToEntityExtentDefinition.cast = lambda arg: arg if isinstance(arg, ToEntityExtentDefinition) else None

class TorusFeature(Feature):
    r"""Object that represents an existing torus feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::TorusFeature *":
        return _fusion.TorusFeature___deref__(self)

    def __eq__(self, rhs: "TorusFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.TorusFeature___eq__(self, rhs)


    def __ne__(self, rhs: "TorusFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.TorusFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.TorusFeature_classType()
    __swig_destroy__ = _fusion.delete_TorusFeature

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.TorusFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.TorusFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.TorusFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.TorusFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.TorusFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.TorusFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.TorusFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.TorusFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.TorusFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.TorusFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.TorusFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.TorusFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.TorusFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.TorusFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.TorusFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.TorusFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.TorusFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.TorusFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.TorusFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.TorusFeature__get_isValid(self)

# Register TorusFeature in _fusion:
_fusion.TorusFeature_swigregister(TorusFeature)

def TorusFeature_classType() -> "char const *":
    return _fusion.TorusFeature_classType()


TorusFeature.cast = lambda arg: arg if isinstance(arg, TorusFeature) else None

class TrimFeature(Feature):
    r"""Object that represents an existing trim feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::TrimFeature *":
        return _fusion.TrimFeature___deref__(self)

    def __eq__(self, rhs: "TrimFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.TrimFeature___eq__(self, rhs)


    def __ne__(self, rhs: "TrimFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.TrimFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.TrimFeature_classType()
    __swig_destroy__ = _fusion.delete_TrimFeature

    def _get_trimTool(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the entity (a patch body, B-Rep face, construction plane or sketch curve) that intersects the trim tool.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.TrimFeature__get_trimTool(self)

    def _set_trimTool(self, value: "Base") -> "bool":
        r"""
        Gets and sets the entity (a patch body, B-Rep face, construction plane or sketch curve) that intersects the trim tool.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.TrimFeature__set_trimTool(self, value)

    def _get_bRepCells(self) -> "adsk::core::Ptr< adsk::fusion::BRepCells >":
        r"""
        Gets the set of valid cells that have been calculated based on the current inputs.
        To get this collection the model must be in the state it was when the feature
        was initially computed, which means the timeline marker must be positioned to immediately
        before this feature. 
        After changing any selected cells you must call the applyCellChanges method to update
        the feature with the changes.
        """
        return _fusion.TrimFeature__get_bRepCells(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::TrimFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.TrimFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::TrimFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.TrimFeature_createForAssemblyContext(self, occurrence)

    def applyCellChanges(self) -> "bool":
        r"""
        After making any changes to the set of selected cells you must call this method to 
        indicate all changes have been made and to apply those changes to the feature. 
        Returns true if the apply was successful.
        """
        return _fusion.TrimFeature_applyCellChanges(self)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.TrimFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.TrimFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.TrimFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.TrimFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.TrimFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.TrimFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.TrimFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.TrimFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.TrimFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.TrimFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.TrimFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.TrimFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.TrimFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.TrimFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.TrimFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.TrimFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.TrimFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.TrimFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.TrimFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.TrimFeature__get_isValid(self)

# Register TrimFeature in _fusion:
_fusion.TrimFeature_swigregister(TrimFeature)

def TrimFeature_classType() -> "char const *":
    return _fusion.TrimFeature_classType()


TrimFeature.trimTool = property(TrimFeature._get_trimTool, TrimFeature._set_trimTool, doc="Gets and sets the entity (a patch body, B-Rep face, construction plane or sketch curve) that intersects the trim tool.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


TrimFeature.bRepCells = property(TrimFeature._get_bRepCells, doc="Gets the set of valid cells that have been calculated based on the current inputs.\nTo get this collection the model must be in the state it was when the feature\nwas initially computed, which means the timeline marker must be positioned to immediately\nbefore this feature.\nAfter changing any selected cells you must call the applyCellChanges method to update\nthe feature with the changes.")


TrimFeature.nativeObject = property(TrimFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


TrimFeature.cast = lambda arg: arg if isinstance(arg, TrimFeature) else None

class TwoDistancesChamferEdgeSet(ChamferEdgeSet):
    r"""Provides access to the edges and the parameters associated with a two distances chamfer."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::TwoDistancesChamferEdgeSet *":
        return _fusion.TwoDistancesChamferEdgeSet___deref__(self)

    def __eq__(self, rhs: "TwoDistancesChamferEdgeSet") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.TwoDistancesChamferEdgeSet___eq__(self, rhs)


    def __ne__(self, rhs: "TwoDistancesChamferEdgeSet") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.TwoDistancesChamferEdgeSet___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.TwoDistancesChamferEdgeSet_classType()
    __swig_destroy__ = _fusion.delete_TwoDistancesChamferEdgeSet

    def _get_edges(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the edges that will be chamfered. This collection can contain BRepEdge, BRepFace,
        and Feature objects. If BRepFace or Feature are objects are provided, all of the edges associated
        with those objects will be chamfered.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.TwoDistancesChamferEdgeSet__get_edges(self)

    def _set_edges(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the edges that will be chamfered. This collection can contain BRepEdge, BRepFace,
        and Feature objects. If BRepFace or Feature are objects are provided, all of the edges associated
        with those objects will be chamfered.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.TwoDistancesChamferEdgeSet__set_edges(self, value)

    def _get_distanceOne(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the model parameter that controls the first offset distance of the chamfer.
        You can edit the distance by using the properties on the returned ModelParameter object.
        """
        return _fusion.TwoDistancesChamferEdgeSet__get_distanceOne(self)

    def _get_distanceTwo(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the model parameter that controls the first offset distance of the chamfer.
        You can edit the distance by using the properties on the returned ModelParameter object.
        """
        return _fusion.TwoDistancesChamferEdgeSet__get_distanceTwo(self)

    def _get_isFlipped(self) -> "bool":
        r"""
        Gets and sets if the chamfer is flipped. This swaps the directions for distance one and two.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.TwoDistancesChamferEdgeSet__get_isFlipped(self)

    def _set_isFlipped(self, value: "bool") -> "bool":
        r"""
        Gets and sets if the chamfer is flipped. This swaps the directions for distance one and two.
        To set this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.TwoDistancesChamferEdgeSet__set_isFlipped(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the chamfer edge set from the chamfer.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        Returns true if the operation was successful.
        """
        return _fusion.TwoDistancesChamferEdgeSet_deleteMe(self)

    def _get_isTangentChain(self) -> "bool":
        r"""Gets and sets the Tangent chain for chamfer. This enables tangent chain option for chamfer."""
        return _fusion.TwoDistancesChamferEdgeSet__get_isTangentChain(self)

    def _set_isTangentChain(self, value: "bool") -> "bool":
        r"""Gets and sets the Tangent chain for chamfer. This enables tangent chain option for chamfer."""
        return _fusion.TwoDistancesChamferEdgeSet__set_isTangentChain(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.TwoDistancesChamferEdgeSet__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.TwoDistancesChamferEdgeSet__get_isValid(self)

# Register TwoDistancesChamferEdgeSet in _fusion:
_fusion.TwoDistancesChamferEdgeSet_swigregister(TwoDistancesChamferEdgeSet)

def TwoDistancesChamferEdgeSet_classType() -> "char const *":
    return _fusion.TwoDistancesChamferEdgeSet_classType()


TwoDistancesChamferEdgeSet.edges = property(TwoDistancesChamferEdgeSet._get_edges, TwoDistancesChamferEdgeSet._set_edges, doc="Gets and sets the edges that will be chamfered. This collection can contain BRepEdge, BRepFace,\nand Feature objects. If BRepFace or Feature are objects are provided, all of the edges associated\nwith those objects will be chamfered.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


TwoDistancesChamferEdgeSet.distanceOne = property(TwoDistancesChamferEdgeSet._get_distanceOne, doc="Returns the model parameter that controls the first offset distance of the chamfer.\nYou can edit the distance by using the properties on the returned ModelParameter object.")


TwoDistancesChamferEdgeSet.distanceTwo = property(TwoDistancesChamferEdgeSet._get_distanceTwo, doc="Returns the model parameter that controls the first offset distance of the chamfer.\nYou can edit the distance by using the properties on the returned ModelParameter object.")


TwoDistancesChamferEdgeSet.isFlipped = property(TwoDistancesChamferEdgeSet._get_isFlipped, TwoDistancesChamferEdgeSet._set_isFlipped, doc="Gets and sets if the chamfer is flipped. This swaps the directions for distance one and two.\nTo set this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


TwoDistancesChamferEdgeSet.cast = lambda arg: arg if isinstance(arg, TwoDistancesChamferEdgeSet) else None

class TwoDistancesChamferTypeDefinition(ChamferTypeDefinition):
    r"""Provides information to create a chamfer that is defined by a two distances from the edge."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::TwoDistancesChamferTypeDefinition *":
        return _fusion.TwoDistancesChamferTypeDefinition___deref__(self)

    def __eq__(self, rhs: "TwoDistancesChamferTypeDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.TwoDistancesChamferTypeDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "TwoDistancesChamferTypeDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.TwoDistancesChamferTypeDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.TwoDistancesChamferTypeDefinition_classType()
    __swig_destroy__ = _fusion.delete_TwoDistancesChamferTypeDefinition

    def _get_distanceOne(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the parameter controlling the first distance. You can edit the distance
        by editing the value of the parameter object.
        """
        return _fusion.TwoDistancesChamferTypeDefinition__get_distanceOne(self)

    def _get_distanceTwo(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the parameter controlling the second distance. You can edit the distance
        by editing the value of the parameter object.
        """
        return _fusion.TwoDistancesChamferTypeDefinition__get_distanceTwo(self)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::ChamferFeature >":
        r"""Returns the feature that owns this chamfer type definition"""
        return _fusion.TwoDistancesChamferTypeDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.TwoDistancesChamferTypeDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.TwoDistancesChamferTypeDefinition__get_isValid(self)

# Register TwoDistancesChamferTypeDefinition in _fusion:
_fusion.TwoDistancesChamferTypeDefinition_swigregister(TwoDistancesChamferTypeDefinition)

def TwoDistancesChamferTypeDefinition_classType() -> "char const *":
    return _fusion.TwoDistancesChamferTypeDefinition_classType()


TwoDistancesChamferTypeDefinition.distanceOne = property(TwoDistancesChamferTypeDefinition._get_distanceOne, doc="Returns the parameter controlling the first distance. You can edit the distance\nby editing the value of the parameter object.")


TwoDistancesChamferTypeDefinition.distanceTwo = property(TwoDistancesChamferTypeDefinition._get_distanceTwo, doc="Returns the parameter controlling the second distance. You can edit the distance\nby editing the value of the parameter object.")


TwoDistancesChamferTypeDefinition.cast = lambda arg: arg if isinstance(arg, TwoDistancesChamferTypeDefinition) else None

class TwoSidesAngleExtentDefinition(ExtentDefinition):
    r"""
    Defines the inputs for a TwoSidesAngleExtentDefinition object.
    This feature extent type defines the extents of the feature using angle extents on two sides.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::TwoSidesAngleExtentDefinition *":
        return _fusion.TwoSidesAngleExtentDefinition___deref__(self)

    def __eq__(self, rhs: "TwoSidesAngleExtentDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.TwoSidesAngleExtentDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "TwoSidesAngleExtentDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.TwoSidesAngleExtentDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.TwoSidesAngleExtentDefinition_classType()
    __swig_destroy__ = _fusion.delete_TwoSidesAngleExtentDefinition

    def _get_angleOne(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the ModelParameter that defines the angle on the first side.
        The value of the angle can be edited by using the properties on the ModelParameter object to edit the parameter.
        """
        return _fusion.TwoSidesAngleExtentDefinition__get_angleOne(self)

    def _get_angleTwo(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the ModelParameter that defines the angle on the second side.
        The value of the angle can be edited by using the properties on the ModelParameter object to edit the parameter.
        """
        return _fusion.TwoSidesAngleExtentDefinition__get_angleTwo(self)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >":
        r"""
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.TwoSidesAngleExtentDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.TwoSidesAngleExtentDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.TwoSidesAngleExtentDefinition__get_isValid(self)

# Register TwoSidesAngleExtentDefinition in _fusion:
_fusion.TwoSidesAngleExtentDefinition_swigregister(TwoSidesAngleExtentDefinition)

def TwoSidesAngleExtentDefinition_classType() -> "char const *":
    return _fusion.TwoSidesAngleExtentDefinition_classType()


TwoSidesAngleExtentDefinition.angleOne = property(TwoSidesAngleExtentDefinition._get_angleOne, doc="Gets the ModelParameter that defines the angle on the first side.\nThe value of the angle can be edited by using the properties on the ModelParameter object to edit the parameter.")


TwoSidesAngleExtentDefinition.angleTwo = property(TwoSidesAngleExtentDefinition._get_angleTwo, doc="Gets the ModelParameter that defines the angle on the second side.\nThe value of the angle can be edited by using the properties on the ModelParameter object to edit the parameter.")


TwoSidesAngleExtentDefinition.cast = lambda arg: arg if isinstance(arg, TwoSidesAngleExtentDefinition) else None

class TwoSidesDistanceExtentDefinition(ExtentDefinition):
    r"""
    Defines the inputs for a TwoSidesDistanceExtentDefinition object. 
    This defines a feature extent where the distance in each direction can be a different value.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::TwoSidesDistanceExtentDefinition *":
        return _fusion.TwoSidesDistanceExtentDefinition___deref__(self)

    def __eq__(self, rhs: "TwoSidesDistanceExtentDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.TwoSidesDistanceExtentDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "TwoSidesDistanceExtentDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.TwoSidesDistanceExtentDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.TwoSidesDistanceExtentDefinition_classType()
    __swig_destroy__ = _fusion.delete_TwoSidesDistanceExtentDefinition

    def _get_distanceOne(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""Gets the ModelParameter that defines the first distance"""
        return _fusion.TwoSidesDistanceExtentDefinition__get_distanceOne(self)

    def _get_distanceTwo(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""Gets the ModelParameter that defines the second distance"""
        return _fusion.TwoSidesDistanceExtentDefinition__get_distanceTwo(self)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >":
        r"""
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.TwoSidesDistanceExtentDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.TwoSidesDistanceExtentDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.TwoSidesDistanceExtentDefinition__get_isValid(self)

# Register TwoSidesDistanceExtentDefinition in _fusion:
_fusion.TwoSidesDistanceExtentDefinition_swigregister(TwoSidesDistanceExtentDefinition)

def TwoSidesDistanceExtentDefinition_classType() -> "char const *":
    return _fusion.TwoSidesDistanceExtentDefinition_classType()


TwoSidesDistanceExtentDefinition.distanceOne = property(TwoSidesDistanceExtentDefinition._get_distanceOne, doc="Gets the ModelParameter that defines the first distance")


TwoSidesDistanceExtentDefinition.distanceTwo = property(TwoSidesDistanceExtentDefinition._get_distanceTwo, doc="Gets the ModelParameter that defines the second distance")


TwoSidesDistanceExtentDefinition.cast = lambda arg: arg if isinstance(arg, TwoSidesDistanceExtentDefinition) else None

class TwoSidesToExtentDefinition(ExtentDefinition):
    r"""
    Defines the inputs for a TwoSidesToExtentDefinition object
    This defines a feature extent where the extents of feature go up to faces or construction planes in both directions.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::TwoSidesToExtentDefinition *":
        return _fusion.TwoSidesToExtentDefinition___deref__(self)

    def __eq__(self, rhs: "TwoSidesToExtentDefinition") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.TwoSidesToExtentDefinition___eq__(self, rhs)


    def __ne__(self, rhs: "TwoSidesToExtentDefinition") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.TwoSidesToExtentDefinition___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.TwoSidesToExtentDefinition_classType()
    __swig_destroy__ = _fusion.delete_TwoSidesToExtentDefinition

    def _get_toEntityOne(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the entity that defines the extent on side one. The valid types of entities can vary depending on
        the type of feature this is being used with.
        """
        return _fusion.TwoSidesToExtentDefinition__get_toEntityOne(self)

    def _set_toEntityOne(self, value: "Base") -> "bool":
        r"""
        Gets and sets the entity that defines the extent on side one. The valid types of entities can vary depending on
        the type of feature this is being used with.
        """
        return _fusion.TwoSidesToExtentDefinition__set_toEntityOne(self, value)

    def _get_toEntityTwo(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Gets and sets the entity that defines the extent on side two. The valid types of entities can vary depending on
        the type of feature this is being used with.
        """
        return _fusion.TwoSidesToExtentDefinition__get_toEntityTwo(self)

    def _set_toEntityTwo(self, value: "Base") -> "bool":
        r"""
        Gets and sets the entity that defines the extent on side two. The valid types of entities can vary depending on
        the type of feature this is being used with.
        """
        return _fusion.TwoSidesToExtentDefinition__set_toEntityTwo(self, value)

    def _get_matchShape(self) -> "bool":
        r"""Gets and sets whether the toEntity is extended to fully intersect the extrusion."""
        return _fusion.TwoSidesToExtentDefinition__get_matchShape(self)

    def _set_matchShape(self, value: "bool") -> "bool":
        r"""Gets and sets whether the toEntity is extended to fully intersect the extrusion."""
        return _fusion.TwoSidesToExtentDefinition__set_matchShape(self, value)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >":
        r"""
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.TwoSidesToExtentDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.TwoSidesToExtentDefinition__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.TwoSidesToExtentDefinition__get_isValid(self)

# Register TwoSidesToExtentDefinition in _fusion:
_fusion.TwoSidesToExtentDefinition_swigregister(TwoSidesToExtentDefinition)

def TwoSidesToExtentDefinition_classType() -> "char const *":
    return _fusion.TwoSidesToExtentDefinition_classType()


TwoSidesToExtentDefinition.toEntityOne = property(TwoSidesToExtentDefinition._get_toEntityOne, TwoSidesToExtentDefinition._set_toEntityOne, doc="Gets and sets the entity that defines the extent on side one. The valid types of entities can vary depending on\nthe type of feature this is being used with.")


TwoSidesToExtentDefinition.toEntityTwo = property(TwoSidesToExtentDefinition._get_toEntityTwo, TwoSidesToExtentDefinition._set_toEntityTwo, doc="Gets and sets the entity that defines the extent on side two. The valid types of entities can vary depending on\nthe type of feature this is being used with.")


TwoSidesToExtentDefinition.matchShape = property(TwoSidesToExtentDefinition._get_matchShape, TwoSidesToExtentDefinition._set_matchShape, doc="Gets and sets whether the toEntity is extended to fully intersect the extrusion.")


TwoSidesToExtentDefinition.cast = lambda arg: arg if isinstance(arg, TwoSidesToExtentDefinition) else None

class UnfoldFeature(Feature):
    r"""Object that represents an existing unfold feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::UnfoldFeature *":
        return _fusion.UnfoldFeature___deref__(self)

    def __eq__(self, rhs: "UnfoldFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.UnfoldFeature___eq__(self, rhs)


    def __ne__(self, rhs: "UnfoldFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.UnfoldFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.UnfoldFeature_classType()
    __swig_destroy__ = _fusion.delete_UnfoldFeature

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.UnfoldFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.UnfoldFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.UnfoldFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.UnfoldFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.UnfoldFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.UnfoldFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.UnfoldFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.UnfoldFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.UnfoldFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.UnfoldFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.UnfoldFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.UnfoldFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.UnfoldFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.UnfoldFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.UnfoldFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.UnfoldFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.UnfoldFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.UnfoldFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.UnfoldFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.UnfoldFeature__get_isValid(self)

# Register UnfoldFeature in _fusion:
_fusion.UnfoldFeature_swigregister(UnfoldFeature)

def UnfoldFeature_classType() -> "char const *":
    return _fusion.UnfoldFeature_classType()


UnfoldFeature.cast = lambda arg: arg if isinstance(arg, UnfoldFeature) else None

class UnstitchFeature(Feature):
    r"""Object that represents an existing Unstitch feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::UnstitchFeature *":
        return _fusion.UnstitchFeature___deref__(self)

    def __eq__(self, rhs: "UnstitchFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.UnstitchFeature___eq__(self, rhs)


    def __ne__(self, rhs: "UnstitchFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.UnstitchFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.UnstitchFeature_classType()
    __swig_destroy__ = _fusion.delete_UnstitchFeature

    def setInputFaces(self, faces: "ObjectCollection", isChainSelection: "bool"=True) -> "bool":
        r"""
        Sets the faces and/or bodies to be unstiched.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        faces : The faces and/or bodies to Unstitch. Individual faces can be unstitched from solids and/or patch bodies. 
        The faces being unstitched need not all come from the same body. 
        isChainSelection : A boolean value for setting whether or not faces that are connected and adjacent to 
        the input faces will be included in the selection. The default value is true. 
        Returns true if successful.
        """
        return _fusion.UnstitchFeature_setInputFaces(self, faces, isChainSelection)

    def _get_inputFaces(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets the faces that were input to be unstitched.
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.UnstitchFeature__get_inputFaces(self)

    def _get_isChainSelection(self) -> "bool":
        r"""
        A boolean value for setting whether or not faces that are connected and adjacent to 
        the input faces will be included in the selection. The default value is true.
        """
        return _fusion.UnstitchFeature__get_isChainSelection(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::UnstitchFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.UnstitchFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::UnstitchFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.UnstitchFeature_createForAssemblyContext(self, occurrence)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.UnstitchFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.UnstitchFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.UnstitchFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.UnstitchFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.UnstitchFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.UnstitchFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.UnstitchFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.UnstitchFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.UnstitchFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.UnstitchFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.UnstitchFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.UnstitchFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.UnstitchFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.UnstitchFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.UnstitchFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.UnstitchFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.UnstitchFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.UnstitchFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.UnstitchFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.UnstitchFeature__get_isValid(self)

# Register UnstitchFeature in _fusion:
_fusion.UnstitchFeature_swigregister(UnstitchFeature)

def UnstitchFeature_classType() -> "char const *":
    return _fusion.UnstitchFeature_classType()


UnstitchFeature.inputFaces = property(UnstitchFeature._get_inputFaces, doc="Gets the faces that were input to be unstitched.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


UnstitchFeature.isChainSelection = property(UnstitchFeature._get_isChainSelection, doc="A boolean value for setting whether or not faces that are connected and adjacent to\nthe input faces will be included in the selection. The default value is true.")


UnstitchFeature.nativeObject = property(UnstitchFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


UnstitchFeature.cast = lambda arg: arg if isinstance(arg, UnstitchFeature) else None

class UntrimFeature(Feature):
    r"""Object that represents an existing Untrim feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::UntrimFeature *":
        return _fusion.UntrimFeature___deref__(self)

    def __eq__(self, rhs: "UntrimFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.UntrimFeature___eq__(self, rhs)


    def __ne__(self, rhs: "UntrimFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.UntrimFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.UntrimFeature_classType()
    __swig_destroy__ = _fusion.delete_UntrimFeature

    def _get_untrimLoopType(self) -> "adsk::fusion::UntrimLoopTypes":
        r"""Gets the loop type that was untrimmed. To change the trim type, use one of the redefine methods."""
        return _fusion.UntrimFeature__get_untrimLoopType(self)

    def _get_facesToUntrim(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepFace > > >":
        r"""
        Gets the face objects to untrim.
        Returns null/None in the case where loops are specified instead of faces.
        """
        return _fusion.UntrimFeature__get_facesToUntrim(self)

    def redefineLoopsFromFaces(self, faces: "BRepFaceVector", untrimLoopType: "UntrimLoopTypes") -> "bool":
        r"""
        Set the loops to be removed from a set of faces. 
        faces : An array of BRepFace objects that will have the loops of the specified types removed.
        Only loops that do not have a connected face can be removed (the edges in the loop have a single face).
        The array can only contain faces from surface bodies, (the isSolid property of the BRepBody returns false). 
        untrimLoopType : The loop type to be untrimmed (AllLoopUntrimType, InternalLoopUntrimType, or ExternalLoopUntrimType). 
        Returns whether the operation was successful
        """
        return _fusion.UntrimFeature_redefineLoopsFromFaces(self, faces, untrimLoopType)

    def _get_loopsToUntrim(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepLoop >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepLoop > > >":
        r"""
        Gets the loop objects to untrim.
        Returns null/None in the case where faces are specified instead of loops
        """
        return _fusion.UntrimFeature__get_loopsToUntrim(self)

    def redefineLoops(self, loops: "BRepLoopVector") -> "bool":
        r"""
        Set the loops to be removed. 
        loops : Input the entities that define loops to remove.
        Only loops that do not have a connected face can be removed (the edges in the loop have a single face)
        The array can only contain loops from surface bodies, (the isSolid property of the BRepBody returns false). 
        Returns whether the operation was successful
        """
        return _fusion.UntrimFeature_redefineLoops(self, loops)

    def _get_extensionDistance(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Gets the ModelParameter that defines the extension distance used to extend external boundaries.
        This can return null in the case where only internal boundaries have been removed. 
        The value can be edited by using the properties of the returned ModelParameter object.
        """
        return _fusion.UntrimFeature__get_extensionDistance(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::UntrimFeature >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.UntrimFeature__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::UntrimFeature >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.UntrimFeature_createForAssemblyContext(self, occurrence)

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.UntrimFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.UntrimFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.UntrimFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.UntrimFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.UntrimFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.UntrimFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.UntrimFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.UntrimFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.UntrimFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.UntrimFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.UntrimFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.UntrimFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.UntrimFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.UntrimFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.UntrimFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.UntrimFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.UntrimFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.UntrimFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.UntrimFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.UntrimFeature__get_isValid(self)

# Register UntrimFeature in _fusion:
_fusion.UntrimFeature_swigregister(UntrimFeature)

def UntrimFeature_classType() -> "char const *":
    return _fusion.UntrimFeature_classType()


UntrimFeature.untrimLoopType = property(UntrimFeature._get_untrimLoopType, doc="Gets the loop type that was untrimmed. To change the trim type, use one of the redefine methods.")


UntrimFeature.facesToUntrim = property(UntrimFeature._get_facesToUntrim, doc="Gets the face objects to untrim.\nReturns null/None in the case where loops are specified instead of faces.")


UntrimFeature.loopsToUntrim = property(UntrimFeature._get_loopsToUntrim, doc="Gets the loop objects to untrim.\nReturns null/None in the case where faces are specified instead of loops")


UntrimFeature.extensionDistance = property(UntrimFeature._get_extensionDistance, doc="Gets the ModelParameter that defines the extension distance used to extend external boundaries.\nThis can return null in the case where only internal boundaries have been removed.\nThe value can be edited by using the properties of the returned ModelParameter object.")


UntrimFeature.nativeObject = property(UntrimFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


UntrimFeature.cast = lambda arg: arg if isinstance(arg, UntrimFeature) else None

class UserParameter(Parameter):
    r"""Represents a User Parameter."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::UserParameter *":
        return _fusion.UserParameter___deref__(self)

    def __eq__(self, rhs: "UserParameter") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.UserParameter___eq__(self, rhs)


    def __ne__(self, rhs: "UserParameter") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.UserParameter___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.UserParameter_classType()
    __swig_destroy__ = _fusion.delete_UserParameter

    def deleteMe(self) -> "bool":
        r"""
        Deletes the user parameter
        A parameter can only be deleted if it is a UserParameter and
        it is not referenced by other parameters. 
        Returns a bool indicating if the delete was successful or not.
        Bug!!! Currently returning true if the parameter can't be deleted because it is
        being referenced by other parameters.
        """
        return _fusion.UserParameter_deleteMe(self)

    def _get_userParameters(self) -> "adsk::core::Ptr< adsk::fusion::UserParameters >":
        r"""Returns the Collection containing the UserParameter."""
        return _fusion.UserParameter__get_userParameters(self)

    def _get_design(self) -> "adsk::core::Ptr< adsk::fusion::Design >":
        r"""Returns the Design containing the UserParameter."""
        return _fusion.UserParameter__get_design(self)

    def _get_value(self) -> "double":
        r"""
        Gets and sets the real value (a double) of the parameter in database units. 
        Setting this property will set/reset the expression value for this parameter
        """
        return _fusion.UserParameter__get_value(self)

    def _set_value(self, value: "double") -> "bool":
        r"""
        Gets and sets the real value (a double) of the parameter in database units. 
        Setting this property will set/reset the expression value for this parameter
        """
        return _fusion.UserParameter__set_value(self, value)

    def _get_expression(self) -> "std::string":
        r"""Gets and sets the expression (ie. '22.064 mm') used to calculate the value of the parameter"""
        return _fusion.UserParameter__get_expression(self)

    def _set_expression(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the expression (ie. '22.064 mm') used to calculate the value of the parameter"""
        return _fusion.UserParameter__set_expression(self, value)

    def _get_name(self) -> "std::string":
        r"""
        Gets and sets the name of the parameter. Setting the name can fail if the name 
        is not unique with respect to all other parameters in the design.
        """
        return _fusion.UserParameter__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the name of the parameter. Setting the name can fail if the name 
        is not unique with respect to all other parameters in the design.
        """
        return _fusion.UserParameter__set_name(self, value)

    def _get_unit(self) -> "std::string":
        r"""
        The unit type associated with this parameter. An empty string is returned for parameters
        that don't have a unit type.
        """
        return _fusion.UserParameter__get_unit(self)

    def _get_comment(self) -> "std::string":
        r"""The comment associated with this parameter"""
        return _fusion.UserParameter__get_comment(self)

    def _set_comment(self, value: "std::string const &") -> "bool":
        r"""The comment associated with this parameter"""
        return _fusion.UserParameter__set_comment(self, value)

    def _get_isFavorite(self) -> "bool":
        r"""
        Gets and sets whether this parameter is included in the Favorites list in the
        parameters dialog
        """
        return _fusion.UserParameter__get_isFavorite(self)

    def _set_isFavorite(self, value: "bool") -> "bool":
        r"""
        Gets and sets whether this parameter is included in the Favorites list in the
        parameters dialog
        """
        return _fusion.UserParameter__set_isFavorite(self, value)

    def _get_dependentParameters(self) -> "adsk::core::Ptr< adsk::fusion::ParameterList >":
        r"""
        Returns a list of parameters that are dependent on this parameter as a result
        of this parameter being referenced in their equation.
        """
        return _fusion.UserParameter__get_dependentParameters(self)

    def _get_isDeletable(self) -> "bool":
        r"""
        Gets if this parameter can be deleted. Parameters that cannot be deleted are: Model Parameters and 
        User Parameters that have dependents.
        """
        return _fusion.UserParameter__get_isDeletable(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.UserParameter__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Parameter object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same parameter.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.UserParameter__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.UserParameter__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.UserParameter__get_isValid(self)

# Register UserParameter in _fusion:
_fusion.UserParameter_swigregister(UserParameter)

def UserParameter_classType() -> "char const *":
    return _fusion.UserParameter_classType()


UserParameter.userParameters = property(UserParameter._get_userParameters, doc="Returns the Collection containing the UserParameter.")


UserParameter.design = property(UserParameter._get_design, doc="Returns the Design containing the UserParameter.")


UserParameter.cast = lambda arg: arg if isinstance(arg, UserParameter) else None

class VariableRadiusFilletEdgeSet(FilletEdgeSet):
    r"""Provides access to the edges and the parameters associated with a variable radius fillet."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::VariableRadiusFilletEdgeSet *":
        return _fusion.VariableRadiusFilletEdgeSet___deref__(self)

    def __eq__(self, rhs: "VariableRadiusFilletEdgeSet") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.VariableRadiusFilletEdgeSet___eq__(self, rhs)


    def __ne__(self, rhs: "VariableRadiusFilletEdgeSet") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.VariableRadiusFilletEdgeSet___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.VariableRadiusFilletEdgeSet_classType()
    __swig_destroy__ = _fusion.delete_VariableRadiusFilletEdgeSet

    def _get_edges(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Gets and sets the edges that will be filleted. 
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.VariableRadiusFilletEdgeSet__get_edges(self)

    def _set_edges(self, value: "ObjectCollection") -> "bool":
        r"""
        Gets and sets the edges that will be filleted. 
        To use this property, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.VariableRadiusFilletEdgeSet__set_edges(self, value)

    def _get_startRadius(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the model parameter that controls the start radius of the fillet. You can edit
        the start radius by using the properties on the returned ModelParameter object.
        """
        return _fusion.VariableRadiusFilletEdgeSet__get_startRadius(self)

    def _get_endRadius(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >":
        r"""
        Returns the model parameter that controls the end radius of the fillet. You can edit
        the end radius by using the properties on the returned ModelParameter object.
        """
        return _fusion.VariableRadiusFilletEdgeSet__get_endRadius(self)

    def _get_midRadii(self) -> "adsk::core::Ptr< adsk::fusion::ParameterList >":
        r"""
        Returns a list of model parameters that control radius of the fillet at each position defined along the edge set.
        You can edit any of these radii by using the properties on its returned ModelParameter object. This list does
        not include the parameters for the start and end radii. Use the startRadius and endRadius properties to get those.
        """
        return _fusion.VariableRadiusFilletEdgeSet__get_midRadii(self)

    def _get_midPositions(self) -> "adsk::core::Ptr< adsk::fusion::ParameterList >":
        r"""
        Returns a list of model parameters that control the location of each mid point radius. These positions are defined
        from 0 to 1 where 0 is at the start of the edge and 1 is at the end. You can edit any of these positions by 
        using the properties on its returned ModelParameter object.
        """
        return _fusion.VariableRadiusFilletEdgeSet__get_midPositions(self)

    def addMidPosition(self, position: "ValueInput", radius: "ValueInput") -> "bool":
        r"""
        Creates a new mid position radius on the variable radius edge set.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        position : The position where the new radius is to be created. This is a value between 0 and 1 where 0 is at the start of the 
        edge and 1 is at the end. If the ValueInput uses a real then it is interpreted as a unitless value. If it is a string
        then it must resolve to a unitless value. 
        radius : A ValueInput object that defines the radius at the defined position. If the ValueInput uses a real 
        then it is interpreted as centimeters. If it is a string then the units can be defined as part of 
        the string (i.e. '2 in'). If no units are specified it will be interpreted using the current 
        default units for length. 
        Returns true if successful.
        """
        return _fusion.VariableRadiusFilletEdgeSet_addMidPosition(self, position, radius)

    def deleteMidPosition(self, positionIndex: "size_t") -> "bool":
        r"""
        Deletes the specified mid position from the variable radius fillet.
        To use this method, you need to position the timeline marker to immediately before this feature. 
        This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True) 
        positionIndex : The index of the mid position to delete. The points are in the order they appear along the edge
        where the first point has an index of 0. The number of mid positions and their locations can be
        obtained by getting the list of mid positions using the midPositions property. 
        Returns true if successful.
        """
        return _fusion.VariableRadiusFilletEdgeSet_deleteMidPosition(self, positionIndex)

    def _get_isTangentChain(self) -> "bool":
        r"""Gets and sets the Tangent chain for fillet. This enables tangent chain option for fillet."""
        return _fusion.VariableRadiusFilletEdgeSet__get_isTangentChain(self)

    def _set_isTangentChain(self, value: "bool") -> "bool":
        r"""Gets and sets the Tangent chain for fillet. This enables tangent chain option for fillet."""
        return _fusion.VariableRadiusFilletEdgeSet__set_isTangentChain(self, value)

    def _get_objectType(self) -> "char const *":
        return _fusion.VariableRadiusFilletEdgeSet__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.VariableRadiusFilletEdgeSet__get_isValid(self)

# Register VariableRadiusFilletEdgeSet in _fusion:
_fusion.VariableRadiusFilletEdgeSet_swigregister(VariableRadiusFilletEdgeSet)

def VariableRadiusFilletEdgeSet_classType() -> "char const *":
    return _fusion.VariableRadiusFilletEdgeSet_classType()


VariableRadiusFilletEdgeSet.edges = property(VariableRadiusFilletEdgeSet._get_edges, VariableRadiusFilletEdgeSet._set_edges, doc="Gets and sets the edges that will be filleted.\nTo use this property, you need to position the timeline marker to immediately before this feature.\nThis can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)")


VariableRadiusFilletEdgeSet.startRadius = property(VariableRadiusFilletEdgeSet._get_startRadius, doc="Returns the model parameter that controls the start radius of the fillet. You can edit\nthe start radius by using the properties on the returned ModelParameter object.")


VariableRadiusFilletEdgeSet.endRadius = property(VariableRadiusFilletEdgeSet._get_endRadius, doc="Returns the model parameter that controls the end radius of the fillet. You can edit\nthe end radius by using the properties on the returned ModelParameter object.")


VariableRadiusFilletEdgeSet.midRadii = property(VariableRadiusFilletEdgeSet._get_midRadii, doc="Returns a list of model parameters that control radius of the fillet at each position defined along the edge set.\nYou can edit any of these radii by using the properties on its returned ModelParameter object. This list does\nnot include the parameters for the start and end radii. Use the startRadius and endRadius properties to get those.")


VariableRadiusFilletEdgeSet.midPositions = property(VariableRadiusFilletEdgeSet._get_midPositions, doc="Returns a list of model parameters that control the location of each mid point radius. These positions are defined\nfrom 0 to 1 where 0 is at the start of the edge and 1 is at the end. You can edit any of these positions by\nusing the properties on its returned ModelParameter object.")


VariableRadiusFilletEdgeSet.cast = lambda arg: arg if isinstance(arg, VariableRadiusFilletEdgeSet) else None

class VerticalConstraint(GeometricConstraint):
    r"""A vertical constraint in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::VerticalConstraint *":
        return _fusion.VerticalConstraint___deref__(self)

    def __eq__(self, rhs: "VerticalConstraint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.VerticalConstraint___eq__(self, rhs)


    def __ne__(self, rhs: "VerticalConstraint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.VerticalConstraint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.VerticalConstraint_classType()
    __swig_destroy__ = _fusion.delete_VerticalConstraint

    def _get_line(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""Returns the line being constrained."""
        return _fusion.VerticalConstraint__get_line(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::VerticalConstraint >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.VerticalConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::VerticalConstraint >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.VerticalConstraint_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.VerticalConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this constraint is deletable."""
        return _fusion.VerticalConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.VerticalConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.VerticalConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.VerticalConstraint__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the GeometricConstraint object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same geometric constraint.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.VerticalConstraint__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.VerticalConstraint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.VerticalConstraint__get_isValid(self)

# Register VerticalConstraint in _fusion:
_fusion.VerticalConstraint_swigregister(VerticalConstraint)

def VerticalConstraint_classType() -> "char const *":
    return _fusion.VerticalConstraint_classType()


VerticalConstraint.line = property(VerticalConstraint._get_line, doc="Returns the line being constrained.")


VerticalConstraint.nativeObject = property(VerticalConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


VerticalConstraint.cast = lambda arg: arg if isinstance(arg, VerticalConstraint) else None

class VerticalPointsConstraint(GeometricConstraint):
    r"""A vertical constraint between two points in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::VerticalPointsConstraint *":
        return _fusion.VerticalPointsConstraint___deref__(self)

    def __eq__(self, rhs: "VerticalPointsConstraint") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.VerticalPointsConstraint___eq__(self, rhs)


    def __ne__(self, rhs: "VerticalPointsConstraint") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.VerticalPointsConstraint___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.VerticalPointsConstraint_classType()
    __swig_destroy__ = _fusion.delete_VerticalPointsConstraint

    def _get_pointOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""Returns the first point."""
        return _fusion.VerticalPointsConstraint__get_pointOne(self)

    def _get_pointTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""Returns the second point."""
        return _fusion.VerticalPointsConstraint__get_pointTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::VerticalPointsConstraint >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.VerticalPointsConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::VerticalPointsConstraint >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.VerticalPointsConstraint_createForAssemblyContext(self, occurrence)

    def deleteMe(self) -> "bool":
        r"""
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.VerticalPointsConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool":
        r"""Indicates if this constraint is deletable."""
        return _fusion.VerticalPointsConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch object."""
        return _fusion.VerticalPointsConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.VerticalPointsConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.VerticalPointsConstraint__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the GeometricConstraint object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same geometric constraint.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.VerticalPointsConstraint__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.VerticalPointsConstraint__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.VerticalPointsConstraint__get_isValid(self)

# Register VerticalPointsConstraint in _fusion:
_fusion.VerticalPointsConstraint_swigregister(VerticalPointsConstraint)

def VerticalPointsConstraint_classType() -> "char const *":
    return _fusion.VerticalPointsConstraint_classType()


VerticalPointsConstraint.pointOne = property(VerticalPointsConstraint._get_pointOne, doc="Returns the first point.")


VerticalPointsConstraint.pointTwo = property(VerticalPointsConstraint._get_pointTwo, doc="Returns the second point.")


VerticalPointsConstraint.nativeObject = property(VerticalPointsConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


VerticalPointsConstraint.cast = lambda arg: arg if isinstance(arg, VerticalPointsConstraint) else None

class WebFeature(Feature):
    r"""Object that represents an existing web feature in a design."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::WebFeature *":
        return _fusion.WebFeature___deref__(self)

    def __eq__(self, rhs: "WebFeature") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.WebFeature___eq__(self, rhs)


    def __ne__(self, rhs: "WebFeature") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.WebFeature___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.WebFeature_classType()
    __swig_destroy__ = _fusion.delete_WebFeature

    def _get_name(self) -> "std::string":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.WebFeature__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.WebFeature__set_name(self, value)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.WebFeature_deleteMe(self)

    def dissolve(self) -> "bool":
        r"""
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.WebFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.WebFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.WebFeature__set_isSuppressed(self, value)

    def _get_isParametric(self) -> "bool":
        r"""Indicates if this feature is parametric or not."""
        return _fusion.WebFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >":
        r"""
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.WebFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the parent component that owns this feature."""
        return _fusion.WebFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >":
        r"""
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.WebFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.WebFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >":
        r"""Returns the timeline object associated with this feature."""
        return _fusion.WebFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >":
        r"""
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.WebFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.WebFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >":
        r"""
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.WebFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates":
        r"""Returns the current health state of the feature."""
        return _fusion.WebFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string":
        r"""
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.WebFeature__get_errorOrWarningMessage(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Feature object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same feature.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.WebFeature__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.WebFeature__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.WebFeature__get_isValid(self)

# Register WebFeature in _fusion:
_fusion.WebFeature_swigregister(WebFeature)

def WebFeature_classType() -> "char const *":
    return _fusion.WebFeature_classType()


WebFeature.cast = lambda arg: arg if isinstance(arg, WebFeature) else None

class CustomFeatureParameter(ModelParameter):
    r"""
    A custom parameter is a parameter that was created as the result of a custom feature
    being created. It is associated with the custom feature and it's lifetime is the same
    as the custom feature that owns it.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::CustomFeatureParameter *":
        return _fusion.CustomFeatureParameter___deref__(self)

    def __eq__(self, rhs: "CustomFeatureParameter") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.CustomFeatureParameter___eq__(self, rhs)


    def __ne__(self, rhs: "CustomFeatureParameter") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.CustomFeatureParameter___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.CustomFeatureParameter_classType()
    __swig_destroy__ = _fusion.delete_CustomFeatureParameter

    def _get_id(self) -> "std::string":
        r"""Returns the ID of this custom feature parameter."""
        return _fusion.CustomFeatureParameter__get_id(self)

    def _get_isVisible(self) -> "bool":
        r"""
        Gets and sets if this parameter is visible in the parameters dialog. By default, all new parameters are visible. 
        This can be useful in cases where the feature can be edited to be in different states where a parameter 
        is only valid in a certain state. You can change the visibility based on the current state of the feature 
        and if that parameter should be available for edit. This implies that you create all the parameters that
        might be needed and then change their visibility based on the current state of the feature. The parameters
        that are not visible will not be returned by the ModelParameters collection and are only available through
        the custom feature they're associated with.
        """
        return _fusion.CustomFeatureParameter__get_isVisible(self)

    def _set_isVisible(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this parameter is visible in the parameters dialog. By default, all new parameters are visible. 
        This can be useful in cases where the feature can be edited to be in different states where a parameter 
        is only valid in a certain state. You can change the visibility based on the current state of the feature 
        and if that parameter should be available for edit. This implies that you create all the parameters that
        might be needed and then change their visibility based on the current state of the feature. The parameters
        that are not visible will not be returned by the ModelParameters collection and are only available through
        the custom feature they're associated with.
        """
        return _fusion.CustomFeatureParameter__set_isVisible(self, value)

    def _get_parentCustomFeature(self) -> "adsk::core::Ptr< adsk::fusion::CustomFeature >":
        r"""Returns the custom feature this parameter is associated with."""
        return _fusion.CustomFeatureParameter__get_parentCustomFeature(self)

    def _get_modelParameters(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameters >":
        r"""Returns the Collection containing the ModelParameter."""
        return _fusion.CustomFeatureParameter__get_modelParameters(self)

    def _get_component(self) -> "adsk::core::Ptr< adsk::fusion::Component >":
        r"""Returns the Component containing the ModelParameter."""
        return _fusion.CustomFeatureParameter__get_component(self)

    def _get_role(self) -> "std::string":
        r"""
        This property identifies what the parameter is used for. For an extrude, it 
        could be 'Depth', for a Workplane it could be 'Offset'.
        """
        return _fusion.CustomFeatureParameter__get_role(self)

    def _get_createdBy(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the object that created this parameter. For example,
        a feature, a sketch dimension, or a construction plane.
        """
        return _fusion.CustomFeatureParameter__get_createdBy(self)

    def _get_value(self) -> "double":
        r"""
        Gets and sets the real value (a double) of the parameter in database units. 
        Setting this property will set/reset the expression value for this parameter
        """
        return _fusion.CustomFeatureParameter__get_value(self)

    def _set_value(self, value: "double") -> "bool":
        r"""
        Gets and sets the real value (a double) of the parameter in database units. 
        Setting this property will set/reset the expression value for this parameter
        """
        return _fusion.CustomFeatureParameter__set_value(self, value)

    def _get_expression(self) -> "std::string":
        r"""Gets and sets the expression (ie. '22.064 mm') used to calculate the value of the parameter"""
        return _fusion.CustomFeatureParameter__get_expression(self)

    def _set_expression(self, value: "std::string const &") -> "bool":
        r"""Gets and sets the expression (ie. '22.064 mm') used to calculate the value of the parameter"""
        return _fusion.CustomFeatureParameter__set_expression(self, value)

    def _get_name(self) -> "std::string":
        r"""
        Gets and sets the name of the parameter. Setting the name can fail if the name 
        is not unique with respect to all other parameters in the design.
        """
        return _fusion.CustomFeatureParameter__get_name(self)

    def _set_name(self, value: "std::string const &") -> "bool":
        r"""
        Gets and sets the name of the parameter. Setting the name can fail if the name 
        is not unique with respect to all other parameters in the design.
        """
        return _fusion.CustomFeatureParameter__set_name(self, value)

    def _get_unit(self) -> "std::string":
        r"""
        The unit type associated with this parameter. An empty string is returned for parameters
        that don't have a unit type.
        """
        return _fusion.CustomFeatureParameter__get_unit(self)

    def _get_comment(self) -> "std::string":
        r"""The comment associated with this parameter"""
        return _fusion.CustomFeatureParameter__get_comment(self)

    def _set_comment(self, value: "std::string const &") -> "bool":
        r"""The comment associated with this parameter"""
        return _fusion.CustomFeatureParameter__set_comment(self, value)

    def _get_isFavorite(self) -> "bool":
        r"""
        Gets and sets whether this parameter is included in the Favorites list in the
        parameters dialog
        """
        return _fusion.CustomFeatureParameter__get_isFavorite(self)

    def _set_isFavorite(self, value: "bool") -> "bool":
        r"""
        Gets and sets whether this parameter is included in the Favorites list in the
        parameters dialog
        """
        return _fusion.CustomFeatureParameter__set_isFavorite(self, value)

    def _get_dependentParameters(self) -> "adsk::core::Ptr< adsk::fusion::ParameterList >":
        r"""
        Returns a list of parameters that are dependent on this parameter as a result
        of this parameter being referenced in their equation.
        """
        return _fusion.CustomFeatureParameter__get_dependentParameters(self)

    def _get_isDeletable(self) -> "bool":
        r"""
        Gets if this parameter can be deleted. Parameters that cannot be deleted are: Model Parameters and 
        User Parameters that have dependents.
        """
        return _fusion.CustomFeatureParameter__get_isDeletable(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.CustomFeatureParameter__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the Parameter object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same parameter.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.CustomFeatureParameter__get_entityToken(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.CustomFeatureParameter__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.CustomFeatureParameter__get_isValid(self)

# Register CustomFeatureParameter in _fusion:
_fusion.CustomFeatureParameter_swigregister(CustomFeatureParameter)

def CustomFeatureParameter_classType() -> "char const *":
    return _fusion.CustomFeatureParameter_classType()


CustomFeatureParameter.id = property(CustomFeatureParameter._get_id, doc="Returns the ID of this custom feature parameter.")


CustomFeatureParameter.isVisible = property(CustomFeatureParameter._get_isVisible, CustomFeatureParameter._set_isVisible, doc="Gets and sets if this parameter is visible in the parameters dialog. By default, all new parameters are visible.\nThis can be useful in cases where the feature can be edited to be in different states where a parameter\nis only valid in a certain state. You can change the visibility based on the current state of the feature\nand if that parameter should be available for edit. This implies that you create all the parameters that\nmight be needed and then change their visibility based on the current state of the feature. The parameters\nthat are not visible will not be returned by the ModelParameters collection and are only available through\nthe custom feature they're associated with.")


CustomFeatureParameter.parentCustomFeature = property(CustomFeatureParameter._get_parentCustomFeature, doc="Returns the custom feature this parameter is associated with.")


CustomFeatureParameter.cast = lambda arg: arg if isinstance(arg, CustomFeatureParameter) else None

class SketchArc(SketchCurve):
    r"""An arc in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchArc *":
        return _fusion.SketchArc___deref__(self)

    def __eq__(self, rhs: "SketchArc") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchArc___eq__(self, rhs)


    def __ne__(self, rhs: "SketchArc") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchArc___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchArc_classType()
    __swig_destroy__ = _fusion.delete_SketchArc

    def _get_centerSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""
        The sketch point at the center of the arc. The arc is dependent on this point and moving the
        point will cause the arc to adjust.
        """
        return _fusion.SketchArc__get_centerSketchPoint(self)

    def _get_startSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""
        The sketch point at the start of the arc. The arc is dependent on this point and moving the
        point will cause the arc to adjust.
        """
        return _fusion.SketchArc__get_startSketchPoint(self)

    def _get_endSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""
        The sketch point at the end of the arc. The arc is dependent on this point and moving the
        point will cause the arc to adjust.
        """
        return _fusion.SketchArc__get_endSketchPoint(self)

    def _get_radius(self) -> "double":
        r"""
        Gets and sets the radius of the arc. Changing the radius is limited
        by any constraints that might exist on the circle. Setting the radius
        can fail in cases where the radius is fully defined through constraints.
        """
        return _fusion.SketchArc__get_radius(self)

    def _set_radius(self, value: "double") -> "bool":
        r"""
        Gets and sets the radius of the arc. Changing the radius is limited
        by any constraints that might exist on the circle. Setting the radius
        can fail in cases where the radius is fully defined through constraints.
        """
        return _fusion.SketchArc__set_radius(self, value)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Arc3D >":
        r"""
        Returns the transient geometry of the arc which provides geometric
        information about the arc. The returned geometry is always in sketch space.
        """
        return _fusion.SketchArc__get_geometry(self)

    def _get_worldGeometry(self) -> "adsk::core::Ptr< adsk::core::Arc3D >":
        r"""
        Returns an Arc3D object which provides geometric information in world space.
        The returned geometry takes into account the assembly context and the position of the
        sketch in it's parent component, which means the geometry will be returned in the root
        component space.
        """
        return _fusion.SketchArc__get_worldGeometry(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchArc >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchArc__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SketchArc >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchArc_createForAssemblyContext(self, occurrence)

    def _get_length(self) -> "double":
        r"""Returns the length of the curve in centimeters."""
        return _fusion.SketchArc__get_length(self)

    def _get_isConstruction(self) -> "bool":
        r"""Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchArc__get_isConstruction(self)

    def _set_isConstruction(self, value: "bool") -> "bool":
        r"""Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchArc__set_isConstruction(self, value)

    def split(self, splitPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Split a curve at a position specified along the curve 
        splitPoint : A position (transient Point3D) on the curve that defines the point at which to split the curve 
        createConstraints : Constraints are created by default. Specify false to create no constraints. 
        Returns the resulting 2 curves; the original curve + the newly created curve
        When split spline the original is deleted and two new curves returned.
        Empty collection returned if curve is closed.
        """
        return _fusion.SketchArc_split(self, splitPoint, createConstraints)

    def trim(self, segmentPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Trim a curve by specifying a point that determines the segment of the curve to trim away 
        segmentPoint : A point (transient Point3D) on or closest to the segment of the curve to remove. (start, end or middle)
        The segment of the curve closest to the segmentPoint gets removed 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        When trimming the start or end side of a line, unclosed circular or elliptical arc, the original entity is modified and returned
        When trimming the middle of a line, unclosed circular or elliptical arc the original entity is deleted and two new entities are returned
        When trimming the start or end of any type of closed curve, the original is deleted and a new curve is returned
        Any trimming of a spline (open or closed) deletes the original and new spline/s are returned
        Trimming a curve having no intersections deletes the original and returns an empty collection
        """
        return _fusion.SketchArc_trim(self, segmentPoint, createConstraints)

    def breakCurve(self, segmentPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Breaks a curve into two or three pieces by finding intersections of this curve with all other curves in the
        sketch and splitting this curve at the nearest intersections to a specified point on the curve. 
        segmentPoint : A point that specifies the segment of the curve that is to be split from the rest of the curve. The nearest
        intersection(s) to this point define the break location(s). 
        createConstraints : Optional argument that specifies if constraints should be created between the new curve segments. A value of
        true indicates constraints will be created. 
        All of the curves resulting from the break are returned in an ObjectCollection. In the case where no intersections
        are found and as a result the curve is not broken, an empty ObjectCollection is returned.
        """
        return _fusion.SketchArc_breakCurve(self, segmentPoint, createConstraints)

    def extend(self, endPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Extend a curve by specifying a point that determines the end of the curve to extend 
        endPoint : A point (transient Point3D) on or closest to the end of the curve to extend. (start or end)
        The end of the curve closest to the endPoint gets extended 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        Returns the modified original curve if the start or end of the curve is extended
        If the extend joins a curve to another, the two original curves are deleted and a new curve is returned
        If an arc is extended so as to become a circle, the original arc is deleted and a new circle is returned
        """
        return _fusion.SketchArc_extend(self, endPoint, createConstraints)

    def intersections(self, sketchCurves: "ObjectCollection") -> "bool":
        r"""
        Get the curves that intersect this curve along with the intersection points (Point3D) 
        sketchCurves : A collection of curves to attempt to find intersections with. 
        Set the value of this parameter to null to use all curves in the sketch for the calculation. 
        intersectingCurves : A collection of the actual intersecting curves 
        intersectionPoints : A collection of intersection points (Point3D)
        Item numbers in this collection correspond to the item numbers in the intersectingCurves collection. 
        Returns true if the method was successful. It can be successful regardless of whether intersections were found or not.
        """
        return _fusion.SketchArc_intersections(self, sketchCurves)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch."""
        return _fusion.SketchArc__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >":
        r"""Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchArc__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >":
        r"""Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchArc__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool":
        r"""Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchArc__get_is2D(self)

    def _get_isReference(self) -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchArc__get_isReference(self)

    def _set_isReference(self, value: "bool") -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchArc__set_isReference(self, value)

    def _get_isFixed(self) -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchArc__get_isFixed(self)

    def _set_isFixed(self, value: "bool") -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchArc__set_isFixed(self, value)

    def _get_isVisible(self) -> "bool":
        r"""
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchArc__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchArc__get_boundingBox(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchArc_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchArc__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchArc__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool":
        r"""
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchArc__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool":
        r"""Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchArc__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.SketchArc__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the SketchEntity object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same sketch entity.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SketchArc__get_entityToken(self)

    def _get_isLinked(self) -> "bool":
        r"""
        Indicates if this sketch entity was created by a projection, inclusion, or driven by an API script.
        If this returns true, then the entity is presented to the user as not editable and with a 'break link'
        command available.
        """
        return _fusion.SketchArc__get_isLinked(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchArc__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchArc__get_isValid(self)

# Register SketchArc in _fusion:
_fusion.SketchArc_swigregister(SketchArc)

def SketchArc_classType() -> "char const *":
    return _fusion.SketchArc_classType()


SketchArc.centerSketchPoint = property(SketchArc._get_centerSketchPoint, doc="The sketch point at the center of the arc. The arc is dependent on this point and moving the\npoint will cause the arc to adjust.")


SketchArc.startSketchPoint = property(SketchArc._get_startSketchPoint, doc="The sketch point at the start of the arc. The arc is dependent on this point and moving the\npoint will cause the arc to adjust.")


SketchArc.endSketchPoint = property(SketchArc._get_endSketchPoint, doc="The sketch point at the end of the arc. The arc is dependent on this point and moving the\npoint will cause the arc to adjust.")


SketchArc.radius = property(SketchArc._get_radius, SketchArc._set_radius, doc="Gets and sets the radius of the arc. Changing the radius is limited\nby any constraints that might exist on the circle. Setting the radius\ncan fail in cases where the radius is fully defined through constraints.")


SketchArc.geometry = property(SketchArc._get_geometry, doc="Returns the transient geometry of the arc which provides geometric\ninformation about the arc. The returned geometry is always in sketch space.")


SketchArc.worldGeometry = property(SketchArc._get_worldGeometry, doc="Returns an Arc3D object which provides geometric information in world space.\nThe returned geometry takes into account the assembly context and the position of the\nsketch in it's parent component, which means the geometry will be returned in the root\ncomponent space.")


SketchArc.nativeObject = property(SketchArc._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SketchArc.cast = lambda arg: arg if isinstance(arg, SketchArc) else None

class SketchCircle(SketchCurve):
    r"""A circle in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchCircle *":
        return _fusion.SketchCircle___deref__(self)

    def __eq__(self, rhs: "SketchCircle") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchCircle___eq__(self, rhs)


    def __ne__(self, rhs: "SketchCircle") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchCircle___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchCircle_classType()
    __swig_destroy__ = _fusion.delete_SketchCircle

    def _get_centerSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""Returns the sketch point at the center of the circle."""
        return _fusion.SketchCircle__get_centerSketchPoint(self)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Circle3D >":
        r"""
        Returns the transient geometry of the circle which provides geometric
        information about the circle. The returned geometry is always in sketch space.
        """
        return _fusion.SketchCircle__get_geometry(self)

    def _get_worldGeometry(self) -> "adsk::core::Ptr< adsk::core::Circle3D >":
        r"""
        Returns a Point3D object which provides the position of the sketch point in world space.
        The returned coordinate takes into account the assembly context and the position of the
        sketch in it's parent component, which means the coordinate will be returned in the root
        component space.
        """
        return _fusion.SketchCircle__get_worldGeometry(self)

    def _get_area(self) -> "double":
        r"""Returns the area of the circle in square centimeters."""
        return _fusion.SketchCircle__get_area(self)

    def _get_radius(self) -> "double":
        r"""
        Gets and sets the radius of the circle. Changing the radius is limited
        by any constraints that might exist on the circle.
        """
        return _fusion.SketchCircle__get_radius(self)

    def _set_radius(self, value: "double") -> "bool":
        r"""
        Gets and sets the radius of the circle. Changing the radius is limited
        by any constraints that might exist on the circle.
        """
        return _fusion.SketchCircle__set_radius(self, value)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchCircle >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchCircle__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SketchCircle >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchCircle_createForAssemblyContext(self, occurrence)

    def _get_length(self) -> "double":
        r"""Returns the length of the curve in centimeters."""
        return _fusion.SketchCircle__get_length(self)

    def _get_isConstruction(self) -> "bool":
        r"""Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchCircle__get_isConstruction(self)

    def _set_isConstruction(self, value: "bool") -> "bool":
        r"""Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchCircle__set_isConstruction(self, value)

    def split(self, splitPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Split a curve at a position specified along the curve 
        splitPoint : A position (transient Point3D) on the curve that defines the point at which to split the curve 
        createConstraints : Constraints are created by default. Specify false to create no constraints. 
        Returns the resulting 2 curves; the original curve + the newly created curve
        When split spline the original is deleted and two new curves returned.
        Empty collection returned if curve is closed.
        """
        return _fusion.SketchCircle_split(self, splitPoint, createConstraints)

    def trim(self, segmentPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Trim a curve by specifying a point that determines the segment of the curve to trim away 
        segmentPoint : A point (transient Point3D) on or closest to the segment of the curve to remove. (start, end or middle)
        The segment of the curve closest to the segmentPoint gets removed 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        When trimming the start or end side of a line, unclosed circular or elliptical arc, the original entity is modified and returned
        When trimming the middle of a line, unclosed circular or elliptical arc the original entity is deleted and two new entities are returned
        When trimming the start or end of any type of closed curve, the original is deleted and a new curve is returned
        Any trimming of a spline (open or closed) deletes the original and new spline/s are returned
        Trimming a curve having no intersections deletes the original and returns an empty collection
        """
        return _fusion.SketchCircle_trim(self, segmentPoint, createConstraints)

    def breakCurve(self, segmentPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Breaks a curve into two or three pieces by finding intersections of this curve with all other curves in the
        sketch and splitting this curve at the nearest intersections to a specified point on the curve. 
        segmentPoint : A point that specifies the segment of the curve that is to be split from the rest of the curve. The nearest
        intersection(s) to this point define the break location(s). 
        createConstraints : Optional argument that specifies if constraints should be created between the new curve segments. A value of
        true indicates constraints will be created. 
        All of the curves resulting from the break are returned in an ObjectCollection. In the case where no intersections
        are found and as a result the curve is not broken, an empty ObjectCollection is returned.
        """
        return _fusion.SketchCircle_breakCurve(self, segmentPoint, createConstraints)

    def extend(self, endPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Extend a curve by specifying a point that determines the end of the curve to extend 
        endPoint : A point (transient Point3D) on or closest to the end of the curve to extend. (start or end)
        The end of the curve closest to the endPoint gets extended 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        Returns the modified original curve if the start or end of the curve is extended
        If the extend joins a curve to another, the two original curves are deleted and a new curve is returned
        If an arc is extended so as to become a circle, the original arc is deleted and a new circle is returned
        """
        return _fusion.SketchCircle_extend(self, endPoint, createConstraints)

    def intersections(self, sketchCurves: "ObjectCollection") -> "bool":
        r"""
        Get the curves that intersect this curve along with the intersection points (Point3D) 
        sketchCurves : A collection of curves to attempt to find intersections with. 
        Set the value of this parameter to null to use all curves in the sketch for the calculation. 
        intersectingCurves : A collection of the actual intersecting curves 
        intersectionPoints : A collection of intersection points (Point3D)
        Item numbers in this collection correspond to the item numbers in the intersectingCurves collection. 
        Returns true if the method was successful. It can be successful regardless of whether intersections were found or not.
        """
        return _fusion.SketchCircle_intersections(self, sketchCurves)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch."""
        return _fusion.SketchCircle__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >":
        r"""Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchCircle__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >":
        r"""Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchCircle__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool":
        r"""Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchCircle__get_is2D(self)

    def _get_isReference(self) -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchCircle__get_isReference(self)

    def _set_isReference(self, value: "bool") -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchCircle__set_isReference(self, value)

    def _get_isFixed(self) -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchCircle__get_isFixed(self)

    def _set_isFixed(self, value: "bool") -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchCircle__set_isFixed(self, value)

    def _get_isVisible(self) -> "bool":
        r"""
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchCircle__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchCircle__get_boundingBox(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchCircle_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchCircle__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchCircle__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool":
        r"""
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchCircle__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool":
        r"""Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchCircle__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.SketchCircle__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the SketchEntity object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same sketch entity.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SketchCircle__get_entityToken(self)

    def _get_isLinked(self) -> "bool":
        r"""
        Indicates if this sketch entity was created by a projection, inclusion, or driven by an API script.
        If this returns true, then the entity is presented to the user as not editable and with a 'break link'
        command available.
        """
        return _fusion.SketchCircle__get_isLinked(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchCircle__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchCircle__get_isValid(self)

# Register SketchCircle in _fusion:
_fusion.SketchCircle_swigregister(SketchCircle)

def SketchCircle_classType() -> "char const *":
    return _fusion.SketchCircle_classType()


SketchCircle.centerSketchPoint = property(SketchCircle._get_centerSketchPoint, doc="Returns the sketch point at the center of the circle.")


SketchCircle.geometry = property(SketchCircle._get_geometry, doc="Returns the transient geometry of the circle which provides geometric\ninformation about the circle. The returned geometry is always in sketch space.")


SketchCircle.worldGeometry = property(SketchCircle._get_worldGeometry, doc="Returns a Point3D object which provides the position of the sketch point in world space.\nThe returned coordinate takes into account the assembly context and the position of the\nsketch in it's parent component, which means the coordinate will be returned in the root\ncomponent space.")


SketchCircle.area = property(SketchCircle._get_area, doc="Returns the area of the circle in square centimeters.")


SketchCircle.radius = property(SketchCircle._get_radius, SketchCircle._set_radius, doc="Gets and sets the radius of the circle. Changing the radius is limited\nby any constraints that might exist on the circle.")


SketchCircle.nativeObject = property(SketchCircle._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SketchCircle.cast = lambda arg: arg if isinstance(arg, SketchCircle) else None

class SketchConicCurve(SketchCurve):
    r"""The SketchConicCurve class represents conic curves in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchConicCurve *":
        return _fusion.SketchConicCurve___deref__(self)

    def __eq__(self, rhs: "SketchConicCurve") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchConicCurve___eq__(self, rhs)


    def __ne__(self, rhs: "SketchConicCurve") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchConicCurve___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchConicCurve_classType()
    __swig_destroy__ = _fusion.delete_SketchConicCurve

    def _get_startSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""The sketch point at the start of the curve."""
        return _fusion.SketchConicCurve__get_startSketchPoint(self)

    def _get_endSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""The sketch point at the end of the curve."""
        return _fusion.SketchConicCurve__get_endSketchPoint(self)

    def _get_apexSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""The sketch point at the apex of the conic curve."""
        return _fusion.SketchConicCurve__get_apexSketchPoint(self)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >":
        r"""
        Returns the transient geometry of the curve which provides geometric
        information about the curve. The returned geometry is always in sketch space.
        Because the fixed spline can be analytically defined, for example it
        can be the precise intersection of a surface and the sketch plane,
        returning a NURBS curve that represents the spline may be an 
        approximation of the actual curve. You can use the Evaluator
        property of the SketchFixedSpline object to perform evaluations
        on the precise curve.
        """
        return _fusion.SketchConicCurve__get_geometry(self)

    def _get_worldGeometry(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >":
        r"""
        Returns a NurbsCurve3D object that is the equivalent of this sketch curve 
        but is in the space of the parent component rather than in sketch space.
        """
        return _fusion.SketchConicCurve__get_worldGeometry(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator3D >":
        r"""
        Returns an evaluator object that lets you perform evaluations
        on the precise geometry of the curve.
        """
        return _fusion.SketchConicCurve__get_evaluator(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchConicCurve >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchConicCurve__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SketchConicCurve >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchConicCurve_createForAssemblyContext(self, occurrence)

    def _get_length(self) -> "double":
        r"""Returns the length of the curve in centimeters."""
        return _fusion.SketchConicCurve__get_length(self)

    def _get_isConstruction(self) -> "bool":
        r"""Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchConicCurve__get_isConstruction(self)

    def _set_isConstruction(self, value: "bool") -> "bool":
        r"""Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchConicCurve__set_isConstruction(self, value)

    def split(self, splitPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Split a curve at a position specified along the curve 
        splitPoint : A position (transient Point3D) on the curve that defines the point at which to split the curve 
        createConstraints : Constraints are created by default. Specify false to create no constraints. 
        Returns the resulting 2 curves; the original curve + the newly created curve
        When split spline the original is deleted and two new curves returned.
        Empty collection returned if curve is closed.
        """
        return _fusion.SketchConicCurve_split(self, splitPoint, createConstraints)

    def trim(self, segmentPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Trim a curve by specifying a point that determines the segment of the curve to trim away 
        segmentPoint : A point (transient Point3D) on or closest to the segment of the curve to remove. (start, end or middle)
        The segment of the curve closest to the segmentPoint gets removed 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        When trimming the start or end side of a line, unclosed circular or elliptical arc, the original entity is modified and returned
        When trimming the middle of a line, unclosed circular or elliptical arc the original entity is deleted and two new entities are returned
        When trimming the start or end of any type of closed curve, the original is deleted and a new curve is returned
        Any trimming of a spline (open or closed) deletes the original and new spline/s are returned
        Trimming a curve having no intersections deletes the original and returns an empty collection
        """
        return _fusion.SketchConicCurve_trim(self, segmentPoint, createConstraints)

    def breakCurve(self, segmentPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Breaks a curve into two or three pieces by finding intersections of this curve with all other curves in the
        sketch and splitting this curve at the nearest intersections to a specified point on the curve. 
        segmentPoint : A point that specifies the segment of the curve that is to be split from the rest of the curve. The nearest
        intersection(s) to this point define the break location(s). 
        createConstraints : Optional argument that specifies if constraints should be created between the new curve segments. A value of
        true indicates constraints will be created. 
        All of the curves resulting from the break are returned in an ObjectCollection. In the case where no intersections
        are found and as a result the curve is not broken, an empty ObjectCollection is returned.
        """
        return _fusion.SketchConicCurve_breakCurve(self, segmentPoint, createConstraints)

    def extend(self, endPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Extend a curve by specifying a point that determines the end of the curve to extend 
        endPoint : A point (transient Point3D) on or closest to the end of the curve to extend. (start or end)
        The end of the curve closest to the endPoint gets extended 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        Returns the modified original curve if the start or end of the curve is extended
        If the extend joins a curve to another, the two original curves are deleted and a new curve is returned
        If an arc is extended so as to become a circle, the original arc is deleted and a new circle is returned
        """
        return _fusion.SketchConicCurve_extend(self, endPoint, createConstraints)

    def intersections(self, sketchCurves: "ObjectCollection") -> "bool":
        r"""
        Get the curves that intersect this curve along with the intersection points (Point3D) 
        sketchCurves : A collection of curves to attempt to find intersections with. 
        Set the value of this parameter to null to use all curves in the sketch for the calculation. 
        intersectingCurves : A collection of the actual intersecting curves 
        intersectionPoints : A collection of intersection points (Point3D)
        Item numbers in this collection correspond to the item numbers in the intersectingCurves collection. 
        Returns true if the method was successful. It can be successful regardless of whether intersections were found or not.
        """
        return _fusion.SketchConicCurve_intersections(self, sketchCurves)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch."""
        return _fusion.SketchConicCurve__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >":
        r"""Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchConicCurve__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >":
        r"""Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchConicCurve__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool":
        r"""Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchConicCurve__get_is2D(self)

    def _get_isReference(self) -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchConicCurve__get_isReference(self)

    def _set_isReference(self, value: "bool") -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchConicCurve__set_isReference(self, value)

    def _get_isFixed(self) -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchConicCurve__get_isFixed(self)

    def _set_isFixed(self, value: "bool") -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchConicCurve__set_isFixed(self, value)

    def _get_isVisible(self) -> "bool":
        r"""
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchConicCurve__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchConicCurve__get_boundingBox(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchConicCurve_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchConicCurve__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchConicCurve__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool":
        r"""
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchConicCurve__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool":
        r"""Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchConicCurve__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.SketchConicCurve__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the SketchEntity object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same sketch entity.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SketchConicCurve__get_entityToken(self)

    def _get_isLinked(self) -> "bool":
        r"""
        Indicates if this sketch entity was created by a projection, inclusion, or driven by an API script.
        If this returns true, then the entity is presented to the user as not editable and with a 'break link'
        command available.
        """
        return _fusion.SketchConicCurve__get_isLinked(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchConicCurve__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchConicCurve__get_isValid(self)

# Register SketchConicCurve in _fusion:
_fusion.SketchConicCurve_swigregister(SketchConicCurve)

def SketchConicCurve_classType() -> "char const *":
    return _fusion.SketchConicCurve_classType()


SketchConicCurve.startSketchPoint = property(SketchConicCurve._get_startSketchPoint, doc="The sketch point at the start of the curve.")


SketchConicCurve.endSketchPoint = property(SketchConicCurve._get_endSketchPoint, doc="The sketch point at the end of the curve.")


SketchConicCurve.apexSketchPoint = property(SketchConicCurve._get_apexSketchPoint, doc="The sketch point at the apex of the conic curve.")


SketchConicCurve.geometry = property(SketchConicCurve._get_geometry, doc="Returns the transient geometry of the curve which provides geometric\ninformation about the curve. The returned geometry is always in sketch space.\nBecause the fixed spline can be analytically defined, for example it\ncan be the precise intersection of a surface and the sketch plane,\nreturning a NURBS curve that represents the spline may be an\napproximation of the actual curve. You can use the Evaluator\nproperty of the SketchFixedSpline object to perform evaluations\non the precise curve.")


SketchConicCurve.worldGeometry = property(SketchConicCurve._get_worldGeometry, doc="Returns a NurbsCurve3D object that is the equivalent of this sketch curve\nbut is in the space of the parent component rather than in sketch space.")


SketchConicCurve.evaluator = property(SketchConicCurve._get_evaluator, doc="Returns an evaluator object that lets you perform evaluations\non the precise geometry of the curve.")


SketchConicCurve.nativeObject = property(SketchConicCurve._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SketchConicCurve.cast = lambda arg: arg if isinstance(arg, SketchConicCurve) else None

class SketchEllipse(SketchCurve):
    r"""An ellipse in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchEllipse *":
        return _fusion.SketchEllipse___deref__(self)

    def __eq__(self, rhs: "SketchEllipse") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchEllipse___eq__(self, rhs)


    def __ne__(self, rhs: "SketchEllipse") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchEllipse___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchEllipse_classType()
    __swig_destroy__ = _fusion.delete_SketchEllipse

    def _get_centerSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""
        Returns the sketch point that defines the center of the ellipse. You can
        reposition the ellipse by moving the sketch point, assuming any existing
        constraints allow the desired change.
        """
        return _fusion.SketchEllipse__get_centerSketchPoint(self)

    def _get_majorAxis(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Gets and sets the major axis direction of the ellipse. Changing the axis is 
        limited by any constraints that might exist on the ellipse. Setting the axis
        can fail in cases where the direction is fully defined through constraints.
        """
        return _fusion.SketchEllipse__get_majorAxis(self)

    def _set_majorAxis(self, value: "Vector3D") -> "bool":
        r"""
        Gets and sets the major axis direction of the ellipse. Changing the axis is 
        limited by any constraints that might exist on the ellipse. Setting the axis
        can fail in cases where the direction is fully defined through constraints.
        """
        return _fusion.SketchEllipse__set_majorAxis(self, value)

    def _get_majorAxisRadius(self) -> "double":
        r"""
        Gets and sets the major axis radius of the ellipse. Changing the radius is 
        limited by any constraints that might exist on the ellipse. Setting the radius
        can fail in cases where the radius is fully defined through constraints.
        """
        return _fusion.SketchEllipse__get_majorAxisRadius(self)

    def _set_majorAxisRadius(self, value: "double") -> "bool":
        r"""
        Gets and sets the major axis radius of the ellipse. Changing the radius is 
        limited by any constraints that might exist on the ellipse. Setting the radius
        can fail in cases where the radius is fully defined through constraints.
        """
        return _fusion.SketchEllipse__set_majorAxisRadius(self, value)

    def _get_minorAxisRadius(self) -> "double":
        r"""
        Gets and sets the minor axis radius of the ellipse. Changing the radius is 
        limited by any constraints that might exist on the ellipse. Setting the radius
        can fail in cases where the radius is fully defined through constraints.
        """
        return _fusion.SketchEllipse__get_minorAxisRadius(self)

    def _set_minorAxisRadius(self, value: "double") -> "bool":
        r"""
        Gets and sets the minor axis radius of the ellipse. Changing the radius is 
        limited by any constraints that might exist on the ellipse. Setting the radius
        can fail in cases where the radius is fully defined through constraints.
        """
        return _fusion.SketchEllipse__set_minorAxisRadius(self, value)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Ellipse3D >":
        r"""
        Returns the transient geometry of the ellipse which provides geometric
        information about the ellipse. The returned geometry is always in sketch space.
        """
        return _fusion.SketchEllipse__get_geometry(self)

    def _get_worldGeometry(self) -> "adsk::core::Ptr< adsk::core::Ellipse3D >":
        r"""
        Returns an Ellipse3D object which provides geometric information in world space.
        The returned geometry takes into account the assembly context and the position of the
        sketch in it's parent component, which means the geometry will be returned in the root
        component space.
        """
        return _fusion.SketchEllipse__get_worldGeometry(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchEllipse >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchEllipse__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SketchEllipse >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchEllipse_createForAssemblyContext(self, occurrence)

    def _get_majorAxisLine(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""
        Returns the sketch line associated with the ellipse that lies along the major axis.
        This can return null in the case where the line has been deleted.
        """
        return _fusion.SketchEllipse__get_majorAxisLine(self)

    def _get_minorAxisLine(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""
        Returns the sketch line associated with the ellipse that lies along the minor axis.
        This can return null in the case where the line has been deleted.
        """
        return _fusion.SketchEllipse__get_minorAxisLine(self)

    def _get_length(self) -> "double":
        r"""Returns the length of the curve in centimeters."""
        return _fusion.SketchEllipse__get_length(self)

    def _get_isConstruction(self) -> "bool":
        r"""Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchEllipse__get_isConstruction(self)

    def _set_isConstruction(self, value: "bool") -> "bool":
        r"""Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchEllipse__set_isConstruction(self, value)

    def split(self, splitPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Split a curve at a position specified along the curve 
        splitPoint : A position (transient Point3D) on the curve that defines the point at which to split the curve 
        createConstraints : Constraints are created by default. Specify false to create no constraints. 
        Returns the resulting 2 curves; the original curve + the newly created curve
        When split spline the original is deleted and two new curves returned.
        Empty collection returned if curve is closed.
        """
        return _fusion.SketchEllipse_split(self, splitPoint, createConstraints)

    def trim(self, segmentPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Trim a curve by specifying a point that determines the segment of the curve to trim away 
        segmentPoint : A point (transient Point3D) on or closest to the segment of the curve to remove. (start, end or middle)
        The segment of the curve closest to the segmentPoint gets removed 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        When trimming the start or end side of a line, unclosed circular or elliptical arc, the original entity is modified and returned
        When trimming the middle of a line, unclosed circular or elliptical arc the original entity is deleted and two new entities are returned
        When trimming the start or end of any type of closed curve, the original is deleted and a new curve is returned
        Any trimming of a spline (open or closed) deletes the original and new spline/s are returned
        Trimming a curve having no intersections deletes the original and returns an empty collection
        """
        return _fusion.SketchEllipse_trim(self, segmentPoint, createConstraints)

    def breakCurve(self, segmentPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Breaks a curve into two or three pieces by finding intersections of this curve with all other curves in the
        sketch and splitting this curve at the nearest intersections to a specified point on the curve. 
        segmentPoint : A point that specifies the segment of the curve that is to be split from the rest of the curve. The nearest
        intersection(s) to this point define the break location(s). 
        createConstraints : Optional argument that specifies if constraints should be created between the new curve segments. A value of
        true indicates constraints will be created. 
        All of the curves resulting from the break are returned in an ObjectCollection. In the case where no intersections
        are found and as a result the curve is not broken, an empty ObjectCollection is returned.
        """
        return _fusion.SketchEllipse_breakCurve(self, segmentPoint, createConstraints)

    def extend(self, endPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Extend a curve by specifying a point that determines the end of the curve to extend 
        endPoint : A point (transient Point3D) on or closest to the end of the curve to extend. (start or end)
        The end of the curve closest to the endPoint gets extended 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        Returns the modified original curve if the start or end of the curve is extended
        If the extend joins a curve to another, the two original curves are deleted and a new curve is returned
        If an arc is extended so as to become a circle, the original arc is deleted and a new circle is returned
        """
        return _fusion.SketchEllipse_extend(self, endPoint, createConstraints)

    def intersections(self, sketchCurves: "ObjectCollection") -> "bool":
        r"""
        Get the curves that intersect this curve along with the intersection points (Point3D) 
        sketchCurves : A collection of curves to attempt to find intersections with. 
        Set the value of this parameter to null to use all curves in the sketch for the calculation. 
        intersectingCurves : A collection of the actual intersecting curves 
        intersectionPoints : A collection of intersection points (Point3D)
        Item numbers in this collection correspond to the item numbers in the intersectingCurves collection. 
        Returns true if the method was successful. It can be successful regardless of whether intersections were found or not.
        """
        return _fusion.SketchEllipse_intersections(self, sketchCurves)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch."""
        return _fusion.SketchEllipse__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >":
        r"""Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchEllipse__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >":
        r"""Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchEllipse__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool":
        r"""Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchEllipse__get_is2D(self)

    def _get_isReference(self) -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchEllipse__get_isReference(self)

    def _set_isReference(self, value: "bool") -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchEllipse__set_isReference(self, value)

    def _get_isFixed(self) -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchEllipse__get_isFixed(self)

    def _set_isFixed(self, value: "bool") -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchEllipse__set_isFixed(self, value)

    def _get_isVisible(self) -> "bool":
        r"""
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchEllipse__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchEllipse__get_boundingBox(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchEllipse_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchEllipse__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchEllipse__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool":
        r"""
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchEllipse__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool":
        r"""Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchEllipse__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.SketchEllipse__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the SketchEntity object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same sketch entity.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SketchEllipse__get_entityToken(self)

    def _get_isLinked(self) -> "bool":
        r"""
        Indicates if this sketch entity was created by a projection, inclusion, or driven by an API script.
        If this returns true, then the entity is presented to the user as not editable and with a 'break link'
        command available.
        """
        return _fusion.SketchEllipse__get_isLinked(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchEllipse__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchEllipse__get_isValid(self)

# Register SketchEllipse in _fusion:
_fusion.SketchEllipse_swigregister(SketchEllipse)

def SketchEllipse_classType() -> "char const *":
    return _fusion.SketchEllipse_classType()


SketchEllipse.centerSketchPoint = property(SketchEllipse._get_centerSketchPoint, doc="Returns the sketch point that defines the center of the ellipse. You can\nreposition the ellipse by moving the sketch point, assuming any existing\nconstraints allow the desired change.")


SketchEllipse.majorAxis = property(SketchEllipse._get_majorAxis, SketchEllipse._set_majorAxis, doc="Gets and sets the major axis direction of the ellipse. Changing the axis is\nlimited by any constraints that might exist on the ellipse. Setting the axis\ncan fail in cases where the direction is fully defined through constraints.")


SketchEllipse.majorAxisRadius = property(SketchEllipse._get_majorAxisRadius, SketchEllipse._set_majorAxisRadius, doc="Gets and sets the major axis radius of the ellipse. Changing the radius is\nlimited by any constraints that might exist on the ellipse. Setting the radius\ncan fail in cases where the radius is fully defined through constraints.")


SketchEllipse.minorAxisRadius = property(SketchEllipse._get_minorAxisRadius, SketchEllipse._set_minorAxisRadius, doc="Gets and sets the minor axis radius of the ellipse. Changing the radius is\nlimited by any constraints that might exist on the ellipse. Setting the radius\ncan fail in cases where the radius is fully defined through constraints.")


SketchEllipse.geometry = property(SketchEllipse._get_geometry, doc="Returns the transient geometry of the ellipse which provides geometric\ninformation about the ellipse. The returned geometry is always in sketch space.")


SketchEllipse.worldGeometry = property(SketchEllipse._get_worldGeometry, doc="Returns an Ellipse3D object which provides geometric information in world space.\nThe returned geometry takes into account the assembly context and the position of the\nsketch in it's parent component, which means the geometry will be returned in the root\ncomponent space.")


SketchEllipse.nativeObject = property(SketchEllipse._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SketchEllipse.majorAxisLine = property(SketchEllipse._get_majorAxisLine, doc="Returns the sketch line associated with the ellipse that lies along the major axis.\nThis can return null in the case where the line has been deleted.")


SketchEllipse.minorAxisLine = property(SketchEllipse._get_minorAxisLine, doc="Returns the sketch line associated with the ellipse that lies along the minor axis.\nThis can return null in the case where the line has been deleted.")


SketchEllipse.cast = lambda arg: arg if isinstance(arg, SketchEllipse) else None

class SketchEllipticalArc(SketchCurve):
    r"""An elliptical arc in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchEllipticalArc *":
        return _fusion.SketchEllipticalArc___deref__(self)

    def __eq__(self, rhs: "SketchEllipticalArc") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchEllipticalArc___eq__(self, rhs)


    def __ne__(self, rhs: "SketchEllipticalArc") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchEllipticalArc___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchEllipticalArc_classType()
    __swig_destroy__ = _fusion.delete_SketchEllipticalArc

    def _get_centerSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""
        Gets the sketch point that defines the center of the elliptical arc. You can
        reposition the elliptical arc by moving the sketch point, assuming any existing
        constraints allow the desired change.
        """
        return _fusion.SketchEllipticalArc__get_centerSketchPoint(self)

    def _get_startSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""
        Gets the sketch point that defines the start of the elliptical arc. You can
        reposition the sketch point, assuming any existing constraints allow the 
        desired change.
        """
        return _fusion.SketchEllipticalArc__get_startSketchPoint(self)

    def _get_endSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""
        Gets the sketch point that defines the end of the elliptical arc. You can
        reposition the sketch point, assuming any existing constraints allow the 
        desired change.
        """
        return _fusion.SketchEllipticalArc__get_endSketchPoint(self)

    def _get_majorAxis(self) -> "adsk::core::Ptr< adsk::core::Vector3D >":
        r"""
        Gets and sets the major axis direction of the elliptical arc. Changing the axis is 
        limited by any constraints that might exist on the elliptical arc. Setting the axis
        can fail in cases where the direction is fully defined through constraints.
        """
        return _fusion.SketchEllipticalArc__get_majorAxis(self)

    def _set_majorAxis(self, value: "Vector3D") -> "bool":
        r"""
        Gets and sets the major axis direction of the elliptical arc. Changing the axis is 
        limited by any constraints that might exist on the elliptical arc. Setting the axis
        can fail in cases where the direction is fully defined through constraints.
        """
        return _fusion.SketchEllipticalArc__set_majorAxis(self, value)

    def _get_majorAxisRadius(self) -> "double":
        r"""
        Gets and sets the major axis radius of the elliptical arc. Changing the radius is 
        limited by any constraints that might exist on the elliptical arc. Setting the radius
        can fail in cases where the radius is fully defined through constraints.
        """
        return _fusion.SketchEllipticalArc__get_majorAxisRadius(self)

    def _set_majorAxisRadius(self, value: "double") -> "bool":
        r"""
        Gets and sets the major axis radius of the elliptical arc. Changing the radius is 
        limited by any constraints that might exist on the elliptical arc. Setting the radius
        can fail in cases where the radius is fully defined through constraints.
        """
        return _fusion.SketchEllipticalArc__set_majorAxisRadius(self, value)

    def _get_minorAxisRadius(self) -> "double":
        r"""
        Gets and sets the minor axis radius of the elliptical arc. Changing the radius is 
        limited by any constraints that might exist on the elliptical arc. Setting the radius
        can fail in cases where the radius is fully defined through constraints.
        """
        return _fusion.SketchEllipticalArc__get_minorAxisRadius(self)

    def _set_minorAxisRadius(self, value: "double") -> "bool":
        r"""
        Gets and sets the minor axis radius of the elliptical arc. Changing the radius is 
        limited by any constraints that might exist on the elliptical arc. Setting the radius
        can fail in cases where the radius is fully defined through constraints.
        """
        return _fusion.SketchEllipticalArc__set_minorAxisRadius(self, value)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::EllipticalArc3D >":
        r"""
        Returns the transient geometry of the elliptical arc which provides geometric
        information about the elliptical arc. The returned geometry is always in sketch space.
        """
        return _fusion.SketchEllipticalArc__get_geometry(self)

    def _get_worldGeometry(self) -> "adsk::core::Ptr< adsk::core::EllipticalArc3D >":
        r"""
        Returns an EllipticalArc3D object which provides geometric information in world space.
        The returned geometry takes into account the assembly context and the position of the
        sketch in it's parent component, which means the geometry will be returned in the root
        component space.
        """
        return _fusion.SketchEllipticalArc__get_worldGeometry(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchEllipticalArc >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchEllipticalArc__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SketchEllipticalArc >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchEllipticalArc_createForAssemblyContext(self, occurrence)

    def _get_length(self) -> "double":
        r"""Returns the length of the curve in centimeters."""
        return _fusion.SketchEllipticalArc__get_length(self)

    def _get_isConstruction(self) -> "bool":
        r"""Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchEllipticalArc__get_isConstruction(self)

    def _set_isConstruction(self, value: "bool") -> "bool":
        r"""Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchEllipticalArc__set_isConstruction(self, value)

    def split(self, splitPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Split a curve at a position specified along the curve 
        splitPoint : A position (transient Point3D) on the curve that defines the point at which to split the curve 
        createConstraints : Constraints are created by default. Specify false to create no constraints. 
        Returns the resulting 2 curves; the original curve + the newly created curve
        When split spline the original is deleted and two new curves returned.
        Empty collection returned if curve is closed.
        """
        return _fusion.SketchEllipticalArc_split(self, splitPoint, createConstraints)

    def trim(self, segmentPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Trim a curve by specifying a point that determines the segment of the curve to trim away 
        segmentPoint : A point (transient Point3D) on or closest to the segment of the curve to remove. (start, end or middle)
        The segment of the curve closest to the segmentPoint gets removed 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        When trimming the start or end side of a line, unclosed circular or elliptical arc, the original entity is modified and returned
        When trimming the middle of a line, unclosed circular or elliptical arc the original entity is deleted and two new entities are returned
        When trimming the start or end of any type of closed curve, the original is deleted and a new curve is returned
        Any trimming of a spline (open or closed) deletes the original and new spline/s are returned
        Trimming a curve having no intersections deletes the original and returns an empty collection
        """
        return _fusion.SketchEllipticalArc_trim(self, segmentPoint, createConstraints)

    def breakCurve(self, segmentPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Breaks a curve into two or three pieces by finding intersections of this curve with all other curves in the
        sketch and splitting this curve at the nearest intersections to a specified point on the curve. 
        segmentPoint : A point that specifies the segment of the curve that is to be split from the rest of the curve. The nearest
        intersection(s) to this point define the break location(s). 
        createConstraints : Optional argument that specifies if constraints should be created between the new curve segments. A value of
        true indicates constraints will be created. 
        All of the curves resulting from the break are returned in an ObjectCollection. In the case where no intersections
        are found and as a result the curve is not broken, an empty ObjectCollection is returned.
        """
        return _fusion.SketchEllipticalArc_breakCurve(self, segmentPoint, createConstraints)

    def extend(self, endPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Extend a curve by specifying a point that determines the end of the curve to extend 
        endPoint : A point (transient Point3D) on or closest to the end of the curve to extend. (start or end)
        The end of the curve closest to the endPoint gets extended 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        Returns the modified original curve if the start or end of the curve is extended
        If the extend joins a curve to another, the two original curves are deleted and a new curve is returned
        If an arc is extended so as to become a circle, the original arc is deleted and a new circle is returned
        """
        return _fusion.SketchEllipticalArc_extend(self, endPoint, createConstraints)

    def intersections(self, sketchCurves: "ObjectCollection") -> "bool":
        r"""
        Get the curves that intersect this curve along with the intersection points (Point3D) 
        sketchCurves : A collection of curves to attempt to find intersections with. 
        Set the value of this parameter to null to use all curves in the sketch for the calculation. 
        intersectingCurves : A collection of the actual intersecting curves 
        intersectionPoints : A collection of intersection points (Point3D)
        Item numbers in this collection correspond to the item numbers in the intersectingCurves collection. 
        Returns true if the method was successful. It can be successful regardless of whether intersections were found or not.
        """
        return _fusion.SketchEllipticalArc_intersections(self, sketchCurves)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch."""
        return _fusion.SketchEllipticalArc__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >":
        r"""Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchEllipticalArc__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >":
        r"""Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchEllipticalArc__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool":
        r"""Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchEllipticalArc__get_is2D(self)

    def _get_isReference(self) -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchEllipticalArc__get_isReference(self)

    def _set_isReference(self, value: "bool") -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchEllipticalArc__set_isReference(self, value)

    def _get_isFixed(self) -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchEllipticalArc__get_isFixed(self)

    def _set_isFixed(self, value: "bool") -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchEllipticalArc__set_isFixed(self, value)

    def _get_isVisible(self) -> "bool":
        r"""
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchEllipticalArc__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchEllipticalArc__get_boundingBox(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchEllipticalArc_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchEllipticalArc__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchEllipticalArc__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool":
        r"""
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchEllipticalArc__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool":
        r"""Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchEllipticalArc__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.SketchEllipticalArc__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the SketchEntity object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same sketch entity.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SketchEllipticalArc__get_entityToken(self)

    def _get_isLinked(self) -> "bool":
        r"""
        Indicates if this sketch entity was created by a projection, inclusion, or driven by an API script.
        If this returns true, then the entity is presented to the user as not editable and with a 'break link'
        command available.
        """
        return _fusion.SketchEllipticalArc__get_isLinked(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchEllipticalArc__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchEllipticalArc__get_isValid(self)

# Register SketchEllipticalArc in _fusion:
_fusion.SketchEllipticalArc_swigregister(SketchEllipticalArc)

def SketchEllipticalArc_classType() -> "char const *":
    return _fusion.SketchEllipticalArc_classType()


SketchEllipticalArc.centerSketchPoint = property(SketchEllipticalArc._get_centerSketchPoint, doc="Gets the sketch point that defines the center of the elliptical arc. You can\nreposition the elliptical arc by moving the sketch point, assuming any existing\nconstraints allow the desired change.")


SketchEllipticalArc.startSketchPoint = property(SketchEllipticalArc._get_startSketchPoint, doc="Gets the sketch point that defines the start of the elliptical arc. You can\nreposition the sketch point, assuming any existing constraints allow the\ndesired change.")


SketchEllipticalArc.endSketchPoint = property(SketchEllipticalArc._get_endSketchPoint, doc="Gets the sketch point that defines the end of the elliptical arc. You can\nreposition the sketch point, assuming any existing constraints allow the\ndesired change.")


SketchEllipticalArc.majorAxis = property(SketchEllipticalArc._get_majorAxis, SketchEllipticalArc._set_majorAxis, doc="Gets and sets the major axis direction of the elliptical arc. Changing the axis is\nlimited by any constraints that might exist on the elliptical arc. Setting the axis\ncan fail in cases where the direction is fully defined through constraints.")


SketchEllipticalArc.majorAxisRadius = property(SketchEllipticalArc._get_majorAxisRadius, SketchEllipticalArc._set_majorAxisRadius, doc="Gets and sets the major axis radius of the elliptical arc. Changing the radius is\nlimited by any constraints that might exist on the elliptical arc. Setting the radius\ncan fail in cases where the radius is fully defined through constraints.")


SketchEllipticalArc.minorAxisRadius = property(SketchEllipticalArc._get_minorAxisRadius, SketchEllipticalArc._set_minorAxisRadius, doc="Gets and sets the minor axis radius of the elliptical arc. Changing the radius is\nlimited by any constraints that might exist on the elliptical arc. Setting the radius\ncan fail in cases where the radius is fully defined through constraints.")


SketchEllipticalArc.geometry = property(SketchEllipticalArc._get_geometry, doc="Returns the transient geometry of the elliptical arc which provides geometric\ninformation about the elliptical arc. The returned geometry is always in sketch space.")


SketchEllipticalArc.worldGeometry = property(SketchEllipticalArc._get_worldGeometry, doc="Returns an EllipticalArc3D object which provides geometric information in world space.\nThe returned geometry takes into account the assembly context and the position of the\nsketch in it's parent component, which means the geometry will be returned in the root\ncomponent space.")


SketchEllipticalArc.nativeObject = property(SketchEllipticalArc._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SketchEllipticalArc.cast = lambda arg: arg if isinstance(arg, SketchEllipticalArc) else None

class SketchFittedSpline(SketchCurve):
    r"""A fitted spline in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchFittedSpline *":
        return _fusion.SketchFittedSpline___deref__(self)

    def __eq__(self, rhs: "SketchFittedSpline") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchFittedSpline___eq__(self, rhs)


    def __ne__(self, rhs: "SketchFittedSpline") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchFittedSpline___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchFittedSpline_classType()
    __swig_destroy__ = _fusion.delete_SketchFittedSpline

    def _get_startSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""
        Returns the sketch point that defines the starting position
        of the spline. Editing the position of this sketch point
        will result in editing the spline.
        """
        return _fusion.SketchFittedSpline__get_startSketchPoint(self)

    def _get_endSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""
        Returns the sketch point that defines the ending position
        of the spline. Editing the position of this sketch point
        will result in editing the spline.
        """
        return _fusion.SketchFittedSpline__get_endSketchPoint(self)

    def _get_fitPoints(self) -> "adsk::core::Ptr< adsk::fusion::SketchPointList >":
        r"""
        Returns the set of sketch points that the spline fits through.
        The points include the start and end points and are returned in
        the same order as the spline fits through them where the first point
        in the list is the start point and the last point is the end point.
        Editing the position of these sketch points will result in
        editing the spline.
        """
        return _fusion.SketchFittedSpline__get_fitPoints(self)

    def _get_isClosed(self) -> "bool":
        r"""
        Gets and sets if this spline is closed. A closed spline
        is also periodic. This property can return false even in 
        the case where the spline is physically closed. It's possible
        that the start and end points of a spline can be the same point
        but the curve is still not considered closed. This can happen
        when the start and end points of an open curve are merged. The 
        curve is physically closed but is not periodic and can have a 
        discontinuity at the joint. Setting it to closed will cause it
        to be periodic and to always remain closed even as fit points
        are deleted.
        """
        return _fusion.SketchFittedSpline__get_isClosed(self)

    def _set_isClosed(self, value: "bool") -> "bool":
        r"""
        Gets and sets if this spline is closed. A closed spline
        is also periodic. This property can return false even in 
        the case where the spline is physically closed. It's possible
        that the start and end points of a spline can be the same point
        but the curve is still not considered closed. This can happen
        when the start and end points of an open curve are merged. The 
        curve is physically closed but is not periodic and can have a 
        discontinuity at the joint. Setting it to closed will cause it
        to be periodic and to always remain closed even as fit points
        are deleted.
        """
        return _fusion.SketchFittedSpline__set_isClosed(self, value)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >":
        r"""
        Returns the transient geometry of the curve which provides geometric
        information about the curve. The returned geometry is always in sketch space.
        """
        return _fusion.SketchFittedSpline__get_geometry(self)

    def _get_worldGeometry(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >":
        r"""
        Returns an NurbsCurve3D object which provides geometric information in world space.
        The returned geometry takes into account the assembly context and the position of the
        sketch in it's parent component, which means the geometry will be returned in the root
        component space.
        """
        return _fusion.SketchFittedSpline__get_worldGeometry(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchFittedSpline >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchFittedSpline__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SketchFittedSpline >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchFittedSpline_createForAssemblyContext(self, occurrence)

    def activateTangentHandle(self, fitPoint: "SketchPoint") -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""
        Activates the tangent handle for the specified fit point and returns the sketch line
        that acts as the handle to control the tangency. You can use the getTangentHandle
        property to determine if the tangent handle has already been activated. If this method
        is called for a handle that already exists, nothing changes and the existing sketch line
        that acts as the tangent handle is returned.
        The getTangentHandle method can be used to determine if the handle has already been
        activated.
        To deactivate a sketch handle you can delete the sketch line. 
        fitPoint : The fit point on the curve where you want to activate the tangent handle.
        The fit points can be obtained by using the fitPoints property of the SketchFittedSpline object. 
        Returns the sketch line that acts as the tangent handle at the specified fit point.
        """
        return _fusion.SketchFittedSpline_activateTangentHandle(self, fitPoint)

    def getTangentHandle(self, fitPoint: "SketchPoint") -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""
        Returns the sketch line that acts as the handle to control the tangency at the specified fit
        point. Returns null in the case where the tangent handle has not been activated at that sketch point.
        Deleting the returned line will deactivate the tangent handle. Use the activateTangentHandle method
        to activate the tangent handle. 
        fitPoint : The fit point on the curve where you want to get the tangent handle.
        The fit points can be obtained by using the fitPoints property of the SketchFittedSpline object. 
        Returns the sketch line that acts as the handle to control the tangency at the specified point or
        returns null in the case where the tangency handle has not been activated at the specified sketch point.
        """
        return _fusion.SketchFittedSpline_getTangentHandle(self, fitPoint)

    def activateCurvatureHandle(self, fitPoint: "SketchPoint") -> "adsk::core::Ptr< adsk::fusion::SketchArc >":
        r"""
        Activates the curvature handle for the specified fit point and returns the sketch arc
        that acts as the handle to control the curvature. You can use the getCurvatureHandle
        property to determine if the curvature handle has already been activated. If this method
        is called for a handle that already exists, nothing changes and the existing sketch arc
        that acts as the curvature handle is returned.
        The getCurvatureHandle method can be used to determine if the handle has already been
        activated.
        To deactivate a sketch handle you can delete the sketch arc. 
        fitPoint : The fit point on the curve where you want to activate the curvature handle.
        The fit points can be obtained by using the fitPoints property of the SketchFittedSpline object. 
        Returns the sketch arc that acts as the curvature handle at the specified fit point.
        """
        return _fusion.SketchFittedSpline_activateCurvatureHandle(self, fitPoint)

    def getCurvatureHandle(self, fitPoint: "SketchPoint") -> "adsk::core::Ptr< adsk::fusion::SketchArc >":
        r"""
        Returns the sketch arc that acts as the handle to control the curvature at the specified fit
        point. Returns null in the case where the curvature handle has not been activated at that sketch point.
        Deleting the returned arc will deactivate the curvature handle. Use the activateCurvatureHandle method
        to activate the curvature handle. 
        fitPoint : The fit point on the curve where you want to get the curvature handle.
        The fit points can be obtained by using the fitPoints property of the SketchFittedSpline object. 
        Returns the sketch arc that acts as the handle to control the curvature at the specified point or
        returns null in the case where the curvature handle has not been activated at the specified sketch point.
        """
        return _fusion.SketchFittedSpline_getCurvatureHandle(self, fitPoint)

    def _get_length(self) -> "double":
        r"""Returns the length of the curve in centimeters."""
        return _fusion.SketchFittedSpline__get_length(self)

    def _get_isConstruction(self) -> "bool":
        r"""Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchFittedSpline__get_isConstruction(self)

    def _set_isConstruction(self, value: "bool") -> "bool":
        r"""Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchFittedSpline__set_isConstruction(self, value)

    def split(self, splitPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Split a curve at a position specified along the curve 
        splitPoint : A position (transient Point3D) on the curve that defines the point at which to split the curve 
        createConstraints : Constraints are created by default. Specify false to create no constraints. 
        Returns the resulting 2 curves; the original curve + the newly created curve
        When split spline the original is deleted and two new curves returned.
        Empty collection returned if curve is closed.
        """
        return _fusion.SketchFittedSpline_split(self, splitPoint, createConstraints)

    def trim(self, segmentPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Trim a curve by specifying a point that determines the segment of the curve to trim away 
        segmentPoint : A point (transient Point3D) on or closest to the segment of the curve to remove. (start, end or middle)
        The segment of the curve closest to the segmentPoint gets removed 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        When trimming the start or end side of a line, unclosed circular or elliptical arc, the original entity is modified and returned
        When trimming the middle of a line, unclosed circular or elliptical arc the original entity is deleted and two new entities are returned
        When trimming the start or end of any type of closed curve, the original is deleted and a new curve is returned
        Any trimming of a spline (open or closed) deletes the original and new spline/s are returned
        Trimming a curve having no intersections deletes the original and returns an empty collection
        """
        return _fusion.SketchFittedSpline_trim(self, segmentPoint, createConstraints)

    def breakCurve(self, segmentPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Breaks a curve into two or three pieces by finding intersections of this curve with all other curves in the
        sketch and splitting this curve at the nearest intersections to a specified point on the curve. 
        segmentPoint : A point that specifies the segment of the curve that is to be split from the rest of the curve. The nearest
        intersection(s) to this point define the break location(s). 
        createConstraints : Optional argument that specifies if constraints should be created between the new curve segments. A value of
        true indicates constraints will be created. 
        All of the curves resulting from the break are returned in an ObjectCollection. In the case where no intersections
        are found and as a result the curve is not broken, an empty ObjectCollection is returned.
        """
        return _fusion.SketchFittedSpline_breakCurve(self, segmentPoint, createConstraints)

    def extend(self, endPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Extend a curve by specifying a point that determines the end of the curve to extend 
        endPoint : A point (transient Point3D) on or closest to the end of the curve to extend. (start or end)
        The end of the curve closest to the endPoint gets extended 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        Returns the modified original curve if the start or end of the curve is extended
        If the extend joins a curve to another, the two original curves are deleted and a new curve is returned
        If an arc is extended so as to become a circle, the original arc is deleted and a new circle is returned
        """
        return _fusion.SketchFittedSpline_extend(self, endPoint, createConstraints)

    def intersections(self, sketchCurves: "ObjectCollection") -> "bool":
        r"""
        Get the curves that intersect this curve along with the intersection points (Point3D) 
        sketchCurves : A collection of curves to attempt to find intersections with. 
        Set the value of this parameter to null to use all curves in the sketch for the calculation. 
        intersectingCurves : A collection of the actual intersecting curves 
        intersectionPoints : A collection of intersection points (Point3D)
        Item numbers in this collection correspond to the item numbers in the intersectingCurves collection. 
        Returns true if the method was successful. It can be successful regardless of whether intersections were found or not.
        """
        return _fusion.SketchFittedSpline_intersections(self, sketchCurves)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch."""
        return _fusion.SketchFittedSpline__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >":
        r"""Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchFittedSpline__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >":
        r"""Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchFittedSpline__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool":
        r"""Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchFittedSpline__get_is2D(self)

    def _get_isReference(self) -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchFittedSpline__get_isReference(self)

    def _set_isReference(self, value: "bool") -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchFittedSpline__set_isReference(self, value)

    def _get_isFixed(self) -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchFittedSpline__get_isFixed(self)

    def _set_isFixed(self, value: "bool") -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchFittedSpline__set_isFixed(self, value)

    def _get_isVisible(self) -> "bool":
        r"""
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchFittedSpline__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchFittedSpline__get_boundingBox(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchFittedSpline_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchFittedSpline__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchFittedSpline__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool":
        r"""
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchFittedSpline__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool":
        r"""Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchFittedSpline__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.SketchFittedSpline__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the SketchEntity object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same sketch entity.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SketchFittedSpline__get_entityToken(self)

    def _get_isLinked(self) -> "bool":
        r"""
        Indicates if this sketch entity was created by a projection, inclusion, or driven by an API script.
        If this returns true, then the entity is presented to the user as not editable and with a 'break link'
        command available.
        """
        return _fusion.SketchFittedSpline__get_isLinked(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchFittedSpline__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchFittedSpline__get_isValid(self)

# Register SketchFittedSpline in _fusion:
_fusion.SketchFittedSpline_swigregister(SketchFittedSpline)

def SketchFittedSpline_classType() -> "char const *":
    return _fusion.SketchFittedSpline_classType()


SketchFittedSpline.startSketchPoint = property(SketchFittedSpline._get_startSketchPoint, doc="Returns the sketch point that defines the starting position\nof the spline. Editing the position of this sketch point\nwill result in editing the spline.")


SketchFittedSpline.endSketchPoint = property(SketchFittedSpline._get_endSketchPoint, doc="Returns the sketch point that defines the ending position\nof the spline. Editing the position of this sketch point\nwill result in editing the spline.")


SketchFittedSpline.fitPoints = property(SketchFittedSpline._get_fitPoints, doc="Returns the set of sketch points that the spline fits through.\nThe points include the start and end points and are returned in\nthe same order as the spline fits through them where the first point\nin the list is the start point and the last point is the end point.\nEditing the position of these sketch points will result in\nediting the spline.")


SketchFittedSpline.isClosed = property(SketchFittedSpline._get_isClosed, SketchFittedSpline._set_isClosed, doc="Gets and sets if this spline is closed. A closed spline\nis also periodic. This property can return false even in\nthe case where the spline is physically closed. It's possible\nthat the start and end points of a spline can be the same point\nbut the curve is still not considered closed. This can happen\nwhen the start and end points of an open curve are merged. The\ncurve is physically closed but is not periodic and can have a\ndiscontinuity at the joint. Setting it to closed will cause it\nto be periodic and to always remain closed even as fit points\nare deleted.")


SketchFittedSpline.geometry = property(SketchFittedSpline._get_geometry, doc="Returns the transient geometry of the curve which provides geometric\ninformation about the curve. The returned geometry is always in sketch space.")


SketchFittedSpline.worldGeometry = property(SketchFittedSpline._get_worldGeometry, doc="Returns an NurbsCurve3D object which provides geometric information in world space.\nThe returned geometry takes into account the assembly context and the position of the\nsketch in it's parent component, which means the geometry will be returned in the root\ncomponent space.")


SketchFittedSpline.nativeObject = property(SketchFittedSpline._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SketchFittedSpline.cast = lambda arg: arg if isinstance(arg, SketchFittedSpline) else None

class SketchFixedSpline(SketchCurve):
    r"""
    The SketchFixedSpline class represents splines in a sketch that are
    uneditable. These can result from including splines from other sketches
    or the spline edges. They can also be created by intersections and 
    projecting splines onto a sketch.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchFixedSpline *":
        return _fusion.SketchFixedSpline___deref__(self)

    def __eq__(self, rhs: "SketchFixedSpline") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchFixedSpline___eq__(self, rhs)


    def __ne__(self, rhs: "SketchFixedSpline") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchFixedSpline___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchFixedSpline_classType()
    __swig_destroy__ = _fusion.delete_SketchFixedSpline

    def _get_startSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""The sketch point at the start of the spline."""
        return _fusion.SketchFixedSpline__get_startSketchPoint(self)

    def _get_endSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""The sketch point at the end of the spline."""
        return _fusion.SketchFixedSpline__get_endSketchPoint(self)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >":
        r"""
        Returns the transient geometry of the curve which provides geometric
        information about the curve. The returned geometry is always in sketch space.
        Because the fixed spline can be analytically defined, for example it
        can be the precise intersection of a surface and the sketch plane,
        returning a NURBS curve that represents the spline may be an 
        approximation of the actual curve. You can use the Evaluator
        property of the SketchFixedSpline object to perform evaluations
        on the precise curve.
        """
        return _fusion.SketchFixedSpline__get_geometry(self)

    def _get_worldGeometry(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >":
        r"""
        Returns a NurbsCurve3D object that is the equivalent of this sketch curve 
        but is in the space of the parent component rather than in sketch space.
        """
        return _fusion.SketchFixedSpline__get_worldGeometry(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator3D >":
        r"""
        Returns an evaluator object that lets you perform evaluations
        on the precise geometry of the curve.
        """
        return _fusion.SketchFixedSpline__get_evaluator(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchFixedSpline >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchFixedSpline__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SketchFixedSpline >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchFixedSpline_createForAssemblyContext(self, occurrence)

    def replaceGeometry(self, nurbsCurve: "NurbsCurve3D") -> "bool":
        r"""
        Replaces the underlying NURBS curve that defines the shape of the fixed curve. This
        can only be used if the isNative property of the SketchFixedSpline returns false. 
        nurbsCurve : A NurbsCurve3D object that defines a valid NURBS curve and will be used to replace
        the existing geometry definition. 
        Returns true if the replacement was successful.
        """
        return _fusion.SketchFixedSpline_replaceGeometry(self, nurbsCurve)

    def _get_length(self) -> "double":
        r"""Returns the length of the curve in centimeters."""
        return _fusion.SketchFixedSpline__get_length(self)

    def _get_isConstruction(self) -> "bool":
        r"""Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchFixedSpline__get_isConstruction(self)

    def _set_isConstruction(self, value: "bool") -> "bool":
        r"""Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchFixedSpline__set_isConstruction(self, value)

    def split(self, splitPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Split a curve at a position specified along the curve 
        splitPoint : A position (transient Point3D) on the curve that defines the point at which to split the curve 
        createConstraints : Constraints are created by default. Specify false to create no constraints. 
        Returns the resulting 2 curves; the original curve + the newly created curve
        When split spline the original is deleted and two new curves returned.
        Empty collection returned if curve is closed.
        """
        return _fusion.SketchFixedSpline_split(self, splitPoint, createConstraints)

    def trim(self, segmentPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Trim a curve by specifying a point that determines the segment of the curve to trim away 
        segmentPoint : A point (transient Point3D) on or closest to the segment of the curve to remove. (start, end or middle)
        The segment of the curve closest to the segmentPoint gets removed 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        When trimming the start or end side of a line, unclosed circular or elliptical arc, the original entity is modified and returned
        When trimming the middle of a line, unclosed circular or elliptical arc the original entity is deleted and two new entities are returned
        When trimming the start or end of any type of closed curve, the original is deleted and a new curve is returned
        Any trimming of a spline (open or closed) deletes the original and new spline/s are returned
        Trimming a curve having no intersections deletes the original and returns an empty collection
        """
        return _fusion.SketchFixedSpline_trim(self, segmentPoint, createConstraints)

    def breakCurve(self, segmentPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Breaks a curve into two or three pieces by finding intersections of this curve with all other curves in the
        sketch and splitting this curve at the nearest intersections to a specified point on the curve. 
        segmentPoint : A point that specifies the segment of the curve that is to be split from the rest of the curve. The nearest
        intersection(s) to this point define the break location(s). 
        createConstraints : Optional argument that specifies if constraints should be created between the new curve segments. A value of
        true indicates constraints will be created. 
        All of the curves resulting from the break are returned in an ObjectCollection. In the case where no intersections
        are found and as a result the curve is not broken, an empty ObjectCollection is returned.
        """
        return _fusion.SketchFixedSpline_breakCurve(self, segmentPoint, createConstraints)

    def extend(self, endPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Extend a curve by specifying a point that determines the end of the curve to extend 
        endPoint : A point (transient Point3D) on or closest to the end of the curve to extend. (start or end)
        The end of the curve closest to the endPoint gets extended 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        Returns the modified original curve if the start or end of the curve is extended
        If the extend joins a curve to another, the two original curves are deleted and a new curve is returned
        If an arc is extended so as to become a circle, the original arc is deleted and a new circle is returned
        """
        return _fusion.SketchFixedSpline_extend(self, endPoint, createConstraints)

    def intersections(self, sketchCurves: "ObjectCollection") -> "bool":
        r"""
        Get the curves that intersect this curve along with the intersection points (Point3D) 
        sketchCurves : A collection of curves to attempt to find intersections with. 
        Set the value of this parameter to null to use all curves in the sketch for the calculation. 
        intersectingCurves : A collection of the actual intersecting curves 
        intersectionPoints : A collection of intersection points (Point3D)
        Item numbers in this collection correspond to the item numbers in the intersectingCurves collection. 
        Returns true if the method was successful. It can be successful regardless of whether intersections were found or not.
        """
        return _fusion.SketchFixedSpline_intersections(self, sketchCurves)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch."""
        return _fusion.SketchFixedSpline__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >":
        r"""Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchFixedSpline__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >":
        r"""Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchFixedSpline__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool":
        r"""Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchFixedSpline__get_is2D(self)

    def _get_isReference(self) -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchFixedSpline__get_isReference(self)

    def _set_isReference(self, value: "bool") -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchFixedSpline__set_isReference(self, value)

    def _get_isFixed(self) -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchFixedSpline__get_isFixed(self)

    def _set_isFixed(self, value: "bool") -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchFixedSpline__set_isFixed(self, value)

    def _get_isVisible(self) -> "bool":
        r"""
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchFixedSpline__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchFixedSpline__get_boundingBox(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchFixedSpline_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchFixedSpline__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchFixedSpline__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool":
        r"""
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchFixedSpline__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool":
        r"""Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchFixedSpline__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.SketchFixedSpline__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the SketchEntity object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same sketch entity.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SketchFixedSpline__get_entityToken(self)

    def _get_isLinked(self) -> "bool":
        r"""
        Indicates if this sketch entity was created by a projection, inclusion, or driven by an API script.
        If this returns true, then the entity is presented to the user as not editable and with a 'break link'
        command available.
        """
        return _fusion.SketchFixedSpline__get_isLinked(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchFixedSpline__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchFixedSpline__get_isValid(self)

# Register SketchFixedSpline in _fusion:
_fusion.SketchFixedSpline_swigregister(SketchFixedSpline)

def SketchFixedSpline_classType() -> "char const *":
    return _fusion.SketchFixedSpline_classType()


SketchFixedSpline.startSketchPoint = property(SketchFixedSpline._get_startSketchPoint, doc="The sketch point at the start of the spline.")


SketchFixedSpline.endSketchPoint = property(SketchFixedSpline._get_endSketchPoint, doc="The sketch point at the end of the spline.")


SketchFixedSpline.geometry = property(SketchFixedSpline._get_geometry, doc="Returns the transient geometry of the curve which provides geometric\ninformation about the curve. The returned geometry is always in sketch space.\nBecause the fixed spline can be analytically defined, for example it\ncan be the precise intersection of a surface and the sketch plane,\nreturning a NURBS curve that represents the spline may be an\napproximation of the actual curve. You can use the Evaluator\nproperty of the SketchFixedSpline object to perform evaluations\non the precise curve.")


SketchFixedSpline.worldGeometry = property(SketchFixedSpline._get_worldGeometry, doc="Returns a NurbsCurve3D object that is the equivalent of this sketch curve\nbut is in the space of the parent component rather than in sketch space.")


SketchFixedSpline.evaluator = property(SketchFixedSpline._get_evaluator, doc="Returns an evaluator object that lets you perform evaluations\non the precise geometry of the curve.")


SketchFixedSpline.nativeObject = property(SketchFixedSpline._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SketchFixedSpline.cast = lambda arg: arg if isinstance(arg, SketchFixedSpline) else None

class SketchLine(SketchCurve):
    r"""A line in a sketch."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __deref__(self) -> "adsk::fusion::SketchLine *":
        return _fusion.SketchLine___deref__(self)

    def __eq__(self, rhs: "SketchLine") -> "bool":

        if not isinstance(self, type(rhs)) :
           return False


        return _fusion.SketchLine___eq__(self, rhs)


    def __ne__(self, rhs: "SketchLine") -> "bool":

        if not isinstance(self, type(rhs)):
           return True


        return _fusion.SketchLine___ne__(self, rhs)


    @staticmethod
    def classType() -> "char const *":
        return _fusion.SketchLine_classType()
    __swig_destroy__ = _fusion.delete_SketchLine

    def _get_startSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""
        The sketch point at the start of the line. The line is dependent on this point and moving the
        point will cause the line to adjust.
        """
        return _fusion.SketchLine__get_startSketchPoint(self)

    def _get_endSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >":
        r"""
        The sketch point at the end of the line. The line is dependent on this point and moving the
        point will cause the line to adjust.
        """
        return _fusion.SketchLine__get_endSketchPoint(self)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Line3D >":
        r"""
        Returns the transient geometry of the line which provides geometry 
        information about the line. The returned geometry is always in sketch space.
        """
        return _fusion.SketchLine__get_geometry(self)

    def _get_worldGeometry(self) -> "adsk::core::Ptr< adsk::core::Line3D >":
        r"""
        Returns a Line3D object which provides geometric information in world space.
        The returned geometry takes into account the assembly context and the position of the
        sketch in it's parent component, which means the geometry will be returned in the root
        component space.
        """
        return _fusion.SketchLine__get_worldGeometry(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchLine__get_nativeObject(self)

    def createForAssemblyContext(self, occurrence: "Occurrence") -> "adsk::core::Ptr< adsk::fusion::SketchLine >":
        r"""
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchLine_createForAssemblyContext(self, occurrence)

    def _get_isCenterLine(self) -> "bool":
        r"""Gets and sets whether this llne is defined as a centerline."""
        return _fusion.SketchLine__get_isCenterLine(self)

    def _set_isCenterLine(self, value: "bool") -> "bool":
        r"""Gets and sets whether this llne is defined as a centerline."""
        return _fusion.SketchLine__set_isCenterLine(self, value)

    def _get_length(self) -> "double":
        r"""Returns the length of the curve in centimeters."""
        return _fusion.SketchLine__get_length(self)

    def _get_isConstruction(self) -> "bool":
        r"""Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchLine__get_isConstruction(self)

    def _set_isConstruction(self, value: "bool") -> "bool":
        r"""Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchLine__set_isConstruction(self, value)

    def split(self, splitPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Split a curve at a position specified along the curve 
        splitPoint : A position (transient Point3D) on the curve that defines the point at which to split the curve 
        createConstraints : Constraints are created by default. Specify false to create no constraints. 
        Returns the resulting 2 curves; the original curve + the newly created curve
        When split spline the original is deleted and two new curves returned.
        Empty collection returned if curve is closed.
        """
        return _fusion.SketchLine_split(self, splitPoint, createConstraints)

    def trim(self, segmentPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Trim a curve by specifying a point that determines the segment of the curve to trim away 
        segmentPoint : A point (transient Point3D) on or closest to the segment of the curve to remove. (start, end or middle)
        The segment of the curve closest to the segmentPoint gets removed 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        When trimming the start or end side of a line, unclosed circular or elliptical arc, the original entity is modified and returned
        When trimming the middle of a line, unclosed circular or elliptical arc the original entity is deleted and two new entities are returned
        When trimming the start or end of any type of closed curve, the original is deleted and a new curve is returned
        Any trimming of a spline (open or closed) deletes the original and new spline/s are returned
        Trimming a curve having no intersections deletes the original and returns an empty collection
        """
        return _fusion.SketchLine_trim(self, segmentPoint, createConstraints)

    def breakCurve(self, segmentPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Breaks a curve into two or three pieces by finding intersections of this curve with all other curves in the
        sketch and splitting this curve at the nearest intersections to a specified point on the curve. 
        segmentPoint : A point that specifies the segment of the curve that is to be split from the rest of the curve. The nearest
        intersection(s) to this point define the break location(s). 
        createConstraints : Optional argument that specifies if constraints should be created between the new curve segments. A value of
        true indicates constraints will be created. 
        All of the curves resulting from the break are returned in an ObjectCollection. In the case where no intersections
        are found and as a result the curve is not broken, an empty ObjectCollection is returned.
        """
        return _fusion.SketchLine_breakCurve(self, segmentPoint, createConstraints)

    def extend(self, endPoint: "Point3D", createConstraints: "bool"=True) -> "adsk::core::Ptr< adsk::core::ObjectCollection >":
        r"""
        Extend a curve by specifying a point that determines the end of the curve to extend 
        endPoint : A point (transient Point3D) on or closest to the end of the curve to extend. (start or end)
        The end of the curve closest to the endPoint gets extended 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        Returns the modified original curve if the start or end of the curve is extended
        If the extend joins a curve to another, the two original curves are deleted and a new curve is returned
        If an arc is extended so as to become a circle, the original arc is deleted and a new circle is returned
        """
        return _fusion.SketchLine_extend(self, endPoint, createConstraints)

    def intersections(self, sketchCurves: "ObjectCollection") -> "bool":
        r"""
        Get the curves that intersect this curve along with the intersection points (Point3D) 
        sketchCurves : A collection of curves to attempt to find intersections with. 
        Set the value of this parameter to null to use all curves in the sketch for the calculation. 
        intersectingCurves : A collection of the actual intersecting curves 
        intersectionPoints : A collection of intersection points (Point3D)
        Item numbers in this collection correspond to the item numbers in the intersectingCurves collection. 
        Returns true if the method was successful. It can be successful regardless of whether intersections were found or not.
        """
        return _fusion.SketchLine_intersections(self, sketchCurves)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >":
        r"""Returns the parent sketch."""
        return _fusion.SketchLine__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >":
        r"""Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchLine__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >":
        r"""Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchLine__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool":
        r"""Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchLine__get_is2D(self)

    def _get_isReference(self) -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchLine__get_isReference(self)

    def _set_isReference(self, value: "bool") -> "bool":
        r"""
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchLine__set_isReference(self, value)

    def _get_isFixed(self) -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchLine__get_isFixed(self)

    def _set_isFixed(self, value: "bool") -> "bool":
        r"""Indicates if this geometry is 'fixed'."""
        return _fusion.SketchLine__set_isFixed(self, value)

    def _get_isVisible(self) -> "bool":
        r"""
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchLine__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >":
        r"""Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchLine__get_boundingBox(self)

    def deleteMe(self) -> "bool":
        r"""
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchLine_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >":
        r"""
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchLine__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >":
        r"""
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchLine__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool":
        r"""
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchLine__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool":
        r"""Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchLine__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >":
        r"""Returns the collection of attributes associated with this face."""
        return _fusion.SketchLine__get_attributes(self)

    def _get_entityToken(self) -> "std::string":
        r"""
        Returns a token for the SketchEntity object. This can be saved and used at a later 
        time with the Design.findEntityByToken method to get back the same sketch entity.
        When using entity tokens it's important to understand that the token string returned for a 
        specific entity can be different over time. However, even if you have two different token
        strings that were obtained from the same entity, when you use findEntityByToken they
        will both return the same entity. Because of that you should never compare entity tokens
        as way to determine what the token represents. Instead, you need to use the findEntityByToken
        method to get the two entities identified by the tokens and then compare them.
        """
        return _fusion.SketchLine__get_entityToken(self)

    def _get_isLinked(self) -> "bool":
        r"""
        Indicates if this sketch entity was created by a projection, inclusion, or driven by an API script.
        If this returns true, then the entity is presented to the user as not editable and with a 'break link'
        command available.
        """
        return _fusion.SketchLine__get_isLinked(self)

    def _get_objectType(self) -> "char const *":
        return _fusion.SketchLine__get_objectType(self)

    def _get_isValid(self) -> "bool":
        return _fusion.SketchLine__get_isValid(self)

# Register SketchLine in _fusion:
_fusion.SketchLine_swigregister(SketchLine)

def SketchLine_classType() -> "char const *":
    return _fusion.SketchLine_classType()


SketchLine.startSketchPoint = property(SketchLine._get_startSketchPoint, doc="The sketch point at the start of the line. The line is dependent on this point and moving the\npoint will cause the line to adjust.")


SketchLine.endSketchPoint = property(SketchLine._get_endSketchPoint, doc="The sketch point at the end of the line. The line is dependent on this point and moving the\npoint will cause the line to adjust.")


SketchLine.geometry = property(SketchLine._get_geometry, doc="Returns the transient geometry of the line which provides geometry\ninformation about the line. The returned geometry is always in sketch space.")


SketchLine.worldGeometry = property(SketchLine._get_worldGeometry, doc="Returns a Line3D object which provides geometric information in world space.\nThe returned geometry takes into account the assembly context and the position of the\nsketch in it's parent component, which means the geometry will be returned in the root\ncomponent space.")


SketchLine.nativeObject = property(SketchLine._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")


SketchLine.isCenterLine = property(SketchLine._get_isCenterLine, SketchLine._set_isCenterLine, doc="Gets and sets whether this llne is defined as a centerline.")


SketchLine.cast = lambda arg: arg if isinstance(arg, SketchLine) else None



